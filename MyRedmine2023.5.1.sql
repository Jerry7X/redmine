--
-- PostgreSQL database dump
--

-- Dumped from database version 9.6.1
-- Dumped by pg_dump version 9.6.14

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: attachments; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.attachments (
    id integer NOT NULL,
    container_id integer,
    container_type character varying(30),
    filename character varying DEFAULT ''::character varying NOT NULL,
    disk_filename character varying DEFAULT ''::character varying NOT NULL,
    filesize bigint DEFAULT 0 NOT NULL,
    content_type character varying DEFAULT ''::character varying,
    digest character varying(64) DEFAULT ''::character varying NOT NULL,
    downloads integer DEFAULT 0 NOT NULL,
    author_id integer DEFAULT 0 NOT NULL,
    created_on timestamp without time zone,
    description character varying,
    disk_directory character varying
);


ALTER TABLE public.attachments OWNER TO redmine;

--
-- Name: attachments_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.attachments_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.attachments_id_seq OWNER TO redmine;

--
-- Name: attachments_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.attachments_id_seq OWNED BY public.attachments.id;


--
-- Name: auth_sources; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.auth_sources (
    id integer NOT NULL,
    type character varying(30) DEFAULT ''::character varying NOT NULL,
    name character varying(60) DEFAULT ''::character varying NOT NULL,
    host character varying(60),
    port integer,
    account character varying,
    account_password character varying DEFAULT ''::character varying,
    base_dn character varying(255),
    attr_login character varying(30),
    attr_firstname character varying(30),
    attr_lastname character varying(30),
    attr_mail character varying(30),
    onthefly_register boolean DEFAULT false NOT NULL,
    tls boolean DEFAULT false NOT NULL,
    filter text,
    timeout integer
);


ALTER TABLE public.auth_sources OWNER TO redmine;

--
-- Name: auth_sources_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.auth_sources_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.auth_sources_id_seq OWNER TO redmine;

--
-- Name: auth_sources_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.auth_sources_id_seq OWNED BY public.auth_sources.id;


--
-- Name: boards; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.boards (
    id integer NOT NULL,
    project_id integer NOT NULL,
    name character varying DEFAULT ''::character varying NOT NULL,
    description character varying,
    "position" integer,
    topics_count integer DEFAULT 0 NOT NULL,
    messages_count integer DEFAULT 0 NOT NULL,
    last_message_id integer,
    parent_id integer
);


ALTER TABLE public.boards OWNER TO redmine;

--
-- Name: boards_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.boards_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.boards_id_seq OWNER TO redmine;

--
-- Name: boards_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.boards_id_seq OWNED BY public.boards.id;


--
-- Name: changes; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.changes (
    id integer NOT NULL,
    changeset_id integer NOT NULL,
    action character varying(1) DEFAULT ''::character varying NOT NULL,
    path text NOT NULL,
    from_path text,
    from_revision character varying,
    revision character varying,
    branch character varying
);


ALTER TABLE public.changes OWNER TO redmine;

--
-- Name: changes_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.changes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.changes_id_seq OWNER TO redmine;

--
-- Name: changes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.changes_id_seq OWNED BY public.changes.id;


--
-- Name: changeset_parents; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.changeset_parents (
    changeset_id integer NOT NULL,
    parent_id integer NOT NULL
);


ALTER TABLE public.changeset_parents OWNER TO redmine;

--
-- Name: changesets; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.changesets (
    id integer NOT NULL,
    repository_id integer NOT NULL,
    revision character varying NOT NULL,
    committer character varying,
    committed_on timestamp without time zone NOT NULL,
    comments text,
    commit_date date,
    scmid character varying,
    user_id integer
);


ALTER TABLE public.changesets OWNER TO redmine;

--
-- Name: changesets_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.changesets_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.changesets_id_seq OWNER TO redmine;

--
-- Name: changesets_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.changesets_id_seq OWNED BY public.changesets.id;


--
-- Name: changesets_issues; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.changesets_issues (
    changeset_id integer NOT NULL,
    issue_id integer NOT NULL
);


ALTER TABLE public.changesets_issues OWNER TO redmine;

--
-- Name: comments; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.comments (
    id integer NOT NULL,
    commented_type character varying(30) DEFAULT ''::character varying NOT NULL,
    commented_id integer DEFAULT 0 NOT NULL,
    author_id integer DEFAULT 0 NOT NULL,
    comments text,
    created_on timestamp without time zone NOT NULL,
    updated_on timestamp without time zone NOT NULL
);


ALTER TABLE public.comments OWNER TO redmine;

--
-- Name: comments_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.comments_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.comments_id_seq OWNER TO redmine;

--
-- Name: comments_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.comments_id_seq OWNED BY public.comments.id;


--
-- Name: custom_field_enumerations; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.custom_field_enumerations (
    id integer NOT NULL,
    custom_field_id integer NOT NULL,
    name character varying NOT NULL,
    active boolean DEFAULT true NOT NULL,
    "position" integer DEFAULT 1 NOT NULL
);


ALTER TABLE public.custom_field_enumerations OWNER TO redmine;

--
-- Name: custom_field_enumerations_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.custom_field_enumerations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.custom_field_enumerations_id_seq OWNER TO redmine;

--
-- Name: custom_field_enumerations_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.custom_field_enumerations_id_seq OWNED BY public.custom_field_enumerations.id;


--
-- Name: custom_fields; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.custom_fields (
    id integer NOT NULL,
    type character varying(30) DEFAULT ''::character varying NOT NULL,
    name character varying(30) DEFAULT ''::character varying NOT NULL,
    field_format character varying(30) DEFAULT ''::character varying NOT NULL,
    possible_values text,
    regexp character varying DEFAULT ''::character varying,
    min_length integer,
    max_length integer,
    is_required boolean DEFAULT false NOT NULL,
    is_for_all boolean DEFAULT false NOT NULL,
    is_filter boolean DEFAULT false NOT NULL,
    "position" integer,
    searchable boolean DEFAULT false,
    default_value text,
    editable boolean DEFAULT true,
    visible boolean DEFAULT true NOT NULL,
    multiple boolean DEFAULT false,
    format_store text,
    description text
);


ALTER TABLE public.custom_fields OWNER TO redmine;

--
-- Name: custom_fields_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.custom_fields_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.custom_fields_id_seq OWNER TO redmine;

--
-- Name: custom_fields_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.custom_fields_id_seq OWNED BY public.custom_fields.id;


--
-- Name: custom_fields_projects; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.custom_fields_projects (
    custom_field_id integer DEFAULT 0 NOT NULL,
    project_id integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.custom_fields_projects OWNER TO redmine;

--
-- Name: custom_fields_roles; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.custom_fields_roles (
    custom_field_id integer NOT NULL,
    role_id integer NOT NULL
);


ALTER TABLE public.custom_fields_roles OWNER TO redmine;

--
-- Name: custom_fields_trackers; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.custom_fields_trackers (
    custom_field_id integer DEFAULT 0 NOT NULL,
    tracker_id integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.custom_fields_trackers OWNER TO redmine;

--
-- Name: custom_values; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.custom_values (
    id integer NOT NULL,
    customized_type character varying(30) DEFAULT ''::character varying NOT NULL,
    customized_id integer DEFAULT 0 NOT NULL,
    custom_field_id integer DEFAULT 0 NOT NULL,
    value text
);


ALTER TABLE public.custom_values OWNER TO redmine;

--
-- Name: custom_values_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.custom_values_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.custom_values_id_seq OWNER TO redmine;

--
-- Name: custom_values_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.custom_values_id_seq OWNED BY public.custom_values.id;


--
-- Name: documents; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.documents (
    id integer NOT NULL,
    project_id integer DEFAULT 0 NOT NULL,
    category_id integer DEFAULT 0 NOT NULL,
    title character varying DEFAULT ''::character varying NOT NULL,
    description text,
    created_on timestamp without time zone
);


ALTER TABLE public.documents OWNER TO redmine;

--
-- Name: documents_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.documents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.documents_id_seq OWNER TO redmine;

--
-- Name: documents_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.documents_id_seq OWNED BY public.documents.id;


--
-- Name: email_addresses; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.email_addresses (
    id integer NOT NULL,
    user_id integer NOT NULL,
    address character varying NOT NULL,
    is_default boolean DEFAULT false NOT NULL,
    notify boolean DEFAULT true NOT NULL,
    created_on timestamp without time zone NOT NULL,
    updated_on timestamp without time zone NOT NULL
);


ALTER TABLE public.email_addresses OWNER TO redmine;

--
-- Name: email_addresses_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.email_addresses_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.email_addresses_id_seq OWNER TO redmine;

--
-- Name: email_addresses_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.email_addresses_id_seq OWNED BY public.email_addresses.id;


--
-- Name: enabled_modules; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.enabled_modules (
    id integer NOT NULL,
    project_id integer,
    name character varying NOT NULL
);


ALTER TABLE public.enabled_modules OWNER TO redmine;

--
-- Name: enabled_modules_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.enabled_modules_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.enabled_modules_id_seq OWNER TO redmine;

--
-- Name: enabled_modules_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.enabled_modules_id_seq OWNED BY public.enabled_modules.id;


--
-- Name: enumerations; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.enumerations (
    id integer NOT NULL,
    name character varying(30) DEFAULT ''::character varying NOT NULL,
    "position" integer,
    is_default boolean DEFAULT false NOT NULL,
    type character varying,
    active boolean DEFAULT true NOT NULL,
    project_id integer,
    parent_id integer,
    position_name character varying(30)
);


ALTER TABLE public.enumerations OWNER TO redmine;

--
-- Name: enumerations_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.enumerations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.enumerations_id_seq OWNER TO redmine;

--
-- Name: enumerations_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.enumerations_id_seq OWNED BY public.enumerations.id;


--
-- Name: groups_users; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.groups_users (
    group_id integer NOT NULL,
    user_id integer NOT NULL
);


ALTER TABLE public.groups_users OWNER TO redmine;

--
-- Name: import_items; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.import_items (
    id integer NOT NULL,
    import_id integer NOT NULL,
    "position" integer NOT NULL,
    obj_id integer,
    message text
);


ALTER TABLE public.import_items OWNER TO redmine;

--
-- Name: import_items_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.import_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.import_items_id_seq OWNER TO redmine;

--
-- Name: import_items_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.import_items_id_seq OWNED BY public.import_items.id;


--
-- Name: imports; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.imports (
    id integer NOT NULL,
    type character varying,
    user_id integer NOT NULL,
    filename character varying,
    settings text,
    total_items integer,
    finished boolean DEFAULT false NOT NULL,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL
);


ALTER TABLE public.imports OWNER TO redmine;

--
-- Name: imports_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.imports_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.imports_id_seq OWNER TO redmine;

--
-- Name: imports_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.imports_id_seq OWNED BY public.imports.id;


--
-- Name: issue_categories; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.issue_categories (
    id integer NOT NULL,
    project_id integer DEFAULT 0 NOT NULL,
    name character varying(60) DEFAULT ''::character varying NOT NULL,
    assigned_to_id integer
);


ALTER TABLE public.issue_categories OWNER TO redmine;

--
-- Name: issue_categories_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.issue_categories_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.issue_categories_id_seq OWNER TO redmine;

--
-- Name: issue_categories_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.issue_categories_id_seq OWNED BY public.issue_categories.id;


--
-- Name: issue_relations; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.issue_relations (
    id integer NOT NULL,
    issue_from_id integer NOT NULL,
    issue_to_id integer NOT NULL,
    relation_type character varying DEFAULT ''::character varying NOT NULL,
    delay integer
);


ALTER TABLE public.issue_relations OWNER TO redmine;

--
-- Name: issue_relations_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.issue_relations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.issue_relations_id_seq OWNER TO redmine;

--
-- Name: issue_relations_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.issue_relations_id_seq OWNED BY public.issue_relations.id;


--
-- Name: issue_statuses; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.issue_statuses (
    id integer NOT NULL,
    name character varying(30) DEFAULT ''::character varying NOT NULL,
    is_closed boolean DEFAULT false NOT NULL,
    "position" integer,
    default_done_ratio integer
);


ALTER TABLE public.issue_statuses OWNER TO redmine;

--
-- Name: issue_statuses_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.issue_statuses_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.issue_statuses_id_seq OWNER TO redmine;

--
-- Name: issue_statuses_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.issue_statuses_id_seq OWNED BY public.issue_statuses.id;


--
-- Name: issues; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.issues (
    id integer NOT NULL,
    tracker_id integer NOT NULL,
    project_id integer NOT NULL,
    subject character varying DEFAULT ''::character varying NOT NULL,
    description text,
    due_date date,
    category_id integer,
    status_id integer NOT NULL,
    assigned_to_id integer,
    priority_id integer NOT NULL,
    fixed_version_id integer,
    author_id integer NOT NULL,
    lock_version integer DEFAULT 0 NOT NULL,
    created_on timestamp without time zone,
    updated_on timestamp without time zone,
    start_date date,
    done_ratio integer DEFAULT 0 NOT NULL,
    estimated_hours double precision,
    parent_id integer,
    root_id integer,
    lft integer,
    rgt integer,
    is_private boolean DEFAULT false NOT NULL,
    closed_on timestamp without time zone
);


ALTER TABLE public.issues OWNER TO redmine;

--
-- Name: issues_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.issues_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.issues_id_seq OWNER TO redmine;

--
-- Name: issues_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.issues_id_seq OWNED BY public.issues.id;


--
-- Name: journal_details; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.journal_details (
    id integer NOT NULL,
    journal_id integer DEFAULT 0 NOT NULL,
    property character varying(30) DEFAULT ''::character varying NOT NULL,
    prop_key character varying(30) DEFAULT ''::character varying NOT NULL,
    old_value text,
    value text
);


ALTER TABLE public.journal_details OWNER TO redmine;

--
-- Name: journal_details_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.journal_details_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.journal_details_id_seq OWNER TO redmine;

--
-- Name: journal_details_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.journal_details_id_seq OWNED BY public.journal_details.id;


--
-- Name: journals; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.journals (
    id integer NOT NULL,
    journalized_id integer DEFAULT 0 NOT NULL,
    journalized_type character varying(30) DEFAULT ''::character varying NOT NULL,
    user_id integer DEFAULT 0 NOT NULL,
    notes text,
    created_on timestamp without time zone NOT NULL,
    private_notes boolean DEFAULT false NOT NULL
);


ALTER TABLE public.journals OWNER TO redmine;

--
-- Name: journals_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.journals_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.journals_id_seq OWNER TO redmine;

--
-- Name: journals_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.journals_id_seq OWNED BY public.journals.id;


--
-- Name: member_roles; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.member_roles (
    id integer NOT NULL,
    member_id integer NOT NULL,
    role_id integer NOT NULL,
    inherited_from integer
);


ALTER TABLE public.member_roles OWNER TO redmine;

--
-- Name: member_roles_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.member_roles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.member_roles_id_seq OWNER TO redmine;

--
-- Name: member_roles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.member_roles_id_seq OWNED BY public.member_roles.id;


--
-- Name: members; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.members (
    id integer NOT NULL,
    user_id integer DEFAULT 0 NOT NULL,
    project_id integer DEFAULT 0 NOT NULL,
    created_on timestamp without time zone,
    mail_notification boolean DEFAULT false NOT NULL
);


ALTER TABLE public.members OWNER TO redmine;

--
-- Name: members_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.members_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.members_id_seq OWNER TO redmine;

--
-- Name: members_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.members_id_seq OWNED BY public.members.id;


--
-- Name: messages; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.messages (
    id integer NOT NULL,
    board_id integer NOT NULL,
    parent_id integer,
    subject character varying DEFAULT ''::character varying NOT NULL,
    content text,
    author_id integer,
    replies_count integer DEFAULT 0 NOT NULL,
    last_reply_id integer,
    created_on timestamp without time zone NOT NULL,
    updated_on timestamp without time zone NOT NULL,
    locked boolean DEFAULT false,
    sticky integer DEFAULT 0
);


ALTER TABLE public.messages OWNER TO redmine;

--
-- Name: messages_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.messages_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.messages_id_seq OWNER TO redmine;

--
-- Name: messages_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.messages_id_seq OWNED BY public.messages.id;


--
-- Name: news; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.news (
    id integer NOT NULL,
    project_id integer,
    title character varying(60) DEFAULT ''::character varying NOT NULL,
    summary character varying(255) DEFAULT ''::character varying,
    description text,
    author_id integer DEFAULT 0 NOT NULL,
    created_on timestamp without time zone,
    comments_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.news OWNER TO redmine;

--
-- Name: news_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.news_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.news_id_seq OWNER TO redmine;

--
-- Name: news_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.news_id_seq OWNED BY public.news.id;


--
-- Name: open_id_authentication_associations; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.open_id_authentication_associations (
    id integer NOT NULL,
    issued integer,
    lifetime integer,
    handle character varying,
    assoc_type character varying,
    server_url bytea,
    secret bytea
);


ALTER TABLE public.open_id_authentication_associations OWNER TO redmine;

--
-- Name: open_id_authentication_associations_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.open_id_authentication_associations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.open_id_authentication_associations_id_seq OWNER TO redmine;

--
-- Name: open_id_authentication_associations_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.open_id_authentication_associations_id_seq OWNED BY public.open_id_authentication_associations.id;


--
-- Name: open_id_authentication_nonces; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.open_id_authentication_nonces (
    id integer NOT NULL,
    "timestamp" integer NOT NULL,
    server_url character varying,
    salt character varying NOT NULL
);


ALTER TABLE public.open_id_authentication_nonces OWNER TO redmine;

--
-- Name: open_id_authentication_nonces_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.open_id_authentication_nonces_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.open_id_authentication_nonces_id_seq OWNER TO redmine;

--
-- Name: open_id_authentication_nonces_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.open_id_authentication_nonces_id_seq OWNED BY public.open_id_authentication_nonces.id;


--
-- Name: projects; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.projects (
    id integer NOT NULL,
    name character varying DEFAULT ''::character varying NOT NULL,
    description text,
    homepage character varying DEFAULT ''::character varying,
    is_public boolean DEFAULT true NOT NULL,
    parent_id integer,
    created_on timestamp without time zone,
    updated_on timestamp without time zone,
    identifier character varying,
    status integer DEFAULT 1 NOT NULL,
    lft integer,
    rgt integer,
    inherit_members boolean DEFAULT false NOT NULL,
    default_version_id integer,
    default_assigned_to_id integer
);


ALTER TABLE public.projects OWNER TO redmine;

--
-- Name: projects_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.projects_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.projects_id_seq OWNER TO redmine;

--
-- Name: projects_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.projects_id_seq OWNED BY public.projects.id;


--
-- Name: projects_trackers; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.projects_trackers (
    project_id integer DEFAULT 0 NOT NULL,
    tracker_id integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.projects_trackers OWNER TO redmine;

--
-- Name: queries; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.queries (
    id integer NOT NULL,
    project_id integer,
    name character varying DEFAULT ''::character varying NOT NULL,
    filters text,
    user_id integer DEFAULT 0 NOT NULL,
    column_names text,
    sort_criteria text,
    group_by character varying,
    type character varying,
    visibility integer DEFAULT 0,
    options text
);


ALTER TABLE public.queries OWNER TO redmine;

--
-- Name: queries_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.queries_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.queries_id_seq OWNER TO redmine;

--
-- Name: queries_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.queries_id_seq OWNED BY public.queries.id;


--
-- Name: queries_roles; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.queries_roles (
    query_id integer NOT NULL,
    role_id integer NOT NULL
);


ALTER TABLE public.queries_roles OWNER TO redmine;

--
-- Name: repositories; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.repositories (
    id integer NOT NULL,
    project_id integer DEFAULT 0 NOT NULL,
    url character varying DEFAULT ''::character varying NOT NULL,
    login character varying(60) DEFAULT ''::character varying,
    password character varying DEFAULT ''::character varying,
    root_url character varying(255) DEFAULT ''::character varying,
    type character varying,
    path_encoding character varying(64),
    log_encoding character varying(64),
    extra_info text,
    identifier character varying,
    is_default boolean DEFAULT false,
    created_on timestamp without time zone
);


ALTER TABLE public.repositories OWNER TO redmine;

--
-- Name: repositories_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.repositories_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.repositories_id_seq OWNER TO redmine;

--
-- Name: repositories_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.repositories_id_seq OWNED BY public.repositories.id;


--
-- Name: roles; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.roles (
    id integer NOT NULL,
    name character varying(30) DEFAULT ''::character varying NOT NULL,
    "position" integer,
    assignable boolean DEFAULT true,
    builtin integer DEFAULT 0 NOT NULL,
    permissions text,
    issues_visibility character varying(30) DEFAULT 'default'::character varying NOT NULL,
    users_visibility character varying(30) DEFAULT 'all'::character varying NOT NULL,
    time_entries_visibility character varying(30) DEFAULT 'all'::character varying NOT NULL,
    all_roles_managed boolean DEFAULT true NOT NULL,
    settings text
);


ALTER TABLE public.roles OWNER TO redmine;

--
-- Name: roles_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.roles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.roles_id_seq OWNER TO redmine;

--
-- Name: roles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.roles_id_seq OWNED BY public.roles.id;


--
-- Name: roles_managed_roles; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.roles_managed_roles (
    role_id integer NOT NULL,
    managed_role_id integer NOT NULL
);


ALTER TABLE public.roles_managed_roles OWNER TO redmine;

--
-- Name: schema_migrations; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.schema_migrations (
    version character varying NOT NULL
);


ALTER TABLE public.schema_migrations OWNER TO redmine;

--
-- Name: settings; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.settings (
    id integer NOT NULL,
    name character varying(255) DEFAULT ''::character varying NOT NULL,
    value text,
    updated_on timestamp without time zone
);


ALTER TABLE public.settings OWNER TO redmine;

--
-- Name: settings_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.settings_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.settings_id_seq OWNER TO redmine;

--
-- Name: settings_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.settings_id_seq OWNED BY public.settings.id;


--
-- Name: time_entries; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.time_entries (
    id integer NOT NULL,
    project_id integer NOT NULL,
    user_id integer NOT NULL,
    issue_id integer,
    hours double precision NOT NULL,
    comments character varying(1024),
    activity_id integer NOT NULL,
    spent_on date NOT NULL,
    tyear integer NOT NULL,
    tmonth integer NOT NULL,
    tweek integer NOT NULL,
    created_on timestamp without time zone NOT NULL,
    updated_on timestamp without time zone NOT NULL
);


ALTER TABLE public.time_entries OWNER TO redmine;

--
-- Name: time_entries_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.time_entries_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.time_entries_id_seq OWNER TO redmine;

--
-- Name: time_entries_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.time_entries_id_seq OWNED BY public.time_entries.id;


--
-- Name: tokens; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.tokens (
    id integer NOT NULL,
    user_id integer DEFAULT 0 NOT NULL,
    action character varying(30) DEFAULT ''::character varying NOT NULL,
    value character varying(40) DEFAULT ''::character varying NOT NULL,
    created_on timestamp without time zone NOT NULL,
    updated_on timestamp without time zone
);


ALTER TABLE public.tokens OWNER TO redmine;

--
-- Name: tokens_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.tokens_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.tokens_id_seq OWNER TO redmine;

--
-- Name: tokens_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.tokens_id_seq OWNED BY public.tokens.id;


--
-- Name: trackers; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.trackers (
    id integer NOT NULL,
    name character varying(30) DEFAULT ''::character varying NOT NULL,
    is_in_chlog boolean DEFAULT false NOT NULL,
    "position" integer,
    is_in_roadmap boolean DEFAULT true NOT NULL,
    fields_bits integer DEFAULT 0,
    default_status_id integer
);


ALTER TABLE public.trackers OWNER TO redmine;

--
-- Name: trackers_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.trackers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.trackers_id_seq OWNER TO redmine;

--
-- Name: trackers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.trackers_id_seq OWNED BY public.trackers.id;


--
-- Name: user_preferences; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.user_preferences (
    id integer NOT NULL,
    user_id integer DEFAULT 0 NOT NULL,
    others text,
    hide_mail boolean DEFAULT true,
    time_zone character varying
);


ALTER TABLE public.user_preferences OWNER TO redmine;

--
-- Name: user_preferences_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.user_preferences_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.user_preferences_id_seq OWNER TO redmine;

--
-- Name: user_preferences_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.user_preferences_id_seq OWNED BY public.user_preferences.id;


--
-- Name: users; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.users (
    id integer NOT NULL,
    login character varying DEFAULT ''::character varying NOT NULL,
    hashed_password character varying(40) DEFAULT ''::character varying NOT NULL,
    firstname character varying(30) DEFAULT ''::character varying NOT NULL,
    lastname character varying(255) DEFAULT ''::character varying NOT NULL,
    admin boolean DEFAULT false NOT NULL,
    status integer DEFAULT 1 NOT NULL,
    last_login_on timestamp without time zone,
    language character varying(5) DEFAULT ''::character varying,
    auth_source_id integer,
    created_on timestamp without time zone,
    updated_on timestamp without time zone,
    type character varying,
    identity_url character varying,
    mail_notification character varying DEFAULT ''::character varying NOT NULL,
    salt character varying(64),
    must_change_passwd boolean DEFAULT false NOT NULL,
    passwd_changed_on timestamp without time zone
);


ALTER TABLE public.users OWNER TO redmine;

--
-- Name: users_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.users_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.users_id_seq OWNER TO redmine;

--
-- Name: users_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.users_id_seq OWNED BY public.users.id;


--
-- Name: versions; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.versions (
    id integer NOT NULL,
    project_id integer DEFAULT 0 NOT NULL,
    name character varying DEFAULT ''::character varying NOT NULL,
    description character varying DEFAULT ''::character varying,
    effective_date date,
    created_on timestamp without time zone,
    updated_on timestamp without time zone,
    wiki_page_title character varying,
    status character varying DEFAULT 'open'::character varying,
    sharing character varying DEFAULT 'none'::character varying NOT NULL
);


ALTER TABLE public.versions OWNER TO redmine;

--
-- Name: versions_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.versions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.versions_id_seq OWNER TO redmine;

--
-- Name: versions_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.versions_id_seq OWNED BY public.versions.id;


--
-- Name: watchers; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.watchers (
    id integer NOT NULL,
    watchable_type character varying DEFAULT ''::character varying NOT NULL,
    watchable_id integer DEFAULT 0 NOT NULL,
    user_id integer
);


ALTER TABLE public.watchers OWNER TO redmine;

--
-- Name: watchers_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.watchers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.watchers_id_seq OWNER TO redmine;

--
-- Name: watchers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.watchers_id_seq OWNED BY public.watchers.id;


--
-- Name: wiki_content_versions; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.wiki_content_versions (
    id integer NOT NULL,
    wiki_content_id integer NOT NULL,
    page_id integer NOT NULL,
    author_id integer,
    data bytea,
    compression character varying(6) DEFAULT ''::character varying,
    comments character varying(1024) DEFAULT ''::character varying,
    updated_on timestamp without time zone NOT NULL,
    version integer NOT NULL
);


ALTER TABLE public.wiki_content_versions OWNER TO redmine;

--
-- Name: wiki_content_versions_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.wiki_content_versions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.wiki_content_versions_id_seq OWNER TO redmine;

--
-- Name: wiki_content_versions_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.wiki_content_versions_id_seq OWNED BY public.wiki_content_versions.id;


--
-- Name: wiki_contents; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.wiki_contents (
    id integer NOT NULL,
    page_id integer NOT NULL,
    author_id integer,
    text text,
    comments character varying(1024) DEFAULT ''::character varying,
    updated_on timestamp without time zone NOT NULL,
    version integer NOT NULL
);


ALTER TABLE public.wiki_contents OWNER TO redmine;

--
-- Name: wiki_contents_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.wiki_contents_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.wiki_contents_id_seq OWNER TO redmine;

--
-- Name: wiki_contents_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.wiki_contents_id_seq OWNED BY public.wiki_contents.id;


--
-- Name: wiki_pages; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.wiki_pages (
    id integer NOT NULL,
    wiki_id integer NOT NULL,
    title character varying(255) NOT NULL,
    created_on timestamp without time zone NOT NULL,
    protected boolean DEFAULT false NOT NULL,
    parent_id integer
);


ALTER TABLE public.wiki_pages OWNER TO redmine;

--
-- Name: wiki_pages_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.wiki_pages_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.wiki_pages_id_seq OWNER TO redmine;

--
-- Name: wiki_pages_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.wiki_pages_id_seq OWNED BY public.wiki_pages.id;


--
-- Name: wiki_redirects; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.wiki_redirects (
    id integer NOT NULL,
    wiki_id integer NOT NULL,
    title character varying,
    redirects_to character varying,
    created_on timestamp without time zone NOT NULL,
    redirects_to_wiki_id integer NOT NULL
);


ALTER TABLE public.wiki_redirects OWNER TO redmine;

--
-- Name: wiki_redirects_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.wiki_redirects_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.wiki_redirects_id_seq OWNER TO redmine;

--
-- Name: wiki_redirects_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.wiki_redirects_id_seq OWNED BY public.wiki_redirects.id;


--
-- Name: wikis; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.wikis (
    id integer NOT NULL,
    project_id integer NOT NULL,
    start_page character varying(255) NOT NULL,
    status integer DEFAULT 1 NOT NULL
);


ALTER TABLE public.wikis OWNER TO redmine;

--
-- Name: wikis_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.wikis_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.wikis_id_seq OWNER TO redmine;

--
-- Name: wikis_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.wikis_id_seq OWNED BY public.wikis.id;


--
-- Name: workflows; Type: TABLE; Schema: public; Owner: redmine
--

CREATE TABLE public.workflows (
    id integer NOT NULL,
    tracker_id integer DEFAULT 0 NOT NULL,
    old_status_id integer DEFAULT 0 NOT NULL,
    new_status_id integer DEFAULT 0 NOT NULL,
    role_id integer DEFAULT 0 NOT NULL,
    assignee boolean DEFAULT false NOT NULL,
    author boolean DEFAULT false NOT NULL,
    type character varying(30),
    field_name character varying(30),
    rule character varying(30)
);


ALTER TABLE public.workflows OWNER TO redmine;

--
-- Name: workflows_id_seq; Type: SEQUENCE; Schema: public; Owner: redmine
--

CREATE SEQUENCE public.workflows_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.workflows_id_seq OWNER TO redmine;

--
-- Name: workflows_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: redmine
--

ALTER SEQUENCE public.workflows_id_seq OWNED BY public.workflows.id;


--
-- Name: attachments id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.attachments ALTER COLUMN id SET DEFAULT nextval('public.attachments_id_seq'::regclass);


--
-- Name: auth_sources id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.auth_sources ALTER COLUMN id SET DEFAULT nextval('public.auth_sources_id_seq'::regclass);


--
-- Name: boards id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.boards ALTER COLUMN id SET DEFAULT nextval('public.boards_id_seq'::regclass);


--
-- Name: changes id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.changes ALTER COLUMN id SET DEFAULT nextval('public.changes_id_seq'::regclass);


--
-- Name: changesets id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.changesets ALTER COLUMN id SET DEFAULT nextval('public.changesets_id_seq'::regclass);


--
-- Name: comments id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.comments ALTER COLUMN id SET DEFAULT nextval('public.comments_id_seq'::regclass);


--
-- Name: custom_field_enumerations id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.custom_field_enumerations ALTER COLUMN id SET DEFAULT nextval('public.custom_field_enumerations_id_seq'::regclass);


--
-- Name: custom_fields id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.custom_fields ALTER COLUMN id SET DEFAULT nextval('public.custom_fields_id_seq'::regclass);


--
-- Name: custom_values id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.custom_values ALTER COLUMN id SET DEFAULT nextval('public.custom_values_id_seq'::regclass);


--
-- Name: documents id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.documents ALTER COLUMN id SET DEFAULT nextval('public.documents_id_seq'::regclass);


--
-- Name: email_addresses id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.email_addresses ALTER COLUMN id SET DEFAULT nextval('public.email_addresses_id_seq'::regclass);


--
-- Name: enabled_modules id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.enabled_modules ALTER COLUMN id SET DEFAULT nextval('public.enabled_modules_id_seq'::regclass);


--
-- Name: enumerations id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.enumerations ALTER COLUMN id SET DEFAULT nextval('public.enumerations_id_seq'::regclass);


--
-- Name: import_items id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.import_items ALTER COLUMN id SET DEFAULT nextval('public.import_items_id_seq'::regclass);


--
-- Name: imports id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.imports ALTER COLUMN id SET DEFAULT nextval('public.imports_id_seq'::regclass);


--
-- Name: issue_categories id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.issue_categories ALTER COLUMN id SET DEFAULT nextval('public.issue_categories_id_seq'::regclass);


--
-- Name: issue_relations id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.issue_relations ALTER COLUMN id SET DEFAULT nextval('public.issue_relations_id_seq'::regclass);


--
-- Name: issue_statuses id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.issue_statuses ALTER COLUMN id SET DEFAULT nextval('public.issue_statuses_id_seq'::regclass);


--
-- Name: issues id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.issues ALTER COLUMN id SET DEFAULT nextval('public.issues_id_seq'::regclass);


--
-- Name: journal_details id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.journal_details ALTER COLUMN id SET DEFAULT nextval('public.journal_details_id_seq'::regclass);


--
-- Name: journals id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.journals ALTER COLUMN id SET DEFAULT nextval('public.journals_id_seq'::regclass);


--
-- Name: member_roles id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.member_roles ALTER COLUMN id SET DEFAULT nextval('public.member_roles_id_seq'::regclass);


--
-- Name: members id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.members ALTER COLUMN id SET DEFAULT nextval('public.members_id_seq'::regclass);


--
-- Name: messages id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.messages ALTER COLUMN id SET DEFAULT nextval('public.messages_id_seq'::regclass);


--
-- Name: news id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.news ALTER COLUMN id SET DEFAULT nextval('public.news_id_seq'::regclass);


--
-- Name: open_id_authentication_associations id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.open_id_authentication_associations ALTER COLUMN id SET DEFAULT nextval('public.open_id_authentication_associations_id_seq'::regclass);


--
-- Name: open_id_authentication_nonces id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.open_id_authentication_nonces ALTER COLUMN id SET DEFAULT nextval('public.open_id_authentication_nonces_id_seq'::regclass);


--
-- Name: projects id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.projects ALTER COLUMN id SET DEFAULT nextval('public.projects_id_seq'::regclass);


--
-- Name: queries id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.queries ALTER COLUMN id SET DEFAULT nextval('public.queries_id_seq'::regclass);


--
-- Name: repositories id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.repositories ALTER COLUMN id SET DEFAULT nextval('public.repositories_id_seq'::regclass);


--
-- Name: roles id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.roles ALTER COLUMN id SET DEFAULT nextval('public.roles_id_seq'::regclass);


--
-- Name: settings id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.settings ALTER COLUMN id SET DEFAULT nextval('public.settings_id_seq'::regclass);


--
-- Name: time_entries id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.time_entries ALTER COLUMN id SET DEFAULT nextval('public.time_entries_id_seq'::regclass);


--
-- Name: tokens id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.tokens ALTER COLUMN id SET DEFAULT nextval('public.tokens_id_seq'::regclass);


--
-- Name: trackers id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.trackers ALTER COLUMN id SET DEFAULT nextval('public.trackers_id_seq'::regclass);


--
-- Name: user_preferences id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.user_preferences ALTER COLUMN id SET DEFAULT nextval('public.user_preferences_id_seq'::regclass);


--
-- Name: users id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.users ALTER COLUMN id SET DEFAULT nextval('public.users_id_seq'::regclass);


--
-- Name: versions id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.versions ALTER COLUMN id SET DEFAULT nextval('public.versions_id_seq'::regclass);


--
-- Name: watchers id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.watchers ALTER COLUMN id SET DEFAULT nextval('public.watchers_id_seq'::regclass);


--
-- Name: wiki_content_versions id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.wiki_content_versions ALTER COLUMN id SET DEFAULT nextval('public.wiki_content_versions_id_seq'::regclass);


--
-- Name: wiki_contents id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.wiki_contents ALTER COLUMN id SET DEFAULT nextval('public.wiki_contents_id_seq'::regclass);


--
-- Name: wiki_pages id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.wiki_pages ALTER COLUMN id SET DEFAULT nextval('public.wiki_pages_id_seq'::regclass);


--
-- Name: wiki_redirects id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.wiki_redirects ALTER COLUMN id SET DEFAULT nextval('public.wiki_redirects_id_seq'::regclass);


--
-- Name: wikis id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.wikis ALTER COLUMN id SET DEFAULT nextval('public.wikis_id_seq'::regclass);


--
-- Name: workflows id; Type: DEFAULT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.workflows ALTER COLUMN id SET DEFAULT nextval('public.workflows_id_seq'::regclass);


--
-- Data for Name: attachments; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.attachments (id, container_id, container_type, filename, disk_filename, filesize, content_type, digest, downloads, author_id, created_on, description, disk_directory) FROM stdin;
1	11	Issue	osd.47.pstack	170929121946_osd.47.pstack	148407	\N	5a9f3e046f998042ae31c5f312eea0501f97856c38ca3667f50186ae4c99190c	0	5	2017-09-29 12:19:46.336604	堆栈	2017/09
2	33	Issue	rgw.stack	171102091119_rgw.stack	2807701	\N	520f317042d1d6fd11977fa4adf9fa519618a1f702c143ea176cfb858e6995dc	0	5	2017-11-02 09:11:19.934841		2017/11
3	37	Issue	QQ图片20171114175259.png	171114152330_1f315197c9d4465c5b958cb0462d1a0c.png	23008	image/png	d038aaeebac45b00459581940c1321a7ff1ef6a65b25da5ad7e869cbd0c80eab	0	5	2017-11-14 15:23:30.366547	tag搜索结果	2017/11
4	88	Issue	pg分裂问题的严重性.png	180808064415_073c5bf409d0fcf3b676412361799c32.png	22141	image/png	79dc35c6c2fc8c6bf756aff05b4c5ca6df1bf8c1a7872e3b3bfa8e9d2bcc1eb3	0	5	2018-08-08 06:44:15.04468	性能长期无法恢复	2018/08
5	\N	\N	ss_lt.png	180827153251_ss_lt.png	220987	image/png	e0ae87196e55dcd0193ab75ddc84ce296b5779c0ef81fe0f1cfaa74ca37b9f7b	0	5	2018-08-27 15:32:51.693116	\N	2018/08
6	\N	\N	ss_lt.png	180827153251_ss_lt.png	220987	image/png	e0ae87196e55dcd0193ab75ddc84ce296b5779c0ef81fe0f1cfaa74ca37b9f7b	0	5	2018-08-27 15:32:51.762851	\N	2018/08
7	\N	\N	ss_lt.png	180827153251_ss_lt.png	220987	image/png	e0ae87196e55dcd0193ab75ddc84ce296b5779c0ef81fe0f1cfaa74ca37b9f7b	0	5	2018-08-27 15:33:50.443529	\N	2018/08
8	\N	\N	ss_lt.png	180827153251_ss_lt.png	220987	image/png	e0ae87196e55dcd0193ab75ddc84ce296b5779c0ef81fe0f1cfaa74ca37b9f7b	0	5	2018-08-27 15:33:50.482899	\N	2018/08
9	149	Issue	rgw架构.png	181107081000_c076975f63bdd70c0aede043fb006262.png	52652	image/png	12f27ba05035e86fd9fc11ed93d4d77a768603808f3b442c3ccd291687b0acb8	0	5	2018-11-07 08:10:00.476252		2018/11
10	170	Issue	data lake.jpg	181115181429_1140c0e36913a4f732cf6e18f2e51231.jpg	42300	image/jpeg	93ab5a83b01cadae9e3ae8c278782aabce056287f3504b4fa8be0c32ee23d782	0	5	2018-11-15 18:14:29.126916		2018/11
12	172	Issue	第四课复习卡.jpg	181128092923_347147790d1b4e0b488ac094e39fd7b1.jpg	264623	image/jpeg	4253107277504a005fbea231e419eae28c9f71c1b89a815a9f12cdcdc9edea65	0	6	2018-11-28 09:29:23.464968		2018/11
13	178	Issue	第五课复习卡.jpg	181128111532_16ef5bd9386509d2e81e3006b7c11766.jpg	203154	image/jpeg	f72374ffc033e9f475b2c667c6a8e5452839da2f0b96bccce89ed54fbe9504c6	0	6	2018-11-28 11:15:32.09912		2018/11
14	148	Issue	第一课复习卡.jpg	181128111607_10dfa814a58fd7686df2e244d6576be0.jpg	120739	image/jpeg	c0353340b832aad0fc72f5a7307a17ad357af59b8b3801a965e58af21795c6e1	0	6	2018-11-28 11:16:07.125992		2018/11
15	161	Issue	第二课复习卡.jpg	181128111644_37ffc8d44a09a68430b486913d0b3562.jpg	137260	image/jpeg	1c2662ed180f901a021e45fcf48117caec77395b126837cfb3a45eb4fabdf6a8	0	6	2018-11-28 11:16:44.734978		2018/11
16	162	Issue	第三课复习卡.jpg	181128113212_74d1b619b7764211f8c4093d39dbec7b.jpg	178739	image/jpeg	394dcbcc16caa12464764cc0ce07ce03bb3f38ca819dd48569f5a9ea42329ddc	0	6	2018-11-28 11:32:12.313156		2018/11
17	4	Issue	499_tcpdump.png	181218134712_499_tcpdump.png	84388	image/png	6da607ecbb24c6213d0d0496d310a40fa92ed35af330afa828a1aa19f17f4208	0	5	2018-12-18 13:47:12.847033		2018/12
18	4	Issue	tcpdump_not_accept.png	181218181946_tcpdump_not_accept.png	668836	image/png	4df7675d213b058324bdef4a4fd2668294570334da84536c4b4d6f916edbd27c	0	5	2018-12-18 18:19:46.551159	server不执行accept的tcpdump	2018/12
20	4	Issue	tcp_netstat_error.png	181224185604_tcp_netstat_error.png	115539	image/png	f72dd97be4348b8380e0fdef15f44d97e68250d014527e8d56593aaae502119d	0	5	2018-12-24 18:56:04.487052	netstat -st	2018/12
21	4	Issue	tcp_netstat_2.png	181224191731_tcp_netstat_2.png	114970	image/png	7758caf9ce1359bc44d7c1fe744006957ab9938e6cf6c050fe187e770235afc7	0	5	2018-12-24 19:17:31.41016		2018/12
22	4	Issue	hang_tcpdump.png	181225123807_hang_tcpdump.png	845211	image/png	40e9e95cba4625f8f3a6186350e5c093577cfc1f1d80064cb525929f03a8bead	0	5	2018-12-25 12:38:07.050542	hang住的socket交互过程	2018/12
23	4	Issue	normal_tcpdump.png	181225123837_normal_tcpdump.png	259007	image/png	a5176b7e3723cda0d29e9a738f9232b272b45f72b29dd6bac7d3917a51f05b38	0	5	2018-12-25 12:38:37.015244	正常的socket关闭	2018/12
24	\N	\N	Alphabet.png	190407202310_Alphabet.png	522525	image/png	5bc3d37271b9b5565aa4275461020e65ab18d9ff84a66cbaca047537d0452932	0	5	2019-04-07 20:23:10.381279	\N	2019/04
25	\N	\N	Alphabet.png	190407202310_Alphabet.png	522525	image/png	5bc3d37271b9b5565aa4275461020e65ab18d9ff84a66cbaca047537d0452932	0	5	2019-04-07 20:23:12.177162	\N	2019/04
26	\N	\N	Alphabet.png	190407202310_Alphabet.png	522525	image/png	5bc3d37271b9b5565aa4275461020e65ab18d9ff84a66cbaca047537d0452932	0	5	2019-04-07 20:23:34.150012	\N	2019/04
27	\N	\N	Alphabet.png	190407202310_Alphabet.png	522525	image/png	5bc3d37271b9b5565aa4275461020e65ab18d9ff84a66cbaca047537d0452932	0	5	2019-04-07 20:23:36.49403	\N	2019/04
28	\N	\N	Alphabet.png	190407202310_Alphabet.png	522525	image/png	5bc3d37271b9b5565aa4275461020e65ab18d9ff84a66cbaca047537d0452932	0	5	2019-04-07 20:24:45.131066	\N	2019/04
29	\N	\N	Alphabet.png	190407202310_Alphabet.png	522525	image/png	5bc3d37271b9b5565aa4275461020e65ab18d9ff84a66cbaca047537d0452932	0	5	2019-04-07 20:24:46.549683	\N	2019/04
30	2	Version	periodsync.png	190419131906_periodsync.png	150761	image/png	3d6203cb8e73c32ee62a1df993a9ebc71e6aa0936434af34878cc7aeabde9cef	0	5	2019-04-19 13:19:06.885295		2019/04
31	394	Issue	2019年5月12日母亲节感恩会.jpg	190514121842_bb33a2f9c21e18a84a72285485c1e2e0.jpg	76821	image/jpeg	72bd1ce7d041cf00d44e08297dd2f380d2a61db051241f14382ee7697a11fcf3	0	6	2019-05-14 12:18:42.046256		2019/05
32	423	Issue	redo_undo日志.png	190809171605_42cc712b63ed5695012cfc9f0ca46451.png	172058	image/png	52c678d8eac43f9351f1b778beea8e2945e72f75a1c037cabde8bd0a1b626777	0	5	2019-08-09 17:16:05.326646		2019/08
34	560	Issue	少有人走的路-群体意识.png	200301182423_6c8921b6d1c63b592b71fe834154f452.png	69521	image/png	46f802c2dbab9b2e44cf524b7907273d1e1195163167665f395c704fdb1572c8	0	5	2020-03-01 18:24:23.243792		2020/03
33	560	Issue	少有人走的路-意识.png	200301182423_919b2c77b9078683e2e1301f6aa83232.png	109895	image/png	21a5d6cbbca8fe392449ba4cb774771c32255a8e4842f42f1715d97807c079c2	0	5	2020-03-01 18:24:23.215425		2020/03
35	560	Issue	少有人走的路.drawio	200301182442_2ba0b3d4826da8ee786d06f12f32685e.drawio	6529	\N	5be30b5ee07040d1db4b2b06b9ec9ee2861040250573fe6f5c9151186094edb9	0	5	2020-03-01 18:24:42.222257		2020/03
36	595	Issue	Learn_english.jpg	200326205955_Learn_english.jpg	29074	image/jpeg	367890758824f189fdec4d53fe94aa2378cc5c416ecc8e26b56c6028b524c9e1	0	5	2020-03-26 20:59:55.401035		2020/03
39	671	Issue	人的能力模型.png	200802094047_a5874466154d1f9efae231ca2592e7a1.png	37561	image/png	c1b60c19d775da4bdce7f04958058bfe381a3b1a9a04f6526c2aaca330d8e3a4	0	5	2020-08-02 09:40:47.901707		2020/08
37	648	Issue	思考.png	200621204353_ca31ebc9872ffee7c4b44b200e01d739.png	67253	image/png	d0fe4e838b3eaf70efe2e297c840c46663e7a0d2acb457bb6b458551e2da9747	0	5	2020-06-21 20:43:53.761456		2020/06
38	648	Issue	思考.drawio	200621204401_1cd546ecbfbc385a751628072c79c251.drawio	2688	\N	5cc953c891fae8e8008358a4be4bbbb170b2955b8fabab341d27009d9e9424cd	0	5	2020-06-21 20:44:01.319091		2020/06
64	968	Issue	软件架构.png	221213164840_d7a19ca1b60b2cf1945354c88b85a04a.png	47813	image/png	89a2bfe4fcd66d915764bd9a79e0f803259b2cf0987069b8a73c9f24d6d3eef4	0	5	2022-12-13 16:48:40.175001		2022/12
40	678	Issue	2019年BP规划.pptx	200813204931_69392812c761a3791c07a02792d58e19.pptx	1875370	application/vnd.openxmlformats-officedocument.presentationml.presentation	7bfbd5cc1565beb73c88a7b144dd0bcd1a401d9664f2197a27af42d8995d7ed0	0	5	2020-08-13 20:49:31.783954		2020/08
41	684	Issue	Rust High Performance.pdf	200828203717_73a8f366e32cfe85d4ec1da9ce7646b0.pdf	5214844	application/pdf	7a976bcd5cedd73df37d630c4310b90126a2c8f8de6945955c0495ca60d0ba42	0	5	2020-08-28 20:37:17.519283		2020/08
42	827	Issue	Oos_framework.png	210327155701_Oos_framework.png	71531	image/png	c692d7aaa8daf08e50d44f071f03c77c29287adf7932d13ba62bda2e1e030880	0	5	2021-03-27 15:57:01.883487		2021/03
43	874	Issue	brain.png	210519050408_brain.png	28572	image/png	7ed369b153be29ef33481a53d5c43f87b30a02a4b39a60091514cb6368a47c12	0	5	2021-05-19 05:04:08.460049		2021/05
66	1173	Issue	p1.png	230214124518_p1.png	29151	image/png	c4b918cd789096ff9d8a5c4f0f304791f2e504959722ac9d930093ffe3fb6b60	0	5	2023-02-14 12:45:18.763768		2023/02
45	882	Issue	培训材料-列数据存储组织.pptx	210608040344_cc0063fb2860a42c7db007058c28f326.pptx	439790	application/vnd.openxmlformats-officedocument.presentationml.presentation	4fc6d88b9a52c6191cb6e0ca6a345d3b3f1616b400297c86c7f0efa21ab5915a	0	5	2021-06-08 04:03:44.368829		2021/06
46	882	Issue	培训材料-列数据存储组织.pptx	210609211504_cc0063fb2860a42c7db007058c28f326.pptx	476280	application/vnd.openxmlformats-officedocument.presentationml.presentation	7b34b89e9a9248a3a090c30c0a14eb71b156957bf184919803296b3fd654056e	0	5	2021-06-09 21:15:04.112847		2021/06
49	887	Issue	docx_generator.py	210613193422_docx_generator.py	3558	text/plain	0db5ad1f7070003e455e23309fa33c400f7b9d9223802b01f51dfd1ac2277d43	0	5	2021-06-13 19:34:22.307174		2021/06
54	882	Issue	列数据存储组织V2.0.pptx	210704131531_65cb207e9070bd9b012d3c3f5faefb2a.pptx	647685	application/vnd.openxmlformats-officedocument.presentationml.presentation	f5c29b3b5d5713a5f4f1923956bc2ddf288921c0ad51d23590422cf070ab571c	0	5	2021-07-04 13:15:31.353761		2021/07
56	945	Issue	软件真相.png	220313194233_38e154d0bde205573044e1a5c3cc651c.png	66440	image/png	365283e9810cf477477f7542a0391bb1b0b87087aec69558cdb5b452f59eb1b4	0	5	2022-03-13 19:42:33.031091		2022/03
57	945	Issue	计算机认知.drawio	220320071832_0a30a9f5f6351de8a08446d21a96fd20.drawio	3641	\N	723d396f81f9d796da9e1a58ed5cf8921c200b603285f7a54ab52a5aca7f872d	0	5	2022-03-20 07:18:32.822993		2022/03
63	1149	Issue	金融数据仓库发展报告（白皮书）-评审稿20220919.docx	221122183901_8486db5a6f835469815045328eacc69a.docx	3178963	application/vnd.openxmlformats-officedocument.wordprocessingml.document	b0de69c489b500ec4f4ad6bca0f5794bdf5f946a13da181a64ad04c789283dc0	0	5	2022-11-22 18:39:01.833409		2022/11
65	1173	Issue	p2.png	230214124518_p2.png	5912	image/png	15d1537dc54b94f64255b8f2bea1a1f75493046419b3b1e29eea8e3cf9133f1b	0	5	2023-02-14 12:45:18.753405		2023/02
44	882	Issue	培训材料-列数据存储组织.pptx	210604154638_cc0063fb2860a42c7db007058c28f326.pptx	397673	application/vnd.openxmlformats-officedocument.presentationml.presentation	06dee14ee0a36802a4369f8b2e9c29422a19d6b1588b50efbafd57d27afbb357	0	5	2021-06-04 15:46:38.280416		2021/06
47	882	Issue	swf.drawio	210609211521_swf.drawio	6459	\N	c687ad7175b3d4b8df1436334456d97e08a87beb20a30b3ad78f6df5c1c67afd	0	5	2021-06-09 21:15:21.519466		2021/06
48	887	Issue	docx_generator.py	210613190623_docx_generator.py	3514	text/plain	3bdda14f0f1cb1e8feefeb5633639098a474a81ca4680380b42d5fa4131f3bbc	0	5	2021-06-13 19:06:23.851818		2021/06
50	887	Issue	docx_generator.py	210614164801_docx_generator.py	5310	text/plain	0ca9b4e10ca6089ef6aa6f432fcb607a42bc120191a6030733615cdf00221ad9	0	5	2021-06-14 16:48:01.539973		2021/06
51	896	Issue	clion_cmake_project.png	210625074616_clion_cmake_project.png	20489	image/png	9e6fe45a9e35f3e938d6177a0d54450034e29869f48124c0a7c6c2e8c23cbadd	0	5	2021-06-25 07:46:16.297323		2021/06
52	882	Issue	列数据存储组织.pptx	210627153849_b8bd085c8983585951dbf7caea0eff57.pptx	550662	application/vnd.openxmlformats-officedocument.presentationml.presentation	6017ad3420dd5a41ef3ba99b640eb5edf91d4a460040bc77df5e4baed6eddd79	0	5	2021-06-27 15:38:49.051146		2021/06
53	882	Issue	列数据存储组织V1.0.pptx	210627155936_1f0dbe1f8068278d244f0cf433825e20.pptx	550478	application/vnd.openxmlformats-officedocument.presentationml.presentation	6e8cdb0ec32fcb7f7a0f7f01c78350550a5240b9089a669cbaeabb86d71f700e	0	5	2021-06-27 15:59:36.975819		2021/06
55	945	Issue	软件真相.png	220313192527_38e154d0bde205573044e1a5c3cc651c.png	24908	image/png	86ac03db519c790d929f497166167493a4fb4e53c647c5791cfa0262101cf300	0	5	2022-03-13 19:25:27.025224		2022/03
58	945	Issue	计算机认知-Page-2.png	220320071833_a0b9e94ca98734fc2a046c9b687040bb.png	56357	image/png	ca358e283ddd893f85d07d25d725951de82e06833d5852f1d7b2e2de851cc16d	0	5	2022-03-20 07:18:33.189169		2022/03
59	1113	Issue	云原生湖仓一体数据平台【第一次讨论会】【会后整理】 _深算院反馈.xlsx	220812154347_1f4b88f3cc7b79c9682d77dc81a60a1a.xlsx	15754	application/vnd.openxmlformats-officedocument.spreadsheetml.sheet	94e0403b576af24608a16ef99cb695b58f6683ca5e72231574f8acec86130ce8	0	5	2022-08-12 15:43:47.568895		2022/08
60	962	Issue	tuningtip-kunpenggrf.pdf	221010130620_tuningtip-kunpenggrf.pdf	2384372	application/pdf	00c94fd41c914339d2462d7a2f290b2bce6c5c990d7faba86baecfb6d74d4f83	0	5	2022-10-10 13:06:20.125943		2022/10
61	1132	Issue	存储功能.png	221108185705_5edc83d6d05d6840cd3e0a167db644c9.png	14421	image/png	a6e3beb512a2d9f0a10fc0311d0110472bd1d742ee078fefa158d01b15d74f86	0	5	2022-11-08 18:57:05.914245		2022/11
62	1148	Issue	abadi-column-stores.pdf	221117182658_abadi-column-stores.pdf	1996890	application/pdf	4f4da49bdae84921ed8a3995c0fe7a39ff046133e2bd8e5ac22a358016291f6d	0	5	2022-11-17 18:26:58.541644		2022/11
\.


--
-- Name: attachments_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.attachments_id_seq', 66, true);


--
-- Data for Name: auth_sources; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.auth_sources (id, type, name, host, port, account, account_password, base_dn, attr_login, attr_firstname, attr_lastname, attr_mail, onthefly_register, tls, filter, timeout) FROM stdin;
\.


--
-- Name: auth_sources_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.auth_sources_id_seq', 1, false);


--
-- Data for Name: boards; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.boards (id, project_id, name, description, "position", topics_count, messages_count, last_message_id, parent_id) FROM stdin;
\.


--
-- Name: boards_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.boards_id_seq', 1, false);


--
-- Data for Name: changes; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.changes (id, changeset_id, action, path, from_path, from_revision, revision, branch) FROM stdin;
\.


--
-- Name: changes_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.changes_id_seq', 1, false);


--
-- Data for Name: changeset_parents; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.changeset_parents (changeset_id, parent_id) FROM stdin;
\.


--
-- Data for Name: changesets; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.changesets (id, repository_id, revision, committer, committed_on, comments, commit_date, scmid, user_id) FROM stdin;
\.


--
-- Name: changesets_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.changesets_id_seq', 1, false);


--
-- Data for Name: changesets_issues; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.changesets_issues (changeset_id, issue_id) FROM stdin;
\.


--
-- Data for Name: comments; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.comments (id, commented_type, commented_id, author_id, comments, created_on, updated_on) FROM stdin;
1	News	1	5	把头脑风暴组织化，制度化	2017-11-02 07:14:41.929281	2017-11-02 07:14:41.929281
\.


--
-- Name: comments_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.comments_id_seq', 1, true);


--
-- Data for Name: custom_field_enumerations; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.custom_field_enumerations (id, custom_field_id, name, active, "position") FROM stdin;
\.


--
-- Name: custom_field_enumerations_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.custom_field_enumerations_id_seq', 1, false);


--
-- Data for Name: custom_fields; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.custom_fields (id, type, name, field_format, possible_values, regexp, min_length, max_length, is_required, is_for_all, is_filter, "position", searchable, default_value, editable, visible, multiple, format_store, description) FROM stdin;
1	IssueCustomField	发现版本	version	\N		\N	\N	f	t	t	1	f	\N	t	t	f	--- !ruby/hash:ActiveSupport::HashWithIndifferentAccess\nversion_status: []\nedit_tag_style: ''\n	xx
\.


--
-- Name: custom_fields_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.custom_fields_id_seq', 1, true);


--
-- Data for Name: custom_fields_projects; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.custom_fields_projects (custom_field_id, project_id) FROM stdin;
\.


--
-- Data for Name: custom_fields_roles; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.custom_fields_roles (custom_field_id, role_id) FROM stdin;
\.


--
-- Data for Name: custom_fields_trackers; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.custom_fields_trackers (custom_field_id, tracker_id) FROM stdin;
1	3
1	5
\.


--
-- Data for Name: custom_values; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.custom_values (id, customized_type, customized_id, custom_field_id, value) FROM stdin;
1	Issue	67	1	
2	Issue	68	1	
3	Issue	4	1	
4	Issue	75	1	
5	Issue	76	1	
6	Issue	77	1	
7	Issue	78	1	
8	Issue	79	1	
9	Issue	80	1	
10	Issue	81	1	
11	Issue	82	1	
12	Issue	84	1	
13	Issue	85	1	
14	Issue	87	1	
15	Issue	89	1	
16	Issue	90	1	
17	Issue	91	1	
18	Issue	92	1	
19	Issue	94	1	
20	Issue	96	1	
21	Issue	97	1	
22	Issue	98	1	
23	Issue	99	1	
24	Issue	101	1	
25	Issue	111	1	
26	Issue	116	1	
27	Issue	120	1	
28	Issue	121	1	
29	Issue	123	1	
30	Issue	124	1	
31	Issue	125	1	
32	Issue	126	1	
33	Issue	127	1	
34	Issue	130	1	
35	Issue	134	1	
36	Issue	140	1	
37	Issue	150	1	
38	Issue	153	1	
39	Issue	154	1	
40	Issue	157	1	
41	Issue	171	1	
42	Issue	176	1	
43	Issue	183	1	
44	Issue	186	1	
45	Issue	206	1	
46	Issue	208	1	
47	Issue	209	1	
48	Issue	210	1	
49	Issue	211	1	
50	Issue	215	1	
51	Issue	230	1	
52	Issue	235	1	
53	Issue	248	1	
54	Issue	253	1	
55	Issue	256	1	
56	Issue	258	1	
57	Issue	260	1	
58	Issue	266	1	
59	Issue	324	1	
60	Issue	21	1	
61	Issue	477	1	
62	Issue	527	1	
63	Issue	535	1	
64	Issue	541	1	
65	Issue	623	1	
66	Issue	626	1	
67	Issue	629	1	
68	Issue	632	1	
69	Issue	641	1	
70	Issue	642	1	
71	Issue	657	1	
72	Issue	667	1	
73	Issue	677	1	
74	Issue	692	1	
75	Issue	697	1	
76	Issue	702	1	
77	Issue	710	1	
78	Issue	714	1	
79	Issue	716	1	
80	Issue	725	1	
81	Issue	726	1	
82	Issue	727	1	
83	Issue	967	1	
84	Issue	975	1	
85	Issue	987	1	
86	Issue	1133	1	
87	Issue	1159	1	
88	Issue	1160	1	
89	Issue	1182	1	
90	Issue	1183	1	
91	Issue	1184	1	
92	Issue	1188	1	
\.


--
-- Name: custom_values_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.custom_values_id_seq', 92, true);


--
-- Data for Name: documents; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.documents (id, project_id, category_id, title, description, created_on) FROM stdin;
8	1	5	osd扩容引起的数据搬迁问题	使用多个pool是一种解决方案，据说xsky采用了这种方式。	2017-10-10 11:25:12.185413
2	1	6	ceph civetweb 工作原理分析	tcp keepalived:\r\nhttp://www.firefoxbug.com/index.php/archives/2805/\r\n\r\nSO_RCVTIMEO and SO_SNDTIMEO\r\n              Specify the receiving or sending timeouts until reporting an\r\n              error.  The argument is a struct timeval.  If an input or out‐\r\n              put function blocks for this period of time, and data has been\r\n              sent or received, the return value of that function will be\r\n              the amount of data transferred; if no data has been trans‐\r\n              ferred and the timeout has been reached, then -1 is returned\r\n              with errno set to EAGAIN or EWOULDBLOCK, or EINPROGRESS (for\r\n              connect(2)) just as if the socket was specified to be non‐\r\n              blocking.  If the timeout is set to zero (the default), then\r\n              the operation will never timeout.  Timeouts only have effect\r\n              for system calls that perform socket I/O (e.g., read(2),\r\n              recvmsg(2), send(2), sendmsg(2)); timeouts have no effect for\r\n              select(2), poll(2), epoll_wait(2), and so on.\r\n如果传输了一点数据，就返回传输长度，如果一点都没成功，并且超时了，返回超时错误。\r\n这个收发是否成功，应该是说tcp的超时，不是说应用层的超时。\r\n\r\n*阻塞模式下可以用setsockopt设置SO_RCVTIMEO（超时时间），即如果在超时时间内接收缓冲区都没有一点数据到来，那么返回-1，errno = EAGAIN | EWOULDBLOCK 错误。同理，还有SO_SNDTIMEO 选项，在超时时间内发送缓冲区都没有足够内存存放数据，也是返回-1，errno = EAGAIN | EWOULDBLOCK 错误。*\r\n\r\nThe AWS SDK for .NET allows you to configure the request timeout and socket read/write timeout values at the service client level. These values are specified in the Timeout and the ReadWriteTimeout properties of the ClientConfig class, respectively. These values are passed on as the Timeout and ReadWriteTimeout properties of the HttpWebRequest objects created by the AWS service client object. By default, the Timeout value is 100 seconds and the ReadWriteTimeout value is 300 seconds.\r\n\r\n\r\n	2017-09-26 14:34:32.444695
3	1	7	软件性能模型分析	通常软件系统中有线程池，有队列，cache，有流控，有锁。同时还有各种硬件资源。\r\n那么在这样一个系统中如何去分析性能瓶颈呢？在存在多种业务时，如何分析他们之间的互相影响？如何对不同业务做流控呢？\r\n\r\n本文意在探讨这个主题。	2017-09-27 07:54:39.494658
6	1	8	对象存储与人工智能	对象存储如何结合人工智能？\r\n\r\n为什么要走这个方向？\r\n\r\n存储是什么？\r\n历史上很多数据，每天也会有很多新数据，如何高效的记录这些数据，整理数据，高效率的存储等这些是存储关心的问题。\r\n存储是未来数据大厦的基石，是原材料。\r\n\r\n但是社会是追求附加值的，社会是创新引领的，存储的特征决定了其变革周期是相对大的。但是数据处理不是，其技术必将日新月异。\r\n\r\n我们想做的就是一个数据处理平台。人们关心的通常并非数据本身，而是数据所体现的规律，特征。\r\n我们不仅提供了存储，我们还可以给用户提供操作平台，给用户构建一种操作数据的能力，并且与时俱进。\r\n\r\n查询，统计是其中非常基本的功能，以前的数据处理很多停留在这个阶段。\r\n数据挖掘，主动帮助用户发现数据规律，辅助生产制造，生活，这是未来的基本功能。\r\n\r\nh1. 图片，视频，音频 识别与搜索\r\n\r\n一个很基本的想法是做图片识别，然后打标签。\r\n这跟人的记忆有点相似，标签即概念，图片就是背后的大脑影像。\r\n根据元素在图片中的比重，设置score。\r\n\r\n视频是图片和声音的结合。 文字即概念。\r\n\r\n这也是人智力的最初阶段，就是分辨，有点机器学习的感觉。\r\n\r\n\r\n2017-10-11：\r\n先智数据的思路是用AI改进存储软件。主要是\r\n1，磁盘寿命预测\r\n2，业务模型分析，预测。\r\n\r\n当然这2点是非常有价值的。\r\n我之前考虑的是如何辅助用户挖掘数据价值。\r\n\r\n	2017-09-30 07:31:09.560443
4	1	7	rgw性能模型	硬件：\r\nrgw使用cpu和网络，rgw目前还不支持使用ssd做cache.可能通常意义并不大.\r\n\r\n组件：\r\ncivetweb, nginx, fastcgi, rados\r\n\r\n线程：\r\nrgw_thread_pool_size\r\n\r\ncache：\r\nrgw cache: 给元数据，普通数据的属性做cache.\r\n\r\n队列：\r\n请求等待队列,由线程池负责处理\r\n\r\n流控：\r\nrgw处理流控\r\nrados client流控\r\n\r\n互斥资源：\r\nrados client？\r\nbucket index\r\ndata log\r\n\r\n	2017-09-27 12:06:04.309287
9	1	7	华为对象存储的部分使用场景	1，存储各种软件包\r\n比如support的安装包，CI的软件包\r\n\r\n2，存储镜像文件\r\n\r\nVDI和docker镜像，VDI增量备份\r\n\r\n3，扫描图片\r\n安全扫描等，这里有额外价值的地方在于图片的处理上\r\n\r\n4，个人网盘\r\n\r\n5，数据库备份\r\n\r\n6，云化应用的后端存储\r\n就是与openstack，docker对接\r\n\r\n痛点表现在：\r\n1，nas的规模问题\r\n2，数据容灾\r\n3，多版本\r\n4，WORM\r\n\r\nEC的使用还是比较广泛的。	2017-10-11 09:01:02.946874
5	1	8	Osd rebalance优化	在osd out之后会触发数据迁移，但是通常我们在osd down之后并不希望触发数据迁移。\r\n这时通常会延长osd out的时间，需要人工干预。\r\n\r\n如果只有2个副本，挂掉一个之后，osd不out，继续写可靠性会降低。\r\n\r\n\r\n\r\n\r\nidea：out的时候osd产生新副本，但是新副本只写新数据。增加一个状态 die，表示这个osd彻底不行了，这时迁移其上的全部数据。\r\ndie状态需要运维干预。\r\n\r\n这个特性对于中小规模的集群还是很有价值的。\r\n\r\n大规模集群可能直接迁移更合适。	2017-09-29 09:43:06.004812
12	1	7	从编程语言想到的	中文几乎没什么新单词出现\r\n\r\n英文一个新的事物出现时，就会利用词根生发出新的单词\r\n\r\n这跟go和c++对比起来感觉有点意思。\r\n\r\n中文没有很好的扩展机制，这种语言机制对人的思维可能是一种约束。\r\n虽说语言只是世界的一种反应，但是语言可能本身也影响着世界。\r\n\r\n我讨厌c++，为什么？\r\n复杂的语法？蹩脚的代码？ 也许是对简单的热爱\r\n\r\n一个地方使用泛型，相关的其他地方可能也得用泛型。整个代码看起来很麻烦。\r\n其他也只有那么一两个类型。\r\n\r\ngo正交设计，较少的关键字，做一件事情只需一种方法，避免重复工作浪费。\r\ngo语言 interface的方式很妙，可以很方便的对接\r\n\r\nhttps://www.zhihu.com/question/20275578\r\n封装和归一化类似军队制度建设，目标是搞出一个标准化、立体、多变、高效的指挥体系，从而获得打大战、打硬战的能力，然后再去轻松碾压问题。此所谓战略。\r\n\r\n\r\n这里面很长的一个回答很有意思，也说明了面向对象的本质：接口与归一化。\r\n其实go语言非常好的具备了这2个能力\r\n\r\n计算机语言 与 人类语言难以类比。\r\n\r\n人类的语言重点在于沟通。\r\n\r\n计算机语言的本质是命令，告诉机器做什么，怎么做。所以计算机编程就像一个工程。是达成某种结果的。\r\n\r\n计算机语言是纯逻辑性的。\r\n\r\n\r\nKISS应该是最重要的编程的艺术了吧，这也是生活的艺术，非常合适的解决一些问题。\r\n\r\n何为工程人士，我觉得工程设计最牛的地方应该在于简单，实用吧。但做到这样很难。\r\n\r\n人工智能可能颠覆软件工程吗？\r\n我觉得这是一个过程，最终结果不好说。\r\n而且这也不是一个问题，其实软件从业人员面临的是解决问题，问题会变，但是问题却从未消失过。\r\n\r\n如何聪明的解决问题，才是我们需要关心的，而我们关心什么问题，想解决什么问题，才是我们的使命，这就是世事变幻。\r\n\r\n所以正确的方式\r\n也许是找到定义使命，定义自己要解决的问题，熟悉解决问题所需要的工具，不断完善自己的方法。\r\n如果已经自己已经无法做得更好\r\n\r\n那就换另一个有趣的使命吧。\r\n\r\n以后技术的方向肯定让每个人都成为专家。\r\n而每个行业都有一些细分的公司，这些公司提供专家的能力给大众。\r\n\r\nAI辅助象棋，AI辅助羽毛球教学。让人快速具备专家能力。\r\n\r\n人改进AI，AI辅助人	2017-10-16 13:12:26.588307
15	1	5	backfill期间，pglog会overflow吗,如何处理这种情况？	你刚问的问题 在osd正常的情况下不会有问题吧 正常backfill情况下，pglog都是两边都写的。trim也是可以都trim的\r\n只有当backfill节点挂了 才会出现backfill期间 pglog相差很多的情况。\r\n\r\nbackfill期间异常的情况，首先猜想一下：\r\n1，pglog还能接上的情况，那当然可以做普通的recovery，先根据pglog恢复。\r\nbackfill是会对比版本的，因此也不存在重复恢复的问题。但是尚未backfill的对象不写数据，这样会造成额外的恢复？\r\n\r\n2，pglog绕了的情况，那也只能重新做backfill了。\r\n	2017-10-24 15:11:23.407039
11	1	5	bluestore layout	bluestore元数据，对照这篇文章看：\r\nhttp://www.cnblogs.com/lucas-sre/p/7096856.html\r\n\r\n\r\nextent：文件的逻辑片段，显然文件是可能有洞的，所以这个是有存在必要的\r\nblob：空间分配的单位，一个blob对应于一段空间，blob在csum和compress，以及clone的share都会用到\r\npextent: 实际的空间片段，分配的空间都是min_alloc_size的倍数的片段。\r\n\r\n注意blob的重用只能按照偏移顺序 为什么？\r\n这样可以保证在文件不存在空洞时最好的空间利用率，同时利于读取\r\n\r\n严格按照偏移来的，不会错乱放置，可以顺序读取\r\n\r\n显然一个pextent不可能同属于多个blob，但一个blob可能包含多个pextent。\r\n同样一个lextent不可能跨越多个blob，但是一个blob可能有多个lextent\r\n\r\n对于可能跨越blob的请求，可以拆分成多个lextent。\r\n\r\n\r\n对象存储是整体写的，非常适合COW，不必在原来的地方写。\r\n这样可以避免使用journal。\r\n\r\n对象存储可以只需一层。直接映射到pextent。没有lextent的合并，也不必搞blob那套。\r\n\r\nXBlueStore！！	2017-10-12 11:37:30.001905
14	1	8	一次应聘面试点	期望对方达到：\r\n1，对ceph的了解程度，逻辑思考能力\r\n2，对开发特性的认识\r\n3，对未来的思考，期望，待遇期望\r\n4，对事物发展的看法，对象存储的未来\r\n\r\n\r\n1，对s3接口熟悉，可以独立完成nginx或者上层的一些中间件和接口开发，对接各种数据库。\r\n2，对ceph，rgw内部实现不熟悉，了解一些基本概念，没有使用c/c++开发过项目\r\n3，经验主要在业务开发，创新想法一般\r\n4，他个人看好存储的发展，但是并未展现很多对自己未来的规划。\r\n\r\n主要经历是做软件外包，沟通还比较随和，\r\n如果预期未来有类似需求和开发任务，可考虑。\r\n	2017-10-24 12:52:15.391911
16	1	7	logstash 与 elasticsearch的安装	logstash直接下载zip包，解压就可以用了\r\n\r\n	2017-10-26 09:16:55.663167
13	1	7	使用es改善运维，提升效率	elk？ 能带来什么？ 首先是认知的改变。\r\nelk能做哪些统计，分析，报表？	2017-10-23 11:47:43.247047
10	1	5	ceph社区跟踪方法	1，社区计划，线路\r\nroadmap blueprint\r\n\r\ntracker网站上的没有及时更新\r\n\r\nhttps://trello.com/b/ugTc2QFH/ceph-backlog\r\nhttp://tracker.ceph.com/projects/ceph\r\n\r\n2，社区特性的讨论\r\n邮件列表\r\n\r\n3，关键时间点，版本计划\r\nhttp://docs.ceph.com/docs/master/releases/\r\n\r\n4，问题跟踪\r\nhttp://tracker.ceph.com/projects/ceph	2017-10-11 17:39:18.152353
18	1	8	ceph对象集群扩展问题的解决思路	ceph集群在扩容时，有两种比较合适的做法，避免数据迁移。\r\n\r\n一是新增物理pool，二是新增集群。\r\n\r\nrgw上管理多个集群的方案可能略为复杂。\r\n\r\n在bucket index上实现物理pool的方案也许更为可行。\r\n\r\nbucket index就是那一层，需要使用ssd加速。\r\n\r\n还有一种方案是使用类似olh一样的redirect方案，支持让对象在读取或写入时变更所属池子。\r\nbucket的base pool，以及extra pool。这种方案也可以纳入考虑范围。	2017-11-01 13:16:09.015343
17	1	7	docker在工作中的运用	docker 开发人员用来测试功能还是非常合适的。\r\n\r\n实际生产用docker还真难说合适，容器技术的本质就是环境，资源隔离。\r\n\r\n对于无状态服务这个很爽，跟其他应用隔离，避免了各种环境不一致导致的问题。\r\n开发和运维都简化很多\r\n\r\ndocker技术是应devops而生的。\r\n\r\n但数据库，存储的生产环境，通常仅仅用来跑存储和附属服务，没有强烈的隔离需求。\r\n\r\n但平时开发测试还是很方便的，避免重复安装，虚拟化，轻量级。\r\n\r\ndocker的特点：\r\n1，虚拟化\r\n   环境，资源隔离\r\n2，轻量级\r\n   效率高，启动，关闭速度快，拷贝文件快，镜像文件小。\r\n3，镜像管理技术\r\n\r\ndocker：应用虚拟化\r\n\r\n目前应用场景：\r\n1，编译工程\r\n 尤其是像ceph这种依赖一堆东西的项目\r\n2，搭建集群，容灾环境做测试\r\n3，部署其他应用，傻瓜式，不需要懂一个软件就可以部署应用。\r\n\r\n\r\n发起一个探讨：\r\nceph docker化是过度使用？还是必然方向？\r\n	2017-10-27 08:24:14.523759
20	1	7	关于招聘的理解	招聘的本质就是找齐产品缺乏的那个人。\r\n\r\n所以明确产品规划，以及人力部署之后，就很清晰了。\r\n\r\n而招人的核心：\r\n1，这个人能胜任工作\r\n2，这个人对这个领域有兴趣，能创造公司期望的价值。\r\n\r\n而人才对于公司：\r\n1，待遇合适\r\n2，公司战略符合自己的价值观，使命预期。	2017-11-02 08:33:44.383684
21	1	5	源代码注释规则	\r\nXRCM：注释\r\nXRWHY：暂时看不懂的地方	2017-11-03 13:59:32.879864
25	1	7	分布式系统常用算法	一致性hash\r\npaxos/raft	2017-11-10 13:08:28.118427
23	1	7	阿里初步面试总结	面试是采用电话的方式，视频比较卡。\r\n\r\n面试的重点还是在做过的项目上，面试官看重：\r\n1，算法\r\n  问了一致性hash，以及hbase等的路由算法\r\n2，论文\r\n\r\n这两个关注点也是比较自然的，想想我们工作，刨除一些价值不大的琐碎之外，主要价值就是算法方面。\r\n\r\n解决的大问题，以及核心算法。而我们平时学习的重心也在于此。	2017-11-08 13:49:15.67259
24	1	8	组件的解耦	如果底下用ceph了，那么上面一些组件用ceph合适吗？\r\n\r\n这得看情况：\r\n依赖有点不好的地方就是兼容，如果不是使用原生ceph，那就得做些不兼容的事情。\r\n\r\n另外要避免循环依赖。\r\n比如om系统，elast search本身就是ceph集群的一部分，这时这些组件依赖ceph，会造成循环依赖。\r\n1，你想定位问题，但是ceph坏了，om也不能提供有效信息\r\n	2017-11-08 16:01:12.887266
28	1	7	网宿胡瑶交流纪要	他们目前使用的还是H版本\r\n1，bucket index不做recovery，直接做backfill （减少阻塞的bucket index个数）\r\n2，对象合并直接在Rgw路径上做，后台等一个大对象内部的小对象删除到一定数量，再GC。\r\n另外由于读也经过bucket index，所以在osd上做了bucket index的缓冲。\r\n  该特性还没投入使用\r\n3，扩容，他们在上层有数据库存元数据，所以采用的多集群方案。\r\n4，他们在做将RGW元数据存到mongodb的方案，但是mongodb没事务，目前遇到一些一致性问题。\r\n但他们场景下可接受。\r\n5，他们还尝试过OpenCV做人脸识别，但是精度不高，放弃了。\r\n\r\n\r\n使用bucket index来实现object跨故障域或集群，显然非常受限制。\r\n并发的粒度太小了。如果分512个shard。读写冲突仍然是非常厉害的。\r\n而且osd pg的读写锁机制，对于并发非常不好。\r\n\r\n	2017-11-16 09:28:53.407278
22	1	8	ceph rgw架构分析	1，bucket index\r\n如果rgw使用no bucket index模式，我难以想象object version怎么实现。\r\nbucket index无序的组织方式注定了list是很慢的。s3 list要求按照字母排序\r\n\r\n2，元数据分多个地方存储，造成了rgw一致性的复杂局面\r\n为了保证bucket index， object version，olh 代码复杂度搞的非常高。\r\n好处是什么呢？ 避免了操作需要经过bucket index。然而为了支撑更加复杂的特性，最终访问经过元数据层可能仍然难以避免。\r\nhttp://tracker.ceph.com/projects/ceph/wiki/RGW_Object_Versioning\r\n看这文档简直复杂的无话可说，不就是一个事务搞定的事么。\r\n\r\n为了解决扩缩容，冷热数据问题。这里可能难免有一次调整。\r\n	2017-11-03 20:26:07.654727
26	1	8	bucket index优化	bucket index使用hash方式不是很合适，bucket index上的主要操作：\r\n1，list\r\n2，write\r\n\r\nlist是需要排序的，hash在排序上非常慢。\r\nwrite的时候方便，只需hash就可以得到。\r\n\r\n改进思路：\r\n采用类似哈夫曼树的方式来组织数据。\r\n一个bucket dir节点就是一个哈夫曼节点，在达到一定规模时自动分裂。\r\n\r\n需要分裂。\r\n\r\n考虑到各种情况，可能还是得使用平衡树。\r\n\r\n否则可能出现不平衡的情况，导致一些场景下恶化。\r\n\r\n但是这种场景还是相对简单，只需不断分裂即可，不必合并节点。\r\n而且可以保证树的深度为2.	2017-11-10 13:31:00.671116
27	1	7	数据组织方式的研究	可以分几个大类：\r\n1，内存中的数据\r\n2，磁盘中的数据\r\n3，网络中的数据	2017-11-10 15:32:43.076395
30	1	7	爱数方钰翔面试	对其他竞品有些了解，日立等\r\n对公司技术方向有全面了解\r\n  超融合的困境，对象存储销售的艰难，公司销售的思维\r\n\r\n技术方面：\r\n对rados和rgw有全面的了解。\r\nEC那块也有涉及。爱数网盘就是用的EC\r\n当然还有一些奇怪的需求，比如multisite之间不同bucket sync。解决了一些multisite的问题。\r\n支持rgw对象的tail跨pool。\r\n\r\n也搞过EIO\r\n	2017-12-11 14:14:02.876267
31	1	7	紫晶光存储	1，技术特征\r\n是怎么玩的？原理\r\n\r\n2，产品优势\r\n\r\n3，合作带来的价值提升	2017-12-12 07:07:11.834308
34	1	8	OSD优化点	1，心跳优化，心跳不会因为osd压力大而挂掉\r\n2，peering优化，优化peer消息处理的优先级\r\n3，scrub优化。	2018-01-02 08:26:44.447637
33	1	7	RGW一致性保证	1，冲突写同一个对象的情况，使用id tag来 cmp write保护。\r\n2，单个对象使用两阶段来保证bi和对象一致性， prepare + complete\r\n3，多版本对象使用olh log保障，bi，olh，instance的一致性。\r\n4，容灾使用bilog同步，保证一致性。全量同步和增量同步。	2017-12-27 07:42:30.891303
36	1	5	特性快照	如果单纯的在多版本基础上实现快照，然后打完快照就不允许关闭多版本，那做起来就容易了。\r\n\r\n但是如果想支持真正意义上的快照，并且和多版本可作独立特性而存在。那么就要理清楚多版本与快照之间的关系。\r\n\r\n*将快照的不同版本当作null一样处理是一个关键点。*	2018-01-03 04:35:13.247239
37	1	7	多版本容灾bugfix汇总	1, slave zone should consider version suspend too for delete, otherwise slave may generate new version for delete - set_olh case,this is different with master zone.\r\n2, slave zone also need "null" instance to keep the same delete logic for delete null instance.\r\n这个实际上是因为delete在slave执行与master同样流程导致，但是slave执行时没有“null” instance信息，导致流程与master不一致。\r\n3，乱序执行的影响\r\n可能产生多个olh tag，导致部分同步失败。\r\n\r\n而将全量改为按序执行主要是因为支持桶快照功能。\r\n4，convert 的null instance， epoch并非总是1\r\n比如fullsync，如果按社区版本逻辑，current是null，其epoch假设是5.\r\n如果null instance最新同步，那么将会出现2个null，一个epoch是5，另一个是1（convert的）。  将fullsync的执行顺序改为按照epoch顺序执行，则不会遇到这个问题。\r\n\r\nfix : 1,olh time use empty time,otherwise slave zone may use it as null instance mtime, then will not sync null instance because of olh's mtime is newer.\r\n2, set "null" instance for unlink_instance and skip del op, otherwise we can not delete null instance from suspend version bucket.\r\n这个问题另一种解决办法是slave和master采用不同逻辑。显然slave delete不需要产生新版本，它只是同步。\r\n\r\n3, set null instance for versioned(include suspended) bucket, otherwise fullsync will create new version for null instance.\r\n这个的核心问题在于slave与master使用了同样的RGWPutObjProcessor_Atomic::prepare，这里面会产生新的instance，slave sync过程显然不需要产生新的instance。\r\n\r\n5，slave zone，多版本instance并发执行同样有问题。\r\nupdate_olh_log参考这个函数，olh log是写入最新的epoch的。\r\nolh log没有按epoch顺序产生，老epoch的instance操作olh log写入了新的epoch中，*这时trim olh log就会因为并发导致trim掉尚未执行的olh log。*\r\n\r\n6，fullsync没有同步delete marker。\r\n	2018-01-04 13:11:27.843674
61	1	7	面试套路	筛选：\r\n1，学校，专业，年龄\r\n2，工作经验符合度\r\n3，背景\r\n\r\n电话面试(15分钟以内)\r\n问题1，请做一下自我介绍\r\n  观察点：自我认知，价值观，态度，表达能力\r\n问题2，简历中某件事情内容，如何完成的(3年以下偏向个人，3年以上偏向团队，最好有成功经验)\r\n  观察点：办事能力，团队协作能力，经验认知，专业知识\r\n问题3，专业领域技术问题\r\n  观察点：学习能力，分析解决问题能力\r\n问题4，专业知识问题\r\n  观察点：基本功\r\n问题5，个人求职意向(工资？发展方向？)\r\n  观点点：价值观\r\n\r\n  \r\n  \r\n当面面试（1个小时以内）：\r\n问题1，请做一下自我介绍\r\n问题2，请详细阐述简历中一项工作（这里如果不过关，可直接终止，参与人数？你的职责？代码行数？缺陷程度？改进想法？）\r\n问题3，技术细节盘问 （说不清楚，pass）\r\n问题4，如果让你做XX工作，你的想法是什么？(套路掌握情况，更适合有一定经验的人)\r\n问题5. 有一些展示项目吗？业余一般做什么？提升手段？（对于基本功差的，这个要重点问下）\r\n问题6，离职原因，个人发展规划 （不是非常match的，经验也不是特别match, pass）\r\n\r\nlinux基础：\r\n怎么查看线程的CPU占用？\r\n怎么查看防火墙是否开启？\r\n网络和磁盘压力怎么看？怎么查看磁盘信息？\r\n怎么判定一个linux环境是虚拟机还是物理机？\r\n用什么命令查看raid卡信息？\r\n\r\nC++基础：\r\nstl或boost库问题\r\ngdb条件断点怎么用？如何仅调试一个线程？\r\n程序segmefault之后没产生core文件，可能有哪些原因？\r\nC++ map，set各有什么特性？\r\n\r\n算法：\r\n基础算法与分布式算法\r\n冒泡排序逻辑过程是怎样的？\r\n你知道有哪些分布式一致性算法？\r\n一致性hash是什么？\r\n	2018-04-17 08:47:35.762957
62	1	7	性格，工作与成功	性格在心理学上也叫人格。\r\n\r\n成长型思维与固定型思维。如何让比较一般的人成为优秀的人，如何寻找天赋和成长都不错的人。\r\n人都喜欢停留在自己的舒适区，多巴胺的记忆。这也许是性格的起源。缺乏爱的人缺乏自信，小时候缺乏交流的人沟通可能有障碍。\r\n还有一种非常重要的情绪就是恐惧，惊吓。自卑或自傲等情绪。\r\n\r\n聪明与愚钝 （处理事物上，认知障碍）\r\n感性思维与理性思维 （认知障碍，情感障碍）\r\n\r\n依赖性人格与独立性人格\r\n立即满足型与延迟满足型 （急躁，尖酸。）\r\n集体型与个体型 （在责任感，荣誉感上不一样）\r\n勇敢与软弱  （成长阻碍，恐惧）\r\n\r\n自卑自大与自信 （与爱也有关系，有的人会伪造行为，制造出一个自我，这种人通常是自卑的）\r\n积极型与消极型（乐观与悲观）\r\n外向与内向型 （交际能力）\r\n给予型与获取型 （快感来源不一样）\r\n慈爱型与冷酷型（这与小时候获取的关爱有关系）\r\n\r\n寻求满足，自我保护，恐惧是最基本的性格特质。\r\n害羞，紧张，担心，忧虑都是恐惧情绪。\r\n对于批评的恐惧让人成为完美主义者。\r\n\r\n动力(性格)，能力，匹配好才能促成成功。\r\n\r\n当我在游泳时，我看到周围很多大人在岸上。泳池里面浅水区大部分是小孩。\r\n我仿佛听到有人在议论，看这么大的人还跟小孩一样在这游。而当时我却无比坚定。\r\n不懂就要学，好玩就可以玩，跟年龄有关系吗？\r\n\r\n当我看着青春的小孩时，不禁感叹，啊，时光走的真快，我没法把他们浪费在boring的事情上了，我得去潇洒的生活，才对得起这光阴啊。\r\n\r\n\r\n人性的弱点：\r\n人类天性至深的本质，就是渴求为人所重视。（满足）\r\n人通常不会承认自己犯了错误，而且在面对别人批评时，绝大部分人都是没有任何触动的。\r\n同样亲人也会看不到自己的错误。\r\n尖锐的批评、斥责，、永远不会有效果的。\r\n有的人需要鼓励，但我想并非所有人都如此，自傲自大的人显然鼓励没什么效果。\r\n延迟满足感，玩游戏时高潮来的特别快，然而当一切停下来时，只剩下虚空。\r\n自信心，很多人缺乏这个，鼓励产生作用的原因。让事情看起来没那么难，容易达成。\r\n\r\n有一种态度非常重要，就是把一切行为和情绪当成人的逻辑反应，而不是情绪化的看待这一切。\r\n佛洛依德就是那个最早仰望星空的人，去真正关心，理解一个人的心智。\r\n\r\n掌握原则，刻意练习，不断完善，就可以达成目标。\r\n这是每个人可以做到的，或者在一定帮助下可以做到的。\r\n\r\n集体的目标一致性非常重要，这就是价值观，工作的成就感，说得急功近利一点就是上升途径。\r\n每个人都应该从工作中获得乐趣，不然就是非常boring的。	2018-05-06 21:55:11.465282
63	1	7	git使用	git的多版本快照机制，记录全量而非增量、这是git与其他版本控制最大的区别。这也决定了git能提供离线工作方式\r\n\r\ngit checkout某个分支的完整版：\r\ngit clone -b v10.2.10 --recursive https://github.com/ceph/ceph.git\r\n\r\ngit tag： tag的本质commit标记。不同branch之间的commit是树状关系。所以如果你打一个tag 3.1.5，然后想基于此修改，那么应该从该tag拉出branch。\r\n而不是先创建branch，然后打tag，这样master分支将看不到tag。\r\n\r\ngit rebase -i HEAD~4\r\ngit push origin branch-name --force\r\ngit commit --amend\r\n注意，squash的意思是挤压，也就是和previous commit合并\r\ngit.exe push -v --progress  "origin" mylocal:xr.mylocal --force\r\n\r\ngit cherry-pick\r\n\r\ngithub提交流程：\r\n1，fork\r\n2，pull request\r\n注意comment格式\r\n\r\n\r\n问题单通常不会提到master上，是因为：\r\n1，开发过程出现问题不用提单\r\n2，客户或测试都是基于特定版本\r\n\r\n社区开发对bug处理方式总是合回master，然后再backport到其他分支。在分支上仍然是需要回归验证问题单的。\r\n\r\n在冲突的情况下，放弃本地修改，强行fetch某个文件:\r\ngit fetch\r\ngit checkout origin/master -- path/to/file\r\n\r\n	2018-05-17 06:49:47.709816
35	1	5	git无法push问题解决	fatal: sha1 file '<stdout>' write error: Invalid argument\r\n\r\n\r\n$ git push -u origin feature_mos_snap2 --force\r\nCounting objects: 631, done.\r\nDelta compression using up to 4 threads.\r\nCompressing objects: 100% (437/437), done.\r\nremote: error: object file ./objects/6e/b397e0dd15073c401e1870211d3fa5004be22a is empty\r\nremote: fatal: SHA1 COLLISION FOUND WITH 6eb397e0dd15073c401e1870211d3fa5004be22a !\r\nfatal: sha1 file '<stdout>' write error: Invalid argument\r\nerror: failed to push some refs to 'git@10.10.2.111:develop/sandstone.git'\r\n\r\n网上查了很多方法不行。\r\n最后是通过创建一个新分支，然后reset到有问题的那个commit之前。再push才成功。\r\n\r\n估计是git local和remote出现冲突，一致性出现问题导致。	2018-01-02 11:55:36.381424
41	1	7	RGW特性风险	1，双活同步模块，偶尔出现同步卡住的情况，需要手动触发才能恢复。\r\n   而且问题定位这块做的不够好，出问题仍然不好定位\r\n\r\n2，快照基于epoch的逻辑顺序，与多活基于时间的顺序是有矛盾的。\r\n另外使用epoch序与异步同步方式也存在逻辑上的缺陷。比如slave自己修改了epoch 10，然后改了epoch 11.\r\nmaster这时改了epoch 11，但是尚未同步epoch 10，这样snap指向的修改对象就不一样了。\r\n回滚的时候需要注意是回滚到那个版本。\r\n\r\n3，快照基于bucket来扫描，每次去读取bucket info是不合适的。\r\nbucket的数量在不同业务场景下，可能是有非常大差异的。也许300s都读不完。\r\n这里应该将信息同步到snap对应的pool中。\r\n\r\n4，es检索的效果不是很理想，可能查询不到。\r\n\r\n5，bucket list期间，如果一些instance删除了。如何确保能够list其后的instance？\r\n目前似乎没做到，rgw会跳过该对象其他instance。	2018-01-17 08:22:01.54981
43	1	7	ceph集群单机安装	#!/bin/bash\r\n\r\nrm -f /tmp/monmap\r\nrm -rf /etc/ceph/data/*\r\nINSTALL_DIR=/var/lib/ceph\r\nHOSTNAME=node0001\r\nIP="172.18.0.130:6789"\r\n#install master\r\n${INSTALL_DIR}/bin/monmaptool --create --add a  ${IP} /tmp/monmap\r\nmkdir -p /etc/ceph/data/ceph-a\r\n${INSTALL_DIR}/bin/ceph-mon --mkfs -i a --monmap /tmp/monmap\r\n${INSTALL_DIR}/sbin/init-ceph start mon.a\r\nsleep 10\r\n#install osd\r\n\r\nmkdir -p /etc/ceph/data/ceph-0\r\nmkdir -p /etc/ceph/data/ceph-1\r\nmkdir -p /etc/ceph/data/ceph-2\r\n${INSTALL_DIR}/bin/ceph osd create\r\n${INSTALL_DIR}/bin/ceph-osd -i 0 --mkfs\r\n${INSTALL_DIR}/bin/ceph osd create\r\n${INSTALL_DIR}/bin/ceph-osd -i 1 --mkfs\r\n${INSTALL_DIR}/bin/ceph osd create\r\n${INSTALL_DIR}/bin/ceph-osd -i 2 --mkfs\r\n#modify crush\r\n${INSTALL_DIR}/bin/ceph osd crush add-bucket ${HOSTNAME} host\r\n${INSTALL_DIR}/bin/ceph osd crush move ${HOSTNAME}  root=default\r\n${INSTALL_DIR}/bin/ceph osd crush add osd.0 1.0 host=${HOSTNAME}\r\n${INSTALL_DIR}/bin/ceph osd crush add osd.1 1.0 host=${HOSTNAME}\r\n${INSTALL_DIR}/bin/ceph osd crush add osd.2 1.0 host=${HOSTNAME}	2018-01-18 10:29:28.471846
42	1	7	rgw对象存储基本配置	[global]\r\nfsid = 005e9cec-819e-45cd-b911-976ada60d545\r\nrbd_default_features = 3\r\nauth cluster required = none\r\nauth service required = none\r\nauth client required = none\r\nosd pool default min size = 1\r\nosd pool default pg num = 64\r\nosd pool default pgp num = 64\r\nrgw_cache_enabled = False\r\nrgw_cache_lru_size = 100000\r\nrgw_thread_pool_size = 600\r\nrgw_num_rados_handles = 1\r\nrgw_override_bucket_index_max_shards = 64\r\nrgw_max_chunk_size = 4194304\r\nrgw_enable_usage_log = True\r\nrgw_user_quota_sync_wait_time = 1800\r\nrgw_user_quota_sync_interval = 1800\r\nrgw_multipart_min_part_size = 4194304\r\npublic network = 172.18.0.1/24\r\ncluster network = 172.18.0.1/24\r\nmon_osd_reporter_subtree_level = osd\r\nosd_crush_chooseleaf_type = 0\r\nrun dir = /etc/ceph/\r\n\r\n[mon]\r\nmon initial members = a\r\nmon osd down out interval = 172800\r\nlog_file = /etc/ceph/log/$cluster-$name.log\r\nmon data = /etc/ceph/data/$cluster-${id}\r\n\r\n[mon.a]\r\nhost = node0001\r\nmon addr = 172.18.0.130\r\n\r\n[osd]\r\nosd data = /etc/ceph/data/$cluster-${id}\r\nosd journal = /etc/ceph/data/$cluster-${id}/journal\r\nosd_max_write_size = 8\r\nosd_journal_size = 64\r\nlog_file = /etc/ceph/log/$cluster-$name.log\r\nosd scrub begin hour = 1\r\nosd scrub end hour = 5\r\nosd erasure code plugins = ""\r\nosd recovery max single start = 1\r\nosd recovery threads = 1\r\nosd push per object cost = 1000\r\nosd max backfills = 1\r\nosd max push objects = 1\r\nosd max push cost = 2097152\r\nosd delay recovery util = 0.6\r\nosd recovery max chunk = 4194304\r\nosd recovery max active = 1\r\nosd recovery sleep sec = 0.05\r\ndebug_objclass = 2\r\n[osd.0]\r\nhost = node0001\r\n[osd.1]\r\nhost = node0001\r\n[osd.2]\r\nhost = node0001\r\n\r\n[client.radosgw.sync_rgw1]\r\nkeyring = /etc/ceph/ceph.client.radosgw.keyring\r\nrgw_frontends = fastcgi\r\nrgw_port = 8090\r\nlog file = /etc/ceph/log/client.radosgw.sync_rgw1.log\r\nrgw test mode = 0\r\nrgw_zone = SZ\r\nrgw bucket map max pull size = 16777216\r\nrgw_print_continue = false\r\nrgw_content_length_compat = true\r\ndebug_rgw = 1\r\nrgw_bucket_max_snaps = 2\r\noperation_log_path = /etc/ceph/log/\r\nrgw_snaptask_processor_max_time = 10\r\n\r\n[client.radosgw.es]\r\nkeyring = /etc/ceph/ceph.client.radosgwes.keyring\r\nrgw_frontends = fastcgi\r\nrgw_port = 8092\r\nlog file = /etc/ceph/log/client.radosgw.es.log\r\nrgw test mode = 0\r\nrgw_zone = SZES\r\ndebug_rgw = 1\r\nrgw bucket map max pull size = 16777216\r\nrgw_print_continue = false\r\nrgw_content_length_compat = true\r\nrgw_enable_gc_threads = false\r\n\r\n\r\nnginx_conf:\r\nuser  root;\r\n\r\nworker_processes auto;\r\nworker_cpu_affinity auto;\r\nworker_rlimit_nofile 65535;\r\n\r\npid        /etc/ceph/nginx.pid;\r\nerror_log  /etc/ceph/nginx_error.log;\r\n\r\nevents {\r\n    use epoll;\r\n    worker_connections  65535;\r\n}\r\nhttp {\r\n    include       mime.types;\r\n    default_type  application/octet-stream;\r\n    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '\r\n                      '$status $body_bytes_sent "$http_referer" '\r\n                      '"$http_user_agent" "$http_x_forwarded_for"';\r\n\r\n    access_log  /etc/ceph/nginx_access.log  main;\r\n    #charset  utf-8;\r\n    sendfile        on;\r\n    tcp_nopush     on;\r\n    tcp_nodelay on;\r\n\r\n    fastcgi_connect_timeout 300;\r\n    fastcgi_send_timeout 300;\r\n    fastcgi_read_timeout 300;\r\n    fastcgi_buffer_size 64k;\r\n    fastcgi_buffers 4 64k;\r\n    fastcgi_busy_buffers_size 128k;\r\n    fastcgi_temp_file_write_size 128k;\r\n    keepalive_timeout  0;\r\n    client_max_body_size        100G;\r\n\r\n    include /root/nginx/conf/conf.d/*.conf ;\r\n} \r\n\r\nrgw conf:\r\nserver {\r\n        listen   8080;\r\n        location / {\r\n        if ($request_method = 'OPTIONS') {\r\n    add_header 'Access-Control-Allow-Origin' '*' always ;\r\n    add_header 'Access-Control-Allow-Methods' 'GET, POST,PUT, DELETE, OPTIONS' always;\r\n    add_header 'Access-Control-Max-Age' 1728000;\r\n    add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-MD5,ETag,authorization,x-amz-content-sha256,x-amz-acl,x-amz-date,x-amz-user-agent,x-amz-tagging,x-amz-copy-source'  always ;\r\n    add_header 'Content-Type' 'text/plain charset=UTF-8' always ;\r\n    add_header 'Access-Control-Expose-Headers' 'ETag' always;\r\n    return 204;\r\n}\r\nif ($request_method = 'POST') {\r\n  add_header 'Access-Control-Allow-Origin' '*' always ;\r\n  add_header 'Access-Control-Allow-Methods' 'GET, POST,PUT,DELETE, OPTIONS'  always ;\r\n  add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-MD5,ETag,authorization,x-amz-content-sha256,x-amz-acl,x-amz-date,x-amz-user-agent,x-amz-tagging,x-amz-copy-source'  always ;\r\n  add_header 'Access-Control-Expose-Headers' 'ETag' always;\r\n}\r\nif ($request_method = 'GET') {\r\n  add_header 'Access-Control-Allow-Origin' '*';\r\n  add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT,DELETE,OPTIONS';\r\n  add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-MD5,ETag,authorization,x-amz-content-sha256,x-amz-acl,x-amz-date,x-amz-user-agent,x-amz-tagging,x-amz-copy-source';\r\n  add_header 'Access-Control-Expose-Headers' 'ETag' always;\r\n}\r\nif ($request_method = 'PUT') {\r\n  add_header 'Access-Control-Allow-Origin' '*' always;\r\n  add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT,DELETE,OPTIONS' always;\r\n  add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-MD5,ETag,authorization,x-amz-content-sha256,x-amz-acl,x-amz-date,x-amz-user-agent,x-amz-tagging,x-amz-copy-source';\r\n  add_header 'Access-Control-Expose-Headers' 'ETag' always;\r\n}\r\nif ($request_method = 'DELETE') {\r\n  add_header 'Access-Control-Allow-Origin' '*' always;\r\n  add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-MD5,ETag,authorization,x-amz-content-sha256,x-amz-acl,x-amz-date,x-amz-user-agent,x-amz-tagging,x-amz-copy-source';\r\n  add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT,DELETE,OPTIONS' always;\r\n  add_header 'Access-Control-Expose-Headers' 'ETag' always;\r\n}\r\n             fastcgi_pass  127.0.0.1:8090 ;\r\n\r\n             fastcgi_param  QUERY_STRING     $query_string;\r\n             fastcgi_param  REQUEST_METHOD   $request_method;\r\n             fastcgi_param  CONTENT_TYPE     $content_type;\r\n             fastcgi_param  CONTENT_LENGTH   $content_length;\r\n             fastcgi_pass_header Authorization;\r\n             fastcgi_pass_request_headers on;\r\n\r\n             fastcgi_connect_timeout 600;\r\n             fastcgi_send_timeout 600;\r\n             fastcgi_read_timeout 600;\r\n             fastcgi_request_buffering off;\r\n\r\n             fastcgi_cache_valid 200 302 301 1h;\r\n             fastcgi_cache_valid any 1m;\r\n             fastcgi_cache_min_uses 1;\r\n             fastcgi_cache_use_stale error timeout invalid_header http_500;\r\n             fastcgi_cache_key $request_method://$host$request_uri;\r\n             include fastcgi_params;\r\n        }\r\n}\r\n	2018-01-18 09:45:18.742848
45	1	7	与邱尚高聊天记录	邱哥的观点：\r\n小企业在夹缝中生存。\r\nUSP难以构建竞争力，竞争激烈。\r\n\r\n对象存储的机遇在于大企业尚未在企业市场内投入，小企业在营销上存在一些缺陷。\r\n一般的售前在推广对象存储上有些困难。对象存储需要与用户深入交流。\r\n\r\n对象存储对于小企业是个机会。\r\n\r\n另外AI下沉到对象内部处理有一定优势。 但是并未讲明白优势在哪里。\r\n\r\n人事上，邱哥也明说很多人可能出来了，处于高位，但是不具备相应的能力。\r\n这种能力不仅是技术能力，还有社交能力，政治能力。\r\n\r\n不知人事，焉能带队。\r\n\r\n目前我在独自带队打造产品核心竞争力上仍然欠缺。对产品大架构调整的能力仍然欠缺。\r\n如何掌握ceph这种复杂度的软件的大规模修改。设计方案上的缺陷仍然存在。\r\n比如桶快照这种规格的特性，都有一些缺陷。\r\n\r\n就像打羽毛球的能力提升一样，研发技术上也有很多细节需要不断锻炼，不断提升。\r\n\r\n通人事，能干事。 也许年薪百万就不是难事了吧。\r\n给自己一年时间。	2018-01-19 20:43:32.871647
38	1	5	多版本代码解读之delete marker	在开启多版本的时候，delete marker比较单纯，因为没有对应的instance rados obj。 但是在多版本挂起或者快照场景下，就不一样了。delete marker可能直接写到一个有实体的对象上。\r\n\r\n为了应对这个问题，rgw有一个特殊的处理：\r\n<pre><code class="cpp">\r\n/*\r\n   * Special handling for null instance object / delete-marker. For these objects we're going to\r\n   * have separate instances for a data object vs. delete-marker to avoid collisions. We now check\r\n   * if we got to overwrite a previous entry, and in that case we'll remove its list entry.\r\n   */\r\n  if (op.key.instance.empty()) {\r\n    //XRCM:这段说白了就是清理以前的null instance index\r\n    //其他非null instance的instance is not need, will key the key\r\n    BIVerObjEntry other_obj(hctx, op.key);\r\n    ret = other_obj.init(!op.delete_marker); /* try reading the other null versioned entry */\r\n    existed = (ret >= 0 && !other_obj.is_delete_marker());\r\n    if (ret >= 0 && other_obj.is_delete_marker() != op.delete_marker) {\r\n      //XRCM:如果有delete marker,或者目前要执行delete，都clear index\r\n      ret = other_obj.unlink_list_entry();\r\n      if (ret < 0) {\r\n        return ret;\r\n      }\r\n      ret = other_obj.unlink();\r\n      if (ret < 0) {\r\n        return ret;\r\n      }\r\n    }\r\n\r\n    removing = existed && op.delete_marker;\r\n  } else {\r\n    removing = (existed && !obj.is_delete_marker() && op.delete_marker);\r\n  }\r\n</code></pre>\r\n\r\n这段意思是说给null instance & delete marker的情况额外的制造一个instance entry，从而避免冲突。 也就是 XX_id(d就是delete，参见)\r\n<pre><code class="cpp">\r\nstatic void encode_obj_versioned_data_key(const cls_rgw_obj_key& key, string *index_key, bool append_delete_marker_suffix = false)\r\n{\r\n  *index_key = BI_PREFIX_CHAR;\r\n  index_key->append(bucket_index_prefixes[BI_BUCKET_OBJ_INSTANCE_INDEX]);\r\n  index_key->append(key.name);\r\n  string delim("\\0i", 2);\r\n  index_key->append(delim);\r\n  index_key->append(key.instance);\r\n  *if (append_delete_marker_suffix) {\r\n    string dm("\\0d", 2);\r\n    index_key->append(dm);\r\n  }*\r\n}\r\n</code></pre>\r\n这里仅仅是处理这种特殊情况。\r\n\r\n上述第一段代码里面处理2种情况：\r\n1，在有instance的对象上，复用instance创建marker（bucket挂起或快照时存在）\r\n2，覆盖delete marker的instance，写入新对象。\r\n	2018-01-04 15:07:26.068343
32	1	8	黄金法则for 多版本，容灾	rule 1：olh修改操作对象哪个版本，取决于bucket状态。多版本挂起则olh操作null对象，多版本开启产生新版本作为操作对象。\r\nrule 2：容灾总是操作instance，所以不必产生新版本。\r\nrule 3：对于rados和bi， olh和null是一样的，总是操作一样的对象和key。 empty instance(olh)和null instance唯一区别在于操作对象的选取上，但容灾不必选取对象。所以容灾不必感知empty还是null。\r\nrule 4：全量同步按对象版本生成顺序串行执行\r\nrule 5：增量同步按bilog顺序串行执行（并发执行无法保证按照epoch顺序，因而造成逻辑混乱）\r\nrule 6：olh不是对象，没有mtime。\r\n\r\n多活下，olh epoch不一致会有问题吗？什么情况会导致olh epoch不一致？\r\n快照索引在多活下根据epoch调整的逻辑合适吗？会不会master zone快照的上一个对象与slave不一致？\r\n这种不一致存在，试想slave在没同步snap 10的对象时，自己写了snap 10对象，然后又切到snap 11.\r\n这时在slave上已经有了snap index，再次同步master snap 10的对象时，epoch可能比较小，就不会修改snap index了。\r\n\r\nrule 7：多活在多版本，或者快照下没有串行化，不同zone执行顺序并不一样。因而存在一致性上的问题。\r\nrule 8：元数据与数据分开同步，导致不同zone在执行操作时，可能使用不同的元数据。就像ceph按照pg分主从一样，在无锁条件下，完全的多主是实现不了的。\r\n所以使用多活也有约束，比如某些bucket在某些zone上作为主。\r\nrule 9：主备zone的olh epoch应该一致，否则olh指向的版本可能不一样。\r\n	2017-12-21 11:45:16.435082
44	1	7	如何写代码注释	代码的修改，新增都是有原因的。\r\n\r\n注释要写应该有2点原因：\r\n1，解释为什么改动代码\r\n2，解释复杂的逻辑\r\n\r\n<pre><code class="cpp">\r\n    bool versioning_enabled() {\r\n      //version able or disable,we can get from instance or olh, no need get from bucket info.\r\n      //espically from slave\r\n      return (!versioning_disabled);\r\n    }\r\n</code></pre>\r\n\r\n这注释就写的很龊，no need并非修改代码的原因，深层次的原因是什么呢？\r\n\r\n	2018-01-19 19:15:05.786891
46	1	7	git常用命令	删除远程分支 ： git push origin --delete branchname\r\n\r\n清除unstack file ： git clean -df\r\n\r\nsquash： \r\ngit rebase -i HEAD~4\r\ngit push origin branch-name --force\r\ngit commit --amend\r\n注意，squash的意思是挤压，也就是和previous commit合并\r\ngit.exe push -v --progress  "origin" mylocal:xr.mylocal --force\r\n\r\nmerge：\r\ngit merge --no-ff\r\n\r\n技巧：\r\n1，临时修改源文件，编译后还原\r\n使用git status | grep cc, git status | grep "\\.h"	2018-01-24 12:15:52.391627
47	1	7	桶快照操作	创建快照\tRest API\t"PUT bucket/?snapshot\r\n\r\n<SnapShot><description>snapshotexample</description></SnapShot>\r\n"\t\t\r\n获取快照列表\tRest API\t"GET bucket/?snapshot\r\n\r\n"\t<?xml version="1.0" encoding="UTF-8"?><SnapSet xmlns="http://s3.amazonaws.com/doc/2006-03-01/"><SnapShots><SnapShot><id>1</id><time>2018-01-02 07:58:32.000000Z</time><description>snapshotexample</description></SnapShot></SnapShots></SnapSet>\t\r\n获取快照变更列表\tRest API\t"GET bucket/?snapshot&id=\r\n\r\nid为快照id\r\n\r\n\r\n鉴权不包含id参数"\t<?xml version="1.0" encoding="UTF-8"?><ListSnapResult xmlns="http://s3.amazonaws.com/doc/2006-03-01/"><Objects><Object><Key>assert.h</Key><Mtime>2018-01-02T08:08:04.092Z</Mtime><CurVersion>.DkPJfOsvXaF1xc8an.hQdORCtmzovv</CurVersion><PreVersion>oMq8adujIdz.lv1BZ0C56nkUhawUBKa</PreVersion></Object></Objects></ListSnapResult>\t\r\n设置bucket快照配置\tRest API\t"PUT bucket/?snapshot&config\r\n\r\n<SnapSetConfiguration><num>1</num><mode>day</mode><day>1</day><hour>14</hour><min>30</min></SnapSetConfiguration>\r\n\r\n鉴权不包含config参数\r\n"\t\t"interval单位是s\r\nnum是保留快照数量"\r\n获取bucket快照配置\tRest API\tGET bucket/?snapshot&config\t<?xml version="1.0" encoding="UTF-8"?><SnapSetConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/"><num>1</num><mode>day</mode><day>1</day><hour>14</hour><min>30</min><sec>0</sec></SnapSetConfiguration>\tmode分为day, week, month三种，sec可以不传入，默认为0\r\n回滚bucket到快照点\tRest API\t"PUT bucket/?rollback&id=\r\n\r\n鉴权不包含id参数"\t\t请求会在后台执行，该命令参数检查通过触发回滚就返回\r\n获取回滚进度\tRest API\tGET /?rollback\t<?xml version="1.0" encoding="UTF-8"?><ListBuckets xmlns="http://s3.amazonaws.com/doc/2006-03-01/"><Buckets><Bucket><name>test18</name><percent>0</percent></Bucket></Buckets></ListBuckets>\tpercent为回滚进度\r\n	2018-01-24 12:16:13.118571
48	1	7	多版本实现说明	特性描述\r\n目的\r\n桶快照特性的目标是解决用户桶出现整体性故障的恢复问题。在多版本下，故障恢复需要应用程序记录bucket内每个需要恢复的对象的版本，增加了应用使用的负担。\r\n\r\n有了桶快照之后，可以直接rollback到某个快照点即可。\r\n\r\n功能\r\n从快照设计目标看，快照功能与多版本功能是可以独立的。多版本是每个修改操作都操作新版本，但是快照从语义上讲是修改操作作用于当前版本，打了快照之后当前版本变成历史版本。也就是说新版本仅产生于新快照生成时。\r\n\r\n功能列表：\r\n\r\n支持同时启用快照和多版本\r\n支持手动创建快照\r\n支持配置规则自动打快照\r\n支持查询快照列表\r\n支持查询快照规则配置\r\n支持查询快照变更对象(这里没有提供查询快照对象，提供的是增量变化的列表)\r\n支持快照回滚，回滚进度可查\r\n支持自动trim快照\r\n支持在zone故障时，仍然能够rollback快照，trim快照\r\nrgw故障之后，其他rgw或者恢复后的rgw应该能够继续执行中断的rollback，trim 操作。\r\n\r\n数据结构\r\n快照ID\r\n每个快照的唯一编号，单调递增，从1开始。\r\n\r\n快照对象的表示\r\n如何表示快照对象？快照对象与普通对象，以及多版本对象的区别是什么？\r\n\r\n为了简化处理模型，这里将普通对象当作快照0，第一个快照的编号是1，以此类推。打完快照n之后，修改操作就落在该快照对应的对象上。这里可能与常见的快照处理就有点不一样了。也就是说null instance是“属于”快照1的对象，而快照1上修改的对象实际上属于快照2，但当前没有快照2. 这时需要注意的地方。\r\n\r\n所以rollback和trim的时候，处理的是snap Id对应的上一个版本的对象。比如rollback to snap 1，很可能就是拿着null instance来覆盖当前版本了。\r\n\r\n快照独立使用时，其使用的versionId(instance)可以使用快照编号。这样做的原因是修改操作在没有新快照产生时，总是写入到当前快照版本对应的对象上。\r\n\r\n快照与多版本一起使用时，使用多版本的规则，每次都产生新的versionId。但是bucket index中会记录每个instance(version)属于哪个快照版本。\r\n\r\n快照变更列表\r\n快照变更列表记录了快照期间修改的所有对象。 快照信息的维护，快照回滚，trim快照都是围绕该数据结构来的。\r\n\r\nstruct rgw_bucket_snapshot_entry {\r\n  uint64_t snapid;\r\n  cls_rgw_obj_key key;//obj name\r\n  list<string> instances; //该snap下的所有变更对象版本，用于trim清理\r\n  uint64_t prev_snapid; //用于找到上一个snapshot entry，trim的时候会用到\r\n  string prev_snap; //上一个版本，这个就是回滚的目标\r\n  ceph::real_time mtime;\r\n实现\r\n有了上述结构之后，实现就是根据该结构来执行相应的操作。\r\n\r\n回滚\r\n回滚任务只会在master zone执行。\r\n回滚期间bucket不可读写。\r\n\r\n用户触发回滚之后，会在snap worker中添加一个snap回滚的任务。snap worker每隔一段时间检查是否有任务要执行，如果有则触发回滚的执行。\r\n\r\n实现主体函数：\r\n\r\nint RGWSnapWorker::rollback(cls_rgw_snaptask_info &task, utime_t end)\r\n为了避免rgw故障后重复回滚，回滚会记录进度，进度信息持久化在snap相关的pool中（跟gc类似的机制）。在rgw重启或其他rgw接手任务之后，会从持久化的rollback位置继续。\r\n\r\n为了在zone切换时，仍然能够执行回滚，在rgw重新加载的时候(切换角色rgw会重新init rados storage)执行init_buckets_task加载bucket上的回滚任务。\r\n\r\nvoid RGWSnapWorker::init_buckets_task()\r\ntrim\r\n超过预留数量的snapshot会被trim。\r\n\r\ntrim 实现主体函数：\r\n\r\nint RGWSnapWorker::trim_snap(cls_rgw_snaptask_info &task, utime_t end)\r\ntrim根据snap index找到snap下的变更对象列表，然后将对象逐个删除。最终删除snap index，并且更新bucket的快照列表。\r\n\r\n自动快照\r\n支持按照每天/周/月 为周期打快照，打快照的具体时间可配置。 打快照的时间误差为配置项rgw_snaptask_processor_period，默认为5分钟。\r\n\r\nvoid RGWSnapWorker::check_buckets()\r\n注意事项\r\n快照的对象可以删除，但是删除可能影响快照的完整性。\r\n快照回滚期间，bucket不能读写，以免产生数据不一致。\r\n数据同步序按照epoch顺序，否则会导致快照信息的紊乱。\r\nbucket info同步存在时间差，在多活情况下，在时间临界点可能出现快照变更列表不一致。要考虑是否在业务接受范围。自动快照最好在业务不繁忙时。\r\n规格以及rest接口请参考：\r\nhttps://svn.szsandstone.com/svn/sandstone/doc/20.版本配套文档/对象存储文档/V3.1.3/bucket快照特性规格描述.xlsx	2018-01-30 08:22:42.864382
51	1	7	面试C++开发点评	沈普春： \r\n技能，毕业一年多了解的面还可以，深度一般。 \r\n能力，在组织表达上偏弱，阐述想法的逻辑性上不是特别好。解决问题的方法，思路方面没有体系化。\r\n学习，专业相关知识业余学习还可以，其他方面涉及不多。\r\n价值观，没有明确的职业规划，尚未想清楚自己的方向。\r\n性格，感觉比较温和敦厚。\r\n\r\n技能上，关于bug定位，性能调优，review代码，实现方案设计方面可以多涉及一点。\r\n\r\n价值观与公司文化契合度。\r\n性格，团队协作能力。积极主动，严于律己，宽以待人，具备反思精神。\r\n学习，更新自己，这是人发展潜力的标志。一年没进步的人，10年可能也没进步。\r\n\r\n	2018-03-06 14:11:21.890708
54	1	5	s3请求超时分析	{"op":"PUT","bucket":"test1","object":"myobjects9656","instance":"","mtime":"2018-03-13T10:55:47.853Z","user_id":"04ee2278917d3848becab9337dcc1a1c","display_name":"yuty","data_type":"BUSINESS","code":200}\r\n\r\n2018-03-13 21:24:25.865187 7f8c89c7f700 2 ====== req done req=0x7f8c70f621c0 obj=test1/myobjects9656 op status=-1 op name=get_obj http_status=403 ======\r\nget请求错误，get返回403的原因是什么？\r\n\r\nput请求\r\n2018-03-13 21:22:11.587343 7f8d0ad81700 3 req 165074:60.003823:s3:PUT /test1/ivw5gr62hpxse8zbk47l/b2918vtpgmihweo0u5knf6cd/mgkvq2zb/rjcshn83ka9q6pdvtluxz157/1xv/9sb3n17ozpejdiuf/xjq5U9q1kL:put_obj:test1/ivw5gr62hpxse8zbk47l/b2918vtpgmihweo0u5knf6cd/mgkvq2zb/rjcshn83ka9q6pdvtluxz157/1xv/9sb3n17ozpejdiuf/xjq5U9q1kL :completing\r\n2018-03-13 21:22:11.587408 7f8d0ad81700 3 req 165074:60.003888:s3:PUT /test1/ivw5gr62hpxse8zbk47l/b2918vtpgmihweo0u5knf6cd/mgkvq2zb/rjcshn83ka9q6pdvtluxz157/1xv/9sb3n17ozpejdiuf/xjq5U9q1kL:put_obj:test1/ivw5gr62hpxse8zbk47l/b2918vtpgmihweo0u5knf6cd/mgkvq2zb/rjcshn83ka9q6pdvtluxz157/1xv/9sb3n17ozpejdiuf/xjq5U9q1kL :op status=-2010\r\n2018-03-13 21:22:11.587413 7f8d0ad81700 3 req 165074:60.003891:s3:PUT /test1/ivw5gr62hpxse8zbk47l/b2918vtpgmihweo0u5knf6cd/mgkvq2zb/rjcshn83ka9q6pdvtluxz157/1xv/9sb3n17ozpejdiuf/xjq5U9q1kL:put_obj:test1/ivw5gr62hpxse8zbk47l/b2918vtpgmihweo0u5knf6cd/mgkvq2zb/rjcshn83ka9q6pdvtluxz157/1xv/9sb3n17ozpejdiuf/xjq5U9q1kL :http status=400\r\n2018-03-13 21:22:11.587418 7f8d0ad81700 2 ====== req done req=0x7f8c6ef77d00 obj=test1/ivw5gr62hpxse8zbk47l/b2918vtpgmihweo0u5knf6cd/mgkvq2zb/rjcshn83ka9q6pdvtluxz157/1xv/9sb3n17ozpejdiuf/xjq5U9q1kL op status=-2010 op name=put_obj http_status=400 ======\r\n\r\n对应于nginx的就是408错误：\r\n10.10.4.25 - - [13/Mar/2018:21:17:25 +0800] "PUT /test1/ivw5gr62hpxse8zbk47l/b2918vtpgmihweo0u5knf6cd/mgkvq2zb/rjcshn83ka9q6pdvtluxz157/1xv/9sb3n17ozpejdiuf/xjq5U9q1kL HTTP/1.1" 408 25 "-" "Boto/2.46.1 Python/2.7.10 Windows/7" "-"\r\n\r\n在中孚现场问题：\r\nnginx返回400错误，与此同时rgw的http err是403\r\n这个问题暴露了我们很多缺陷：\r\n1，rgw日志，审计日志都有问题，而日志是我们定位问题的第一道关，按理说95%问题在这一步能解决。\r\n2，nginx日志也有问题，而且nginx这块没人很精通，出了问题风险非常大。	2018-03-14 08:09:13.291394
59	1	7	人力需求	1，强化运维能力。打磨产品运维细节。\r\n\r\n2，osd研发，解决osd恢复阻塞业务，EC等问题。\r\n\r\n3，rgw研发，解决rgw核心竞争力问题，bucket无限扩展，跨故障域。\r\nrgw性能竞争力。数据流动，支持各种模式的多数据中心等。	2018-04-10 12:12:25.624987
56	1	7	docker在rgw开发中的使用	1，配置静态网络\r\ndocker network create --subnet=172.18.0.0/16 dockernet\r\n\r\n2.利用镜像创建docker虚拟机，并配置端口映射\r\ndocker run -it --privileged=true -v /opt/sandstone/:/var/lib/ceph/ --net dockernet --ip 172.18.0.102 -p 8000:8080 cephcluster_base /bin/bash\r\n其中8000是宿主机端口。\r\n\r\n3，启动容器，进入容器\r\ndocker start xx\r\ndocker exec -it xx /bin/sh\r\n\r\n\r\n目前用的docker容器：\r\nMOS_bugfix\r\ndocker run -it --privileged=true -v /home/xierui/mos/release/:/var/lib/ceph/ --net dockernet --ip 172.18.0.100 -p 8070:8080 registry.cn-hangzhou.aliyuncs.com/freelink/ceph_rgw_master:1 /bin/sh\r\n	2018-03-21 12:06:15.276145
49	1	8	Redmine项目管理的思考	redmine操作注意\r\n1，代码提交必须有对应的单号，或者feature编号\r\n  为什么这点如此重要？因为过了一段时间后，将没人知道为何有这个修改。\r\n2，问题需要在不同版本合入时，需要复制问题单到对应版本\r\n   避免问题单遗漏\r\n3，问题单根据定位的原因，纳入到相关特性，根据需要变更责任人。\r\n   划清责任人\r\n4，master转测拉分支时，Feature复制到对应分支，部分尚未解决但需要在该分支解决的问题单也需从master同步到新的release分支。\r\n5，发布，列出本版本新增特性Readme，确保所有问题得到解决，未解决说明原因可走到不解决的状态，文档更新。\r\n6，问题解决状态为resolved，转给测试，回归通过后close。\r\n7，问题单必须自测通过，才能走到resolved状态。\r\n8，问题在提出之后，需要立即做初步定为，并且增加注释，走出new状态。\r\n   任何系统都得使用起来，才有效果。trace很重要\r\n9，利用子任务功能，做好开发任务的进度管理。\r\n10，研发特性需提供的文档：1，特性实现文档， 2，特性规格接口文档。\r\n11，遇到问题，快速记录。 持续改进，这种创新改进氛围非常重要。\r\n\r\n核心问题：\r\n1，按版本，特性的维度把项目管理起来\r\n确保问题及时的记录到所有分支版本上\r\n确保版本的所有问题得到解决，风险可控。\r\n了解特性的风险\r\n\r\n2，代码提交规范，问题与提交记录关联。\r\n强调自测试，及时更新问题状态。\r\n\r\n版本1.0\r\n需解决如下问题：\r\n1，文档的更新如何与特性，bug相关联？\r\n因为有些特性，以及bug涉及更新文档。比如规格上的，规避手段上的。\r\n*\r\n可以把开发任务和分解任务，bug关联起来。*\r\n\r\n2，如何量化特性开发的进度？\r\n特性需进一步分解成小任务。并且需要从不同维度来展开。\r\n比如文档，升级影响，安全，性能 等等。\r\n\r\n3，更详细的产品规格，包括可靠性，硬盘故障的修复时间等等。\r\n\r\n4，另外例会时，应该有办法反应整个项目的进度，风险。 量化的方式展示出来，而不是从时间维度看，这周做什么，下周做什么。\r\n这种反应是有时间连贯性的。反应了一种因果逻辑，即我们的目标是什么？ 完成某个版本，分解下来有哪些事情，每个进展如何？\r\n\r\n基于目标的纵横。\r\n纵者，深入做好其中的一步，处理好与各种周边的关系\r\n横者，找到各种相关项，明确特性之间的相互影响关系。\r\nDFX等虽说不是代码，但是也是产品所体现出来的非常重要的特性， 是非常重要的维度。\r\n\r\n搞清楚项目管理这台机器基本运行，人的因素。\r\n\r\n绩效好的标准：\r\n1，个人高效\r\n2，团队高效\r\n\r\n\r\n高效包含质量和速度两个指标。\r\n包含方向和执行力两个维度。\r\n\r\n\r\n1，以目标驱动\r\n每个人根据整体目标，任务分解情况，制定小目标。\r\n目标要符合OKR的特征：\r\n1，可量化\r\n2，具备挑战\r\n3，公开透明\r\n\r\n重点在于目标制定和任务分解。\r\n\r\n2，任务执行\r\n任务制定之后，需要人高质量的执行，这是实在出成果的地方。\r\n为了方便沟通，确保任务的落实闭环，适当的流程是需要的。\r\n开发任务上，建议使用好redmine系统。\r\n从版本/特性/bug 维度，展示版本开发工作任务。\r\n从计划/完成 维度理清执行情况。\r\n\r\n重点在于有节奏的执行好每一步。\r\n\r\n3，自发的任务\r\n3.1 及时记录问题\r\n当脑海中闪现某个问题，产品缺陷时，要及时记录。\r\n当用户出现某个问题时，要及时记录。\r\n记录避免遗漏，避免犯同样的错误。\r\n\r\n3.2 专项任务的闭环\r\n当出现专项任务时，任务的闭环这块是需要做好的。\r\n否则可能出现无人跟踪的情况，专项任何其实也可以使用redmine来简单跟踪。\r\n但是详细资料可能需要另外存储。\r\n\r\n积极主动，确保目标达成。\r\n\r\n积极主动：改进与实施。组织人员是否能主动提出改进建议，并进行实施。\r\n这块需要预留一定的时间，同时可以缓冲一些风险。\r\n\r\n把事情做清楚的能力，很多人没搞清根因。\r\n\r\n\r\n人员交接的代价是非常高的。尤其是在缺乏科学的工程管理的情况下。\r\n想想那些千丝万缕的逻辑，保持软件逻辑的简单是软件设计的NO 1任务。\r\n即便如此，在长时间之后，也可能面目全非。没有人能够理解的代码就没办法维护。\r\n\r\n1，简单胜过其他\r\n2，重要修改应该有详细记录，所有修改都已经有对应的记录。记录中因为描述因果\r\n3，任务需要分解，需要设立时间点，责任人。\r\n4，把一套体系运作起来，就像一个机器一样。推动它，使用它，改进它。redmine如此，项目管理也是如此。\r\n\r\n\r\n在提交代码时的check：\r\n1，用例变更与自动化\r\n2，文档变更\r\n3，规格变更\r\n4，工具变更	2018-03-01 14:35:58.235544
52	1	7	rgw placement操作命令	ceph  osd crush add-bucket root_ssd root\r\nceph  osd crush add-bucket sandstone0001_ssd  host\r\nceph  osd crush move sandstone0001_ssd root=root_ssd\r\nceph  osd crush add osd.15 1.0 host=sandstone0001_ssd\r\nceph  osd crush rule create-simple rule_ssd root_ssd osd（crush choose leaf by osd）\r\n\r\nceph osd pool new_index  ssd 1024\r\nceph osd pool set new_index crush_ruleset 1\r\n\r\nbin/radosgw-admin zonegroup placement add --placement-id sandstone\r\nbin/radosgw-admin zone placement add  --placement-id sandstone --index_pool=new_index --data_pool=new_data --placement-index-type=indexless\r\nbin/radosgw-admin period update --commit\r\n\r\n./s3.sh create_bucket test4 "<CreateBucketConfiguration><LocationConstraint>:sandstone</LocationConstraint></CreateBucketConfiguration>"\r\n\r\n	2018-03-09 18:38:18.211907
19	1	7	杉岩数据对象存储发展路标	坚持与开源社区融合的方向\r\n\r\n分布式存储时代：\r\n1，解决海量小文件问题\r\n2，解决集群扩容问题\r\n\r\n2017下半年\r\n2018上半年\r\n\r\n智能存储时代：\r\n1，图片**\r\n2，规律**\r\n\r\n2018年底启动\r\n解决集群扩容问题。扩容后如何使用，bucket如何跨越故障域？\r\n解决bucket index对象恢复影响业务的问题。能否去掉bucket index，同时具备一些其他功能？ bucket数据量统计是需要的，quota目前依赖于bucket index。\r\n\r\n不同pool恢复的优先级其实不一样，但是是否会被阻塞呢？ 其实在IO路径上的object应该能很快恢复才对。\r\n有missing的时候是不是开启允许读呢？ 不然玩起来非常难，om也卡住。\r\n*本来就允许，只要当前节点在acting中，且在当前节点object不missing就可以读*\r\n\r\nQos，控制达到效果：阻塞io的请求优先处理。\r\n目前阻塞在io路径上的消息优先级本来也高些，所以这里也没问题。\r\n调度算法也是基于优先级的。\r\n io_queue get_io_queue() const {\r\n    if (cct->_conf->osd_op_queue == "debug_random") {\r\n      srand(time(NULL));\r\n      return (rand() % 2 < 1) ? prioritized : weightedpriority;\r\n    } else if (cct->_conf->osd_op_queue == "wpq") {\r\n      return weightedpriority;\r\n    } else {\r\n      return prioritized;\r\n    }\r\n  }\r\n\r\n\r\n压力大时，osd会自杀，sage看来这是磁盘压力大，慢盘导致的，并非问题。\r\nhttp://tracker.ceph.com/issues/14341\r\n\r\n能否在bucket index中记录增量？恢复该对象时，采用增量恢复的方式？\r\n\r\n*\r\n可以把bucket shard搞得非常大，根据数据总量来。但是不提供list功能。或者通过外部数据库来提供list功能。*\r\n\r\n\r\n	2017-11-01 13:19:26.000263
58	1	7	工作任务划分	1，sdk部分\r\n2，rgw特性，quato/acl/usage/policy等。\r\n3，rgw特性，多版本，快照，多数据中心。\r\n	2018-04-08 14:32:47.250996
60	1	6	period同步过程	period同步过程：\r\n\r\n当period修改提交之后。会在realm对象上发起notify。所有存活的radosgw都会收到notify信息。\r\nraodsgw处理notify信息，并且启动一个线程将最新period同步给其他zone,这个线程会一直执行，知道同步操作成功。\r\n\r\n代码请参考：void RGWPeriodPusher::handle_notify(RGWZonesNeedPeriod&& period)\r\n\r\n处理过程：RGWOp_Period_Post::execute\r\n其他zone收到Post请求之后保存period到本zone。\r\n\r\n注意period id不是每次都发生变化。\r\n\r\n然后在period history中加入该period。\r\n并且触发reload realm。\r\n\r\n如果当前本zone没有活着的radosgw，也没关系。\r\nRGWPeriodPusher::RGWPeriodPusher\r\n该构造函数中会读取最新的period，并且触发notify操作。\r\n\r\n那么period不同步到底是什么情况下发生呢？ \r\n日志中还可以看到failed to decode period.	2018-04-12 14:12:00.899024
29	1	8	杉岩数据对象存储项目管理建议	为了大家可以更加轻松有效的完成工作，建立更好的研发文化：\r\n1，严格版本出口，每个版本特性的时间确定，如果确定无法按期完成，则需要在例会中提出延期，并做出相关说明。\r\n2，任务按特性划分责任人，特性相关问题直接分给特性责任人。\r\n   可根据实际情况讨论，变更特性责任人划分。\r\n3，特性的设计方案，开发代码以及bugfix需要review，给出review意见\r\n4，建议使用redmine\r\n\r\n*物资奖励与工作任务*\r\n明确绩效达成奖励，当然这个不一定能落实，但是可以保证的是优秀者得到的更多。\r\n\r\n考核办法：\r\n在最初就定义好考核办法：\r\n根据有效人天量来评估，评估story的工作量。\r\n\r\n维护一个模块也有工作量，团队协助也有一定工作量。培养新人的工作量。\r\n\r\n\r\n工作安排：\r\n优先分配（个人能力和经验） + 人天价值模式。\r\n生长模型，新年都将加入新的任务，这是一种个人成长的需要，也是组织发展的需要。\r\n\r\n*发展和使命感*：\r\n渴望发展的人多进取，并且追求变革。\r\n使命感是把其当作长期事业的基础。\r\n\r\nOKR是什么？ 适合公司吗？ 如何落实？ 最最关键的是如何让大家都目标正确和明确，合理。\r\n\r\n\r\n核心目标：MOS产品在市场上的竞争优势\r\n这是无法非议的，每年的目标都如此，今年也许可以细化下，在金融领域的竞争力。\r\n\r\n比如rados模块，提升竞争力的方法： 支持单bucket多少数据量，支持多大的文件规模。延迟维持在多少等等。\r\n\r\n研发人员的kpi肯定不是开发哪些特性，开发多少行代码，少出多少bug，这些不是目标，而且没有激励性。\r\n这些目标是冰冷的，并不激励人。这些是工作，并非目标。\r\n\r\n这是OKR与KPI的区别，KPI引导人寻找指标，而不是目标。重点在于找到目标并且很好的分解目标，这是抓住核心的东西。\r\nOKR透明的意义在于大家都知道彼此的目标，并且每个人都明白自己的努力方向，对是方向而不是拼凑的任务。\r\n\r\n尝试使用redmine构建OKR系统。我觉得这是一个好想法。\r\n使用excel最大的问题在于写完之后很少打开去看。而使用redmine大家都知道文件就在那里，随时可以查看。\r\n\r\n几个大目标驱动团队\r\n让大家明白执行小任务背后的大目标。\r\n\r\nRedmine：任务分解与管理\r\nRedmine：版本开发管理，类别可以看作是大的feature，而每个小开发任务是feature内的划分。\r\n\r\n专项任务：\r\n邮件，专项文件，如果想用redmine也是可以的。\r\n\r\n企业内竞争的一个很重要的地方就是信息不对称，某些人掌握着其他人没有掌握的信息，别人只告诉你怎么做，但不一定告诉你为什么这样做。\r\n而企业生存一般在一个领域，更新较慢，一旦某个人的全部被其他人掌握，那么这个人就失去了权力。权力就是控制事情方向的能力。\r\n\r\n互联网竞争的核心是个人及团队能力，因为协作方法，知识，idea都是开放的，拼的是方案，营销，运维，运营的能力。\r\n\r\n\r\n1，目标\r\n整体目标充分讨论明确，每个人的分解目标明确。\r\n并且知道其他人的目标，以便更好的合作。\r\n同时目标的达成度是个人工作业绩的体现。\r\n\r\n1.1 模块分解，明确责任人\r\n\r\n2，任务\r\n2.1 版本\r\n团队最重要的任务就是交付版本\r\n每个版本都是由一些新增特性，或者增强特性组成。\r\n保证高质量的交付开发特性要求大家做好每一步，需求讨论，方案设计，review，开发，自测试，bugfix等等。\r\n\r\n2.2，专项任务\r\n\r\n3，团队建设\r\n建设一流的团队，成长的团队。\r\n\r\n\r\n\r\n\r\n	2017-11-20 07:40:33.094164
57	1	7	multiste 配置代码解读：RGWRados::init_complete	1，如何找到realm呢？\r\ndefault.realm  存了一个id\r\nrealms.${id} 存了realm的name\r\n\r\n这个是整个集群唯一的，放在.rgw.root pool中。\r\n\r\n2， period初始化\r\nperiod由3部分组成：\r\nperiods.3b289420-d65f-4203-a6a0-7b91d5e4980b.3\r\n中间是id. 最后是epoch\r\nid来自于realm。\r\n\r\n3，RGWRados::replace_region_with_zonegroup\r\n这个函数在zonegroup下基本什么都不执行。\r\n\r\n4，zonegroup从period初始化而来。init_zg_from_period\r\n注意这个函数如果当前没有zonegroup会创建，没有zone也会创建。\r\n\r\ndefault.zonegroup.$realmid 存放的就是本\r\n\r\n5，zone是怎么初始化的呢？\r\n从配置项rgw_zone而来，这个是核心。否则rgw都无法知道自己是谁。\r\n\r\n	2018-03-21 19:26:23.349675
64	1	7	发展规划	1，侧重点是在研发上，能独立设计产品，深谙技术方案的核心。优劣等。（个人能力）\r\n   当然运维能力也是能力。（知识是能力的基础）\r\n2，其次是带队，任务的执行，人员的成长，文化精神的建立等等。\r\n 连接人与事。 （团队能力）\r\n3，对大方向的把握，了解技术动态，看到未来。自己的主张。（价值认知）。\r\n\r\n可以看成是三维坐标。\r\n\r\n传道授业解惑，任何阶段的人都需要老师。只是恰在合适的时间遇到彼此。\r\n\r\n设计架构可以管5年吗？10年呢？\r\n\r\n定位：基础软件开发\r\n乐趣：发现基础软件设计之奥秘，软件研发之精髓。以达在软件领域知行合一之境界。若你真理解，请你实现它。	2018-05-23 06:59:21.502387
70	1	7	rgw http错误码	rgw内部错误码：\r\n\r\n#define STATUS_CREATED           1900\r\n\r\n#define STATUS_ACCEPTED          1901\r\n\r\n#define STATUS_NO_CONTENT        1902\r\n\r\n#define STATUS_PARTIAL_CONTENT   1903\r\n\r\n#define STATUS_REDIRECT          1904\r\n\r\n#define STATUS_NO_APPLY          1905\r\n\r\n#define STATUS_APPLIED           1906\r\n\r\n\r\n\r\n#define ERR_INVALID_BUCKET_NAME  2000\r\n\r\n#define ERR_INVALID_OBJECT_NAME  2001\r\n\r\n#define ERR_NO_SUCH_BUCKET       2002\r\n\r\n#define ERR_METHOD_NOT_ALLOWED   2003\r\n\r\n#define ERR_INVALID_DIGEST       2004\r\n\r\n#define ERR_BAD_DIGEST           2005\r\n\r\n#define ERR_UNRESOLVABLE_EMAIL   2006\r\n\r\n#define ERR_INVALID_PART         2007\r\n\r\n#define ERR_INVALID_PART_ORDER   2008\r\n\r\n#define ERR_NO_SUCH_UPLOAD       2009\r\n\r\n#define ERR_REQUEST_TIMEOUT      2010\r\n\r\n#define ERR_LENGTH_REQUIRED      2011\r\n\r\n#define ERR_REQUEST_TIME_SKEWED  2012\r\n\r\n#define ERR_BUCKET_EXISTS        2013\r\n\r\n#define ERR_BAD_URL              2014\r\n\r\n#define ERR_PRECONDITION_FAILED  2015\r\n\r\n#define ERR_NOT_MODIFIED         2016\r\n\r\n#define ERR_INVALID_UTF8         2017\r\n\r\n#define ERR_UNPROCESSABLE_ENTITY 2018\r\n\r\n#define ERR_TOO_LARGE            2019\r\n\r\n#define ERR_TOO_MANY_BUCKETS     2020\r\n\r\n#define ERR_INVALID_REQUEST      2021\r\n\r\n#define ERR_TOO_SMALL            2022\r\n\r\n#define ERR_NOT_FOUND            2023\r\n\r\n#define ERR_PERMANENT_REDIRECT   2024\r\n\r\n#define ERR_LOCKED               2025\r\n\r\n#define ERR_QUOTA_EXCEEDED       2026\r\n\r\n#define ERR_SIGNATURE_NO_MATCH   2027\r\n\r\n#define ERR_INVALID_ACCESS_KEY   2028\r\n\r\n#define ERR_MALFORMED_XML        2029\r\n\r\n#define ERR_USER_EXIST           2030\r\n\r\n#define ERR_NOT_SLO_MANIFEST     2031\r\n\r\n#define ERR_EMAIL_EXIST          2032\r\n\r\n#define ERR_KEY_EXIST            2033\r\n\r\n#define ERR_INVALID_SECRET_KEY   2034\r\n\r\n#define ERR_INVALID_KEY_TYPE     2035\r\n\r\n#define ERR_INVALID_CAP          2036\r\n\r\n#define ERR_INVALID_TENANT_NAME  2037\r\n\r\n#define ERR_WEBSITE_REDIRECT     2038\r\n\r\n#define ERR_NO_SUCH_WEBSITE_CONFIGURATION 2039\r\n\r\n#define ERR_AMZ_CONTENT_SHA256_MISMATCH 2040\r\n\r\n#define ERR_USER_SUSPENDED       2100\r\n\r\n#define ERR_INTERNAL_ERROR       2200\r\n\r\n#define ERR_NOT_IMPLEMENTED      2201\r\n\r\n#define ERR_SERVICE_UNAVAILABLE  2202\r\n\r\n\r\n\r\nhttp错误对照：\r\n\r\nconst static struct rgw_http_errors RGW_HTTP_ERRORS[] = {\r\n\r\n    { 0, 200, "" },\r\n\r\n    { STATUS_CREATED, 201, "Created" },\r\n\r\n    { STATUS_ACCEPTED, 202, "Accepted" },\r\n\r\n    { STATUS_NO_CONTENT, 204, "NoContent" },\r\n\r\n    { STATUS_PARTIAL_CONTENT, 206, "" },\r\n\r\n    { ERR_PERMANENT_REDIRECT, 301, "PermanentRedirect" },\r\n\r\n    { ERR_WEBSITE_REDIRECT, 301, "WebsiteRedirect" },\r\n\r\n    { STATUS_REDIRECT, 303, "" },\r\n\r\n    { ERR_NOT_MODIFIED, 304, "NotModified" },\r\n\r\n    { EINVAL, 400, "InvalidArgument" },\r\n\r\n    { ERR_INVALID_REQUEST, 400, "InvalidRequest" },\r\n\r\n    { ERR_INVALID_DIGEST, 400, "InvalidDigest" },\r\n\r\n    { ERR_BAD_DIGEST, 400, "BadDigest" },\r\n\r\n    { ERR_INVALID_BUCKET_NAME, 400, "InvalidBucketName" },\r\n\r\n    { ERR_INVALID_OBJECT_NAME, 400, "InvalidObjectName" },\r\n\r\n    { ERR_UNRESOLVABLE_EMAIL, 400, "UnresolvableGrantByEmailAddress" },\r\n\r\n    { ERR_INVALID_PART, 400, "InvalidPart" },\r\n\r\n    { ERR_INVALID_PART_ORDER, 400, "InvalidPartOrder" },\r\n\r\n    { ERR_REQUEST_TIMEOUT, 400, "RequestTimeout" },\r\n\r\n    { ERR_TOO_LARGE, 400, "EntityTooLarge" },\r\n\r\n    { ERR_TOO_SMALL, 400, "EntityTooSmall" },\r\n\r\n    { ERR_TOO_MANY_BUCKETS, 400, "TooManyBuckets" },\r\n\r\n    { ERR_MALFORMED_XML, 400, "MalformedXML" },\r\n\r\n    { ERR_AMZ_CONTENT_SHA256_MISMATCH, 400, "XAmzContentSHA256Mismatch" },\r\n\r\n    { ERR_LENGTH_REQUIRED, 411, "MissingContentLength" },\r\n\r\n    { EACCES, 403, "AccessDenied" },\r\n\r\n    { EPERM, 403, "AccessDenied" },\r\n\r\n    { ERR_SIGNATURE_NO_MATCH, 403, "SignatureDoesNotMatch" },\r\n\r\n    { ERR_INVALID_ACCESS_KEY, 403, "InvalidAccessKeyId" },\r\n\r\n    { ERR_USER_SUSPENDED, 403, "UserSuspended" },\r\n\r\n    { ERR_REQUEST_TIME_SKEWED, 403, "RequestTimeTooSkewed" },\r\n\r\n    { ERR_QUOTA_EXCEEDED, 403, "QuotaExceeded" },\r\n\r\n    { ENOENT, 404, "NoSuchKey" },\r\n\r\n    { ERR_NO_SUCH_BUCKET, 404, "NoSuchBucket" },\r\n\r\n    { ERR_NO_SUCH_WEBSITE_CONFIGURATION, 404, "NoSuchWebsiteConfiguration" },\r\n\r\n    { ERR_NO_SUCH_UPLOAD, 404, "NoSuchUpload" },\r\n\r\n    { ERR_NOT_FOUND, 404, "Not Found"},\r\n\r\n    { ERR_METHOD_NOT_ALLOWED, 405, "MethodNotAllowed" },\r\n\r\n    { ETIMEDOUT, 408, "RequestTimeout" },\r\n\r\n    { EEXIST, 409, "BucketAlreadyExists" },\r\n\r\n    { ERR_USER_EXIST, 409, "UserAlreadyExists" },\r\n\r\n    { ERR_EMAIL_EXIST, 409, "EmailExists" },\r\n\r\n    { ERR_KEY_EXIST, 409, "KeyExists"},\r\n\r\n    { ERR_INVALID_SECRET_KEY, 400, "InvalidSecretKey"},\r\n\r\n    { ERR_INVALID_KEY_TYPE, 400, "InvalidKeyType"},\r\n\r\n    { ERR_INVALID_CAP, 400, "InvalidCapability"},\r\n\r\n    { ERR_INVALID_TENANT_NAME, 400, "InvalidTenantName" },\r\n\r\n    { ENOTEMPTY, 409, "BucketNotEmpty" },\r\n\r\n    { ERR_PRECONDITION_FAILED, 412, "PreconditionFailed" },\r\n\r\n    { ERANGE, 416, "InvalidRange" },\r\n\r\n    { ERR_UNPROCESSABLE_ENTITY, 422, "UnprocessableEntity" },\r\n\r\n    { ERR_LOCKED, 423, "Locked" },\r\n\r\n    { ERR_INTERNAL_ERROR, 500, "InternalError" },\r\n\r\n    { ERR_NOT_IMPLEMENTED, 501, "NotImplemented" },\r\n\r\n    { ERR_SERVICE_UNAVAILABLE, 503, "ServiceUnavailable"}\r\n\r\n};	2018-06-13 11:47:03.801634
55	1	7	Git/TortoiseGit账号缓存	https://stackoverflow.com/questions/14000173/tortoisegit-save-user-authentication-credentials\r\n\r\nGo to "TortoiseGit > Settings > Credential"\r\nSelect Credential helper "Advanced"\r\nClick on the "G" (for global) under Helpers\r\nEnter the Helper path as below. Note: a regular Windows path notation (e.g. "C:\\Users...") will not work here, you have to replicate the exact line that installing winstore created in the global .gitconf without the "helper =" bit.\r\n\r\n!'C:\\\\Users\\\\yourlogin\\\\AppData\\\\Roaming\\\\GitCredStore\\\\git-credential-winstore.exe'\r\nClick the "Add New/Save" button\r\n\r\ngit账号缓存：\r\nhttps://help.github.com/en/articles/caching-your-github-password-in-git\r\nlinux：\r\ngit config --global credential.helper cache\r\n长期有效\r\ngit config --global credential.helper store	2018-03-15 18:16:46.428222
40	1	7	RGW ElasticSearch使用	查询所有index：\r\ncurl -XGET 172.18.0.150:9200/_all\r\n\r\n查询所有记录：\r\ncurl -XGET 172.18.0.150:9200/rgw-china-899bd0a5/_search/?\r\ncurl -XGET 172.18.0.150:9200/rgw-china-899bd0a5/_search?pretty=1\r\n\r\n查询某个key:\r\ncurl -XGET 172.18.0.150:9200/rgw-china-899bd0a5/_search -d '{"query":{"match":{"name":"assert.h"}}}'\r\n\r\n查询index状态，记录总数等：\r\ncurl -XGET 10.10.1.157:9200/mos_rgw_metadata/_stats/?pretty=1\r\n\r\n查询记录条数：\r\ncurl 10.10.1.177:9200/_cat/indices?v\r\n\r\n设置es日志级别：\r\ncurl -XPUT 10.10.1.177:9200/_cluster/settings -d '{"transient" : { "logger.discovery" : "DEBUG" }}'\r\n\r\nes 6.x上:\r\ncurl -H "Content-Type: application/json" -XPUT http://192.168.12.11:9200/_cluster/settings -d '{"transient":{"logger.org.elasticsearch.transport":"DEBUG" }}'\r\n详见: https://www.elastic.co/guide/en/elasticsearch/reference/6.x/logging.html\r\n\r\n查询语法请参考：\r\nhttps://es.xiaoleilu.com/010_Intro/30_Tutorial_Search.html\r\n\r\n删除index:\r\ncurl -XDELETE 172.18.0.150:9200/rgw-china-8656ab53\r\n\r\ntag：\r\ntag按照rgw实现，是可以直接同步到es的，但是元数据只有部分是支持的。\r\n\r\n\r\n优化：\r\nES zone同步哪些bucket是可以配置的，同时似乎从master zone同步即可。	2018-01-16 18:14:48.712582
50	1	8	面试方法	招人的本质是招一个能否胜任目标工作的人。就是在三象限上与公司匹配度非常好的人。\r\n太强也不一定合适，可能留不住。合适最重要。\r\n\r\n这里面有几个层面：\r\n1，技能上是否满足，这就得看具体岗位，明确岗位的需求。\r\n2，能力上是否合适，这里可以简单指一个人完成一件事情的质量。\r\n有的人，丢三落四，采用的方法非常低效，不善变通，交代的任务无法确保完成，这里有态度的问题，也有方法的问题。\r\n3，成长上是否有潜力\r\n这是招的人不满足的情况，或者期望其往后能承担什么样的职责的时候。\r\n4，价值观上\r\n个人是否认同企业的价值观，这点就是长线了，但是三观比较正的人发展潜力无疑更大。\r\n有格局，有志向的人，其人生逻辑不一样。\r\n\r\n四个问题：\r\n1，深入简历中某一个事项，深挖其细节，观察一个人做事的深度，以及其逻辑。\r\n2，深入其简历中做得最好的一件事，介绍下这件事的各个方面，核心问题，自己的应对方案，以观察其能力。\r\n3，如果安排进来做某个工作，谈下如何开展工作，思路？\r\n4，如何提到自己？ 学习的方法？\r\n5，你觉得搞软件最重要的品质是什么？\r\n6，对职业发展的规划，对行业的看法。（价值）\r\n7，交给你一个XX特性，你准备怎么开发？（能力，套路）\r\n8，你想解决什么样的问题？（价值）\r\n\r\n技能：\r\n1，深入一些技术细节，看你是否彻底掌握，如何提升技能？\r\n\r\n能力：\r\n1，方法\r\n2，深入其研发的一个特性，看看各方面做的怎么样，知行是否合一\r\n是否能准确的理解需求，方面的要点讲的怎么样。\r\n\r\n人品，性格：\r\n1，能否委托重任？\r\n2，是否追求极致？\r\n人性犹如冰山，很难得其全貌。\r\n有人自大孤傲，有人自卑怯弱。有人勇敢，有人鲁莽。\r\n有人沉着冷静，有人优柔寡断。有人热情诚恳，有人唯唯落落。\r\n有人气质忧郁，有人阳光。\r\n\r\n知人断事真功夫。\r\n\r\n\r\n知识能否胜任：\r\n1，专业，以及职位经验匹配度  （筛选）\r\n2，专业技能如何？ （技术一面）\r\n   linux基础\r\n   c++基础\r\n   算法基础，中高级要求对分布式hash算法，一致性等有一定了解\r\n   \r\n\r\n办事能力：（技术一面）\r\n判断一个人是否积极主动 （做的事情周边是否会涉及到一些）\r\n判断一个人是否能理清要事，能否直接讲到重点，并点明其中的玄机。 （问题是什么，核心矛盾的理解）\r\n判断一个人是否能够以始为终，目标明确 （目标是什么）\r\n\r\n沟通交流，品质：（可以看出一个人的部分品质）\r\n表达是否清晰流畅，有条理。\r\n\r\n更倾向于选择在一个集体中比较优秀的人（筛选）\r\n离职的原因是？\r\n【家庭原因？像梁先杰其实仅仅为了女朋友过来就有点，还是应该兼顾个人发展】\r\n【混不好？】\r\n【公司战略调整，请讲明调整方向】\r\n【专业方向调整， 请说明原因，这种一般经验不匹配】\r\n【挖人另当别论，挖人一般都是针对有经验的。】\r\n\r\n是否注重团队利益？\r\n是否好相处？\r\n\r\n问题：\r\n对团队的贡献体现在哪些方面？\r\n\r\n价值观：\r\n解决什么样的问题。\r\n\r\n\r\n面试的核心难点：\r\n1，如何在短时间内了解一个人\r\n2，如何确认一个新人在培养2年之后不会跳槽？\r\n3，如何在1-2年时间内让一个人产生与待遇匹配的绩效？\r\n\r\n抓紧因果，寻找矛盾的地方。\r\n\r\n\r\n技术水平鉴定：\r\n1，干些打杂的事，一些中小模块开发                    初级工程师 (xk-20k)\r\n2，能独立完成一个稍复杂模块设计开发，bugfix，维护          中级工程师 (20-40k)\r\n3，熟悉整个系统，了解其使用场景，对特性，模块之间的关系有深入理解，\r\n并且理解该系统的一些缺陷                           高级工程师（40-100K，google普通应届生可能是这水平）\r\n4，主导对一个系统进行大的架构调整并取得成功。  \r\n能自主设立项目，解决某一问题                       大牛 （100K+，google高级应届生在这水平，互联网的产品经理也应该达到这水平）\r\n5，能在一个问题上开辟新的算法，并做出大的改进。    大师  (1000K+,李开复可能是这种级别，也可能略高。一般来说独自设计算法，开辟新项目的在此级别)\r\n6，解决新的问题，维护超级大项目                    大神  (无价，这种人凤毛麟角，linus，jim gray，可能比一般xx研究员，首席科学家水平还高)\r\n	2018-03-05 12:46:45.988479
92	21	5	目前想选购的初步电器清单	厨房：\r\n厨余垃圾处理器https://post.smzdm.com\r\n洗碗机\r\n五门冰箱\r\n厨房冷霸\r\n\r\n\r\n\r\n\r\n卫生间\r\n	2019-03-19 18:16:40.829096
65	1	7	研发管理 常用链接	1，邮件系统,QQ,微信群(通知，任务推进)\r\nhttps://exmail.qq.com\r\n\r\n2，禅道（项目，任务管理）\r\nhttp://10.10.30.35/index.php?m=product&f=browse\r\n\r\n3，redmine (代码开发管理，问题单管理)\r\nhttp://10.10.2.201:10083/projects/mos\r\n\r\n4，文件共享（版本发布目录，临时版本也在此）\r\n\\\\10.10.30.39\\version_packages\\MOS\r\n\r\n5，SVN (版本管理)\r\nhttps://svn.szsandstone.com/svn/sandstone/doc/20.版本配套文档/对象存储文档	2018-05-24 08:34:27.467166
39	1	7	rgw multisite搭建过程	前提条件：\r\n安装好ceph集群\r\n\r\n创建zonegroup，zone：\r\nbin/radosgw-admin realm create --rgw-realm=china --default\r\n\r\nbin/radosgw-admin zonegroup create --rgw-zonegroup=china1 --endpoints=http://172.18.0.130:8080 --rgw-realm=china --master --default\r\n\r\nbin/radosgw-admin zone create --rgw-zonegroup=china1 --rgw-zone=SZ --master --default --endpoints=http://172.18.0.130:8080\r\n\r\nbin/radosgw-admin period update --commit\r\n\r\nbin/radosgw-admin user create --uid="sysuser" --display-name="sysuser" --access_key="root" --secret_key="sandstone" --system\r\n\r\nbin/radosgw-admin zone modify --rgw-zone=SZ --access-key="root" --secret="sandstone"\r\n\r\nbin/radosgw-admin period update --commit\r\n\r\nbin/radosgw-admin user create --uid="nuser" --display-name="nuser" --access_key="admin" --secret_key="admin"\r\n\r\n创建zone对应的pool:\r\nbin/ceph osd pool create SZ.rgw.buckets.index 3\r\nbin/ceph osd pool create SZ.rgw.buckets.data 3\r\nbin/ceph osd pool create SZ.rgw.buckets.non-ec 3\r\n\r\n创建EC pool （注意ec pool不支持omap操作，bucket.index, bucket.non-ec都不支持ec pool）：\r\nbin/ceph osd erasure-code-profile get default\r\nk=2\r\nm=1\r\nplugin=jerasure\r\ntechnique=reed_sol_van\r\nbin/ceph osd pool create SZ.rgw.buckets.data 64 erasure myprofile  \r\n\r\nceph osd erasure-code-profile set myprofile1  k=2  m=1  plugin=jerasure crush-failure-domain=osd  ruleset-failure-domain=osd\r\n\r\n注意最好把zone信息都配置好，\r\n然后自己手动建pool，\r\n再启动rgw，不然rgw启动后会建一些默认的。\r\n\r\n创建第二个zone:\r\n第二个zone：\r\nbin/radosgw-admin realm pull --url=http://172.18.0.130:8080 --access-key=root  --secret=sandstone\r\n  \r\nbin/radosgw-admin period pull --url=http://172.18.0.130:8080 --access-key=root --secret=sandstone\r\n\r\nbin/radosgw-admin zone create --rgw-zonegroup=china1 --rgw-zone=BJ --url=http://172.18.0.131:8080 --endpoints=http://172.18.0.131:8080 --access-key=root --secret=sandstone\r\n\r\nbin/radosgw-admin period update --commit\r\n\r\n运行rgw：\r\n/var/lib/ceph/bin/radosgw --pid-file /etc/ceph/client.radosgw.sync_rgw1.pid -c /etc/ceph/ceph.conf -n client.radosgw.sync_rgw1 --setuser sdsadmin --setgroup sdsadmin\r\n\r\n运行nginx：\r\n/root/nginx/sbin/nginx -c /root/nginx/conf/rgw_nginx.conf -p /root/nginx/\r\n\r\n主备zone切换：\r\nbin/radosgw-admin zone modify --rgw-zone=SZ --master --default\r\nbin/radosgw-admin period update --commit\r\n这两条命令之后，主端主动会降为slave。\r\n参考:http://docs.ceph.com/docs/master/radosgw/multisite/\r\n\r\n创建ES zone:\r\nbin/radosgw-admin zone create --rgw-zonegroup=china1 --rgw-zone=SZES --access-key="root" --secret="sandstone" --endpoints=http://172.18.0.130:8082\r\n\r\nbin/radosgw-admin zone modify --rgw-zone=SZES  --tier-type=elasticsearch --tier-config=endpoint=http://172.18.0.150:9200,num_shards=10,num_replicas=1\r\nbin/radosgw-admin zone modify --rgw-zone=SZES1 --sync-from-all=false --sync-from=SZ --tier-type=elasticsearch --tier-config=endpoint=http://172.18.0.161:9200,num_shards=10,num_replicas=1,override_index_path=rgw_metadata1\r\nbin/radosgw-admin period update --commit\r\n\r\nbin/ceph osd pool create SZES.rgw.buckets.index 3\r\nbin/ceph osd pool create SZES.rgw.buckets.data 3\r\nbin/ceph osd pool create SZES.rgw.buckets.non-ec 3\r\n\r\n/var/lib/ceph/bin/radosgw --pid-file /etc/ceph/client.radosgw.es.pid -c /etc/ceph/ceph.conf -n client.radosgw.es --setuser sdsadmin --setgroup sdsadmin\r\n\r\n给用户增加ak/sk\r\nradosgw-admin user modify --uid="sysuser" --acess-key="newk" --secret-key="newk"	2018-01-16 13:03:41.817465
67	1	7	2018.6.8	跟友商PK：\r\n> 生命周期，结合分层存储。\r\n> pk重点还是在性能上\r\n> \r\n> 我看的重点：\r\n> 1，可靠性，稳定性。故障对服务的影响。\r\n> 2，性能\r\n> 3，扩展性，扩容方面的表现。\r\n> \r\n> 基石，仍然存在缺陷。\r\n> \r\n> 4，数据管理，支持数据的各种流转，容灾，数据压缩，重删，加密，保护等.\r\n\r\nbcache加速元数据，backfill恢复优化之后。能抗住5千万+的数据。暂时可以不考虑把bi挪出来。\r\n\r\n\r\n	2018-06-08 14:12:13.19358
69	1	7	linux错误码	#define EPERM   1 /* Operation not permitted */\r\n\r\n#define ENOENT   2 /* No such file or directory */\r\n\r\n#define ESRCH   3 /* No such process */\r\n#define EINTR   4 /* Interrupted system call */\r\n#define EIO   5 /* I/O error */\r\n#define ENXIO   6 /* No such device or address */\r\n#define E2BIG   7 /* Argument list too long */\r\n#define ENOEXEC   8 /* Exec format error */\r\n#define EBADF   9 /* Bad file number */\r\n#define ECHILD  10 /* No child processes */\r\n#define EAGAIN  11 /* Try again */\r\n#define ENOMEM  12 /* Out of memory */\r\n#define EACCES  13 /* Permission denied */\r\n#define EFAULT  14 /* Bad address */\r\n#define ENOTBLK  15 /* Block device required */\r\n#define EBUSY  16 /* Device or resource busy */\r\n#define EEXIST  17 /* File exists */\r\n#define EXDEV  18 /* Cross-device link */\r\n#define ENODEV  19 /* No such device */\r\n#define ENOTDIR  20 /* Not a directory */\r\n#define EISDIR  21 /* Is a directory */\r\n#define EINVAL  22 /* Invalid argument */\r\n#define ENFILE  23 /* File table overflow */\r\n#define EMFILE  24 /* Too many open files */\r\n#define ENOTTY  25 /* Not a typewriter */\r\n#define ETXTBSY  26 /* Text file busy */\r\n#define EFBIG  27 /* File too large */\r\n#define ENOSPC  28 /* No space left on device */\r\n#define ESPIPE  29 /* Illegal seek */\r\n#define EROFS  30 /* Read-only file system */\r\n#define EMLINK  31 /* Too many links */\r\n#define EPIPE  32 /* Broken pipe */\r\n#define EDOM  33 /* Math argument out of domain of func */\r\n#define ERANGE  34 /* Math result not representable */\r\n#define EDEADLK  35 /* Resource deadlock would occur */\r\n#define ENAMETOOLONG 36 /* File name too long */\r\n#define ENOLCK  37 /* No record locks available */\r\n#define ENOSYS  38 /* Function not implemented */\r\n#define ENOTEMPTY 39 /* Directory not empty */\r\n#define ELOOP  40 /* Too many symbolic links encountered */\r\n#define EWOULDBLOCK EAGAIN /* Operation would block */\r\n#define ENOMSG  42 /* No message of desired type */\r\n#define EIDRM  43 /* Identifier removed */\r\n#define ECHRNG  44 /* Channel number out of range */\r\n#define EL2NSYNC 45 /* Level 2 not synchronized */\r\n#define EL3HLT  46 /* Level 3 halted */\r\n#define EL3RST  47 /* Level 3 reset */\r\n#define ELNRNG  48 /* Link number out of range */\r\n#define EUNATCH  49 /* Protocol driver not attached */\r\n#define ENOCSI  50 /* No CSI structure available */\r\n#define EL2HLT  51 /* Level 2 halted */\r\n#define EBADE  52 /* Invalid exchange */\r\n#define EBADR  53 /* Invalid request descriptor */\r\n#define EXFULL  54 /* Exchange full */\r\n#define ENOANO  55 /* No anode */\r\n#define EBADRQC  56 /* Invalid request code */\r\n#define EBADSLT  57 /* Invalid slot */\r\n\r\n#define EDEADLOCK EDEADLK\r\n\r\n#define EBFONT  59 /* Bad font file format */\r\n#define ENOSTR  60 /* Device not a stream */\r\n#define ENODATA  61 /* No data available */\r\n#define ETIME  62 /* Timer expired */\r\n#define ENOSR  63 /* Out of streams resources */\r\n#define ENONET  64 /* Machine is not on the network */\r\n#define ENOPKG  65 /* Package not installed */\r\n#define EREMOTE  66 /* Object is remote */\r\n#define ENOLINK  67 /* Link has been severed */\r\n#define EADV  68 /* Advertise error */\r\n#define ESRMNT  69 /* Srmount error */\r\n#define ECOMM  70 /* Communication error on send */\r\n#define EPROTO  71 /* Protocol error */\r\n#define EMULTIHOP 72 /* Multihop attempted */\r\n#define EDOTDOT  73 /* RFS specific error */\r\n#define EBADMSG  74 /* Not a data message */\r\n#define EOVERFLOW 75 /* Value too large for defined data type */\r\n#define ENOTUNIQ 76 /* Name not unique on network */\r\n#define EBADFD  77 /* File descriptor in bad state */\r\n#define EREMCHG  78 /* Remote address changed */\r\n#define ELIBACC  79 /* Can not access a needed shared library */\r\n#define ELIBBAD  80 /* Accessing a corrupted shared library */\r\n#define ELIBSCN  81 /* .lib section in a.out corrupted */\r\n#define ELIBMAX  82 /* Attempting to link in too many shared libraries */\r\n#define ELIBEXEC 83 /* Cannot exec a shared library directly */\r\n#define EILSEQ  84 /* Illegal byte sequence */\r\n#define ERESTART 85 /* Interrupted system call should be restarted */\r\n#define ESTRPIPE 86 /* Streams pipe error */\r\n#define EUSERS  87 /* Too many users */\r\n#define ENOTSOCK 88 /* Socket operation on non-socket */\r\n#define EDESTADDRREQ 89 /* Destination address required */\r\n#define EMSGSIZE 90 /* Message too long */\r\n#define EPROTOTYPE 91 /* Protocol wrong type for socket */\r\n#define ENOPROTOOPT 92 /* Protocol not available */\r\n#define EPROTONOSUPPORT 93 /* Protocol not supported */\r\n#define ESOCKTNOSUPPORT 94 /* Socket type not supported */\r\n#define EOPNOTSUPP 95 /* Operation not supported on transport endpoint */\r\n#define EPFNOSUPPORT 96 /* Protocol family not supported */\r\n#define EAFNOSUPPORT 97 /* Address family not supported by protocol */\r\n#define EADDRINUSE 98 /* Address already in use */\r\n#define EADDRNOTAVAIL 99 /* Cannot assign requested address */\r\n#define ENETDOWN 100 /* Network is down */\r\n#define ENETUNREACH 101 /* Network is unreachable */\r\n#define ENETRESET 102 /* Network dropped connection because of reset */\r\n#define ECONNABORTED 103 /* Software caused connection abort */\r\n#define ECONNRESET 104 /* Connection reset by peer */\r\n#define ENOBUFS  105 /* No buffer space available */\r\n#define EISCONN  106 /* Transport endpoint is already connected */\r\n#define ENOTCONN 107 /* Transport endpoint is not connected */\r\n#define ESHUTDOWN 108 /* Cannot send after transport endpoint shutdown */\r\n#define ETOOMANYREFS 109 /* Too many references: cannot splice */\r\n#define ETIMEDOUT 110 /* Connection timed out */\r\n#define ECONNREFUSED 111 /* Connection refused */\r\n#define EHOSTDOWN 112 /* Host is down */\r\n#define EHOSTUNREACH 113 /* No route to host */\r\n#define EALREADY 114 /* Operation already in progress */\r\n#define EINPROGRESS 115 /* Operation now in progress */\r\n#define ESTALE  116 /* Stale NFS file handle */\r\n#define EUCLEAN  117 /* Structure needs cleaning */\r\n#define ENOTNAM  118 /* Not a XENIX named type file */\r\n#define ENAVAIL  119 /* No XENIX semaphores available */\r\n#define EISNAM  120 /* Is a named type file */\r\n#define EREMOTEIO 121 /* Remote I/O error */\r\n#define EDQUOT  122 /* Quota exceeded */\r\n\r\n#define ENOMEDIUM 123 /* No medium found */\r\n#define EMEDIUMTYPE 124 /* Wrong medium type */\r\n\r\n	2018-06-13 11:46:25.108602
68	1	7	OKR与项目管理	OKR并非绩效考核方法，OKR是一种管理方法，促进目标在整体上达成的方法。\r\n就像敏捷是达成软件按时按质量交付的方法。\r\n\r\nOKR并非列出O，K, R就完事，还有中间如何推进，蕴含了要事优先的逻辑，并且在组织内达成共识，引发集体的讨论。\r\n1，目标明确，有目标，有关键结果，这样才叫目标明确。\r\n2，目标有优先级，且不能太多\r\n3，根据目标列举的重要任务，也不必列太多。\r\n4，最最重要的是积极主动，这点要求组织是双向的，既自上而下，也自下而上。\r\n让人感受到价值，成就感，有乐趣。\r\n\r\n所以show结果的阶段必须有，非常重要，不能说我们制定了一个宏伟的计划，结果啥都没干成。\r\n这种总结分享是非常必要的。show time！（谁show的好，最佳奖就给谁，点评）\r\n\r\n部门的四象限：\r\nO: 帮助企业更好的存储利用非结构化数据\r\nK：\r\n   版本交付时间准确率XX%，无致命缺陷。\r\n   产品性能保持竞争力\r\n   产品功能基本齐备，同时富有特色,拥有一两个重要功能差异点。\r\n   企业级的产品运维能力(1，产品可靠性，可用性好。 2，超强的故障诊断能力。 3，快速的恢复能力)\r\n\r\n2017年：\r\n1，支持多站点\r\n2，支持元数据检索\r\nXX\r\n\r\n2018年：\r\n1，支持海量小文件\r\n2，支持数据保护(秒级数据恢复到任意时间点)\r\n3，支持存储策略，生命周期，数据的流转 （支持bucket跨pool迁移数据）\r\n4，支持多站点，多分支机构\r\n\r\n目标，结果\r\nTOP 2工作\r\n风险\r\n\r\n每周五回顾result。\r\n\r\n解决目标以及成就感问题对于管理似乎还不够，这是一个大的轮廓。\r\n\r\n在日常执行过程中，还得不断的更新状态，推动项目进步。解决出现的问题。\r\n\r\n晨会的几个问题：\r\n1，首先明确大目标，有达成目标的成就感，价值感这是能量的来源。\r\n2，提起大家的精气神，传递一种能量。\r\n3，深入发现每个人的问题，是否在干其他任务，是否要事首先的处理，是否遇到阻塞任务需要求助。\r\n\r\n管理的本质是激发人的善意和潜能，如何做？\r\n\r\n不断的去发现人的问题，解决人的问题。只有每个人都发出自己的光和热，整体才能迸发出能量。\r\n管理的另一面是不断优化任务目标，降低项目整体的熵，提升流程效率，工具效率等。\r\n所以业务的架构非常重要，业务架构好则可以减少很多不必要的工作。\r\n\r\n现实世界其实也是于此，弱者被欲望控制，普通人被利益欲望驱动，真正的强者被使命和理想驱动。\r\n\r\n2018.7.10：\r\n具体开发任务交给研发人员。\r\n我需要做几件事：1，把握项目的技术风险   2，思考产品的竞争力  3，安排人事。  4，优化执行。\r\n\r\n这个目标机器的目标管理，风险管理，确保走向正确的目标。\r\n另一个就是不断优化机器执行效率。\r\n\r\n对团队成员的要求：\r\n1，接受任务，并且有较好执行能力\r\n2，目标-结果管理法，确保整体目标的达成。 --- 就这么简单，把执行结果发出来。考核根本不需要个人填写。\r\n\r\n产品定位和架构对于整体来说更加重要。当然执行也是非常重要的。\r\n\r\n\r\n考核关注点：\r\n异构集群 + 存储策略（1）\r\nCDP + Meta管理（1）\r\n生命周期 + 压缩/加解密等（1）\r\nS3/FTP/NFS等（2-3人）\r\n双活（1）\r\nES（1）\r\n\r\n从几个维度评价贡献:\r\n1, 研发新特性，提升产品竞争力\r\n2，修复bug，构建测试方案， 提升产品稳定性，可靠性\r\n3，提升效率，构建更好的基础平台\r\n4，支撑客户，促进POC和商业目标达成\r\n\r\n\r\n	2018-06-11 07:37:16.15017
72	1	7	ceph研发环境进化	1,在/home目录下创建自己的目录\r\n\r\n2，git clone 下载mos代码，并切换到自己的想编译的分支\r\n\r\n3，在ceph目录下执行sh autogen.sh\r\n\r\n4, configure，如果仅编译rgw相关，可带参数--with-rbd=no --enable-server=no，路径根据实际环境调整\r\n\r\n./configure --without-lttng --without-fuse --without-libatomic-ops --with-jemalloc --without-tcmalloc --without-libxfs --with-radosgw --with-cephfs=no --with-rbd=no --enable-server=no CXXFLAGS="-O0 -g" --prefix=/home/xierui/release LDFLAGS="-L/home/xierui/sandstone/ceph/thirdpart/leveldb-1.15.0  -L/home/xierui/sandstone/ceph/thirdpart/jemalloc-3.6.0/lib -L/home/xierui/sandstone/ceph/thirdpart/libs/" CFLAGS="-O0 -g"\r\n\r\n5，如果编译不过，请先编译thirdpart下的依赖包\r\n\r\n\r\n\r\n编译好rgw模块之后，替换文件（注意先关闭rgw和osd，替换好之后重启）：\r\n\r\nsrc/.libs/librgw.so.2.0.0 /var/lib/ceph/lib/librgw.so.2.0.0\r\n\r\nsrc/.libs/libcls_rgw.so /var/lib/ceph/lib/rados-classes/libcls_rgw.so\r\n\r\nsrc/.libs/radosgw /var/lib/ceph/bin/radosgw\r\n\r\nsrc/.libs/radosgw-admin /var/lib/ceph/bin/radosgw-admin\r\n\r\n\r\n\r\ndocker环境：\r\n\r\n     \r\n\r\n1，建议使用自己的dockernet网段，避免冲突。可使用docker network list， docker network inspect xx，命令查看当前的网络情况\r\n\r\n创建docker网络：docker network create --subnet=172.18.0.0/16 dockernet  \r\n\r\n注意多个站点只需要一个网段即可。其中16为子网掩码，创建的网络为后面创建容器使用\r\n\r\n\r\n\r\n\r\n2，使用mos_base1.0镜像\r\n\r\n[root@localhost ~]# docker images\r\n\r\nREPOSITORY                                                   TAG                 IMAGE ID            CREATED             SIZE\r\n\r\nmos_base1.0 \r\n\r\n\r\n3，创建容器\r\n\r\ndocker run -it --privileged=true --net dockernet --ip 172.18.0.150 -p 8050:8080 mos_base1.0 /bin/bash\r\n\r\n注意：\r\n\r\n1，网络选用自己创建的\r\n\r\n2，ip地址使用自己规划的网段\r\n\r\n3,8050是映射的主机端口，每个容器需映射自己的端口。\r\n\r\n4,8080是容器中nginx的服务端口\r\n\r\n\r\n\r\n4，配置脚本 /tmp/install.sh\r\n\r\n修改ip地址为上述定义的容器地址，IP="172.18.0.150:6789"\r\n\r\n\r\n\r\n5，配置脚本 /root/setup_zone.sh, /root/setup_slave_zone.sh 修改ip地址 以及ceph集群网段。\r\n\r\nMASTER_IP="172.18.0.150"\r\n\r\nIP="172.18.0.151" （slave rgw使用的ip地址）\r\n\r\npublic network = 172.19.0.1/24\r\n\r\ncluster network = 172.19.0.1/24\r\n\r\n\r\n\r\n6，修改ceph.conf,修改monitor ip配置：\r\n\r\nmon addr = 172.18.0.150\r\n\r\n\r\n\r\n7，创建集群\r\n\r\nsu sdsadmin "/tmp/install.sh"\r\n\r\nsbin/init-ceph start osd\r\n\r\n注：这个脚本需要用sdsadmin用户运行，另外，sdsadmin需要对/var/lib/ceph有相应权限，最好是owner改为sdsadmin\r\n\r\n\r\n\r\n8，注册license\r\n\r\n在http://10.10.30.30/ 上注册mos license\r\n\r\n使用ceph license dump命令查看集群信息，获取sn和机器码，注册。\r\n\r\nbin/ceph license register node0001 XXX（license key）\r\n\r\n\r\n\r\n8，sh /root/setup_zone.sh 配置站点\r\n\r\n\r\n\r\n9，启动rgw\r\n\r\n/var/lib/ceph/bin/radosgw --pid-file /var/lib/ceph/var/run/ceph/client.radosgw.sync_rgw1.pid -c /var/lib/ceph/etc/ceph/ceph.conf -n client.radosgw.sync_rgw1 --setuser sdsadmin --setgroup sdsadmin\r\n\r\n10，启动nginx\r\n\r\n/root/nginx/sbin/nginx -c /root/nginx/conf/rgw_nginx.conf -p /root/nginx/\r\n\r\n\r\n\r\n10，配置slave zone\r\n\r\n重复步骤3~7，注意slave容器使用新的ip。\r\n\r\n修改ceph.conf 配置slave rgw站点名字为BJ\r\n\r\n修改/root/setup_slave_zone.sh配置\r\n\r\n   MASTER_IP="172.18.0.150"\r\n\r\n   IP="172.18.0.151" （slave rgw使用的ip地址）\r\n\r\n运行sh setup_slave_zone.sh\r\n\r\n再按照9-10启动slave zone的rgw和nginx\r\n\r\n\r\n\r\n到此即完成了ceph单机集群和双活站点的配置\r\n\r\n\r\n\r\n\r\n\r\n重置环境：\r\n\r\n1，停止ceph集群\r\n\r\n/var/lib/ceph/sbin/init-ceph stop\r\n\r\n2，杀死rgw服务\r\n\r\nkillall radosgw\r\n\r\n3，重新执行su sdsadmin "/tmp/install.sh"， 启动osd\r\n\r\n4, 重新执行/root/setup_zone.sh\r\n\r\n5, 启动rgw\r\n\r\n\r\n\r\n启动容器\r\n\r\ndocker start xx\r\n\r\n进入容器\r\n\r\ndocker exec -it xx /bin/sh\r\n\r\n\r\n\r\n使用问题总结：\r\n1，容器内进程容易挂掉的问题\r\n是sdsadmin用户资源不够，修改/etc/security/limit.conf和limits.d/下面的文件中的nproc配置\r\n\r\n2，docker exec进不了容器，可尝试别的方式\r\nhttps://www.cnblogs.com/xhyan/p/6593075.html\r\n\r\n\r\n\r\n2018-11-18：\r\n构建一个rados容器，一个rgw容器，分离开来。rados容器通常无需升级。	2018-06-20 19:00:34.660382
71	1	7	第一次OKR会议总结	功能改进：\r\n1，多集群界面状态展示默认一个小时太短\r\n2，线条颜色不够清晰\r\n3，SSD使用模式改为仅支持Bcache,考虑兼容老的形式\r\n4，worm 批量删除bugfix合并可能遗漏。\r\n\r\n反应的问题：\r\n1，前期需求设计工作做的不够，评审方面应投入更多精力。\r\n   解决方法：减少资深人员开发工作量，投入更多精力在设计评审，代码review，困难问题攻关，架构看护上。\r\n\r\n2，部分特性拆分任务不够，导致没有识别出OM，数据管理系统开发任务。\r\n   解决方法：在设计文档中就应该明确各个模块的修改（更新设计文档模板），在录入任务时根据参与模块责任人列出子任务。\r\n\r\n3，研发自测试不充分，部分特性转测了仍然无法成功开始测试，存在非常明显的缺陷。\r\n   解决方法：研发特性转测步骤严格化，开发人员需提供证明其自测范围，以及效果，对自动化测试提出要求。\r\n\r\n整体来说效果还是不错的，这个会议的目的\r\n1，聚焦团队价值\r\n1，激发大家的责任感，使命感，成就感，加强团队凝聚力\r\n2，发现团队警戒信号，发现解决潜在问题。\r\n\r\n如果无法安排工作，无法确定时间，说明还没想清楚。\r\n	2018-06-15 16:01:12.439579
74	1	7	开发规范	特性开发规范：\r\n\r\n1，特性开发首先需明确需求，编写需求分析文档，确保明白所做的事，以及其边界情况。\r\n\r\n   \r\n\r\n2，需求分析文档会集中评审，测试此时介入。\r\n\r\n\r\n\r\n3，需求分析清楚后，进行特性设计，输出特性设计文档。\r\n\r\n\r\n\r\n4，特性设计文档评审，由特性责任人发起，SE，特性相关人，测试参与。\r\n\r\n\r\n\r\n5，开发阶段以及自测。输出测试用例。\r\n\r\n\r\n\r\n6，代码review，提交\r\n\r\n\r\n\r\n7，转测试，bugfix\r\n\r\n\r\n\r\n\r\n\r\n代码提交规范:\r\n\r\n1,代码提交只有两种情况，一是新增feature，二是修改bug，提交代码需带上feature或bug编号。\r\n\r\n\r\n\r\n  提交建议格式：\r\n\r\n  SHA-1: 8f35e0cc8b2a0ec52baf4f59d9b7e38955d480ee\r\n\r\n\r\n\r\n  bugfix: #487, XXX\r\n\r\n\r\n\r\n  Signed-off-by: XX <email>\r\n\r\n  Reviewed-by: \r\n\r\n\r\n\r\n  或\r\n\r\n  \r\n\r\n  SHA-1: 64eadf6fbe78f84312ebc57154ea88fb9172e745\r\n\r\n\r\n\r\n  feature : #311, XXX\r\n\r\n\r\n\r\n  Signed-off-by: XX <email>\r\n\r\n  Reviewed-by: \r\n\r\n  \r\n\r\n  编号使用redmine（后面是禅道）上对应的需求或bug编号。\r\n\r\n  请不要混淆使用feature或bugfix，是什么就填什么，优化也需要对应的单号。\r\n\r\n  \r\n\r\n\r\n\r\n2，代码提交前必须自验证\r\n\r\n\r\n\r\n  feature请提供测试清单\r\n\r\n  bugfix请说明测试方法，测试结果\r\n\r\n  \r\n\r\n\r\n\r\n3，代码review，关键代码需经过review,并在提交记录中说明Reviewed-by。\r\n\r\n\r\n\r\nbugfix规范：\r\n\r\n1，问题在发现第一时间，尽量及时定位并在问题单中说明。\r\n\r\n\r\n\r\n2，bug如果在其他发布版本存在，需同步问题单到对应版本。\r\n\r\n\r\n\r\n3，问题定位过程中的进展及时记录，以避免任务中断。\r\n\r\n\r\n\r\n4，bug修复后需自验证，问题单中需注明自验证情况。\r\n\r\n\r\n\r\n5，在每个版本上同步该bugfix	2018-06-27 11:21:04.250688
73	1	5	GMT UTC 时间 时区	谢锐(x8671r@163.com)  11:26:05\r\nhttps://zh.wikipedia.org/wiki/ISO_8601\r\n\r\n谢锐(x8671r@163.com)  11:27:49\r\n\r\nhttps://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6	2018-06-27 09:01:11.529172
75	1	5	浦发提供与ceph官方修改	1、解决双活同步问题\r\n2、解决多版本在双活下同步的问题\r\n3、大量优化日志\r\n4、解决rest api请求datalog死循环问题。#20386\r\n5，解决osd故障时，没有立即发起提案，导致mon无法立即发现osd故障的问题\r\n6，修复osd df命令在新增故障域时，显示使用容量不对的问题\r\n7，修复osd在booting状态下boot失败，不重复send boot message的问题 #12693\r\n8，修复FileStore journal初始化失败的问题\r\n9，修复mon退出时挂住的问题\r\n10， 修复filestore sync超时，重启后仍然不断超时无法正常启动的问题。\r\n11， 修复osd因为机器时间跳变导致部分线程无法正常工作的问题\r\n12，修复osd之间心跳被消耗阻塞导致误判osd之间通信故障的问题\r\n13，优化osd恢复，增加新状态，避免部分pg无法恢复阻塞其他可以恢复的pg\r\n14，优化rgw bi恢复，缓解bi恢复组赛业务的问题\r\n15，解决多版本在全量同步时，因协程执行顺序的不确定导致最终版本混乱的问题\r\n16，优化pglog配置，避免osd使用内存暴涨。\r\n…\r\n\r\n\r\n1、支持iSCSI/FC接口（非对象版本），兼容传统应用访问\r\n2、支持VMWare VAAI和Hyper-V ODX(非对象版本)，加速私有云环境下的性能\r\n3、支持数据中心双写容灾\r\n4、支持跨数据中心异步复制QoS，支持分时间段的设置异步复制流量控制\r\n5、支持数据rebalance或者恢复时的QoS控制，保障业务访问性能\r\n6、支持桶快照和快照策略功能，实现桶级别快照恢复\r\n7、IO流程、元数据缓存机制优化，使得海量小文件情况下，小文件读写性能10倍以上提升；见测试报告\r\n8、支持WORM特性，支持法规遵从需求\r\n9、支持生命周期管理功能\r\n10、支持多集群统一管理功能，实现统一管理、统一监控、统一告警\r\n11、支持FTP/NFC/CIFS网关，兼容传统应用\r\n12、支持审计日志功能\r\n13、管理系统支持故障检测、故障自动隔离、磁盘\r\n14、支持ECM系统(filenet/Documentus) 利旧和统一访问\r\n15、支持文件后处理插件式框架，目前支持文档格式转换、图片处理等基础性功能\r\n	2018-06-27 13:26:12.310769
77	1	7	绩效引导意见	绩效考核引导：\r\nA：\r\n1，出色完成工作任务\r\n   开发任务：设计，代码质量，以及问题数量，完成时间，文档输出等\r\n   其他任务：根据任务实际性质评价\r\n2，在一些地方做出关键贡献\r\n\r\n关键贡献包括:\r\n1, 提出新的Idea或大的改进建议并实施，提升产品竞争力\r\n2，发现或修复重大bug，提升产品稳定性，可靠性\r\n3，提升效率，构建更好的开发以及测试平台\r\n4，支撑客户中贡献突出，促进POC和商业目标达成\r\n5，招纳优秀人才\r\n6，其他有价值的贡献\r\n\r\nB+：\r\n1，出色完成工作任务\r\n2，态度积极主动，构建良好团队氛围，积极帮助其他同事\r\n\r\nB：\r\n1，按时完成工作任务\r\n2，工作态度良好\r\n\r\nC：\r\n1，未能完成工作任务\r\n2，工作态度一般或存在恶习\r\n3，与公司文化不符或在工作中引入重大事故	2018-07-19 08:58:06.340015
78	1	7	一些工具使用问题	1，gitlab无法提交初始代码，提示：You are not allowed to push code to protected branches on this project.\r\n\r\n初看以为是SSL配置有误，再看以为是developer没权限，最终确定是只有master才能提交最初分支。\r\n然后需在项目的setting->Repository-> Protected Branches中把master分支 unprotect或设置权限\r\n\r\n\r\n\r\n2，yum确定哪个源有效\r\n使用yum list命令即可	2018-07-21 08:46:11.932748
81	1	8	问题与求解	解决问题全靠灵感？经验？显然这不科学。\r\n\r\n如何求解问题呢？	2018-08-22 06:45:56.495553
82	1	5	RAID相关	1，如何查看RAID卡类型，RAID卡有哪些规格？\r\n2，RAID卡的cache与盘的cache是什么回事，分别如何查看？\r\n3，RAID卡BBU状态怎么查看？\r\n4，RAID卡对性能的影响？	2018-09-19 13:59:07.03178
89	21	5	装修知识大梳理	装修的本质是什么？\r\n装修究竟包含了哪些工作流？\r\n如何让装修梳理进展？\r\n如何让装修效果达到自己的预想？	2019-03-18 15:37:26.61484
91	21	5	装修流程2	设计师在装修过程中可能会做哪些工作：\r\n量房拍照，收集信息\r\n协助梳理居住需求，讨论生活场景\r\n根据实际情况，确定设计构想的前瞻度\r\n与委托人配合，对各种方案思路的可行性进行验证\r\n根据双方确定的平面布置方案，进行深化设计\r\n协助控制预算，协助挑选施工方与供应商\r\n确定设计方案，列出采买清单，协助安排施工、采买、安装的时间节点\r\n开工后与施工方保持沟通，及时协商解决意外方案变动和偶发状况\r\n协助进行家具电器、灯具光源、补充配件的安装调试，以及参与其他约定的工作事项\r\n	2019-03-19 11:23:33.607488
79	1	5	面试题	1，网络 172.18.0.100/16  请说出每段的意思\r\n2，磁盘 iostat有哪些参数，各是什么意思？\r\n3，如何分析CPU压力	2018-07-31 09:27:06.960277
66	1	7	统计ceph集群的读写，性能分析	\r\n\r\nosd性能问题定位方法：将osd的日志级别开到15，osd会打印每个读写操作的日志。\r\n分析该日志文件即可得到osd节点的读写请求情况，以及延时。\r\n\r\n结论：\r\n1，在rgw cache打开的情况下，v5.1.0版本rgw会向rados发三种请求，\r\n分别是bi读，object写，bi写。其比例是1:1:1\r\n\r\n2，bi读的延时通常比bi写大，这反应了leveldb写快读慢的特点。\r\n\r\n分析方法：\r\nfor((i=1;i<18;i=i+3)); do bin/ceph --admin-daemon var/run/ceph/ceph-osd.${i}.asok config set debug_osd 15; done\r\nfor((i=1;i<18;i=i+3)); do bin/ceph --admin-daemon var/run/ceph/ceph-osd.${i}.asok config set debug_osd 1; done\r\nfor((i=1;i<18;i=i+3)); do cat var/log/ceph/ceph-osd.${i}.log | grep "log_op_stat" > oplog${i}; done\r\n\r\nobject写入：\r\nfor((i=0;i<18;i=i+3)); do cat oplog${i} | grep writefull | wc -l; done\r\nBI写入：\r\nfor((i=0;i<18;i=i+3)); do cat oplog${i} | grep complete_op | wc -l; done\r\nBI读：\r\nfor((i=0;i<18;i=i+3)); do cat oplog${i} | grep object_get | wc -l; done\r\n\r\n对写入对象大小进行分析：\r\nfor((i=0;i<18;i=i+3)); do cat oplog${i} | grep writefull | awk '{print $(NF-6)}' | awk '$1 > 512' | wc -l; done\r\n\r\n对延时进行分析：\r\n统计延时超过20ms的对象写入\r\nfor((i=0;i<18;i=i+3)); do cat oplog${i} | grep writefull | awk '{print $(NF)}' | awk '$1 > 0.200' | wc -l; done\r\n\r\n统计延时在20ms到50ms的对象写入\r\nfor((i=0;i<18;i=i+3)); do cat oplog${i} | grep writefull | awk '{print $(NF)}' | awk '$1 > 0.200  && $1 < 0.50' | wc -l; done\r\n\r\n\r\n计算延时：\r\nfor((i=0;i<18;i=i+3)); do cat oplog${i} | grep writefull | awk '{print $(NF)}' >> writefull.lat; done\r\n​awk '{sum += $1};END {print sum}' ./writefull.lat\r\n得出总耗时后除以操作个数就可以得到延时。\r\n\r\n\r\n\r\n同样可以分析bi写入和bi读操作的延时。\r\n比如：\r\n[root@wadehao ceph]# for((i=0;i<18;i=i+3)); do cat oplog${i} | grep object_get | awk '{print $(NF)}' | awk '$1 < 0.002' | wc -l; done\r\n3181\r\n3583\r\n3507\r\n3496\r\n4257\r\n4309\r\n[root@wadehao ceph]# for((i=0;i<18;i=i+3)); do cat oplog${i} | grep complete | awk '{print $(NF)}' | awk '$1 < 0.002' | wc -l; done\r\n225\r\n254\r\n190\r\n253\r\n314\r\n281\r\n\r\n通过对比可以发现，bi的写入性能比bi读取会好很多。\r\n\r\n	2018-05-30 18:09:10.908974
80	1	5	多版本与双活V5 黄金法则	多版本与同步总结：\r\n\r\n1，非多版本下操作的都是“null”版本\r\n2, 多版本下操作的都是新版本对象，删除产生delete marker\r\n3，多版本挂起下，操作都是作用于"null版本"，与非多版本区别在于其删除也会产生delete marker（"null"版本的delete marker）。\r\n\r\n4，GET/set_attr操作可以作用于current，也可以作用于具体版本，取决于客户端请求携带的version_id\r\n5，非同步操作，不产生mtime(其实是对象创建时间，在BI中对象按创建时间排序)，由bi产生。\r\n6，目前只有ACL，CORS，TAG等使用的是set_attr, 对象增加其他自定义属性操作属于PUT操作，其区别在于set_attr仅修改元数据，而PUT相当于创建一个\r\n同名的新对象，在多版本下PUT操作会产生新版本，而set_attr不会。同步的时候set_attr仅同步属性部分。\r\n\r\n对于同步：\r\n0，决定是否同步，以及哪个版本对象最新的是mtime（对象创建时间），注意不存在对象覆盖写的情况，只有修改对象属性的情况，这时会记录属性修改时间，以便于分辨master 和 slave谁的attr是最新的。\r\n1，同步操作总是作用于具体的版本，不会产生新版本，所以根据instance判断对象是否是多版本下的。“null”则是非多版本下的。\r\n3，同步对象元数据需使用bilog中的时间（修改时间），执行时与bi中attr_mtime比较决定是否执行。\r\n4，zone上的任何修改操作都需记录bilog（否则从属于该zone的其他zone无法同步数据），也需要zone_trace（否则会循环同步）\r\n5，delete marker同步也要对比时间。\r\n	2018-07-31 11:26:59.059275
85	1	7	责任划分	1，攻关疑难问题，分析产品缺陷，大的技术方案\r\n   osd问题处理\r\n\r\n2，rgw技术负责，处理rgw各种问题\r\n	2018-10-12 11:56:49.545603
84	1	7	代码提交规范	1，特性或重要bug的fix需要经过代码review，需要review的在提交信息中说明reviewed by：\r\n\r\n2，特性或bugfix的提交需提供自验证说明，问题单在单里面说明，特性在特性测试文档中说明。\r\n\r\n3，提交信息规范：\r\n\r\n    新增特性或变更，开头使用feature：\r\n\r\n    bugfix，使用 bugfix:#单号\r\n\r\n    优化，使用optimize:\r\n\r\n即提交格式如下：\r\n\r\n4，特性提交请发邮件知会特性变更情况，bugfix请在问题单中详细说明变更，以及问题复现建议等。\r\n5，squash无效提交。\r\n\r\n\r\nbugfix : #320, xxx\r\n\r\n\r\n\r\nSigned-off-by: lizhong <lizhong@szsandstone.com>\r\n\r\nReviewed-by: xierui <xierui@szsandstone.com>	2018-10-12 11:26:30.206779
53	1	7	对象存储的理解	这就是对象的魅力所在，对象才是真正的大数据，对象打破了块分割使用的思路，同时也剪除了文件系统的巨大限制，使得海量存储成为可能。\r\n\r\n没有海量数据就没必要玩对象存储\r\n\r\n支持标准 RESTful API 接口，并提供丰富的数据在线处理服务，一站式解决互联网时代非结构化数据管理难题。\r\n\r\nrgw架构上：\r\n1，接入层\r\n负责各种协议的接入，使得对象存储可以运用于各种场景，负责应用接入等。\r\n\r\n2，表现层\r\n数据管理系统，提供一些功能，使得用户可以方便的操作数据。\r\n\r\n3，功能层\r\n提供对象各种概念的管理\r\n\r\n4，管理层\r\nom系统，管理监控整个系统\r\n\r\n5，内核层\r\nrados，提供数据存储能力。\r\n\r\n6，处理层\r\n提供数据处理能力\r\n\r\n支持异构多集群，支持使用几乎无感的数据迁移，故障切换（DNS），扩容，升级。（1人）\r\n\r\n支持隐私保护，账户管理，ldap, 权限验证，acl, ssl, worm， policy，加解密（1人）\r\n支持Qos控制，Quota控制，流量统计，优化服务质量。（1人）\r\n\r\n支持数据安全，多版本，CDP，快照，生命周期 （1人）\r\n支持高效存储，去重，压缩，EC等。（1人）\r\n\r\n\r\n维护版本的事情：\r\n支持系统内部部件的各种健康监控告警，性能监控，审计日志，性能排忧，配置优化，使用等（1人）\r\n\r\n对象存储基本功能支持，CORS，multipart，元数据检索（0.5人）\r\n支持外围接口丰富，S3 SDK，FTP，NFS等（0.5人）\r\n\r\n隐私，安全，有效，便捷，优质， 稳定可靠， 开放的存储系统。\r\n\r\n\r\n对象存储的限制：\r\n1，默认不支持追加写文件，但OSS支持\r\n2，分片上传可解决流式上传问题(提前不知道文件有多大)\r\n   https://help.aliyun.com/document_detail/90222.html\r\n   https://docs.aws.amazon.com/AmazonS3/latest/API/API_CompleteMultipartUpload.html\r\n3，流量优化，但延迟很大\r\n4，可支持范围读取\r\n\r\n\r\n	2018-03-11 09:47:23.097892
93	17	7	PG内存管理	1，MemoryContext内存上下文\r\n  系统中的内存上文文形成一颗树，以便于区别管理，整体释放不同的内存。\r\n\r\n2，palloc内存分配\r\n  palloc是在当前上下文中分配内存，也可使用接口MemoryContextAlloc指定上下文分配内存。\r\n\r\n3，AllocSetContext内存管理\r\n  实现了内存池，以及buddy算法的freelist管理\r\n  \r\n参考：\r\n  https://blog.csdn.net/taochangchang/article/details/52593475\r\n  以及aset.c的注释部分\r\n\r\n4，genslab/slab 实现特定场景下的高效内存管理\r\n  2017年新增的.\r\n \r\n参考：\r\n  https://www.postgresql.org/message-id/flat/d15dff83-0b37-28ed-0809-95a5cc7292ad@2ndquadrant.com\r\n\r\n有观点认为内存管理不是当前程序的性能瓶颈，当然这是针对不同的软件来说的。\r\n实际上像ceph等涉及大量字符串创建，拷贝，小内存分配等性能影响还是非常大的。\r\n	2019-05-06 15:39:18.520563
86	1	7	mkfs参数	mkfs.xfs -f -i size=2048 /dev/sdb\r\nmkfs.xfs -f -i size=2048 -s size=4096 -b size=4096  /dev/sdb （带ssd cache）\r\nmount -o rw,nobarrier,noatime,inode64,logbsize=256K,delaylog /dev/sdb /sandstone-data/sds-15\r\nmount -o rw,noatime,inode64,logbsize=256K,delaylog	2018-10-25 17:50:32.317837
7	1	5	小文件读写慢的问题	问题原因：\r\n1，文件系统小文件增多之后，性能下降\r\n2，bucket index规模上来之后，相关的恢复，scrub都有风险。\r\n\r\nhttp://www.cnblogs.com/wuhuiyuan/p/4651698.html\r\n这篇文件介绍的方案也可以参考下。\r\n\r\n第二个问题好解决，大不了就增加bucket index，list对象的功能用的还是非常少的。\r\n还有一种牺牲的手法：遍历不保证全局有序，使用id + objectname方式遍历。\r\n\r\n*核心是保证对象不用经过元数据就可以一次性定位到。这样保证可以读性能不会下降。*\r\n\r\n*对象存储其实可以根据其整写整读的方式对store做优化。*\r\n\r\n小文件合并xsky的方案也可以与上述方案做些对比。\r\n\r\n进一步分析：\r\n1，一个文件系统能抗多少文件？\r\n2，rgw的元数据对文件读写性能的影响？\r\n3，bucket index到底多少会导致recover/backfill慢？如何设计测试用例验证?\r\n\r\nhttp://blog.csdn.net/liuaigui/article/details/9981135\r\n这篇文章有比较详细的分析。\r\n这个问题的核心应该是海量小文件导致文件系统元数据无法cache命中，海量之后本身元数据的操作开销也增加。\r\n\r\n通过增加一个中间层，将小文件合并之所以有效，主要是因为"索引文件" 可以利用cache。\r\n如果文件系统支持将元数据独立出来放到ssd，这个问题也就没了。\r\n\r\n目前有3种备选方案：\r\n1，xsky的使用一个pool先暂存，然后合并\r\n2，在filestore做合并的方案\r\n3，bluestore的方案\r\n\r\n长远看 bluestore肯定是主推方案，bluestore抛弃文件系统，可彻底解决该隐患\r\n\r\n2018-9-19:\r\n海量文件的问题本质上就是文件系统调用栈太深引起的开销问题。\r\n通过ssd缓存inode元数据的方案，可以在一定程度上缓解该问题，cache选择有intel的CAS\r\n或者改造bcache，支持仅仅缓存元数据，\r\n但是这种方案只是缓解，调用次数并未减少，调用栈仍然非常深。\r\n\r\n此外xfs的碎片管理上也存在一些问题，如果不主动做碎片整理。在大量空洞时，性能下降非常厉害。\r\n比较奇怪的是为什么在删除掉大量8kb文件时，xfs文件系统没有释放其空间？\r\n\r\n不过自己做小文件合并存在同样的问题。这问题可命名为 “gc问题”。\r\n任何空间管理的方案都要处理这个问题。\r\n\r\n2018-9-20：\r\n在rados的object上实现空间管理也有一些麻烦的地方。\r\n比如如果rgw写入数据成功，但是随后bi修改失败。则raods对象上有相关的key，可能rados对象就无法删除了。\r\n\r\n2018-10-15：\r\n独立出ssd pool，采用小文件合并方案。\r\n\r\n2018-10-17：\r\n三种方案：\r\n1，采用xsky类似方案，先写入小文件，后台合并。\r\n  多了合并操作，且在前端pool满时，可能不得不直接用小文件写后端。\r\n\r\n2，在小对象写入时，管理分配大文件空间。\r\n  这样做需考虑并发时的性能，每个对象都需在bucket shard上做一次空间分配，多了一次交互。\r\n  另外由于这种情况下空间分配与小文件的bi修改不是一个请求完成的，需额外考虑一致性问题。\r\n  并发时如何做空间分配性能更优?\r\n\r\n3，采用hash方式映射小文件到大文件，优化并发性能\r\n  hash扩展麻烦，后续要支持bucket海量数据。\r\n  gc操作无法合并大文件，只能清理无效和释放的对象空间。\r\n\r\n4，hash方式映射小文件到大文件，且空间分配在rados完成，通过cls实现。大对象在BI中记录有哪些小对象。以及操作信息方便gc。\r\n  增强了与rados的耦合\r\n  \r\n\r\n不论哪种方案，应该坚持元数据以BI为准的原则，即对象是否存在，rados空间是否有效以bucket index为准，否则就与当前设计冲突了。\r\n小文件上可记录到大文件的映射(prefix,offset,len)，避免读对象增加一次rados请求。\r\n大对象的bi上应该记录有哪些小文件，以方便实现gc。\r\n\r\nSSD和HDD独立建pool，不仅降低了硬件的耦合，使用上也更加灵活。\r\n\r\n2018.10.26：\r\n在使用bcache做元数据缓存之后，仍然需要做小文件合并的原因：\r\n1，降低硬件耦合，SSD故障不会影响到所有相关的HDD\r\n2，使用大文件，恢复和scrub等速度更快\r\n3，在POC测试时更加灵活(目前bcache使用并未缓存数据)\r\n4，即便在使用bcache情况下，xfs在写入后大量删除时，仍然会出现性能抖动厉害的问题，kworker占用内存暴涨。\r\n\r\n由于在IO路径上做空间管理的复杂度较高，且会增加一次写操作(空间分配)，性能受到影响。\r\n所以目前考虑采用类似xsky的方案，优先写入SSD，然后在后端进行合并。\r\n\r\n由于MOS并不存在对象的覆盖写入，所以对于单个对象修改的原子性没有要求，且可保证在合并之后的pool\r\n写入的对象是超过1MB的，因而V3 AgileStore是可以满足要求的(几个rgw的元数据池除外)。\r\n\r\n实际实现的时候gc是需要重点考虑的，gc的offload，降低rgw与osd之间的带宽消耗。\r\n后续会出具体实现方案，做下一次的细节讨论。\r\n	2017-10-10 08:09:50.065915
87	12	7	成长脚印	震哥小朋友最近有些便秘	2018-11-28 11:40:07.701975
90	21	5	装修流程1	室内设计，必须是基于真实需求，从现实条件的制约中去组合调配设计要素，并最终做出权衡取舍\r\n我们可以用温度、气味、触觉来评判居家环境，必要的时候，我们甚至可以假装自己是失聪者，用触觉、嗅觉、听觉、皮肤感觉来感受居室空间的动线情况、声音分布、空气流通、物品摆放、以及用身体的移动来感受动线走向\r\n\r\n\r\n花点时间了解一下自己的生活习惯，看看这些习惯中，哪些是因为条件所限，被迫潜移默化形成到的，哪些是因为自己觉得舒服自在而长久保持的\r\n装修过程中，你需要投入多少资金预算和时间精力，有相当一部分因素，在你选房买房的阶段就已经决定了\r\n楼位和户型朝向\r\n是否有外墙保温层\r\n入户门品质\r\n窗户是中空玻璃平开窗（包括内开内倒窗）还是单层玻璃推拉窗\r\n晴天正午阳光直射区域及有效直射的时长\r\n以上会影响到家中夏季空调耗电读书、冬季供暖期室内实际温度，房间的落灰层度、客厅和卧室隔离户外噪音的情况，从而在不经意间影响到实际生活品质\r\n\r\n\r\n\r\n装修的主要工序：\r\n拆除清运\r\n水电管线改造及完工确认\r\n墙体新砌及坑洞补平\r\n防水施工及闭水试验\r\n瓷砖铺贴及地面找平\r\n石膏板吊顶及轻质隔墙施工、其他现场木作\r\n墙面基层处理\r\n室内门及门套的现场制作或厂家定制\r\n柜体制作或厂家定制（包括橱柜）\r\n喷刷墙漆\r\n厨卫及阳台吊顶（除石膏板吊顶外的其他做法）\r\n安装室内门\r\n铺贴壁纸壁布\r\n铺设地板与踢脚线\r\n安装合金推拉门\r\n安装开关面板\r\n安装定制家具和相关电器设施\r\n调试安装灯具光源\r\n安装卫浴洁具\r\n安装窗帘轨道及窗帘布\r\n其他定制采购部件的协调安装等\r\n添置其他软装陈设及花卉绿植\r\n\r\n\r\n入住预算：指最终入职之前的最大入住预算，这不仅包括自购的基础建材、建材辅料、装饰建材。还包括水、电、网、气、风、暖设施，成品家具及配套产品、定制家具和其他定制产品、普通家用电器、只能家具硬件、五金配件、卫浴洁具、开关面板和灯具电料、软装陈设等，以及施工安装费用、设计费、灯具和洁具安装费用、物业押金和其他杂费等\r\n\r\n也就是说，在设定预算时，需要把乔迁之前的所有费用都先考虑进去，得到一个现阶段能拿得出的预算的最大值\r\n	2019-03-19 11:17:04.196985
76	1	7	rgw改造 V5	ceph rgw存在如下问题：\r\n1. BI使用rados对象保存，不支持增量恢复，在故障恢复时影响可用性 （使用backfill恢复机制后暂时得到缓解）\r\n2. 不能很好的支持bucket跨故障域和多集群,扩展性受限。 异构集群，冷热pool等。\r\n    bucket与pool绑定，在扩展性和使用的灵活性上存在限制。\r\n3. 海量小文件直接使用rados存储代价太大。\r\n4，多版本，multisite等特性复杂度不合适（非常重要，这决定了后续大量特性开发的复杂度）\r\n5，无法支持高效的list操作\r\n6，rgw put写放大，尤其是在多版本情况下。\r\n\r\n\r\n为了解决上述问题，考虑调整rgw架构：\r\n1，BI作为单独的一层，而不仅是实现bucket list，以及统计功能的附属。\r\n     BI作为对象的元数据存储，可以使用rados，也可以使用其他数据库（以优化问题1，5)\r\n     在此基础上实现小文件合并也相对容易 （问题3）\r\n     \r\n2，底层采用多版本机制，统一非多版本bucket与多版本bucket的实现，简化逻辑。\r\n     针对上述问题4，6\r\n\r\n但是bs的方式不变更，问题5无法彻底解决，bs的方式变更则同步逻辑需要大调整。\r\n\r\n底层数据组织方式决定了架构。\r\n\r\n\r\n2019.4.16:\r\n\r\n1/3/5都没在v5优化，还有昨天讨论的，非多版本pool的读写混合性能。解耦那时候还没提，后来越发觉得解耦是必须选项，以及多站点的重构	2018-06-27 14:08:29.214836
\.


--
-- Name: documents_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.documents_id_seq', 93, true);


--
-- Data for Name: email_addresses; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.email_addresses (id, user_id, address, is_default, notify, created_on, updated_on) FROM stdin;
1	1	jerry.xr86@gmail.com	t	t	2017-09-08 09:19:08.687057	2017-09-08 10:11:30.693949
2	5	x8671r@163.com	t	t	2017-09-08 13:40:38.745192	2017-09-08 13:40:38.745192
3	6	hudongyin@126.com	t	t	2018-11-02 21:03:05.65764	2018-11-02 21:04:07.791254
\.


--
-- Name: email_addresses_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.email_addresses_id_seq', 3, true);


--
-- Data for Name: enabled_modules; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.enabled_modules (id, project_id, name) FROM stdin;
1	1	issue_tracking
2	1	time_tracking
3	1	news
4	1	documents
5	1	files
6	1	wiki
7	1	repository
8	1	boards
9	1	calendar
10	1	gantt
11	2	issue_tracking
12	2	time_tracking
13	2	news
14	2	documents
15	2	files
16	2	wiki
17	2	repository
18	2	boards
19	2	calendar
20	2	gantt
21	3	issue_tracking
22	3	documents
23	3	repository
24	4	issue_tracking
25	4	documents
26	4	files
27	4	calendar
28	5	issue_tracking
31	5	documents
38	6	issue_tracking
39	6	documents
40	7	issue_tracking
41	7	documents
42	7	files
43	8	issue_tracking
44	8	documents
45	9	issue_tracking
46	9	documents
47	10	issue_tracking
48	10	documents
49	11	issue_tracking
50	11	documents
51	12	issue_tracking
52	12	documents
65	15	issue_tracking
66	16	issue_tracking
67	16	time_tracking
68	16	documents
69	16	calendar
70	17	issue_tracking
71	17	documents
72	18	issue_tracking
73	19	issue_tracking
74	19	time_tracking
75	19	news
76	19	documents
77	19	files
78	19	wiki
79	19	repository
80	19	boards
81	19	calendar
82	19	gantt
83	20	issue_tracking
84	20	news
85	20	documents
86	20	files
87	20	wiki
88	20	repository
89	20	boards
90	20	calendar
91	20	gantt
92	21	documents
93	21	files
104	23	issue_tracking
105	23	documents
106	21	issue_tracking
107	24	issue_tracking
108	24	time_tracking
109	24	news
110	24	documents
111	24	files
112	24	wiki
113	24	repository
114	24	boards
115	24	calendar
116	24	gantt
117	25	issue_tracking
118	26	issue_tracking
119	27	issue_tracking
120	27	documents
121	27	repository
122	28	issue_tracking
123	28	documents
124	29	issue_tracking
125	29	documents
126	29	files
127	30	issue_tracking
128	30	time_tracking
129	30	calendar
130	30	gantt
131	31	issue_tracking
132	31	documents
133	31	boards
134	31	calendar
135	31	gantt
136	32	issue_tracking
137	32	documents
138	33	issue_tracking
139	33	time_tracking
140	33	news
141	33	documents
142	33	files
143	33	wiki
144	33	repository
145	33	boards
146	33	calendar
147	33	gantt
\.


--
-- Name: enabled_modules_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.enabled_modules_id_seq', 147, true);


--
-- Data for Name: enumerations; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.enumerations (id, name, "position", is_default, type, active, project_id, parent_id, position_name) FROM stdin;
1	超高	1	f	IssuePriority	t	\N	\N	lowest
2	高	2	f	IssuePriority	t	\N	\N	low2
3	中	3	t	IssuePriority	t	\N	\N	default
4	低	4	f	IssuePriority	t	\N	\N	highest
5	FAQ	1	f	DocumentCategory	t	\N	\N	\N
6	代码注解	2	f	DocumentCategory	t	\N	\N	\N
8	Idea	4	f	DocumentCategory	t	\N	\N	\N
7	doc	3	f	DocumentCategory	t	\N	\N	\N
\.


--
-- Name: enumerations_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.enumerations_id_seq', 8, true);


--
-- Data for Name: groups_users; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.groups_users (group_id, user_id) FROM stdin;
\.


--
-- Data for Name: import_items; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.import_items (id, import_id, "position", obj_id, message) FROM stdin;
\.


--
-- Name: import_items_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.import_items_id_seq', 1, false);


--
-- Data for Name: imports; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.imports (id, type, user_id, filename, settings, total_items, finished, created_at, updated_at) FROM stdin;
\.


--
-- Name: imports_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.imports_id_seq', 1, false);


--
-- Data for Name: issue_categories; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.issue_categories (id, project_id, name, assigned_to_id) FROM stdin;
1	1	RGW	5
2	1	RBD	\N
3	1	OSD	\N
4	1	elk	\N
5	1	rgw_object_versions	\N
6	1	multisite	\N
7	1	每日任务	\N
8	1	docker	\N
9	1	网络	\N
10	1	硬件	\N
11	1	运维	\N
12	5	经济	\N
13	5	政治	\N
14	5	法律	\N
15	5	文学	\N
16	5	历史	\N
17	11	黑玛亚	\N
18	12	记录点滴	\N
20	7	网络	\N
21	7	计算	\N
22	7	存储	\N
23	7	算法	\N
24	19	4月家庭会议主题确定	\N
25	17	索引	\N
26	27	领导力	\N
27	27	执行力	\N
28	27	沟通力	\N
29	27	数理逻辑	\N
30	27	算法	\N
31	27	结构	\N
32	27	设计	\N
33	27	工程	\N
\.


--
-- Name: issue_categories_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.issue_categories_id_seq', 33, true);


--
-- Data for Name: issue_relations; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.issue_relations (id, issue_from_id, issue_to_id, relation_type, delay) FROM stdin;
1	26	27	copied_to	\N
2	438	465	relates	\N
3	466	439	relates	\N
\.


--
-- Name: issue_relations_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.issue_relations_id_seq', 3, true);


--
-- Data for Name: issue_statuses; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.issue_statuses (id, name, is_closed, "position", default_done_ratio) FROM stdin;
1	打开	f	1	\N
3	Need More Info	f	2	\N
4	In Progress	f	3	\N
6	Need Review	f	4	\N
7	Need Test	f	5	\N
8	Testing	f	6	\N
9	Pending Backport	t	7	\N
10	Pending Upstream	t	8	\N
11	Resolved	t	9	\N
12	Closed	t	10	\N
13	Rejected	t	11	\N
14	Won't Fix	t	12	\N
15	Can't reproduce	t	13	\N
16	Duplicate	t	14	\N
17	New	f	15	\N
18	Verified	f	16	\N
19	目标	f	17	\N
20	问题	f	18	\N
21	分析	f	19	\N
22	方案	f	20	\N
23	实施	f	21	\N
24	总结	t	22	\N
\.


--
-- Name: issue_statuses_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.issue_statuses_id_seq', 24, true);


--
-- Data for Name: issues; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.issues (id, tracker_id, project_id, subject, description, due_date, category_id, status_id, assigned_to_id, priority_id, fixed_version_id, author_id, lock_version, created_on, updated_on, start_date, done_ratio, estimated_hours, parent_id, root_id, lft, rgt, is_private, closed_on) FROM stdin;
407	6	21	关于装修的思考	装修的本质是什么？\r\n装修究竟包含了哪些工作流？\r\n如何让装修梳理进展？\r\n如何让装修效果达到自己的预想？\r\n	\N	\N	17	\N	3	\N	6	0	2019-05-22 04:13:26.522948	2019-05-22 04:13:26.522948	2019-05-22	0	\N	\N	407	1	2	f	\N
46	5	1	http://tracker.ceph.com/issues/20728	\N	\N	\N	17	\N	3	\N	5	0	2017-11-28 21:55:19.147402	2017-11-28 21:55:19.147402	2017-11-28	0	\N	\N	46	1	2	f	\N
39	7	1	海量小文件问题	bluestore本身没有海量小文件问题了，但是需要缩减其元数据规模，根据对象存储特征优化bluestore layout。	\N	1	17	5	3	4	5	7	2017-11-20 07:29:48.851521	2019-03-08 14:32:27.441898	2017-11-20	0	\N	\N	39	1	2	f	\N
30	3	1	cloudberry或s3browser增加http headers成功，但是底下什么都没	172.18.0.1 - - [31/Oct/2017:08:47:07 +0000] "PUT /xx1/bbbb.txt HTTP/1.1" 200 194 "-" "CloudBerryLab.Base.HttpUtil.Client 5.0.3 (http://www.cloudberrylab.com/)" "-"\r\n\r\n操作成功后，那一会能看到新增的http header，但是刷新下就没了。\r\n\r\n非常奇怪。	\N	1	14	5	3	3	5	2	2017-10-31 14:32:39.616019	2017-10-31 14:51:47.090629	2017-10-31	0	\N	\N	30	1	2	f	2017-10-31 14:51:47.090629
55	7	1	本周任务	1，完成已有bugfix\r\n2，license合入\r\n3，分析同步那块改进方案。彻底剪除隐患。	\N	\N	19	\N	3	\N	5	0	2018-01-29 07:12:56.625761	2018-01-29 07:12:56.625761	2018-01-29	0	\N	\N	55	1	2	f	\N
313	6	19	4月周末活动安排	发起活动建议，协调家庭成员的时间，促成各项家庭亲子活动的开展	\N	\N	17	\N	3	\N	6	1	2019-03-18 07:42:00.544156	2019-03-18 08:15:55.484395	2019-03-18	0	\N	\N	313	1	2	f	\N
31	3	1	多版本bucket的对象acl无法修改成功	在s3browser操作，apply change之后reload，权限还原成默认的。	\N	1	16	5	3	3	5	3	2017-10-31 14:56:41.285835	2017-11-08 13:27:27.529744	2017-10-31	0	\N	\N	31	1	2	f	2017-11-08 13:27:27.529744
27	3	1	object tag的v4鉴权失败	put_tag () {\r\n    bucket=/$1\r\n    resource=/$2\r\n    tagdata=$3\r\n    dateValue="`TZ=GMT date +'%a, %d %b %Y %H:%M:%S GMT'`"\r\n    stringToSign="PUT\\n\\napplication/x-www-form-urlencoded\\n${dateValue}\\n${bucket}${resource}?tagging"\r\n    echo $stringToSign\r\n    #stringToSign="PUT\\n\\n\\n${dateValue}\\n${bucket}${resource}?tagging"\r\n    signature=`echo -en ${stringToSign} | openssl sha1 -hmac ${Key} -binary | base64`\r\n    url="http://${host}${bucket}${resource}?tagging"\r\n    echo "put tag begin"\r\n    echo "curl -L -i -v  -X PUT -H "Date: ${dateValue}" -H "Authorization: AWS ${Id}:${signature}" "${url}" -d $tagdata"\r\n    #curl -L -i -v  -X PUT -H "Date: ${dateValue}" -H "Authorization: AWS ${Id}:${signature}" "${url}" --data-urlencode "$tagdata"\r\n    curl -L -i -v  -X PUT -H "Date: ${dateValue}" -H "Authorization: AWS ${Id}:${signature}" "${url}" -d "$tagdata"\r\n    echo "put tag end"\r\n}\r\n\r\n当前版本采用v4鉴权会报501 not implemented	\N	1	17	5	3	5	5	2	2017-10-26 07:06:57.306928	2017-11-14 15:05:00.913332	2017-10-25	0	\N	\N	27	1	2	f	\N
59	8	1	http数据包会分片吗？	http数据包格式	\N	9	17	\N	3	\N	5	1	2018-02-28 07:26:21.749419	2018-02-28 08:18:42.135861	\N	0	\N	\N	59	1	2	f	\N
37	7	1	tag支持按照key来检索	tag多个key，搜key或者value都能搜到。\r\nes可以感知其格式么	\N	1	17	5	3	4	5	0	2017-11-14 15:23:46.871555	2017-11-14 15:23:46.871555	2017-11-14	0	\N	\N	37	1	2	f	\N
147	6	11	test	11	\N	\N	17	\N	3	\N	6	0	2018-11-03 13:32:25.073924	2018-11-03 13:32:25.073924	2018-11-03	0	\N	\N	147	1	2	f	\N
442	6	17	PG vacuum	vacuum涉及面非常广，也算是pg比较伤的一个地方	\N	\N	17	\N	3	\N	5	8	2019-06-06 14:13:48.47508	2019-12-27 12:11:37.797693	2019-06-06	0	\N	\N	442	1	2	f	\N
146	6	11	成就最美好的自己	深度阅读，思考从哪些方面成就最美好的自己，写下自己的感悟！	\N	\N	17	\N	3	\N	6	16	2018-11-03 12:13:58.283714	2018-11-28 08:41:59.040571	2018-11-03	0	\N	\N	146	1	2	f	\N
7	7	1	merge fron ceph luminous	迁移到ceph luminous版本，使用es特性。\r\n使用一种方法管理之前的fix，将之前的fix迁移到该版本。	\N	\N	17	\N	3	2	5	0	2017-09-12 07:44:06.528383	2017-09-12 07:44:06.528383	2017-09-12	0	\N	\N	7	1	2	f	\N
38	3	1	多版本删除最终不同步	陈乐  17:14:34\r\n复现步骤：\r\n在master端操作：\r\n1）未开启多版本时上传对象ab；\r\n2）开启多版本后，上传两个版本的ab对象；\r\n3）暂停多版本，删除当前对象列表中的ab对象（不带版本号）；\r\n4）开启多版本，删除多版本列表中所有版本的ab对象（带版本号）；\r\n5）查看bucket的对象列表，ab已被清除；\r\n在slave端查看：\r\n6）查看slave端对象列表：ab对象在对象列表中存在；\r\n陈乐  17:15:38\r\n测试的时候发现第4步没同步到slave	\N	1	4	5	2	5	5	7	2017-11-15 14:47:30.204834	2017-11-20 08:21:28.163894	2017-11-15	0	\N	\N	38	1	2	f	\N
408	6	21	设计一个家读书思考	寻找对自己有启发的知识点	\N	\N	17	\N	3	\N	6	3	2019-05-22 04:15:02.273349	2019-05-22 04:32:20.163261	2019-05-22	0	\N	\N	408	1	2	f	\N
441	6	15	改善球路	http://www.badmintoncn.com/view-8014-1.html	\N	\N	17	\N	3	\N	5	0	2019-06-06 11:50:13.594172	2019-06-06 11:50:13.594172	2019-06-06	0	\N	\N	441	1	2	f	\N
5	3	1	data sync一直显示未完成	"data_sync": [\r\n\r\n        {\r\n\r\n            "zone_name": "machang_master",\r\n\r\n            "zone_id": "b8b24847-9843-4d6f-a9be-f64a2e2baeff",\r\n\r\n            "retrieve_sync_info": "true",\r\n\r\n            "read_sync_status": "true",\r\n\r\n            "sync_status": "syncing",\r\n\r\n            "prepare_full_sync": 0,\r\n\r\n            "all_full_sync": 128,\r\n\r\n            "full_entry_sync": 0,\r\n\r\n            "prepare_incremental_sync": 128,\r\n\r\n            "all_incremental_sync": 128,\r\n\r\n            "fetch_local_sync": "true",\r\n\r\n            "fetch_source_sync": "true",\r\n\r\n            "data_sync_status": "sync",\r\n\r\n            "data_sync_num": 1,\r\n\r\n            "not_applied": "2017-09-06 16:02:59.0.518687s"\r\n\r\n        }\r\n\r\n    ]\r\n\r\n其他现象：\r\nrgw data sync的线程占用CPU接近100%\r\n打开日志疯狂打“[inc sync] can't do op”\r\n\r\n通过cr dump，以及gdb可以看到rgw卡在\r\n<pre><code class="cpp">\r\n        //遇到冲突的情况\r\n\t//这里出现死循环了\r\n        while (!marker_tracker->can_do_op(key) && (sync_status == 0)) {\r\n          if (!updated_status) {\r\n            set_status() << "can't do op, conflicting inflight operation";\r\n            updated_status = true;\r\n          }\r\n          ldout(sync_env->cct, 5) << *this << ": [inc sync] can't do op on key=" << key << " need to wait for conflicting operation to complete" << dendl;\r\n\t  yield wait_for_child();\r\n          bool again = true;\r\n          while (again) {\r\n            again = collect(&ret, lease_stack);\r\n            if (ret < 0) {\r\n              ldout(sync_env->cct, 0) << "ERROR: a child operation returned error (ret=" << ret << ")" << dendl;\r\n              sync_status = ret;\r\n              /* we have reported this error */\r\n            }\r\n          }\r\n        }\r\n</code></pre>\r\n\r\n\r\n进一步分析：\r\n发现RGWBucketShardIncrementalSyncCR的spwan stack都完成了，只有一个lease stack。\r\n但是上面的while循环无法结束。\r\n\r\nhttp://tracker.ceph.com/issues/21285\r\n	\N	1	10	5	3	1	5	6	2017-09-10 12:27:34.237984	2017-09-11 20:34:30.822345	2017-09-10	0	\N	\N	5	1	2	f	2017-09-11 20:34:12.778708
3	3	1	丢包严重时，bucket sync hang，没法完成同步。	http://tracker.ceph.com/issues/21256\r\n\r\n	\N	1	10	5	2	1	5	6	2017-09-10 11:58:40.934571	2017-09-11 11:53:15.270394	2017-09-10	0	\N	\N	3	1	2	f	2017-09-11 11:53:01.169948
6	6	1	RGWCoroutinesStack::collect 返回值	该函数返回值done，完全反应不了是否children都完成了，如果spawned是空了，像这些地方不是会死循环么？\r\n\r\n<pre><code class="cpp">\r\nwhile (num_spawned() > (size_t)num_cr_left) {\r\n      yield wait_for_child();\r\n      int ret;\r\n      while (collect(&ret, skip_stack)) {\r\n        if (ret < 0) {\r\n          ldout(cct, 10) << "collect() returned ret=" << ret << dendl;\r\n          /* we should have reported this error */\r\n          log_error() << "ERROR: collect() returned error (ret=" << ret << ")";\r\n        }\r\n      }\r\n    }\r\n</code></pre>\r\n	\N	1	17	5	3	\N	5	0	2017-09-11 13:37:33.185479	2017-09-11 13:37:33.185479	2017-09-11	0	\N	\N	6	1	2	f	\N
443	8	7	数据的形态变化，数据库的未来		\N	\N	17	\N	3	\N	5	0	2019-06-10 06:59:44.857728	2019-06-10 06:59:44.857728	\N	0	\N	\N	443	1	2	f	\N
8	3	1	s3fs can not show directory create by s3browser, but can show cloudberry.	s3fs挂载后无法正常显示目录	\N	1	8	5	3	\N	5	6	2017-09-12 13:57:56.123901	2017-09-12 19:49:50.525764	2017-09-12	0	\N	\N	8	1	2	f	\N
9	7	1	rgw cors usage	(gdb) p *s->cio\r\n$37 = {_vptr.RGWClientIO = 0x7f5e892798f0 <vtable for RGWFCGX+16>, _account = false, env = {env_map = std::map with 30 elements = {["CONTENT_LENGTH"] = "", ["CONTENT_TYPE"] = "", \r\n      ["DOCUMENT_ROOT"] = "/var/lib/ceph/nginx/html", ["DOCUMENT_URI"] = "/", ["FCGI_ROLE"] = "RESPONDER", ["GATEWAY_INTERFACE"] = "CGI/1.1", ["HTTP_ACCEPT"] = "*/*", \r\n      ["HTTP_ACCEPT_ENCODING"] = "gzip,deflate,sdch", ["HTTP_ACCEPT_LANGUAGE"] = "zh-CN,zh;q=0.8", \r\n      ["HTTP_ACCESS_CONTROL_REQUEST_HEADERS"] = "x-amz-content-sha256, x-amz-user-agent, x-amz-date, authorization", ["HTTP_ACCESS_CONTROL_REQUEST_METHOD"] = "GET", \r\n      ["HTTP_HOST"] = "10.10.7.83:5656", ["HTTP_ORIGIN"] = "http://10.10.7.83:6690", ["HTTP_PROXY_CONNECTION"] = "keep-alive", ["HTTP_REFERER"] = "http://10.10.7.83:6690/sdsomdata/", \r\n      ["HTTP_USER_AGENT"] = "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36", ["HTTP_X_LANTERN_VERSION"] = "3.7.4", \r\n      ["QUERY_STRING"] = "", ["REDIRECT_STATUS"] = "200", ["REMOTE_ADDR"] = "10.10.200.103", ["REMOTE_PORT"] = "56849", ["REQUEST_METHOD"] = "OPTIONS", ["REQUEST_SCHEME"] = "http", \r\n      ["REQUEST_URI"] = "/", ["SCRIPT_NAME"] = "/", ["SERVER_ADDR"] = "10.10.7.83", ["SERVER_NAME"] = "", ["SERVER_PORT"] = "5656", ["SERVER_PROTOCOL"] = "HTTP/1.1", \r\n      ["SERVER_SOFTWARE"] = "nginx/1.9.15"}, conf = 0x7f5e68a1d1d0}}\r\n\r\nhow to set cors for js	\N	\N	17	5	3	2	5	1	2017-09-14 16:01:49.62542	2017-09-14 16:02:19.512055	2017-09-14	0	\N	\N	9	1	2	f	\N
10	7	1	华为的ceph（hammer）环境请求超时问题	业务场景：\r\n客户使用800并发发送head和get请求。\r\n\r\n现象：\r\ncivetweb发送消息时返回EIO，最终http错误码是500\r\nrgw堆栈有466个vivetweb的call back，其中440个是在send函数上。\r\n也就是说大量的请求都在给客户端发送消息上。\r\n\r\n疑问：\r\n1，大量请求卡在给客户端的send函数，是否是因为超时，网络断了，但是rgw仍然sb的在发送？\r\n那这样就不能证明是civetweb发送慢\r\n\r\n2，civetweb比nginx慢的根因是什么？ 慢多少？ 该如何调优？\r\n\r\n3，大量卡在send，而不是给rados发送请求后的等待是否能说明，send存在瓶颈？	\N	\N	17	5	1	\N	5	5	2017-09-25 07:57:46.876645	2017-09-26 15:58:56.646846	2017-09-25	0	\N	\N	10	1	2	f	\N
32	3	1	特殊字符作为key的标签，能写入成功，但es无法检索到	从web界面操作的。\r\n\r\nkey:_1001\r\nvalue: @groupzine\r\n\r\n类似这种	\N	4	17	5	3	4	5	0	2017-11-02 06:50:52.309885	2017-11-02 06:50:52.309885	2017-11-02	0	\N	\N	32	1	2	f	\N
278	7	17	了解firebase 和 snowflake架构		\N	\N	19	\N	3	\N	5	0	2019-02-20 08:46:17.05383	2019-02-20 08:46:17.05383	2019-02-20	0	\N	\N	278	1	2	f	\N
11	3	1	osd scrub时间超长，无法完成	OSD::_committed_osd_maps等待pg锁\r\nosd tick无法获取锁\r\n出现900s超时，osd被down，但进程仍然在。\r\n\r\nbucket 一共780万对象，64个shard。	\N	\N	17	\N	3	1	5	2	2017-09-29 12:19:58.76523	2017-09-30 07:34:39.766652	2017-09-29	0	\N	\N	11	1	2	f	\N
47	7	1	slave zone请求增加审计日志 	提高可运维性。	\N	1	17	5	3	4	5	1	2017-12-29 22:41:52.435812	2017-12-29 22:51:39.431041	2017-12-29	0	\N	\N	47	1	2	f	\N
19	3	1	rgw 无法同步多版本对象		\N	1	11	5	3	1	5	5	2017-10-17 12:48:05.073588	2017-10-19 14:08:52.88303	2017-10-17	0	\N	\N	19	1	2	f	2017-10-19 14:08:52.88303
14	3	1	rgw zone修改endpoint不生效	在创建es zone时，忘了带endpoint参数，使用modify命令无法添加endpoint\r\n\r\nbin/radosgw-admin zone modify --rgw-zone=SZES endpoints=http://172.18.0.130:8082	\N	\N	11	5	3	1	5	2	2017-10-11 07:29:12.61125	2017-10-11 07:35:08.967692	2017-10-11	0	\N	\N	14	1	2	f	2017-10-11 07:35:08.967692
25	4	1	支持审计日志功能	\N	\N	\N	4	\N	3	3	5	7	2017-10-24 14:50:25.232587	2018-01-18 07:31:20.153683	2017-10-24	0	\N	\N	25	1	2	f	\N
12	3	1	目录下的对象元数据es同步失败	很容易复现	\N	\N	8	5	3	1	5	5	2017-09-30 15:15:32.852798	2017-10-10 11:50:36.723792	2017-09-30	0	\N	\N	12	1	2	f	\N
17	7	1	共享桶对共享用户不可见	http://s3browser.com/bucket-sharing-tutorial.aspx\r\n\r\n谢锐(x8671r@163.com)  15:20:20\r\n@董雷  我们版本不支持bucket policy，要实现共享用户bucket可见还得额外处理。 s3browser和cloudberry都是用external bucket的方式实现的。\r\n董雷(836444522)  15:24:37\r\n嗯嗯 那共享桶这个功能在月底出的版本隐藏掉吗\r\n谢锐(x8671r@163.com)  15:31:04\r\n这个要讨论下 如果这个版本没有人用这功能 我觉得可以隐藏掉 \r\n可以在后面的版本 通过bucket policy的方式实现\r\n董雷(836444522)  15:32:06\r\nL版本支持bucket policy了吗\r\n谢锐(x8671r@163.com)  15:33:36\r\nL版本开始部分支持了 \r\nListBucket在L版本支持的	\N	1	4	5	3	1	5	1	2017-10-13 13:06:50.195323	2017-10-13 13:07:12.091753	2017-10-13	0	\N	\N	17	1	2	f	\N
15	7	1	2017-10-11 任务清单	1，支持数据管理，es检索\r\n2，支持ftp\r\n3，支持es\r\n4，分析multisite同步速度，能否压缩优化等。	\N	\N	17	\N	3	\N	5	1	2017-10-11 09:10:14.309459	2017-10-13 13:08:55.204536	2017-10-11	0	\N	\N	15	1	2	f	\N
22	7	1	多版本如何将对象设置为某个版本？	使用copy？\r\n还是get，然后put？	\N	\N	4	\N	3	\N	5	1	2017-10-23 07:58:05.332904	2017-10-24 14:41:53.673935	2017-10-23	0	\N	\N	22	1	2	f	\N
64	3	1	xx问题	xx	\N	\N	4	\N	3	\N	5	0	2018-03-05 13:14:21.236066	2018-03-05 13:14:21.236066	2018-03-05	20	\N	61	61	8	9	f	\N
24	7	1	s3 copy鉴权	ceph rgw日志输出：\r\n\r\n2017-10-24 04:01:01.353844 7f6c35bf3700 10 auth_hdr:\r\nPUT\r\n\r\n\r\nTue, 24 Oct 2017 04:01:01 GMT\r\nx-amz-copy-source:/xx1/abc.jpg\r\n/testv/abc.jpg\r\n\r\n看来x-amz-copy-source 需要加入鉴权的	\N	\N	12	\N	3	3	5	4	2017-10-24 09:46:09.745277	2017-10-26 07:35:03.895416	2017-10-24	0	\N	\N	24	1	2	f	2017-10-24 13:38:42.595784
33	3	1	rgw超时，无法响应请求	@陈乐  rgw堆栈看非常乱 应该是踩内存导致锁结构破坏了，我先把堆栈保留下来。这问题还是第一次出现，不知道跟黎忠那块有没关系，等他改好之后再留意下	\N	1	17	5	3	3	5	0	2017-11-02 09:11:25.341203	2017-11-02 09:11:25.341203	2017-11-02	0	\N	\N	33	1	2	f	\N
62	7	1	任务分解1		\N	\N	19	\N	3	\N	5	2	2018-03-05 12:59:29.575307	2018-03-12 07:12:15.962752	2018-03-12	0	\N	61	61	2	5	f	\N
61	4	1	example	\N	\N	\N	17	\N	3	\N	5	3	2018-03-05 12:58:28.369002	2018-03-12 07:12:15.999709	2018-03-05	7	\N	\N	61	1	10	f	\N
67	3	1	监控mon的使用空间	mon 的空间使用情况是可以评估的，多出的部分需要给出合理解释。\r\n\r\n现场环境出现db猛涨的情况，一天增加了30GB。	\N	\N	17	\N	3	\N	5	0	2018-03-18 20:46:29.835988	2018-03-18 20:46:29.835988	2018-03-18	0	\N	\N	67	1	2	f	\N
68	3	1	如何判断服务器硬盘是否启用raid？	多块磁盘的时候，没有raid会怎么样？\r\nraid和controller的关系？	\N	10	17	5	3	\N	5	0	2018-03-25 13:18:38.691563	2018-03-25 13:18:38.691563	2018-03-25	0	\N	\N	68	1	2	f	\N
42	3	1	多版本同步删除null instance同步失败	测试方法：\r\n1，开启多版本，上传对象2次\r\n2，关闭多版本，上传同一对象一次\r\n3，删除null版本\r\n4，再次上传对象\r\n5，删除null版本\r\n\r\n这次slave zone删除null版本失败。	\N	\N	17	\N	3	\N	5	2	2017-11-23 14:04:58.11104	2017-11-24 19:49:00.637251	2017-11-23	0	\N	\N	42	1	2	f	\N
76	3	1	2018.6.19 （BI改造）	本周聚焦两件事：\r\n1，继续研发V5 demo\r\n2，招聘	\N	\N	17	5	3	\N	5	42	2018-06-19 06:49:59.288249	2019-04-28 07:30:40.817942	2018-06-19	0	\N	\N	76	1	2	f	\N
23	4	1	合入license功能	\N	\N	\N	17	\N	3	1	5	3	2017-10-23 12:58:52.68589	2018-01-18 07:31:48.96399	2017-10-23	0	\N	\N	23	1	2	f	\N
16	7	1	深交所需求痛点	深交所需要在北京，上海，深圳多地同步一些公告文件等，对同步的及时性有点要求，并且走的是公网。\r\n\r\n目前rgw同步是通知方式，但是通知可能出现丢失的情况。\r\n这时就得依赖于定时机制来获取data log。\r\n\r\n文件压缩传输是否有必要？	\N	1	17	5	3	1	5	1	2017-10-11 12:38:58.068347	2017-10-11 13:21:34.457975	2017-10-11	0	\N	\N	16	1	2	f	\N
71	7	1	2018.5.14	1，story合并代码 （重要不紧急）\r\n2，解决广发问题（重要紧急）\r\n3，3.1.5归档\r\n4，补充开工材料\r\n5，招聘发起面试	\N	7	19	5	3	\N	5	9	2018-05-14 06:39:42.818287	2018-06-08 08:49:18.796606	2018-05-14	0	\N	70	70	2	3	f	\N
26	6	1	object tag的操作方式	put_tag () {\r\n    bucket=/$1\r\n    resource=/$2\r\n    tagdata=$3\r\n    dateValue="`TZ=GMT date +'%a, %d %b %Y %H:%M:%S GMT'`"\r\n    stringToSign="PUT\\n\\napplication/x-www-form-urlencoded\\n${dateValue}\\n${bucket}${resource}?tagging"\r\n    echo $stringToSign\r\n    #stringToSign="PUT\\n\\n\\n${dateValue}\\n${bucket}${resource}?tagging"\r\n    signature=`echo -en ${stringToSign} | openssl sha1 -hmac ${Key} -binary | base64`\r\n    url="http://${host}${bucket}${resource}?tagging"\r\n    echo "put tag begin"\r\n    echo "curl -L -i -v  -X PUT -H "Date: ${dateValue}" -H "Authorization: AWS ${Id}:${signature}" "${url}" -d $tagdata"\r\n    #curl -L -i -v  -X PUT -H "Date: ${dateValue}" -H "Authorization: AWS ${Id}:${signature}" "${url}" --data-urlencode "$tagdata"\r\n    curl -L -i -v  -X PUT -H "Date: ${dateValue}" -H "Authorization: AWS ${Id}:${signature}" "${url}" -d "$tagdata"\r\n    echo "put tag end"\r\n}\r\n\r\nget_tag () {\r\n    bucket=/$1\r\n    resource=/$2\r\n    dateValue="`TZ=GMT date +'%a, %d %b %Y %H:%M:%S GMT'`"\r\n    stringToSign="GET\\n\\n\\n${dateValue}\\n${bucket}${resource}?tagging"\r\n    echo $stringToSign\r\n    #stringToSign="PUT\\n\\n\\n${dateValue}\\n${bucket}${resource}?tagging"\r\n    signature=`echo -en ${stringToSign} | openssl sha1 -hmac ${Key} -binary | base64`\r\n    url="http://${host}${bucket}${resource}?tagging"\r\n    echo "get tag begin"\r\n    echo "curl -L -X GET -H "Date: ${dateValue}" -H "Authorization: AWS ${Id}:${signature}" "${url}""\r\n    curl -L -X GET -H "Date: ${dateValue}" -H "Authorization: AWS ${Id}:${signature}" "${url}"\r\n    echo "get tag end"\r\n}	\N	1	17	5	3	\N	5	1	2017-10-25 15:19:26.420453	2017-10-25 15:19:43.147278	2017-10-25	0	\N	\N	26	1	2	f	\N
161	6	12	游戏力实操训练营（第二课 妈妈，我不行-如何培养孩子的自信）		\N	\N	17	\N	3	\N	6	2	2018-11-14 03:35:20.415264	2018-11-28 11:16:46.391461	2018-11-14	0	\N	\N	161	1	2	f	\N
77	3	1	2018.6.25	修复问题单，扫尾。\r\n讨论下一个版本的计划	\N	\N	17	\N	3	\N	5	3	2018-06-25 07:05:55.645817	2018-06-26 15:38:37.391201	2018-06-25	0	\N	\N	77	1	2	f	\N
28	8	1	usage log 在长期运行后会影响性能	理由是omap会持续增长？\r\n\r\nbilog，datalog那也得trim。	\N	\N	17	\N	3	\N	5	1	2017-10-27 07:30:48.569287	2017-10-27 07:43:06.455658	\N	0	\N	\N	28	1	2	f	\N
34	3	1	sqlite-rbd io failed not exit	马四  16:25:48\r\n谢锐 现在sqlite的进程，锁被强制释放后，读写报I/O错误，进程不会退出哦\r\n这样的话 rcm也不会重启db\r\n然后就一直没法访问的\r\n我记得之前说 报错的话  db好像会退出的吧、\r\n？\r\n谢锐  17:18:39\r\nI/O错误不一定会退出 读写因为锁出错才退出\r\n锁出错了还不退出么？\r\n马四  17:19:08\r\n嗯 现在就是锁被抢走了，日志里面报了I/O错误\r\n是的\r\n\r\n\r\n\r\n谢锐  17:28:59\r\n我看下sqlite的日志\r\n马四  17:30:16\r\n嗯 \r\n谢锐  17:53:16\r\n退出是在执行读写请求之间做锁检查的地方加的\r\n可能读写请求已经发下去了，这种读写出错，没有加assert\r\n马四  17:54:22\r\n额 这个地方能改吗\r\n谢锐  17:54:50\r\n我问下文达哈 如果sqlite无法处理底下的io错误 那可以直接退出 \r\n好像也没啥重试机制\r\n	\N	\N	4	\N	3	4	5	1	2017-11-08 15:38:29.586496	2017-11-13 11:55:40.783593	2017-11-08	0	\N	\N	34	1	2	f	\N
13	3	1	目录下的对象检索方式	比如test1目录下有文件iser.c iser.h\r\n\r\ncurl -XGET 172.18.0.151:9200/_search -d '{"query":{"match":{"name":"iser.c"}}}'\r\n{"took":2,"timed_out":false,"_shards":{"total":20,"successful":20,"failed":0},"hits":{"total":0,"max_score":null,"hits":[]}}\r\n\r\n[root@localhost ~]# curl -XGET 172.18.0.151:9200/_search -d '{"query":{"match":{"name":"test1"}}}'\r\n{"took":2,"timed_out":false,"_shards":{"total":20,"successful":20,"failed":0},"hits":{"total":0,"max_score":null,"hits":[]}}[root@localhost ~]# \r\n[root@localhost ~]# curl -XGET 172.18.0.151:9200/_search -d '{"query":{"match":{"name":"test1/"}}}'\r\n{"took":3,"timed_out":false,"_shards":{"total":20,"successful":20,"failed":0},"hits":{"total":1,"max_score":0.6931472,"hits":[{"_index":"rgw-china-95fdffb3","_type":"object","_id":"99c3ac9e-e654-4fd9-9f9f-4a68eb74240e.4147.1:test1/:null","_score":0.6931472,"_source":{"bucket":"xxx1","name":"test1\\/","instance":"","versioned_epoch":0,"owner":{"id":"nuser","display_name":"nuser"},"permissions":["nuser"],"meta":{"size":0,"mtime":"2017-09-30T09:20:15.014Z","content_type":"application\\/octet-stream","etag":"d41d8cd98f00b204e9800998ecf8427e","x-amz-date":"Sat, 30 Sep 2017 09:31:26 GMT"}}}]}}\r\n\r\n这样仍然搜索不到上述2文件\r\n\r\ncurl -XGET 172.18.0.151:9200/_search?q='name>test1'\r\n{"took":15,"timed_out":false,"_shards":{"total":20,"successful":20,"failed":0},"hits":{"total":4,"max_score":0.64433396,"hits":[{"_index":"rgw-china-95fdffb3","_type":"object","_id":"99c3ac9e-e654-4fd9-9f9f-4a68eb74240e.4147.1:test1/:null","_score":0.64433396,"_source":{"bucket":"xxx1","name":"test1\\/","instance":"","versioned_epoch":0,"owner":{"id":"nuser","display_name":"nuser"},"permissions":["nuser"],"meta":{"size":0,"mtime":"2017-09-30T09:20:15.014Z","content_type":"application\\/octet-stream","etag":"d41d8cd98f00b204e9800998ecf8427e","x-amz-date":"Sat, 30 Sep 2017 09:31:26 GMT"}}},{"_index":"rgw-china-95fdffb3","_type":"object","_id":"99c3ac9e-e654-4fd9-9f9f-4a68eb74240e.4147.1:test1/iser.c:null","_score":0.57601494,"_source":{"bucket":"xxx1","name":"test1\\/iser.c","instance":"","versioned_epoch":0,"owner":{"id":"nuser","display_name":"nuser"},"permissions":["nuser"],"meta":{"size":98245,"mtime":"2017-10-10T05:49:58.989Z","content_type":"text\\/plain","etag":"c9fde6ada0a9cd233791974050f0e97d","x-amz-date":"Tue, 10 Oct 2017 06:01:38 GMT"}}},{"_index":"rgw-china-95fdffb3","_type":"object","_id":"99c3ac9e-e654-4fd9-9f9f-4a68eb74240e.4147.1:test1/iser.h:null","_score":0.41360322,"_source":{"bucket":"xxx1","name":"test1\\/iser.h","instance":"","versioned_epoch":0,"owner":{"id":"nuser","display_name":"nuser"},"permissions":["nuser"],"meta":{"size":6966,"mtime":"2017-10-10T05:49:58.904Z","content_type":"text\\/plain","etag":"16063abbb467e965d425d3511f5bd5d9","x-amz-date":"Tue, 10 Oct 2017 06:01:38 GMT"}}},{"_index":"rgw-china-95fdffb3","_type":"object","_id":"99c3ac9e-e654-4fd9-9f9f-4a68eb74240e.4147.1:test1/pglog_assert.jpg:null","_score":0.1710554,"_source":{"bucket":"xxx1","name":"test1\\/pglog_assert.jpg","instance":"","versioned_epoch":0,"owner":{"id":"nuser","display_name":"nuser"},"permissions":["nuser"],"meta":{"size":341962,"mtime":"2017-09-30T09:20:24.052Z","content_type":"image\\/jpeg","etag":"9ee16c41e9a0babbe64b1ff80f774232","x-amz-date":"Sat, 30 Sep 2017 09:31:35 GMT"}}}]}}\r\n这种方式可以。	\N	1	11	5	3	1	5	7	2017-10-10 11:56:15.630012	2017-10-27 20:23:42.435698	2017-10-10	0	\N	\N	13	1	2	f	2017-10-27 20:23:42.435698
20	3	1	elastic search默认分词器无法支持文件后缀搜索	比如abc.jpg，搜索jpg无法找到，搜索abc也无法找到	\N	4	8	\N	3	3	5	8	2017-10-17 12:49:22.997701	2017-10-27 20:29:04.295855	2017-10-17	0	\N	\N	20	1	2	f	\N
36	7	1	支持bucket回滚到一个时间点	用法：用户根据审计日志，查看一个桶上的操作。\r\n可以根据这个来决定回滚到某个时间点。	\N	1	4	5	3	5	5	1	2017-11-14 09:39:46.650867	2017-11-15 15:37:21.058643	2017-11-14	0	\N	\N	36	1	2	f	\N
43	3	1	同步社区问题18885	http://tracker.ceph.com/issues/18885\r\n\r\nThis happens because the unlink_instance has a higher mtime than the del object operation (that happens later), so when squashing the ops we skip the second operations. The object removal on the target already happens, but we don't update the high marker when dealing with squashed entries.	\N	\N	17	\N	3	\N	5	0	2017-11-24 15:48:40.103839	2017-11-24 15:48:40.103839	2017-11-24	0	\N	\N	43	1	2	f	\N
29	3	1	多版本对象打tag，elastic search搜索不到		\N	4	8	5	3	3	5	16	2017-10-27 14:13:12.058884	2017-11-25 14:18:57.115087	2017-10-27	0	\N	\N	29	1	2	f	\N
35	3	1	统计没同步对象数量错误，实际完成同步，但显示有39对象未同步	统计方法有误，副本会合并bilog执行，所以ver不能准确反应实际数据差距	\N	\N	18	\N	3	3	5	1	2017-11-10 08:48:31.226888	2017-11-25 15:20:31.64143	2017-11-10	0	\N	\N	35	1	2	f	\N
44	3	1	多版本同步，slave zone在version suspend的时候，put请求仍然产生了新版本。	从当时现象看，slave zone的bucket version可能没有立即同步，但是这有关系么？\r\n\r\n在version suspend之后，null指向的对象是olh的。	\N	1	14	5	3	4	5	1	2017-11-27 14:09:58.643904	2017-11-27 14:11:56.0266	2017-11-27	0	\N	\N	44	1	2	f	2017-11-27 14:11:56.0266
45	8	1	覆盖写一个null instance会出现什么现象？	bilog会产生一个新版本么？产生的bilog又是怎么样的呢？	\N	1	17	\N	2	\N	5	0	2017-11-27 15:52:06.409453	2017-11-27 15:52:06.409453	\N	0	\N	\N	45	1	2	f	\N
40	3	1	多版本关闭之后出现残留对象 导致bucket 无法删除 delete	rgw_ldap.cc\t\r\nrevision #: 1 (deleted)\t2017/11/20 11:36:17\t\t\t\tnuser (nuser)\tnull\t\r\n\r\n测试步骤：\r\n1.创建一个名为bucket1的bucket；\r\n2.向该bucket上传一个对象深圳-123-.png；\r\n3.开启多版本再上传3个版本的深圳-123-.png对象；\r\n4.暂停bucket1的多版本；\r\n5.在数据管理界面bucket对应的文件列表中删除对象（不指定版本号）；\r\n6.进入多版本页面，删除所有版本的对象（指定版本号）；\r\n7.删除该bucket（bucket1）；	\N	5	4	\N	3	3	5	24	2017-11-20 11:53:46.13729	2017-11-27 21:08:30.687402	2017-11-20	0	\N	\N	40	1	2	f	\N
352	6	17	parser模块培训记录	入口：exec_simple_query\r\nNode和Oid是万物基类。\r\nQuery是核心，其中已经有了具体的table信息(RTE)，attr(Targetlist)信息。\r\n优化分为逻辑优化和物理优化，逻辑优化如上提子查询，条件下沉等。物理优化如动态规划，调整表连接顺序等。\r\n\r\n一个sql命令，可能包含多个sql语句。\r\n一个sql语句也可能解析为多个query。\r\n\r\nRTE有很多类型，不仅是表。\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2019-04-24 14:46:10.75585	2019-04-24 14:46:10.75585	2019-04-24	0	\N	\N	352	1	2	f	\N
41	3	1	多版本同步全量同步异常	测试步骤：\r\n1，关闭slave rgw\r\n2，创建bucket，开启多版本，上传对象2次\r\n3，关闭多版本，再次上传\r\n4，启动slave rgw\r\n\r\nslave zone同步失败：\r\nrgw_tag.h\t\r\nrevision #: 2 (current)\t2017/11/23 16:01:57\t"89acfb788b24ef60d7ad87fb3b9784cd"\t1012 bytes\tSTANDARD\tnuser (nuser)\tV2cNceDh.GYzB3Emf.F.ygb-a.Tvudc\t\r\nrevision #: 1\t2017/11/23 16:01:52\t"89acfb788b24ef60d7ad87fb3b9784cd"\t1012 bytes\tSTANDARD\tnuser (nuser)\tvhCkB3XAbibU91lLk2N1x9XRo.Em8al\t\r\n看不到null对象。	\N	\N	4	\N	3	\N	5	10	2017-11-23 13:54:58.686476	2017-12-17 12:18:54.48622	2017-11-23	0	\N	\N	41	1	2	f	\N
93	8	1	FileStore HashIndex的悬疑	HashIndex::list_by_hash_bitwise中有两种排序：\r\n1，按照CmpHexdigitStringBitwise给hash_prefixes排序\r\n2，按照cmp_bitwise过滤对象，cmp_bitwise过滤对象，其中重点是get_bitwise_key\r\n该函数中如何上述两种顺序不一样，可能出现一种情况：\r\n按照hash_prefixes顺序，object A在B前面，且A作为next结束一次遍历。\r\n再下一次遍历的时候A作为边界对象，虽然B会遍历到，但是不满足cmp_bitwise条件，无法加入到list结果中。\r\n\r\nCmpHexdigitStringBitwise\r\n在HashIndex::get_path_contents_by_hash_bitwise中，使用hash按字节反序(get_path_str).\r\ncmp_bitwise是按照bit反序。\r\n\r\n2B了....\r\nhash_prefixes定义中有CmpHexdigitStringBitwise\r\n会执行reverse_hexdigit_bits_string，完成按bit反序的逻辑。	\N	\N	17	\N	3	\N	5	5	2018-08-22 14:48:23.805734	2018-08-29 00:12:09.72623	\N	0	\N	\N	93	1	2	f	\N
48	3	1	双活环境，主备切换多次，period出现different，master创建bucket不同步	【操作步骤】\r\n1、创建双活环境；\r\n2、执行测试用例：metadata/data正在同步/同步完成时，挂master端或slave端rgw；\r\n3、执行主备切换多次；\r\n4、master端11.16上创建bucket；\r\n【预期结果】\r\n4、slave端同步成功，period信息状态same；\r\n【实际结果】\r\n4、slave端同步失败，查询同步状态出现period信息状态different；\r\n"period":\r\n{ "period_status": "different", "master_period": "b262af32-9fa0-4a1a-8e8c-a180a2342624", "local_period": "8b8f2a8a-e88e-404a-8371-ffabff0fa83c" }	\N	6	17	5	2	\N	5	2	2018-01-16 11:53:31.578011	2018-01-16 12:22:42.711736	2018-01-16	0	\N	\N	48	1	2	f	\N
49	9	1	在集群故障的时候，rgw可能卡住，集群恢复之后，需要手动重启rgw	rgw操作没有超时时间，请求异常的情况下，只能重启rgw。\r\n否则堆栈一直卡在那里，rgw无法响应请求	\N	1	17	\N	3	4	5	0	2018-01-17 09:28:48.122203	2018-01-17 09:28:48.122203	\N	0	\N	\N	49	1	2	f	\N
162	6	12	游戏力实操训练营（第三课 妈妈，我害怕- 如何让孩子勇敢）		\N	\N	17	\N	3	\N	6	3	2018-11-14 03:37:03.604227	2018-11-28 11:32:13.737019	2018-11-14	0	\N	\N	162	1	2	f	\N
50	7	1	完成多版本的bug回归验证	目的：\r\n1，完成工作任务\r\n2，整理多版本相关的bugfix，并列出具体原因，做一个多版本问题总结\r\n\r\n结果：\r\n1，完成bug验证\r\n2，邮件输出到MOS组。\r\n	\N	7	24	\N	3	\N	5	1	2018-01-18 07:36:35.726893	2018-01-19 08:27:37.255889	2018-01-18	0	\N	\N	50	1	2	f	2018-01-19 08:27:37.255889
51	7	1	完成快照文档写作，审视快照设计，以及相关问题修复	总结设计文档格式，写一个漂亮清晰的文档。	\N	7	24	5	3	\N	5	1	2018-01-19 08:29:03.963191	2018-01-19 20:53:45.349555	2018-01-19	0	\N	\N	51	1	2	f	2018-01-19 20:53:45.349555
70	7	1	2018.5	完成bucket规划优化，提供unorder list，bilog trim time功能。写出实现文档\r\nQos方案。\r\n安排调研，生命周期，policy等。考虑rgw以后的发展方向。\r\n分析清楚rgw的一致性方案\r\n调研tikv的region复制方案，raft如何应用于复制。\r\n搞清楚二阶段提交的本质。\r\n分析hash与region分区的利弊，以及hash的其他应用场景。\r\n简单阐述CAP，Base。\r\n	\N	\N	19	5	3	\N	5	6	2018-05-02 06:56:24.447876	2018-05-14 06:39:42.866728	2018-05-14	0	\N	\N	70	1	4	f	\N
4	3	1	rgw无法响应任何请求	nginx upstream的返回值都是499.\r\n客户端发起请求出现502错误，断点打在rgw_process 都没法到，日志级别调整后也看到处理请求。\r\n\r\n是跑在docker中的，但是rgw可以发送sync的请求到对端zone，并且能正常接收应答。\r\nFastCGI的Accept线程并未停止工作。\r\n\r\n需要更充分信息来定位。	\N	1	3	5	3	\N	5	35	2017-09-10 12:20:26.270494	2018-12-27 11:28:01.589632	2017-09-10	0	\N	\N	4	1	2	f	\N
72	7	1	2018.5.23	聚焦：\r\n1，auto trim实现\r\n2，sync from配置\r\n3，编译运行申威。	\N	7	19	5	3	4	5	1	2018-05-23 06:48:50.117551	2018-05-28 06:33:48.638744	2018-05-23	0	\N	\N	72	1	2	f	\N
73	7	1	2018.5.28	完成第二个迭代。\r\n\r\nauto trim，bilog auto trim。\r\n\r\n1，同步配置\r\n2，输出中广核升级可行性分析报告。	\N	\N	19	5	3	\N	5	5	2018-05-28 06:35:05.085179	2018-06-04 07:32:08.479373	2018-05-28	0	\N	\N	73	1	2	f	\N
110	7	1	2018.10.8	1,继续完善特性规格说明书\r\n2，定位双活和osd问题。	\N	\N	19	\N	3	\N	5	2	2018-10-08 08:12:55.925621	2018-10-08 15:10:07.048835	2018-10-08	0	\N	\N	110	1	2	f	\N
84	3	1	2018.7.30	1，V5.1.0版本 bugfix\r\n2，V5.2.0版本重新开工\r\n3，重整docker环境\r\n4，编写需求规格设计模板	\N	\N	17	\N	3	\N	5	1	2018-07-30 06:36:32.703774	2018-08-02 06:30:13.51887	2018-07-30	0	\N	\N	84	1	2	f	\N
74	7	1	2018.6.4	1,日志改进(邓颖聪)\r\n2，rgw v5方案初步设计\r\n2.1分析YIG是否满足要求\r\n\r\n3，ceph 元数据多版本以及cache解析	\N	7	19	5	3	\N	5	4	2018-06-04 07:37:48.476726	2018-06-05 13:38:22.227894	2018-06-04	0	\N	\N	74	1	2	f	\N
75	3	1	2018.6.12	面试周强和蓝盾的哥们	\N	\N	17	\N	3	\N	5	1	2018-06-14 06:48:21.474695	2018-06-14 07:13:05.251946	2018-06-14	0	\N	\N	75	1	2	f	\N
85	3	1	2018.8.6（研发体系）	1，解决V5.1.0的bug\r\n2，修复3.2.1遗留在5.1.0的问题\r\n3，协助完成V5.2.0的任务分解，并进一步审视技术方案\r\n4，编写s3tests用例，并完成s3tests框架的讲解，以及待改进。\r\n\r\n社区体系的玩法，建立一套可以远程协作的研发体系。\r\n每个版本集中开几次会议大讨论就可以了，找一个环境优美的地方。\r\n\r\n这里面有几个核心的地方:\r\n1,产品方向\r\n2，技术方案\r\n3，任务分解与分配\r\n4，基础平台，自动化测试，集成，代码合入等。\r\n5，bugfix，问题攻关\r\n	\N	\N	17	\N	3	\N	5	2	2018-08-06 07:00:00.903912	2018-08-07 17:22:46.612623	2018-08-06	0	\N	\N	85	1	2	f	\N
88	9	1	关于pg分裂		\N	\N	1	\N	3	\N	5	4	2018-08-06 15:13:50.972008	2018-08-10 07:02:56.758955	\N	0	\N	\N	88	1	2	f	\N
216	6	1	V6的思考(解耦)	能否去掉cls-rgw，rados提供三类接口满足各种需求：\r\n1，kv接口，支持批量key\r\n2，read/write接口\r\n3，watch/notify接口	\N	\N	17	\N	3	\N	5	21	2018-12-29 08:44:43.892638	2019-04-15 08:35:34.779857	2018-12-29	0	\N	\N	216	1	2	f	\N
52	3	1	ES 默认分词器文件名检索的问题	【简要描述】\r\nES通过“文件名称”检索，出现的问题归档记录；\r\n【系统版本】\r\nceph version 3.1.1-74-g16a17f7 (16a17f75508868d01ba0148c35e22955f3d1964c)\r\nsandstone-v3.1.1-installer.tar.gz.release.404\r\n【操作步骤】&【实际结果】\r\n1）中文全名搜索对象，匹配不准确；\r\n2）对于全英文字符名的对象，只能全名检索到对象；\r\n3）对于名为“英文”+“数字”的对象，只能全名检索到对象；\r\n4）对于名为“中文”+“英文”的对象，只能通过全名或者中文检索到对象；\r\n5）对于名为由“.”"_" 分割英文的对象，只能通过全名检索到对象；\r\n6）对象类型后缀名都是用'.'分割的，如果'.'前面是英文字母，则通过后缀名检索不到该对象；\r\neg:对象名为：2shenzhen.doc，通过doc检索不到该对象；shenzhen2.doc,通过doc可检索到该对象\r\n7）对于名为由“.”"_" 分割数字的对象，只能通过全名检索到对象；\r\n8）对于名为由“ ”“-”分割的对象，可以通过被符号分割前面的字段检索到对象；\r\n\r\n【预期结果】\r\n“文件名称”检索，匹配准确\r\nPS：记录跟踪	\N	4	18	5	2	\N	5	0	2018-01-19 10:23:17.921873	2018-01-19 10:23:17.921873	2018-01-19	0	\N	\N	52	1	2	f	\N
94	3	1	日志过滤算法	在一段时间内，如果日志第一次出现，则其概率是100%。\r\n随后概率递减。	\N	\N	17	\N	3	\N	5	0	2018-08-23 09:13:37.812582	2018-08-23 09:13:37.812582	2018-08-23	0	\N	\N	94	1	2	f	\N
53	3	1	/var/lib/ceph/bin/radosgw-admin sync status 查询失败	2018-01-19 17:45:12.832768 7f874089c9c0  0 error in read_id for object name: default : (2) No such file or directory\r\n2018-01-19 17:45:12.847812 7f874089c9c0  0 WARNING: can't generate connection for zone d3baa928-4274-4916-bf9c-dd8ec14de9d8 id ES-Sync: no endpoints defined\r\n2018-01-19 17:45:12.860538 7f874089c9c0  1 ERROR: msg->data.result=7\r\n2018-01-19 17:45:12.860612 7f874089c9c0  0 rgw meta sync: ERROR: failed to fetch mdlog info\r\n2018-01-19 17:45:12.862518 7f874089c9c0  1 ERROR: msg->data.result=7\r\n2018-01-19 17:45:12.862585 7f874089c9c0  0 ERROR: failed to fetch datalog info\r\n	\N	\N	17	\N	3	\N	5	0	2018-01-19 15:16:38.963078	2018-01-19 15:16:38.963078	2018-01-19	0	\N	\N	53	1	2	f	\N
54	7	1	合入license功能，处理快照，es问题，梳理es	输出es，元数据检索文档一篇。\r\n\r\n代码解读。\r\n\r\n	\N	7	19	5	3	\N	5	0	2018-01-22 08:09:36.659004	2018-01-22 08:09:36.659004	2018-01-22	0	\N	\N	54	1	2	f	\N
374	6	19	5.4 下周早餐安排	1，2只鸡\r\n2，一份牛排 + 牛奶\r\n3，一份水饺，可蒸 + 牛奶\r\n4，一份包子 + 牛奶\r\n5，一份鸡蛋饼\r\n6，红薯	\N	\N	17	\N	3	\N	5	0	2019-05-04 04:33:29.645523	2019-05-04 04:33:29.645523	2019-05-04	0	\N	\N	374	1	2	f	\N
56	8	1	如何配置网络使得docker容器可以访问宿主机的端口	docker容器可以ping宿主机的ip，但是却无法访问其端口\r\n\r\nsh-4.2# curl -XGET 172.17.0.1:9500/_all\r\ncurl: (7) Failed connect to 172.17.0.1:9500; No route to host\r\n	\N	8	17	\N	3	\N	5	0	2018-02-08 10:23:01.899129	2018-02-08 10:23:01.899129	\N	0	\N	\N	56	1	2	f	\N
57	7	1	2018.1计划	同步Qos控制，方案，以及实施。\r\n性能调测\r\nbugfix	2018-03-03	7	19	5	3	4	5	0	2018-02-26 07:24:13.179606	2018-02-26 07:24:13.179606	2018-02-26	0	\N	\N	57	1	2	f	\N
58	8	1	ldd能显示所有依赖的动态库吗？	在make -n中看到ceph-mon依赖于jemalloc，但是ldd看不到。\r\ncryptopp也是这样，看不到依赖关系。	\N	\N	17	\N	3	\N	5	1	2018-02-26 07:53:46.467598	2018-02-26 09:53:06.868812	\N	0	\N	\N	58	1	2	f	\N
60	4	1	容灾数据恢复	\N	\N	6	17	5	3	\N	5	1	2018-03-02 07:05:06.958516	2018-03-02 07:05:39.188102	2018-03-02	0	\N	\N	60	1	2	f	\N
65	8	1	bucket indexless的bucket可以启用多版本么？	这里面的关系是什么呢？	\N	\N	17	\N	3	\N	5	0	2018-03-09 11:56:26.8659	2018-03-09 11:56:26.8659	\N	0	\N	\N	65	1	2	f	\N
63	6	1	完成xx特性，文档更新	xxx	\N	\N	17	\N	3	\N	5	0	2018-03-05 13:02:25.538969	2018-03-05 13:02:25.538969	2018-03-05	0	\N	61	61	6	7	f	\N
66	7	1	2018-3-12 周计划	example	\N	\N	19	\N	3	\N	5	0	2018-03-12 07:12:15.87223	2018-03-12 07:12:15.87223	2018-03-12	0	\N	62	61	3	4	f	\N
69	9	1	osd scrub	ceph可配置scrub自动repair，并且可以支持超过多少对象error就不自动repair。\r\n\r\nscrub错误能自动repair的条件：\r\n1，存在auth的obj\r\n2，missing或inconsistent\r\n\r\n但是如果object没有缺失元数据，也没有read error，就有可能选错auth。\r\n\r\n比较奇怪的是scrub的时候，为啥没对比oi里面的digest与ScrubObject的digest？\r\n	\N	11	1	\N	3	\N	5	1	2018-04-11 08:26:31.344027	2018-04-11 08:31:07.806622	\N	0	\N	\N	69	1	2	f	\N
80	3	1	rgw 坑记录	1，测试性能时最好不要重复测同样对象，否则性能会差不少。\r\n可能是因为inode和空间重用，以及覆盖写带来额外的逻辑导致。追加写性能会好很多。但是追加写迟早也会做gc。\r\n\r\n2，使用dns来负载均衡有个问题，就是在rgw故障时，dns解析到新的ip需要一些时间。这种业务可能会中断。\r\n  er使用浮动ip则会快很多。	\N	\N	17	\N	3	\N	5	0	2018-07-11 08:56:46.897705	2018-07-11 08:56:46.897705	2018-07-11	0	\N	\N	80	1	2	f	\N
79	3	1	2018.7.10	本周工作事项：\r\n1，敦促3.2.1的转测\r\n2，3.2.1的回顾\r\n3，专利\r\n4，自评\r\n5，招聘\r\n6，3.1.6 双活fix合入\r\n7，5.1.0的gc修复\r\n8，讨论3.3.1计划\r\n	\N	\N	17	\N	3	\N	5	8	2018-07-10 06:44:32.585255	2018-07-16 13:00:28.183005	2018-07-10	0	\N	\N	79	1	2	f	\N
82	3	1	2018.7.23(V5.2.0需求分析，存储策略，异构集群)	本周工作计划：\r\n1，周2/3 出MOS5.1.0 beta版本\r\n2，辅助大家完成5.2.0的需求分析工作。\r\n3，完成一次rgw内部代码讲解。并输出材料\r\n4，完善专利交底书	\N	\N	17	\N	3	\N	5	9	2018-07-23 06:40:25.366499	2018-07-27 06:39:42.854278	2018-07-23	0	\N	\N	82	1	2	f	\N
81	3	1	2018.7.16	1，feature列表\r\n2，pbc\r\n3，专利\r\n4，v5.1.0基础版本\r\n5，招聘\r\n6，新员工计划	\N	\N	17	\N	3	\N	5	3	2018-07-16 09:11:56.162106	2018-07-17 14:55:34.443288	2018-07-16	0	\N	\N	81	1	2	f	\N
83	7	1	2018上半年工作总结	研发工作：\r\n1，开发桶快照功能\r\n2，合入license\r\n3，修复双活模块的bug\r\n4，开发多站点Qos特性\r\n5，支持bilog，datalog autotrim，减少bi数据规模\r\n6，支持bi backfill方式数据恢复，减少业务中断\r\n7，优化es zone索引使用。\r\n8，支持rgw单独编译，提高工作效率\r\n\r\n招聘工作：\r\n1，面试人数若干\r\n2，人数增加了3人\r\n\r\n支撑动作：\r\n1，参与广汽性能问题分析\r\n\r\n项目工作：\r\n1，上半年主要研发了3.1.5和3.2.1版本，3.2.1版本采用新的研发流程。\r\n2，周例会和每日站立会议运行起来。	\N	\N	19	\N	3	\N	5	1	2018-07-27 12:11:12.956472	2018-07-27 16:19:40.456865	2018-07-27	0	\N	\N	83	1	2	f	\N
86	9	1	ceph集群配置	1，控制pool和pg的数量，这个对于osd的内存使用量影响非常大。\r\n2，monitor在集群大时需单独部署。	\N	\N	1	\N	3	\N	5	1	2018-08-06 08:58:24.552573	2018-08-07 12:15:10.053017	\N	0	\N	\N	86	1	2	f	\N
78	3	1	多数据中心当前缺陷思考	1，同步状态不好管理，难以查询每个bucket的数据差异，同步监控方面也非常弱。\r\n2，es zone依赖于其他zone的ceph集群， 这样关系就没理清楚。\r\n   \r\n	\N	\N	17	\N	3	\N	5	3	2018-06-25 08:14:00.585079	2018-08-10 12:26:43.201799	2018-06-25	0	\N	\N	78	1	2	f	\N
87	3	1	奇怪的load average	top - 11:37:48 up 20 days, 20:59,  6 users,  load average: 212.61, 254.50, 336.13\r\nTasks: 594 total,   1 running, 593 sleeping,   0 stopped,   0 zombie\r\n%Cpu(s):  1.3 us,  0.6 sy,  0.0 ni, 93.2 id,  4.9 wa,  0.0 hi,  0.0 si,  0.0 st\r\nKiB Mem : 65759088 total,   349260 free, 62846768 used,  2563060 buff/cache\r\nKiB Swap: 23445500 total, 11722756 free, 11722744 used.  2130876 avail Mem\r\n\r\n这环境上有几个问题：\r\n1，奇怪的内存使用率\r\n2，系统盘超级大的压力\r\n3，load average巨大	\N	\N	17	\N	3	\N	5	0	2018-08-06 09:12:17.007588	2018-08-06 09:12:17.007588	2018-08-06	0	\N	\N	87	1	2	f	\N
92	3	1	8.20	1，从测试情况看，即便对象没达到数量也出现了分裂。\r\n是不是上次也出现了类似情况呢？ 搞清楚这个原因。	\N	\N	17	\N	3	\N	5	6	2018-08-20 07:15:15.699805	2018-08-24 07:35:04.334911	2018-08-20	0	\N	\N	92	1	2	f	\N
129	6	6	如何让一个产品稳定下来	1，梳理清楚代码逻辑，隔离相关影响，不能让代码彻底乱掉\r\n2，认真解决每个问题，不要让问题残留，多了必然乱掉	\N	\N	17	\N	3	\N	1	1	2018-10-22 06:41:55.459094	2018-12-04 13:12:10.88332	2018-10-22	0	\N	\N	129	1	2	f	\N
90	3	1	8.13	1，V5.1.0问题解决\r\n2，考虑海量小文件方案(下半年重点之一)。\r\n\r\n另外可能重点：\r\n1，rgw是否支持多集群？\r\n2，BI放入DB\r\n3，NFS支持	\N	\N	17	\N	3	\N	5	2	2018-08-14 06:40:59.431629	2018-08-17 16:11:13.523242	2018-08-14	0	\N	\N	90	1	2	f	\N
104	6	6	习惯	一个没有习惯的人，就像一个没有生活目标的人一样。生活在不知不觉中耗散。\r\n\r\n让我们良好的日常行为方式形成习惯，就可以减轻我们的负荷。\r\n阻碍习惯养成的2个隐患：\r\n1，没有计划，不做自我约束\r\n2，没有很好的分割我们的工作和生活。\r\n\r\n通常我们在热情高涨时制定一个日常行为指南，但是实际执行通常都有变化。\r\n比如某天精神不好，就不想早起，这样引起一系列连锁反应。\r\n\r\n热情高涨是短暂的，我们应该去寻求习惯背后的意义。\r\n我想养成每天早上7点起床锻炼身体的习惯，因为我真的渴望自己有良好的体质，有肌肉，还有良好的精神状态。\r\n为此我愿意牺牲晚上看手机，电影等不利于睡眠的习惯。\r\n\r\n我愿意养成每天整理知识的习惯，这是因为我真的热爱他们，我渴望自己变得更加睿智。\r\n\r\n持之以恒，这些行为方式就会成为习惯。\r\n\r\nh1. 习惯列表\r\n\r\n1，每天早上7点到8点之间做身体锻炼\r\n2，每天晚上8点-9点 做学习总结\r\n3，每天晚上9点之后，做心情梳理与家庭沟通，把不安的情绪给安放。\r\n   可以把不安情绪，担心的事件作为工作列表记录下来。\r\n4，在任何非常困的时间睡觉。	\N	\N	17	\N	3	\N	5	0	2018-10-06 19:24:55.198035	2018-10-06 19:24:55.198035	2018-10-06	0	\N	\N	104	1	2	f	\N
227	6	9	用人篇	用人德为先，无德则容易偏颇，狭隘。\r\n\r\n理性，有容，价值观正常积极。有责任感，能坦诚。	\N	\N	17	\N	3	\N	5	5	2019-01-06 21:26:11.564941	2019-03-07 10:08:52.522664	2019-01-06	0	\N	\N	227	1	2	f	\N
98	3	1	9.17	目前的疼点：\r\n1，恢复情况下的压力控制\r\n2，扩容对性能的影响（目前通过先扩osd，后修改crush的方式可以控制在几分钟内）\r\n3，海量文件\r\n4，单bucket的数据规模\r\n\r\n先把几个细活干了：\r\n1，整理产品的使用手册，运维手册。\r\n\r\n2，补充s3功能的自动化测试。\r\n   完善产品规格\r\n\r\n3，改进软件日志，以及运维工具。\r\n   admin工具改造。\r\n\r\n删除pool的影响还是比较大的，在数据量多的时候。\r\n\r\n	\N	\N	17	\N	3	\N	5	6	2018-09-17 08:57:17.082662	2018-09-21 07:47:22.313228	2018-09-17	0	\N	\N	98	1	2	f	\N
409	6	21	家用电器的知识准备	思考生活中哪些家用电器是自己所需，找到适合自己的那一款	\N	\N	17	\N	3	\N	6	1	2019-05-22 04:17:24.586946	2019-05-22 04:19:22.497968	2019-05-22	0	\N	\N	409	1	2	f	\N
95	7	1	8.27	1，继续解决5.1.0的问题\r\n2，提供专利材料\r\n3，招聘es的人？	\N	\N	19	\N	3	\N	5	7	2018-08-27 07:03:46.274373	2018-09-04 15:32:30.918697	2018-08-27	0	\N	\N	95	1	2	f	\N
100	6	1	积分式绩效管理法	研究积分式绩效管理法如何改进用于研发团队。\r\n\r\n一个现实的情况是有些任务，其他人无法胜任。这个可根据人的职级来。\r\n\r\n还有点执行困难在于任务有时并非提前确定的。不过这没关系，没任务积分低是合理的。\r\n\r\n按人天算，一个季度总分120。如果能完成交代的任务则得分为120.\r\n主动发现并完成bugfix，根据问题严重程度算积分。\r\n提出模块改进建议，执行按实际情况算得分。\r\n提出新的idea被采纳，实施根据贡献情况算得分。\r\n\r\n\r\n越靠近客户越可能产生想法，并获取积分。但是这跟人的性格等也有关系。\r\n也许有人做bugfix比去客户那更容易获得积分。\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2018-09-21 12:58:07.523309	2018-09-21 12:58:07.523309	2018-09-21	0	\N	\N	100	1	2	f	\N
298	6	18	IDEA-提供跨多云的对象存储服务	解决个人或中小企业使用公有云的风险，以及性能问题等。	\N	\N	17	\N	3	\N	5	4	2019-03-06 22:59:02.527448	2019-03-12 12:48:04.774186	2019-03-06	0	\N	\N	298	1	2	f	\N
96	3	1	9.5	主要任务修复V5.1.0遗留问题\r\n\r\n\r\n完善产品细节，osd增加类似iostat性能观察命令。\r\n	\N	\N	17	\N	3	\N	5	4	2018-09-05 06:59:22.749928	2018-09-07 14:46:42.903223	2018-09-05	0	\N	\N	96	1	2	f	\N
410	6	21	厨房相关		\N	\N	17	\N	3	\N	6	0	2019-05-22 04:20:00.893431	2019-05-22 04:20:00.893431	2019-05-22	0	\N	\N	410	1	2	f	\N
113	8	5	在货币超发的情况下，资产价格有可能下降吗？		\N	12	17	\N	3	\N	1	1	2018-10-08 19:34:34.960761	2018-10-09 05:56:33.82073	\N	0	\N	\N	113	1	2	f	\N
111	3	1	curl: Cannot assign requested address	同步rgw发出的curl请求都是失败的。\r\n\r\n\r\n登陆到服务器，使用netstat -an发现有很多TIME_WAIT。\r\n \r\n根据TCP协议定义的3次握手断开连接规定，发起socket主动关闭的一方，socket将进入TIME_WAIT状态,TIME_WAIT状态将持续2个MSL(Max Segment Lifetime)。TIME_WAIT状态下的socket不能被回收使用。TIME_WAIT累积起来会严重影响服务器性能，甚至耗尽可用的socket。	\N	\N	17	5	3	\N	5	2	2018-10-08 09:40:47.782426	2018-10-08 12:04:18.228599	2018-10-08	0	\N	\N	111	1	2	f	\N
97	3	1	9.10	1，督促完成5.2.0的开发工作\r\n2，支撑各种客户\r\n3，海量小文件与BI的技术预研\r\n\r\n4, 定位廖天伟先做各种持续小优化，邓和梁进行大特性开发。\r\n黎负责支撑对接。	\N	\N	17	\N	3	\N	5	4	2018-09-10 06:59:21.721306	2018-09-13 06:47:23.093735	2018-09-10	0	\N	\N	97	1	2	f	\N
411	6	21	卫生间相关		\N	\N	17	\N	3	\N	6	0	2019-05-22 04:20:15.564845	2019-05-22 04:20:15.564845	2019-05-22	0	\N	\N	411	1	2	f	\N
109	6	8	为何焦虑	我们会对未来不确定性，以及身上背负的压力而焦虑，你没看到大街上，地铁上都是焦虑的面孔么？\r\n安全感缺失，恐惧笼罩于生活。\r\n\r\n如果一个人能保持内心的纯然愉悦，外物触而不动，那说明这个人至少坚定了志向，明确了得失。\r\n一切看空的人只会变得淡然，但无法让人保持愉悦。\r\n\r\n很多人并不忧虑，但是只是他们对于眼下的境况保持一种乐观，但是他们并非努力提升，这种乐观是盲目的。\r\n	\N	\N	17	\N	3	\N	5	1	2018-10-08 05:58:38.958171	2018-10-09 19:08:30.218931	2018-10-08	0	\N	\N	109	1	2	f	\N
128	6	7	C++ auto	auto变量不是引用类型的，无法使用auto来修改原变量\r\n\r\n比如 for(auto i : vec) {\r\n       auto = 1;\r\n     }\r\n这样vec是不会有任何变化的	\N	\N	17	\N	3	\N	1	0	2018-10-20 09:16:24.79969	2018-10-20 09:16:24.79969	2018-10-20	0	\N	\N	128	1	2	f	\N
236	6	1	[idea] 将ceph改造为kv系统，支持关联key的事务，支持key的全量和增量同步	将ceph改造为kv系统，提供通用kv接口能力。\r\n比如支持value上的自增运算，支持cmp等。\r\n提供基于分表的事务。通过批量操作，提高效率。\r\nobject就是一个小的子库。里面有各种类型的kv。\r\n这些kv操作之间要求有事务保障。\r\n\r\n通用的不支持事务的kv系统存在的问题：\r\n1，不能很好的支持并发\r\n2，不支持多个关联key的修改\r\n\r\n传统数据库的强项在于sql。但是sql对于应用系统来说代价有点高。性能损耗大。\r\n\r\n抽象业务系统对于元数据保存的需求。	\N	\N	17	\N	3	\N	5	0	2019-01-18 05:43:13.911546	2019-01-18 05:43:13.911546	2019-01-18	0	\N	\N	236	1	2	f	\N
412	6	21	玄关相关		\N	\N	17	\N	3	\N	6	0	2019-05-22 04:20:35.371449	2019-05-22 04:20:35.371449	2019-05-22	0	\N	\N	412	1	2	f	\N
99	3	1	9.18(海量文件问题)	xfs在大量空洞时性能下降非常明显，非常奇怪的一点时，如果我申请非常多的8k文件，然后全部删除。\r\n这样为啥在文件系统还有空洞呢？ 无法自动合并这些空间，以便后续可以高效实用吗？\r\n\r\n另外通过该问题，暴露了我自身的一些问题：\r\n1，面对任何问题，都应该扑上去，问题就是经验啊\r\n2，linux基础薄弱，必须强化。\r\n3，bcache如果看磁盘没啥压力，那说明问题在调用栈上。\r\n调用栈不一定在应用软件，还有可能是在系统软件上。\r\n4，提供工具，快速分析每个osd节点的性能情况、\r\n	\N	\N	17	5	3	\N	5	0	2018-09-18 23:00:54.742419	2018-09-18 23:00:54.742419	2018-09-18	0	\N	\N	99	1	2	f	\N
91	3	1	大块读性能	磁盘使用direct方式随机读性能比非direct好\r\nfio -ioengine=sync -thread -iodepth=64 -group_reporting -bs=1M -filename=/dev/sdc -numjobs=64 -size=600G -rw=randread -runtime=300 -name=1M_random_read -norandommap\r\n\r\nfio -ioengine=sync -direct=1 -thread -iodepth=64 -group_reporting -bs=1M -filename=/dev/sdc -numjobs=64 -size=600G -rw=randread -runtime=300 -name=1M_random_read -norandommap\r\n\r\n但是如果增大预读，性能就接近了。\r\n[root@localhost ~]# cat /sys/block/sdc/queue/read_ahead_kb \r\n128\r\n[root@localhost ~]# fio -ioengine=sync -thread -iodepth=64 -group_reporting -bs=1M -filename=/dev/sdc -numjobs=64 -size=600G -rw=randread -runtime=300 -name=1M_random_read -norandommap\r\n1M_random_read: (g=0): rw=randread, bs=(R) 1024KiB-1024KiB, (W) 1024KiB-1024KiB, (T) 1024KiB-1024KiB, ioengine=sync, iodepth=64\r\n...\r\nfio-3.1\r\nStarting 64 threads\r\n^Cbs: 64 (f=64): [r(64)][1.3%][r=35.0MiB/s,w=0KiB/s][r=35,w=0 IOPS][eta 04m:56s]\r\n	\N	\N	17	\N	3	\N	5	4	2018-08-15 09:04:24.304176	2018-08-17 11:46:10.24061	2018-08-15	0	\N	\N	91	1	2	f	\N
101	3	1	9.25	1，考虑合并全局osd性能统计工具\r\n2，整理常用性能分析工具，以及分析套路。\r\n3，特性规格文档整理	\N	\N	17	\N	3	\N	5	1	2018-09-25 09:32:28.298942	2018-09-25 09:48:11.862598	2018-09-25	0	\N	\N	101	1	2	f	\N
166	6	7	关于share everything， share disk， share nothing	现在这种提法比较少见了，分布式系统基本都是share nothing架构的，也就是处理节点拥有独立的cpu，内存，磁盘等资源。\r\n\r\nhttps://www.jianshu.com/p/e4562faeef25	\N	\N	17	\N	3	\N	5	0	2018-11-15 09:32:10.866447	2018-11-15 09:32:10.866447	2018-11-15	0	\N	\N	166	1	2	f	\N
102	6	1	关于S3 V4鉴权	https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html\r\n\r\nV4鉴权有几个地方与V2不同：\r\n1，算法不同 \r\n2，可以支持对数据进行保护\r\n\r\nhttps://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-auth-using-authorization-header.html\r\n数据校验有2种情况，chunked和非chunk，这里chunked并非分片上传。\r\n请求过来之后，根据http header中携带的校验值与上一次读取数据计算出来的payload_hash进行比较。\r\n\r\naws4_auth_streaming_mode是什么概念？\r\n\r\nIf you choose chunked upload options, set the header value to STREAMING-AWS4-HMAC-SHA256-PAYLOAD.\r\n就是说chnked方式必须携带该Header	\N	\N	17	\N	3	\N	5	0	2018-09-26 12:30:54.052813	2018-09-26 12:30:54.052813	2018-09-26	0	\N	\N	102	1	2	f	\N
413	6	21	客厅相关		\N	\N	17	\N	3	\N	6	0	2019-05-22 04:20:53.040541	2019-05-22 04:20:53.040541	2019-05-22	0	\N	\N	413	1	2	f	\N
1003	6	9	给自己定个目标-功成身退	45岁之前功成的标准-500万，还完贷款，并且结余200万现金。\r\n实现途径：\r\n1，通过技术提升，找到年薪120万+的工作。\r\n2，做成一个项目并套现。\r\n\r\n练功就得练到功成。\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	1	2022-01-20 06:46:43.065501	2022-01-20 06:51:54.984876	2022-01-20	0	\N	\N	1003	1	2	f	\N
105	6	8	中国人的思想观念	根子在于什么？\r\n在于政治形态。\r\n\r\n缺乏完全的人格尊严，没有人格平等的观念\r\n骨子内内在的等级观念\r\n没有内在的民主自由的能力\r\n培养的都是贪婪，软弱，恐惧的个体。\r\n\r\n没有完整的人哪有什么百家争鸣。\r\n控制和弱化公民。\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2018-10-06 21:35:53.648936	2018-10-06 21:35:53.648936	2018-10-06	0	\N	\N	105	1	2	f	\N
167	6	4	Veritas Cognitive Object Storage	法规遵从性保证: Regulatory compliance assurance	\N	\N	17	\N	3	\N	5	1	2018-11-15 13:26:05.023975	2018-11-15 16:25:30.119834	2018-11-15	0	\N	\N	167	1	2	f	\N
414	6	21	主卧相关		\N	\N	17	\N	3	\N	6	0	2019-05-22 04:21:07.414725	2019-05-22 04:21:07.414725	2019-05-22	0	\N	\N	414	1	2	f	\N
168	6	10	华为存储产品	了解华为的各种存储产品	\N	\N	17	\N	3	\N	5	1	2018-11-15 16:51:31.233883	2018-11-15 16:51:42.201638	2018-11-15	0	\N	\N	168	1	2	f	\N
112	8	5	在外汇严格管制的情况下，外资如何出逃？		\N	12	17	\N	3	\N	1	2	2018-10-08 19:33:55.071188	2018-10-08 19:48:06.71412	\N	0	\N	\N	112	1	2	f	\N
114	6	6	认真的态度	人如果做事情没有认真的精神，就缺了点意思。\r\n\r\n没有认真的精神，事情就做得比较粗糙，不追求极致，做出的事就缺了点精神。\r\n\r\n一桩事就是一桩事，要不不做，要么就做出水平。\r\n\r\nWhen a task is once begun never leave it till it’s done. Be the labor, great or small, do it well or not at all.	\N	\N	17	\N	3	\N	5	1	2018-10-09 18:49:03.389057	2018-10-09 19:05:49.014813	2018-10-09	0	\N	\N	114	1	2	f	\N
415	6	21	次卧相关		\N	\N	17	\N	3	\N	6	0	2019-05-22 04:21:20.121161	2019-05-22 04:21:20.121161	2019-05-22	0	\N	\N	415	1	2	f	\N
416	6	21	儿童房相关		\N	\N	17	\N	3	\N	6	0	2019-05-22 04:21:40.14616	2019-05-22 04:21:40.14616	2019-05-22	0	\N	\N	416	1	2	f	\N
117	6	9	如何有效的聚餐，聚餐时该如何交流？		\N	\N	17	\N	3	\N	5	0	2018-10-12 06:49:33.36202	2018-10-12 06:49:33.36202	2018-10-12	0	\N	\N	117	1	2	f	\N
121	3	1	filestore目录预分裂问题	pg_num  320\r\n\r\nhex: 140\r\n\r\nseed + 320\r\nseed: 1  001  141 281 3C1 501 641 781 8C1 A01 B41 C81 DC1 F01 \r\n \r\n给出一个函数，计算hash值情况，然后创建pg。 可提供参数，允许pool支持提前创建，这样可加快实际执行速度。\r\n参数限制预创建的目录总数，这样就基本可以控制一个pool的对象总数。	\N	\N	17	\N	3	\N	5	6	2018-10-16 09:45:25.556259	2018-10-19 07:43:08.175809	2018-10-16	0	\N	\N	121	1	2	f	\N
130	3	1	2018.10.22	1，完成bugfix\r\n2，完成规格文档\r\n3，完成bugfix合入\r\n\r\n\r\n1，调研分布式存储的未来\r\n2，调研分布式DB解决BI限制。	\N	\N	17	\N	3	\N	1	1	2018-10-22 06:44:26.716621	2018-10-22 11:30:09.241771	2018-10-22	0	\N	\N	130	1	2	f	\N
89	3	1	rgw缺陷记录	ceph rgw存在如下问题：\r\n\r\n1. BI使用rados对象保存，不支持增量恢复，在故障恢复时影响可用性 （使用backfill恢复机制后暂时得到缓解，deep-scrub同样有巨大影响）\r\n\r\n2. 不能很好的支持bucket跨故障域和多集群,扩展性受限。 异构集群，冷热pool等。\r\n\r\n    bucket与pool绑定，在扩展性和使用的灵活性上存在限制。\r\n\r\n3. 海量小文件直接使用rados存储代价太大。使用SSD缓存文件系统元数据之后，仍然饱受FileStore目录分裂的问题困扰。\r\n\r\n4，多版本，multisite等特性复杂度不合适（非常重要，这决定了后续大量特性开发的复杂度）\r\n\r\n5，无法支持高效的list操作\r\n\r\n6，rgw put写放大，尤其是在多版本情况下。\r\n\r\n7，nginx与rgw之间的链路出现问题，nginx无法正常upstream，一直报499错误\r\n\r\n8，双活同步仍然存在卡住的问题\r\n\r\n9，ES搜索结果不确定的问题。\r\n\r\n10，NFS对接仍然各种问题，尤其是在多版本下，会产生各种中级数据。	\N	\N	17	\N	3	\N	5	3	2018-08-08 06:40:10.59768	2018-10-11 13:00:59.977732	2018-08-08	0	\N	\N	89	1	2	f	\N
417	6	21	书房相关		\N	\N	17	\N	3	\N	6	0	2019-05-22 04:21:54.150944	2019-05-22 04:21:54.150944	2019-05-22	0	\N	\N	417	1	2	f	\N
123	3	1	在生命周期转移时，如果有客户端写入新的对象，则存在新的对象被lc覆盖的情况	这显然是不合适的，我今天更新了一个对象，结果后台lc运行用一个老对象覆盖了新的。\r\n\r\n在生命周期完成数据转移，更新bi的时候应该对时间进行检查，如果对象已经更新，则不应该执行覆盖操作。\r\n这时生命周期转移应该失败，且主动把转移的版本数据丢入gc中。	\N	\N	17	\N	3	\N	5	0	2018-10-17 12:09:15.790019	2018-10-17 12:09:15.790019	2018-10-17	0	\N	\N	123	1	2	f	\N
118	6	6	一个人需了解的三个问题	第一个：你想到哪里？\r\n      描述越清晰说明目标越明确，思考的越多。\r\n\r\n七个习惯第一条就是积极主动，但是积极主动必须解决动机问题。积极主动背后是有原因的。\r\n有哪种没有明确目标却非常成功的人吗？存在没有明确目标却能积极主动的人吗？\r\n\r\n就像旅途一样，有些人在一路闲逛，有的人迷恋某处风景，当然不好说好坏，但是肯定这些人都无法走得很远。\r\n无法走得很远，对于一个领域而言，就是无法开拓新局面，也就不会成为最顶尖的那批人。\r\n\r\n\r\n第二个：你的能力支撑你到哪里吗？你的计划是什么？\r\n\r\n第三个：你是如何行动的？	\N	\N	17	\N	3	\N	5	2	2018-10-12 07:47:14.19471	2018-10-12 14:33:39.74926	2018-10-12	0	\N	\N	118	1	2	f	\N
119	6	1	osd满之后，修改pg数量的办法	1，修改/var/lib/ceph/etc/ceph/ceph.conf,在osd配置段加上配置项，并重启osd\r\nosd_backfill_full_ratio = 0.98 \r\n2，增加pg数量\r\n这个数据只能慢慢加，每次一个osd增加的pg数量不超过32\r\n/var/lib/ceph/bin/ceph osd pool set zone01.rgw.bucket.data pg_num 608\r\n/var/lib/ceph/bin/ceph osd pool set zone01.rgw.bucket.data pg_num 1088\r\n/var/lib/ceph/bin/ceph osd pool set zone01.rgw.bucket.data pg_num 1568\r\n/var/lib/ceph/bin/ceph osd pool set zone01.rgw.bucket.data pg_num 2048\r\n\r\n3，设置pgp_num\r\n\r\n/var/lib/ceph/bin/ceph osd pool set zone01.rgw.bucket.data pgp_num 2048	\N	\N	17	\N	3	\N	5	0	2018-10-13 08:57:32.354429	2018-10-13 08:57:32.354429	2018-10-13	0	\N	\N	119	1	2	f	\N
150	3	1	rgw 启动过程中 遇到register watch失败，在realm reload时 unwatch core掉	2018-11-09 21:28:15.154643 7fb4b93fe700 -1 *** Caught signal (Segmentation fault) **\r\n in thread 7fb4b93fe700 thread_name:safe_timer\r\n\r\n SandStone MOS V5.2.0 (aa96edc274de4f07e2d76b1df02d67173ba6c7d7)\r\n 1: (()+0x5e54c2) [0x7fb5037094c2]\r\n 2: (()+0xf5e0) [0x7fb50265d5e0]\r\n 3: (std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string const&)+0x18) [0x7fb502200f98]\r\n 4: (()+0x9cc4b) [0x7fb4f84aac4b]\r\n 5: (()+0x98b2f) [0x7fb4f84a6b2f]\r\n 6: (RGWRados::unwatch(unsigned long)+0x1c) [0x7fb50356349c]\r\n 7: (RGWRados::finalize_watch()+0x38) [0x7fb50356bff8]\r\n 8: (RGWRados::finalize()+0x6f9) [0x7fb5035ba1a9]\r\n 9: (RGWStoreManager::close_storage(RGWRados*)+0xf) [0x7fb5035662af]\r\n 10: (RGWRealmReloader::reload()+0x195) [0x7fb5034d4225]\r\n 11: (Context::complete(int)+0x9) [0x55646844aa79]\r\n 12: (SafeTimer::timer_thread()+0xec) [0x7fb5038e563c]\r\n 13: (SafeTimerThread::entry()+0xd) [0x7fb5038e6fdd]\r\n 14: (()+0x7e25) [0x7fb502655e25]\r\n 15: (clone()+0x6d) [0x7fb501c6134d]\r\n NOTE: a copy of the executable, or `objdump -rdS <executable>` is needed to interpret this.\r\n	\N	\N	17	\N	3	\N	5	1	2018-11-10 14:45:20.412721	2018-11-10 14:45:35.151491	2018-11-10	0	\N	\N	150	1	2	f	\N
124	3	1	rgw后端总是启用多版本的思考	bucket对外展示可以是非多版本的，但是内部实现是多版本的。\r\n\r\n使用多版本可解决并发相关的问题。这与我们按照时间来决定对象的新旧一样重要。\r\n尤其是内部操作与用户操作的并发场景下。\r\n\r\n比如小文件合并场景，如果正在扫描合并的文件被客户端修改，或者删除如何处理呢？\r\n\r\n但是当最终文件合并 与 生命周期淘汰，转移，CDP。\r\n\r\nGC机制为读写不一致提供了缓冲，假设我正准备读一个对象，这时被其他人删除了。但是删除是丢给gc的，所以没那么快就被干掉。\r\n于是仍然可以读取数据。这点非常重要，否则容易出现对象存在，但是没有数据的情况。\r\n\r\n假设后端使用64个线程运行任务。\r\n	\N	\N	17	\N	3	\N	5	0	2018-10-17 12:48:00.298409	2018-10-17 12:48:00.298409	2018-10-17	0	\N	\N	124	1	2	f	\N
120	3	1	2018.10.15	本周整体计划:\r\n1，完成5.2.0开发工作\r\n2，搞一次聚餐\r\n3，抽空讨论下一个版本的安排\r\n4，讨论rgw未来发展\r\n\r\n\r\n个人：\r\n1，优化rgw同步带宽显示\r\n\r\n个人能力：\r\n1，具备整体软件设计能力。\r\n2，具备带领小规模团队的能力，能够理清事和人。\r\n3，具备优秀的件开发能力\r\n\r\n这些都需要方法支持\r\n	\N	\N	17	\N	3	\N	5	1	2018-10-15 07:04:37.810455	2018-10-18 07:11:08.041753	2018-10-15	0	\N	\N	120	1	2	f	\N
153	3	1	linux 7.5 解决了拔盘D状态的问题。		\N	\N	17	\N	3	\N	5	0	2018-11-11 15:24:10.572789	2018-11-11 15:24:10.572789	2018-11-11	0	\N	\N	153	1	2	f	\N
155	8	7	关于软件架构		\N	\N	17	\N	3	\N	5	11	2018-11-11 15:28:05.587741	2020-08-20 06:20:35.644276	\N	0	\N	\N	155	1	2	f	\N
418	6	21	生活阳台相关		\N	\N	17	\N	3	\N	6	0	2019-05-22 04:22:24.11838	2019-05-22 04:22:24.11838	2019-05-22	0	\N	\N	418	1	2	f	\N
1004	6	7	SSDR16 顺序执行的本质	时间就是顺序执行。\r\n时间并非因果，读写才是严格因果。\r\n依赖是使用\r\n组成与包含关系\r\n引用关系	\N	\N	17	\N	3	\N	5	1	2022-01-21 11:38:08.165102	2022-03-19 06:51:09.693338	2022-01-21	0	\N	\N	1004	1	2	f	\N
169	8	10	对象存储与大数据会有关系么	大数据其数据也是非结构化数据，如文件形式。使用对象存储是否有竞争力呢？	\N	\N	17	\N	3	\N	5	1	2018-11-15 17:34:11.73656	2018-11-15 17:55:37.489844	\N	0	\N	\N	169	1	2	f	\N
366	7	17	Beas对于内存和string使用的封装	BEAS架构思考：\r\nbeas的实现除了将beas功能内置为pg的子模块内，还有一种可能是将beas作为外部，内部把pg包住。	\N	\N	19	\N	3	\N	5	2	2019-04-28 13:59:25.652696	2019-05-07 14:56:02.802274	2019-04-28	100	\N	\N	366	1	2	f	\N
170	8	10	非机构化数据存储场景		\N	\N	17	\N	3	\N	5	0	2018-11-15 18:14:31.025185	2018-11-15 18:14:31.025185	\N	0	\N	\N	170	1	2	f	\N
419	6	21	水电改造		\N	\N	17	\N	3	\N	6	0	2019-05-22 04:22:46.342071	2019-05-22 04:22:46.342071	2019-05-22	0	\N	\N	419	1	2	f	\N
152	6	8	不要在自己状态不佳的时候，做重大决定或深度思考	状态不好的时候，需要休息。\r\n\r\n世界是逻辑的，不管政治还是经济。当然人总是身处某些环境下。\r\n我们总有选择，你要做的就是看清真相，然后做合适选择。\r\n\r\n不需悲观，更不需气馁，甚至逃避。\r\n\r\n状态不好就休息，做做自己喜欢的事。将自己隐藏起来修复。	\N	\N	17	\N	3	\N	5	0	2018-11-11 14:57:20.767712	2018-11-11 14:57:20.767712	2018-11-11	0	\N	\N	152	1	2	f	\N
125	3	1	hash数据机构的限制	hash结构排序不方便，但是并发性比较好。\r\n\r\n如果后续采用分布式数据库存放元数据，还合适使用hash结构么？\r\n应该是没问题的，每个hash shard搞成一个子表。rados用来存bi的问题核心在于其只支持整表恢复。\r\n\r\n这是io被卡住的核心，另外目前的同步代码依赖于bucket shard机制，这里彻底改动会比较大。	\N	\N	17	\N	3	\N	5	0	2018-10-17 12:53:05.755158	2018-10-17 12:53:05.755158	2018-10-17	0	\N	\N	125	1	2	f	\N
137	6	5	政治的本质是什么？		\N	\N	17	\N	3	\N	5	5	2018-10-26 06:28:48.692014	2021-02-20 18:57:51.277355	2018-10-26	0	\N	\N	137	1	2	f	\N
126	3	1	多站点之间的数据分发	分发有三种实现方式：\r\n1，get请求发到一个zone，如果本地没数据，自动先去master zone读取数据，如果仍然读取不到则去其他所有zone遍历获取对象。\r\n2，需要异地获取的数据，都汇聚到master zone， get请求发到一个zone，如果本地没有，则去master zone拉取，如果master zone没有，返回404.\r\n3，应用自己根据用户的地域属性，在本地zone读取不到数据时，调用底层提供的copy命令从所属zone拷贝数据到本地zone。\r\n\r\n我们不推荐使用1，考虑到后续分支机构越来越多，遍历的跨地域访问会给整个系统的可用性造成影响。\r\n推荐方式2.3  该方案需进一步内部讨论 @邱尚高 @冯国毅 \r\n\r\n另外支持：\r\n1，支持配置user的所有bucket是否在zone之间同步。\r\n2，支持配置bucket是否在zone之间同步。\r\n3，支持在不同zone，以及相同或不同bucket之间copy对象。\r\n4，支持本地zone读取不到数据，去master zone读取数据。	\N	\N	17	\N	3	\N	1	0	2018-10-18 18:39:14.226232	2018-10-18 18:39:14.226232	2018-10-18	0	\N	\N	126	1	2	f	\N
158	6	1	S3协议	S3有哪些缺点：修改metadata需携带数据部分？\r\n\r\nACL不支持继承，需使用policy实现更细的权限控制。	\N	\N	17	\N	3	\N	5	0	2018-11-13 08:35:28.584143	2018-11-13 08:35:28.584143	2018-11-13	0	\N	\N	158	1	2	f	\N
127	3	1	多数据中心mdlog同步不停输出日志相关分析	ReadSyncStatus优先读取mdlog.sync-status,获取当前同步的realm epoch以及period信息。\r\n随后通过for循环获取每个shard的同步位置。\r\n\r\n注意如果是master，是获取不到信息的，但是不代表其中没有内容。\r\n\r\n通过gdb发现，mdlog_info中是realm为1的period！！！！\r\n这是没问题的，过渡到下一个period靠的是MetaSyncCR。在过渡到下一个period的时候，如果realm发生变化，应该重置marker。\r\nrealm变化其实也就是period id发生变化了。\r\n\r\nbilog_not 对于es zone无效，那么会不会因为这个导致bilog无法清理呢？\r\n不会实现原理不一样，bilog trim没有使用RGWBucketSyncStatusManager\r\n\r\n\r\n\r\nperiod history是如何管理的呢？\r\n\r\n还发现一个非常严重的bug：es的全量同步居然一直没有结束！！！\r\n可能是因为修改了es zone的num shard导致的。	\N	\N	17	\N	3	\N	1	2	2018-10-19 20:34:34.59584	2018-10-20 09:44:24.233686	2018-10-19	0	\N	\N	127	1	2	f	\N
131	7	1	王路稳面试	0，自我介绍\r\n1，使用场景介绍\r\n2，做了哪些修改，开发。如何同步社区修改\r\n3，维护中遇到的问题，性能问题的排查\r\n4，rbd和rgw缺陷的思考\r\n5，对公司看法，以及工作计划\r\n\r\n记住只问不答，不讨论。不说明我们做了什么。\r\n不需要为面试人设计问题，只需明确我们的招聘需求。\r\n\r\n需求：\r\n1，运维人员，能定位ceph，rgw的问题，linux环境以及性能问题。\r\n2，开发人员，开发具体特性，需要对rgw具体特性细节比较熟悉	\N	\N	19	\N	3	\N	1	0	2018-10-22 16:46:59.019733	2018-10-22 16:46:59.019733	2018-10-22	0	\N	\N	131	1	2	f	\N
132	9	1	pg均衡度，osd full默认值	集群full之后，可能需要调整2个参数：\r\n\r\n1，mos_osd_full_ratio\r\n\r\n默认值0.95，该参数会影响osdmap fullflag，osdmap中标记满之后，rados客户端不会发送写请求到osd。\r\n\r\n2，osd_failsafe_full_ratio\r\n\r\n默认值0.97,达到这个ratio之后，osd上无法执行读写操作\r\n\r\n3，osd_backfill_full_ratio\r\n\r\n默认值0.85,这个影响osd做backfill。\r\n\r\n默认值太高，操作风险非常高，可适当降低点。\r\n	\N	\N	1	\N	3	\N	5	0	2018-10-23 07:49:22.381413	2018-10-23 07:49:22.381413	\N	0	\N	\N	132	1	2	f	\N
133	8	10	私有云会长期存在么	从产品形态来说，私有云失去了云最大的特征，就是弹性扩展，以及高效率的统一运维。\r\n企业内部使用各种私有云，其数据仍然是割裂的。\r\n\r\n私有云存在的基础：\r\n1，管控数据\r\n  数据是受管控的，不用担心被公有云公司控制，比如公有云公司倒闭，或恶意陷害，以及各种捆绑销售等。\r\n\r\n2，数据安全\r\n  这里并非是网络安全等，毫无疑问，公有云在技术积累上更有优势，这里说的安全是指数据泄露的风险。\r\n\r\n3，政策推动\r\n  政策推动的项目	\N	\N	17	\N	3	\N	5	4	2018-10-23 08:52:30.550619	2019-02-10 23:03:04.394143	\N	0	\N	\N	133	1	2	f	\N
122	6	9	管理的理解	事：\r\n1，产品整体架构\r\n效率的最终体现，而且会限制公司的发展。\r\n\r\n2，产品的大技术方案\r\n这些都最终决定了事做的怎么样，产品的好坏。\r\n不可不深思熟虑啊，不能仅仅是满足功能，那样无法看到问题的本质。\r\n\r\n3，一些可能细节的遗漏，思考的全面性，严密性\r\n这可能导致一个项目的失败。\r\n\r\n4，沟通\r\n沟通不畅导致失败的例子简直到处都是。即便别人理解你字面的意思，但不一定了解背后的深意，这通常是分歧的根因。\r\n信息不流畅，则可能犯各种错误\r\n\r\n人：\r\n1，了解人\r\n这个非常深奥，且需要经验\r\n2，使用人\r\n\r\n\r\n制度机器：\r\n这是核心，没有强大的制度，就没法建立根本的优势。\r\n但是仅有制度，没有优秀的人也是白搭。	\N	\N	17	\N	3	\N	5	2	2018-10-17 09:25:35.810914	2019-04-28 14:19:36.41142	2018-10-17	0	\N	\N	122	1	2	f	\N
136	6	6	一些真相	1，修身养性，让自己变得有趣变得丰富明显比追逐欲望有意思\r\n2，起因，经过至少与结果同样重要\r\n3，关注结果并不会让人成功\r\n4，80%的人没有明确目标，80%的人缺乏计划，80%没有执行。最终成功的概率只有8%。刨除一些缺乏天赋的，一些意外中断的，再加一些缺乏运气的。\r\n在一个领域内能推动进步的人也许只占了万分之一或更低。而一个领域的主导权就掌握在这批人的手上。\r\n5，年薪千万的工作总需要人做\r\n6，一眼看穿事物本质的人与花几年才看清本质的人命运自然不一样。\r\n7，当我寻找完所有人能依赖的动力之后，发现理性本身就是最好的动力。	\N	\N	17	\N	3	\N	5	1	2018-10-26 06:08:38.544324	2018-10-26 06:13:31.689303	2018-10-26	0	\N	\N	136	1	2	f	\N
134	3	1	10.24	1，处理一个故障域不可用，导致其他故障域不可用问题\r\n2，处理双活同步，最终少同步数据的问题\r\n3，处理上传大对象，可能导致超时的问题	\N	\N	17	\N	3	\N	5	5	2018-10-24 12:44:53.255718	2018-10-27 07:52:33.892075	2018-10-24	0	\N	\N	134	1	2	f	\N
420	6	21	灯具选择		\N	\N	17	\N	3	\N	6	0	2019-05-22 04:23:09.787663	2019-05-22 04:23:09.787663	2019-05-22	0	\N	\N	420	1	2	f	\N
141	6	1	5.2.0发布事宜	1，确定问题单状态\r\n2，输出版本的release notes\r\n3，完成文档刷新\r\n\r\n	\N	\N	17	\N	3	\N	5	2	2018-10-31 08:11:13.653304	2018-11-09 07:08:27.021977	2018-10-31	0	\N	\N	141	1	2	f	\N
369	6	7	设计机器	1，定义问题规模，并理解问题本质\r\n2，对问题涉及的各方面进行分解->模块或组件\r\n3，对每个模块或组件进行抽象，并了解其发展变化的可能性，软件生命周期内可能的大变化。\r\n4，关键路径的核心算法\r\n5，理解现有系统，现有系统的抽象，并加以运用。\r\n6，分析DFx，以及对现有模块产生的影响	\N	\N	17	\N	3	\N	5	3	2019-04-28 17:17:56.261464	2019-08-23 06:59:26.152922	2019-04-28	0	\N	\N	369	1	2	f	\N
156	8	1	hash结构下提升系统可用性	ceph在可用性上最头疼的问题就是一旦有部分节点故障，则整个系统可用性都是最差的情况。\r\n这就是hash的短板。\r\n\r\n能否在对象存储系统中，通过其他技术手段提升系统可用性。\r\n比如一个bi对象正在恢复，系统其实应该在非常短的时间内就能确定该状态。\r\n这时可暂停该对象的写入，与此同时可使用其他对象顶上？\r\n\r\n比如ceph的bi对象返回EBUSY的错误，或者对象等于min size的情况下，可读不可写。\r\n这时可使用另一对象来写入。完成之后后端进行合并操作。或可设置最多2-3层的故障兼容处理。\r\n\r\n值得一试。另ceph在5副本的时候，如果只有1副本故障，有必要限制写入么？	\N	\N	17	\N	3	\N	5	0	2018-11-12 07:07:13.816009	2018-11-12 07:07:13.816009	\N	0	\N	\N	156	1	2	f	\N
154	3	1	海量小文件问题，xfs 碎片整理，内存占用等问题	1，在海量小文件时，xfs可能出现大量碎片，为了分配空间，可能出现效率极低，cpu占用非常高的情况\r\n2，xfs如果attr等比较多，可能吃掉很多内存，但是这部分内存并没有详细统计在meminfo中，造成内存不知不觉被吃掉的情况。	\N	\N	17	\N	3	\N	5	2	2018-11-11 15:26:50.49892	2019-03-15 16:56:05.103095	2018-11-11	0	\N	\N	154	1	2	f	\N
159	6	1	双活同步的http请求	注意 双活同步的请求都是使用system用户发出的\r\n\r\n全量同步时，list objects请求\r\nlist_object() {\r\n    bucket=/$1\r\n    StringToSign="GET\\n\\n\\n${DateValue}\\n${bucket}/?versions"\r\n    #StringToSign="GET\\n\\n\\n${dateValue}\\n${bucket}/"\r\n    #Url="http://${host}$bucket/?versions"\r\n    Url="http://${host}$bucket/?versions&key-marker=light12822917&version-id-marker=null&rgwx-bucket-instance=synctest2:70a82b33-ffe4-4304-9e79-1eca3d30947b.16298.2:20&format=json&objs-container=true&rgw-zonegroup=018dda70-546b-4612-900a-1bea8e79e3af"\r\n    #url="http://${host}$bucket/"\r\n    #url="http://${host}$bucket/?max-keys=1"\r\n    Param="-L -X GET"\r\n}	\N	\N	17	\N	3	\N	5	0	2018-11-13 09:04:15.873669	2018-11-13 09:04:15.873669	2018-11-13	0	\N	\N	159	1	2	f	\N
157	3	1	11.12	1，解决双活同步问题\r\n2，完善规格特性文档\r\n3，招聘\r\n4，召集会议，做版本评审	\N	\N	17	\N	3	\N	5	1	2018-11-13 06:50:12.744754	2018-11-14 09:36:30.849617	2018-11-13	0	\N	\N	157	1	2	f	\N
738	6	8	论保守	美国共和党保守，民主党激进创新。\r\n保持是为了延续，创新是为了解决问题。\r\n\r\n人之道终将灭亡，天之道在于长久。\r\n所以保守与创新是取决于状态的，因特尔保守是必然的，为了稳定长久。\r\n这世界不够好吗？改进那些不够好的地方就可以了，不然就是因为内卷竞争引起的创新，\r\n这种创新很可能加速人的灭亡或者人必须改变，当然也满足了人的一些需要。	\N	\N	17	\N	3	\N	5	0	2021-01-07 06:32:04.450259	2021-01-07 06:32:04.450259	2021-01-07	0	\N	\N	738	1	2	f	\N
182	6	12	0-6岁全脑潜能开发专题	学习全脑潜能开发的相关概念和基础知识，结合实践指导育儿行为	\N	\N	17	\N	3	\N	6	3	2018-11-28 13:43:16.283909	2019-05-14 12:55:36.386394	\N	0	\N	\N	182	1	2	f	\N
174	6	7	异步与多线程的思考	异步实际上将任务和资源分裂了。\r\n假设你100个线程池，如果线程都被占用则无法处理请求。\r\n\r\n如果不加超时，则整个程序像挂死一样。社区rgw也是这种工作模式。\r\n\r\n异步执行相对简单些，丢到任务队列，一旦超时就把任务给出错处理掉，没有占用线程资源。\r\n\r\n在多核下，现在流行的是一个核跑一个线程，减少线程切换开销，达到极致性能。	\N	\N	17	\N	3	\N	5	0	2018-11-18 08:08:14.278327	2018-11-18 08:08:14.278327	2018-11-18	0	\N	\N	174	1	2	f	\N
177	8	1	为啥当datalog同步的retry对象不存在时，返回的错误是-5，而不是-2	<pre><code class="cpp">\r\nfor (unsigned i = 0;\r\n       p != out_ops.end() && pb != op->out_bl.end();\r\n       ++i, ++p, ++pb, ++pr, ++ph) {\r\n    ldout(cct, 10) << " op " << i << " rval " << p->rval\r\n\t\t   << " len " << p->outdata.length() << dendl;\r\n    if (*pb)\r\n      **pb = p->outdata;\r\n    // set rval before running handlers so that handlers\r\n    // can change it if e.g. decoding fails\r\n    if (*pr)\r\n      **pr = ceph_to_hostos_errno(p->rval);\r\n    if (*ph) {\r\n      ldout(cct, 10) << " op " << i << " handler " << *ph << dendl;\r\n      (*ph)->complete(ceph_to_hostos_errno(p->rval));\r\n      *ph = NULL;\r\n    }\r\n  }\r\n</code></pre>\r\n\r\n在此处的complete为：\r\nstruct C_ObjectOperation_decodevals : public Context\r\n\r\n注意此时传入的参数为0，并非是m->result中的-2.\r\n实际上对象不存在，内容也是空的，故而在该结构体的finish函数中decode失败。从而返回-5错误。\r\n\r\n<pre><code class="cpp">\r\ntry {\r\n\t  if (pattrs)\r\n\t    decode(*pattrs, p);\r\n\t  if (ptruncated) {\r\n\t    std::map<std::string,bufferlist> ignore;\r\n\t    if (!pattrs) {\r\n\t      decode(ignore, p);\r\n\t      pattrs = &ignore;\r\n\t    }\r\n\t    if (!p.end()) {\r\n\t      decode(*ptruncated, p);\r\n\t    } else {\r\n\t      // the OSD did not provide this.  since old OSDs do not\r\n\t      // enfoce omap result limits either, we can infer it from\r\n\t      // the size of the result\r\n\t      *ptruncated = (pattrs->size() == max_entries);\r\n\t    }\r\n\t  }\r\n\t}\r\n\tcatch (buffer::error& e) {\r\n\t  if (prval)\r\n\t    *prval = -EIO;\r\n\t}\r\n</code></pre>\r\n\r\n上述为近期master代码，并非jewel代码\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2018-11-27 12:58:01.19123	2018-11-27 12:58:01.19123	\N	0	\N	\N	177	1	2	f	\N
421	6	21	橱柜、衣柜、门的定制		\N	\N	17	\N	3	\N	6	0	2019-05-22 04:23:32.148756	2019-05-22 04:23:32.148756	2019-05-22	0	\N	\N	421	1	2	f	\N
179	6	12	游戏力实操训练营（第六课 孩子，你快点-如何帮助孩子克服磨蹭）		\N	\N	17	\N	3	\N	6	0	2018-11-28 13:35:41.997281	2018-11-28 13:35:41.997281	2018-11-28	0	\N	\N	179	1	2	f	\N
178	6	12	游戏力实操训练营（第五课 孩子，你尽管哭-如何引导孩子管理情绪）		\N	\N	17	\N	3	\N	6	2	2018-11-28 08:46:27.574673	2018-11-28 11:15:34.666578	2018-11-28	0	\N	\N	178	1	2	f	\N
180	6	12	游戏力实操训练营（第七课 孩子，你可以说不-如何帮助孩子面对霸凌）		\N	\N	17	\N	3	\N	6	0	2018-11-28 13:36:35.870433	2018-11-28 13:36:35.870433	2018-11-28	0	\N	\N	180	1	2	f	\N
181	6	12	游戏力实操训练营（第八课 孩子，你不可以-如何帮助孩子建立规则意识）		\N	\N	17	\N	3	\N	6	0	2018-11-28 13:37:16.692417	2018-11-28 13:37:16.692417	2018-11-28	0	\N	\N	181	1	2	f	\N
489	6	7	编译错误定位经验总结	1，c没有bool类型，但是其报错非常奇怪，并非直接报bool类似非法。\r\n\r\n2，大范围莫名其妙的报错，可能是缺少括号，分号等基本语法错误。	\N	\N	17	\N	3	\N	5	4	2019-08-08 06:41:18.70356	2019-10-24 17:20:57.109658	2019-08-08	0	\N	\N	489	1	2	f	\N
368	6	15	羽毛球算法	V1.0：\r\n1，抬起脚根，抬起拍子，准备接球\r\n2，追高点\r\n3，放松(必须自信)展开击球，打到对方难受的地方 （需知彼）\r\n4，有节奏的回动到逻辑中心	\N	\N	17	\N	3	\N	5	3	2019-04-28 15:05:44.498039	2019-05-18 20:30:29.549856	2019-04-28	0	\N	\N	368	1	2	f	\N
194	6	9	设计文档要素	1，需求概述\r\n  5W，明确需求价值，需求规格，时间要求等等\r\n\r\n2，实现原理描述\r\n\r\n3，任务拆分，时间安排\r\n\r\n4，文档相关，规格限制刷新\r\n\r\n5，升级影响\r\n\r\n6，自验证方法，测试建议\r\n\r\n7，review意见	\N	\N	17	\N	3	\N	5	2	2018-12-03 12:28:42.974653	2022-04-07 14:22:17.649862	2018-12-03	0	\N	\N	194	1	2	f	\N
21	3	1	文件系统空间足够，但是没法分配inode	no space left\r\n\r\nhttp://www.zphj1987.com/2017/09/04/osd-has-inode-cannot-write/#more\r\n\r\n谢锐(x8671r@163.com)  12:03:29\r\n默认来说inode chunk 为64 ，也就是需要64*inodesize的存储空间来存储inode\r\n马四<hosfore@qq.com>  12:04:06\r\n我也在看这句话\r\n\r\n谢锐(x8671r@163.com)  12:04:23\r\nblocksize = 4096 \r\n那就是要32个block\r\n马四<hosfore@qq.com>  12:05:22\r\ninode chunk  是包含64个inode的信息 吗？\r\n谢锐(x8671r@163.com)  12:06:51\r\n估计是为了提高分配效率吧  一次搞一个太碎片了\r\n马四<hosfore@qq.com>  12:07:28\r\n  Inode的分配是以64个inode为一个chunk进行分配的。\r\n嗯 inode是动态分配的，一次分配一个chunk（64个）\r\n\r\n	\N	3	18	5	3	\N	5	1	2017-10-19 09:51:50.13149	2019-04-15 08:50:08.660586	2017-10-19	0	\N	\N	21	1	2	f	\N
191	6	15	羽毛球战术	1，重杀目标就是得分\r\n2，点杀，劈杀以落点取胜\r\n3，平高球，平抽挡都是追求速度，打转身，配合，反应\r\n4，小球是为了造机会或过渡的。	\N	\N	17	\N	3	\N	5	1	2018-12-02 12:46:39.885435	2019-01-11 10:19:36.009026	2018-12-02	0	\N	\N	191	1	2	f	\N
160	8	1	http包解析	1，相应的包，header部分长度如何知道？\r\n2，header总长度有何限制？\r\n3，如何解析的？	\N	\N	17	\N	3	\N	5	0	2018-11-13 12:14:17.027784	2018-11-13 12:14:17.027784	\N	0	\N	\N	160	1	2	f	\N
172	6	12	游戏力实操训练营（第四课 妈妈，不要走-如何应对孩子的分离焦虑）		\N	\N	17	\N	3	\N	6	2	2018-11-16 16:11:31.345625	2018-11-28 09:29:24.685065	2018-11-16	0	\N	\N	172	1	2	f	\N
140	3	1	10.29	流程优化: trace每个步骤，按步骤的核心思想做好。\r\n按照经验，转测需提前预留2天开发自验证，尤其是大量特性合入的时候。\r\n\r\n本周任务：5.2.0的bugfix。\r\n	\N	\N	17	\N	3	\N	5	5	2018-10-30 08:47:55.3996	2018-10-30 18:32:41.51884	2018-10-30	0	\N	\N	140	1	2	f	\N
256	3	1	osdmap更新机制，以及过多osdmap问题	1，osdmap能否跳跃更新？ 比如我当前是1，但是系统已经到了10万了。不能一个一个更新吧。\r\n  出现这种情况跟osd状态有关系，如果有pg处于creating或un clena状态，osdmap保留时间会延迟。\r\n2，osdmap占用的内存有多少？\r\n3，osdmap prune机制。	\N	\N	17	\N	3	\N	5	1	2019-01-29 10:33:02.351425	2019-01-30 09:44:26.050243	2019-01-29	0	\N	\N	256	1	2	f	\N
175	6	1	multisite模块可定位能力增强	cr dump 反应每个cr的状态，包括执行状态，被谁阻塞，是否在sleep等等。\r\n\r\n另外需分析是否可能存在挂住的情况，发现时可让同步rgw果断自杀	\N	\N	17	\N	3	\N	5	3	2018-11-23 14:43:28.888274	2018-11-27 09:49:57.075931	2018-11-23	0	\N	\N	175	1	2	f	\N
188	6	15	羽毛球运动特征	羽毛球是一个频繁多向折返的快速多变的羽球运动。\r\n其硬件条件是羽毛球，球拍，球网以及场地。\r\n\r\n但是并不需要很强的力量，没有身体对抗。但是运动量非常大，需要整个身体快速反应，整体协调。\r\n\r\n快速的放松和舒张的过程，就像发动机一样，公交车堵车时的操作。\r\n就是一个不断肌肉收缩，肌肉放松的过程。\r\n\r\n\r\n大健身，不仅锻炼肌肉，还得锻炼关节。平时运动中要注意不能过度。\r\n如果身体强度只允许高强度的活动一个小时，那就不能过度。\r\n\r\n身体强壮是一个循序渐进的过程。可每天坚持一个小时的运动，但是运动内容要根据需要调整。\r\n\r\n羽毛球特征：\r\n1，快速\r\n2，多点移动\r\n3，拍类运动的发力\r\n4，碰撞\r\n\r\n2是步伐面临的核心挑战，多点运动，最好的策略当然是每次打球都回到逻辑中心。\r\n这里说逻辑中心，是因为其跟球的落点有关系，一般球回到哪个半场逻辑中心就偏向哪个半场。还有如果对手不会打高远球，那逻辑中心可以靠前，如果对手不会小球，那逻辑中心可能偏后。\r\n身体从静态启动最好是一个慢到快的过程，多余的发力是没必要的，击球的最后一步最快，这个节奏非常重要。\r\n\r\n3是羽毛球发力的精髓，拍击类运动是拍作用于物体，应该都讲究接触瞬间的速度。所以羽毛球发力的内外旋和手腕很重要，想象甩鞭子，甩手上水，甩灭火柴的过程。手腕可以产生瞬间高速，但是手臂很难，而且手臂很重，容易累。\r\n一个更好的理解是这样的:\r\n大臂可以挥动，让球拍有一个初速度。但这得看引拍距离，短距离大臂引拍效果不好（这就解释了为什么反手防守球一般不用大臂）\r\n小臂和手腕旋甩进一步加速\r\n最后一步是紧，对于正手是食指压，对反手是大拇指顶，目的是防止反弹。\r\n\r\n4，碰撞\r\n上述紧的一步对于碰撞很重要，要尽量保持正面碰撞，这样可以能量最多的转化。\r\n声音由震动产生，击球的声音就是拍网的震动产生的，接触短促，震动越大声音就脆响。\r\n\r\n羽毛球对战策略：\r\n1，打球远离对手的逻辑中心\r\n2，攻击对方的弱点\r\n   弱点主要体现在：跑位特征，发力技巧掌握等。\r\n\r\n声音吧，确实很复杂，正确来说，声音并不是物体振动就发出了声音，而是，产生了振动，并引起周围空气振动，此刻，并没有声音产生，声波随着空气等介质传入耳朵后，耳朵中的鼓膜产生振动，对大脑产生信号，这是人听见声音，使大脑为了让人能感到振动的存在而自己产生的，诗人在进化过程中逐渐形成的一种功能，所以说，物体振动只能产生振动，在介质中可以产生声波，而真正人能听见声音，是耳朵的功能，物体振动并不发声，只是人耳能把振动传给大脑，大脑分析成让人能了解到的声音\r\n拍线的振动特点 与 声音的关系还没看到特别细的文章研究，后面可以检索下。\r\n\r\n从新总结下特征：\r\n1，羽拍击打的球类运动\r\n2，特有的场地\r\n3，一来一回的\r\n\r\n等级一：会发球，能接身边的顺手球\r\n等级二：能接反手球，主动情况可以拉到后场\r\n等级三：主动情况，能打主动小球和后场球，可以快速移动。\r\n等级四：步伐合理，发力良好，能回高质量被动球。\r\n\r\n发力的几种境界：\r\n1，大臂\r\n2，小臂\r\n3，手腕，手指\r\n\r\n羽毛球是一个发力不断叠加的过程，或者说叫逐节发力。从腰腹的摆动，到大臂的挥动，到小臂内外旋，到手腕的收与展，手指的顶与压。这种力量的叠加，最终通过弧线运动体现在球拍速度上。\r\n上一节完成发力之后下一节继续，要掌握这个时机节奏是需要长期训练的。\r\n\r\n为什么要放松？\r\n上一节的力量要传递到下一节，那么下一节必须放松，想想甩腕的过程，而下一节启动发力的时候更小的一节也得放松。\r\n\r\n有了拍子的速度，还得很好施加到球上，羽毛球击球过程就是一个碰撞过程。\r\n除了小球和吊球，抽打要尽量保持正面且在甜区碰撞，且碰撞时保持球拍的刚性，这样可以达到最好的能量转换效果，出去的球速度就会非常快。\r\n\r\n为什么前场球不能甩大臂？\r\n我觉得主要是时间因素，前场球反应时间短，挥拍空间有效，以拍为杠杆支点，通过甩手腕和手指顶压可以在更小空间内更快加速，且击打的精准度更好。而后场球因为球速慢，有足够的时间和空间来完成逐节加速，所以可以利用全身发力。\r\n\r\n为什么击球时要握紧？\r\n就是上述的刚性碰撞的思想，刚性并非是说在击球瞬间给球拍制动，那样就白发力了。而是要在快要碰撞到完成碰撞这极短的时间内不减速的情况下握紧球拍。所以在握紧过程中，手腕是在快速旋转的，否则就会产生制动效果。\r\n\r\n羽毛球黄金法则：\r\nrule 1: 最小发力\r\n          多节发力原则，握拍形式和发力有关系，不合适的握拍会影响发力，新手通常手和拍是一体的，发力靠大小臂。实际上显然除了后场高远，杀球等需要全身和大臂力量。其他很多球都是小臂和手腕，手指的力。发力小可以快速调整进入下一个环节。动作小还比较隐蔽，可辅助实施策略。\r\nrule 2: 精细控制\r\n          这也是羽毛球手法如此重要的原因，羽毛球是一个脑力活动，一个状态好的敌人是很难战胜的，我们必须控制调动对方，才能最大消耗对方。\r\nrule 3: 最省跑动\r\nrule 4 :最优策略\r\n          对付有缺陷的人专攻其缺陷即可。老年人体能速度是弱点，转拉后场反手球，推斜线。\r\n年轻人速度快，但是技术可能不全面。可以多打变化。反正基本三板斧吧：一反手高远，二拉斜线小球，三杀边。\r\n\r\n	\N	\N	17	\N	3	\N	5	1	2018-12-02 12:42:08.06543	2020-04-12 09:18:57.507126	2018-12-02	0	\N	\N	188	1	2	f	\N
258	3	1	大量站点的问题	1，支持几十个分支机构？\r\n2，如何控制同步时间？	\N	\N	17	\N	3	\N	5	0	2019-01-30 23:19:21.576497	2019-01-30 23:19:21.576497	2019-01-30	0	\N	\N	258	1	2	f	\N
163	6	7	性能分析探索	性能分析可以以延时为起点，并发能力下降通常也与延时有关系。\r\n能否清晰的看到每个环节的延时就比较好分析了。	\N	\N	17	\N	3	\N	5	3	2018-11-14 11:39:10.367315	2019-03-29 13:05:11.345994	2018-11-14	0	\N	\N	163	1	2	f	\N
164	8	1	如果bucket policy允许其他用户访问bucket的对象，但是object的acl默认是只属于owner的，这时可以访问么？	也就是说bucket policy与object acl是什么关系？	\N	\N	17	\N	3	\N	5	1	2018-11-14 12:05:50.499633	2018-11-14 12:15:12.025418	\N	0	\N	\N	164	1	2	f	\N
176	3	1	大压力时请求超过600s，rgw超时挂掉问题	显然请求超时，rgw挂掉对于业务rgw非常不合理。会导致业务中断	\N	\N	17	\N	3	\N	5	0	2018-11-27 12:07:47.50261	2018-11-27 12:07:47.50261	2018-11-27	0	\N	\N	176	1	2	f	\N
148	6	12	游戏力实操训练营（第一课 妈妈，你走开-如何与孩子重新建立联结）	https://mp.weixin.qq.com/s/3MOAMMozbmGH7XbapaBfGA	\N	\N	17	\N	3	\N	6	14	2018-11-04 09:30:44.809519	2018-11-28 11:16:24.804825	2018-11-04	0	\N	\N	148	1	2	f	\N
173	6	9	年度演讲主题：科学做事，合适做人		\N	\N	17	\N	3	\N	5	1	2018-11-18 07:34:30.832376	2018-11-18 07:35:26.518105	2018-11-18	0	\N	\N	173	1	2	f	\N
171	3	1	5.2.0版本大压力测试暴露的问题	1.osd full处理欠缺，遗漏。导致osd可能写到100%\r\n\r\n2，rgw在大压力下，会出现请求超时，会残留rados对象，数量不少\r\n\r\n3，大压力下，rgw会出现超时，尤其是大对象	\N	\N	17	\N	3	\N	5	11	2018-11-16 14:39:28.763877	2018-11-18 07:59:41.337927	2018-11-16	0	\N	\N	171	1	2	f	\N
183	3	1	499问题	当rgw处理慢时，rgw来不及处理足够的客户端请求导致堆积。\r\n在这种情况下 我们期望的结果是部分请求可以被正常处理，而不是所有请求都返回499错误。	\N	\N	17	\N	3	\N	5	1	2018-11-28 14:29:48.203388	2018-11-28 14:30:57.116204	2018-11-28	0	\N	\N	183	1	2	f	\N
139	6	7	软件工程方法总结	0，目标与价值\r\n1，架构，组件，模块\r\n2，测试，仿真体系\r\n3，流程与质量\r\n4，工具与效率	\N	\N	17	\N	3	\N	5	1	2018-10-29 13:25:42.889055	2018-12-01 08:05:28.276864	2018-10-29	0	\N	\N	139	1	2	f	\N
165	6	9	任务管理	使用任务来管理日常工作，给予合理的时间，但是需要个人自己推动任务的完成。\r\n让每个人自治，每个下层组织自治，确保目标达成。\r\n\r\n任务：\r\n1，目标(描述尽可能明确，范围清晰)：\r\n2，时间安排(合理)：\r\n3，输出(代码以及其他输出如文档，分享等)	\N	\N	17	\N	3	\N	5	2	2018-11-14 12:48:17.638876	2018-12-06 14:08:57.82776	2018-11-14	0	\N	\N	165	1	2	f	\N
184	6	15	发力心得总结		\N	\N	17	\N	3	\N	5	4	2018-12-01 16:22:44.500425	2018-12-01 16:24:03.521589	2018-12-01	0	\N	\N	184	1	2	f	\N
192	6	15	原则	羽毛球原则：\r\n\r\n保持自信，理性，集中注意力，同时放松身体\r\n提前引拍，在最早的时候击球\r\n减小前场收拍动作\r\n提前转换握拍，形成习惯\r\n缩短准备-移动引拍-击球-收拍-回动流程。\r\n击球后回到逻辑中心\r\n手指发力打前场小球，手腕小臂发力打前中场球，转身全身发力打后场球。\r\n准备时眼睛盯着球，打完之后不要看球，立即收拍，回动。\r\n高远球正面击球，碰撞效果最好。\r\n反手后场顶宽面和斜面要根据个人情况，我顶斜面发力更顺畅。\r\n保持节奏，移动中引拍，脚落地击球，否则应该可以在更早的点击球。\r\n步伐和手法都应该遵守最简原则，过渡转身也是不合适的。\r\n羽毛球发力原理：\r\n\r\n人体的结构来看，速度越慢的地方力量越大。 越是末梢速度越快，也越灵活。几乎所有运动都讲究核心力量。\r\n\r\n但是核心力量无法直接转换成速度。这就是羽毛球比较特别的地方。 它主要是一个速度性的运动。所以必须直接末梢的加速。在网上看到的钟摆理论可以比较好解释这个。羽毛球完整的发力过程是 1，蹬地 2，转体 3，摆大臂 4，甩小臂 （会产生甩腕效果，但是手腕并非发力部位） 5，压手指\r\n\r\n这是一个逐步加速的过程。其他发力都是在这个过程中删减。\r\n\r\n有了这个理论，可以解释如下问题。 为什么不能仅仅甩大臂就很好解释了，因为那样虽然力量大但是速度并不快。 为什么反手不宜转肩膀，其实效果就跟甩大臂一样。 为什么要架拍？ 其实是为了增加加速距离。架拍位置是加速起点。\r\n\r\n转体程度，取决于羽毛球和人的位置。反手打不好很大原因就是习惯问题，缺乏足够的训练很难在最佳的节奏位置上击球。\r\n\r\n发力轨迹也与球的轨迹有关系，但是整体发力过程仍然一样。\r\n\r\n如果把打羽毛球比喻成一个机器，每一个回合就是一次执行的话。 那么： 策略-》指令 发力能力-》cpu能力 发力轨迹-》执行优化 步伐-》寄存器，内存。\r\n\r\n快能弥补策略上的一些缺陷，策略可以优化执行速度。 最终拼的就是谁更快。\r\n\r\n怎么判断是否放松？其实很容易看出来，松则软。僵硬必然没放松。\r\n\r\n通常造成速度慢的几个原因： 1，发力不畅 2，击球点不合适 3，发力太晚，节奏不对 4，步伐沉重不到位。\r\n\r\n要快，必须要有节奏，步伐到了就击球。不存在步伐不到击球，或者步伐已经到位等球的情况。 不应该等球，步伐到了球未到，那就可以跳杀或者做假动作了。或者应该位置更靠前。\r\n\r\n杀球下网一般都是击球点过低，或者人步伐移动不够靠后。\r\n\r\n我的打法就是效仿李宗伟，在快速对抗中寻找机会。	\N	\N	17	\N	3	\N	5	0	2018-12-02 12:49:40.674192	2018-12-02 12:49:40.674192	2018-12-02	0	\N	\N	192	1	2	f	\N
185	6	15	发力	1，羽毛球高远球发力由蹬地，转腰，旋转大臂，内旋小臂，握紧手指等过程。\r\n每步都做好，需要注意一些细节。尤其是手指的握紧，收拍等。\r\n\r\n2，发力时步伐应该到位，身体伸展的。\r\n\r\n3，握拍与发力也关系密切，对于反手尤为明显。顶斜面在反手和正手网前都是比较舒适于发力的。	\N	\N	17	\N	3	\N	5	1	2018-12-01 16:29:31.683526	2018-12-02 12:50:25.099406	2018-12-01	0	\N	\N	185	1	2	f	\N
193	8	1	cr dump命令似乎未见meta cr的信息		\N	\N	17	\N	3	\N	5	0	2018-12-02 13:26:40.161771	2018-12-02 13:26:40.161771	\N	0	\N	\N	193	1	2	f	\N
195	6	9	代码提交的审核	1，问题单是否处理\r\n2，相关文档，规格是否修改\r\n3，review意见\r\n4，是否自测试	\N	\N	17	\N	3	\N	5	2	2018-12-03 12:44:08.381457	2018-12-06 14:13:20.504797	2018-12-03	0	\N	\N	195	1	2	f	\N
186	3	1	rgw下一步发展的想法	1，继续定位于增强存储能力。\r\n2，支持bucket无限对象数量\r\n3，支持系统的无感扩展\r\n4，支持系统的快速演进（架构解耦，测试自动化构建）	\N	\N	17	\N	3	\N	5	4	2018-12-01 19:15:00.799198	2018-12-04 15:47:13.839632	2018-12-01	0	\N	\N	186	1	2	f	\N
223	7	1	2018年工作总结	1，项目管理\r\n  经理了V3.1.5发布（广发升级） 5.23\r\n  V3.2.1发布（非商用） 8.1\r\n  V5.2.0发布 (受控商用) 11.25\r\n  V5.2.1 （即将发布） 1.4\r\n  版本质量，流程规范都是在逐步完善的。\r\n \r\n2，人员招聘与培训\r\n  总人数从\r\n  rgw人数从2人，扩展为5人\r\n\r\n3，流程规范\r\n  正式把迭代跑了起来，每个步骤按照一定规范执行。 \r\n\r\n4，产品架构\r\n\r\n5，开发工作\r\n\r\n6，缺点与改进\r\n6.1 在项目管理上，trace不够，需因人而异的进行管理。没有全程carry。流程执行虽然跑起来了，但是未完全达到预期。\r\n    改进想法：对工作进行分解，部分工作分摊给其他人\r\n6.2 人员招聘上因为经验不足导致了一些无用功，有1人因个人原因离开，另外一人被辞退。培训工作也迟迟才开展起来。\r\n6.3 产品架构调整未能看得更远，有些调整未能更早的识别，对于后续的升级发展有一定影响。\r\n  	\N	\N	19	\N	3	\N	5	0	2019-01-02 07:28:43.393093	2019-01-02 07:28:43.393093	2019-01-02	0	\N	\N	223	1	2	f	\N
314	6	20	我该如何踏出职业转型探索第一步？	纵观我毕业后近10年的毕业生涯，不管从哪个维度来说，都没有做到让自己满意。\r\n以前的日子是做一天和尚撞一天钟，没有太多目标，更没有太多的想法，囿于自己的认知跳不出来，总是认为那些梦想中的事情在我身上不可能发生，苦大仇深却不知去改变，温水煮青蛙的混着日子，看不到可能性。\r\n随着自己的心智不断的成熟，人也到了中年，对自己职业生涯的思考迫在眉睫，打算给自己10个月的时间，在2020年前完成这个大事。	\N	\N	17	\N	3	\N	6	2	2019-03-18 08:39:54.917283	2019-03-18 09:32:26.177639	2019-03-18	0	\N	\N	314	1	2	f	\N
528	6	24	logged 追加写入下的查询实现	在所有写入追加时，如何实现查询，以及compact。\r\nat实现的时候也有类似问题，允许at查询的延迟性？这样能接收么？	\N	\N	17	\N	3	\N	5	1	2019-10-09 06:51:29.863702	2019-10-09 12:00:59.125547	2019-10-09	0	\N	\N	528	1	2	f	\N
238	6	7	一致性hash 与 crush	解决的问题：在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 { K/n} K/n 个关键字重新映射，其中 { K} K是关键字的数量， { n} n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。\r\n\r\n传统hash存在的问题是将key直接映射到存储桶，桶的数量直接影响映射结果。\r\n一致性hash改进是key不直接映射桶，而是映射到中间KEY。再把node也映射到KEY同样的空间上，完成KEY到node的分配。\r\n\r\n这样node可变，KEY不变的情况下，keys不需重新映射。只需将减少的node的KEY加到其他node即可。\r\n\r\n这里分配KEY到node也有不同算法。最简单粗暴的就是一致性hash大量介绍文章中说明的将一个node的KEY丢给下一个node。\r\n但是这样显然压力不均衡。\r\n\r\n问题：\r\n1，如何将虚拟节点分配给存储node，尤其是node有权重的情况下。\r\n2，如何计算副本位置\r\n\r\n这2问题就是crush要解决的。\r\n	\N	\N	17	\N	3	\N	5	0	2019-01-19 17:16:57.755459	2019-01-19 17:16:57.755459	2019-01-19	0	\N	\N	238	1	2	f	\N
225	6	9	个人工作职责的剥离，用身边的人让自己变得成倍的强大。	目前已有角色：\r\n1，项目经理 （执行者）\r\n2，架构师\r\n3，招聘\r\n4，人员培训  能力建设\r\n5，活动组织  建立信任，活跃氛围，培养感情。让工作变得有趣。\r\n6，开发人员\r\n\r\n	\N	\N	17	\N	3	\N	5	3	2019-01-06 20:43:44.748438	2019-01-08 08:24:21.856146	2019-01-06	0	\N	\N	225	1	2	f	\N
315	6	20	职业生涯规划-小章鱼之咨询篇20190228-0336	链接第一个人为自己打开一扇窗	\N	\N	17	\N	3	\N	6	3	2019-03-18 10:19:21.233272	2019-03-18 11:59:55.030293	2019-03-18	0	\N	\N	315	1	2	f	\N
739	6	8	人能弘道	这个社会可能被政府牵引往前走，被政府牵引，这是一些复杂因素的综合结果。\r\n但人理当选择自己的路。\r\n\r\n每个人出生，生活在自己的道路上，体验着经历的一切。	\N	\N	17	\N	3	\N	5	0	2021-01-07 06:34:48.576421	2021-01-07 06:34:48.576421	2021-01-07	0	\N	\N	739	1	2	f	\N
438	6	17	PG索引技术	4，摸清楚索引实现套路，以及可能存在的问题。\r\ngist索引是基于(p,ptr)的模型的，ptr为指向heap tuple的指针。\r\nac索引在插入/删除时，可能需转换为count上的操作。且需管理IKs存放形式。\r\n另外需利用index填充数据，根据fetch的是x | y | count | IKs。\r\nhash索引无法支持联合索引，基本可以排除。\r\n\r\n5，ac的索引实现需skip pg_index.这块的影响。\r\n6，索引是如何使能的？\r\n7，btree联合索引的存储结构\r\n8，分析cover index，include column是如何带入的。以及如何独立于索引更新。\r\n   create a covered index。\r\n   insert into t2 values(1,1) on CONFLICT(id) do update set count=excluded.count+1;\r\n9，GiST with dummy tuple	\N	\N	17	\N	3	\N	5	12	2019-06-04 12:20:38.245877	2019-10-09 17:57:26.949668	2019-07-31	0	\N	\N	438	1	4	f	\N
241	6	6	系统是如何运作的	1，识别系统的核心部件\r\n2，搞清楚他们之间的关系，以及相互影响。知道如何牵一发而动全身。\r\n3，看到趋势与问题，调整系统架构\r\n\r\n部件：人，技术\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2019-01-21 20:37:57.936487	2019-01-21 20:37:57.936487	2019-01-21	0	\N	\N	241	1	2	f	\N
657	3	25	讨论纪要7-9	1，itl不是每条记录都有，itl就是锁区。\r\n2，记录可以指向itl，这样查找老版本的效率更高\r\n\r\nPCR是page consistent read\r\nRCR是row consistent。\r\nCR是consistent read，CC是concurrent \r\n通过SCN干掉了snapshot机制，使用SCN来判断可见性。\r\n\r\n改造点：\r\n1，double write替代fullwrite\r\n2，scn替代snapshot\r\n3，redo buffer支持多part\r\n4，增量checkpoint\r\n5，CR buffer\r\n使得读写不在相同buffer上冲突\r\n6，undo，干掉vacuum\r\n7，buffer管理，预读，干掉page cache\r\n8，含事务信息的index\r\n9，闪回，not PITR\r\n10，支持跨页的tuple migrate	\N	\N	17	\N	3	\N	5	2	2020-07-09 11:45:14.496104	2020-07-09 11:47:20.804901	2020-07-09	0	\N	\N	657	1	2	f	\N
633	7	16	rust unsafe理解	非安全的rust要谨慎对待安全rust的代码，因为安全的rust代码被非安全的使用时\r\n可能引入未定义行为。\r\n安全的rust必须信任非安全rust。总之如果出现未定义行为，责任在于unsafe部分，\r\nsafe部分绝对不对出现未定义行为。\r\nsafe是良民，unsafe非良民，出了问题责任在unsafe。\r\n\r\n比如越界访问，在安全代码中写不出来，但是从安全代码进入到非安全代码可以写出来。\r\n西部世界一样。	\N	\N	19	\N	3	\N	5	1	2020-05-27 20:10:07.673847	2020-05-28 13:56:53.263504	2020-05-27	0	\N	\N	633	1	2	f	\N
741	6	7	技能与知识	技能是知识，方法，训练经验的综合体。\r\n这些都在不断的进步，知识尤其更新的快，而技能则需要形成方法论，再持续练习才有效果。\r\n然技能也可能淘汰。但整体而言有了坚实基础，技能也能进一步进化。	\N	\N	17	\N	3	\N	5	0	2021-01-08 06:28:28.202277	2021-01-08 06:28:28.202277	2021-01-08	0	\N	\N	741	1	2	f	\N
632	3	25	imcs heap实现	1，同一个锁区内，undo是串联的。\r\n可以假设如果这个链上某一条undo是commit的，则其后的undo都是commit的。\r\n\r\n2，同一个事务，可能用到多个锁区。\r\n\r\n3，使用mirror page机制验证redo的正确性。一个不错的方法！	\N	\N	17	\N	3	\N	5	6	2020-05-25 07:34:42.782836	2020-06-11 07:45:33.30852	2020-05-25	0	\N	\N	632	1	2	f	\N
189	6	15	武术境界	http://www.cnblogs.com/secbook/archive/2013/09/09/3309333.html\r\n\r\n利剑和软剑级别：都追求快，破解对手  业余高手的境界，仍然有套路，有套路就有破解方法。区别在于谁能更快的看到对手的套路，弱点，展开攻击。\r\n重剑级别：大巧不工，这里就已经简化招式了，力量碾压  专业选手的中级境界，高远就可以拉死业余选手，重炮可以杀死\r\n木剑级别：以柔克刚  专业选手的高级境界，重炮杀不死，打太极，让对方露出破绽\r\n无剑级别：不需要武器了，这个羽毛球里面不讨论   \r\n\r\n之前业务高手和国家队的对打就是 利剑与木剑的一次较量。当然木剑水平还未及巅峰。                                       \r\n力量好的打力量差的，用不了什么招，只要能抓住弱点，不断碾压就行了。\r\n\r\n这里面有个硬件条件，就是个人的相对速度和力量。\r\n剑招就是打发。套路。\r\n\r\n羽毛球如果只有落地才算输，那木剑级别的林丹基本只有体能差的时候别人打的过，但是有界之后手感就有点重要了。\r\n\r\n如果水平相差很远，那么所有球都可以在高点和前点打，那自然对手就非常难受。	\N	\N	17	\N	3	\N	5	0	2018-12-02 12:42:46.873382	2018-12-02 12:42:46.873382	2018-12-02	0	\N	\N	189	1	2	f	\N
530	6	24	火山模型-编译执行-向量化执行	三种查询执行模型。有系统专门研究，编译执行与向量化执行在性能上各有千秋。\r\n\r\n这篇文章讲的比较清楚。\r\nhttps://www.jianshu.com/p/fe7d5e2d66e7	\N	\N	17	\N	3	\N	5	0	2019-10-09 17:32:21.773568	2019-10-09 17:32:21.773568	2019-10-09	0	\N	\N	530	1	2	f	\N
224	6	9	项目管理-会议	mos技术难点对策研讨。\r\n\r\n管理方法研讨。会议，任务跟踪。每个人讲述本周工作情况。有杀气，有侵略性。\r\n\r\n创新以及Idea探讨。重大问题探讨。 （创新与难关处理）\r\n\r\n	\N	\N	17	\N	3	\N	5	2	2019-01-05 14:39:18.369404	2019-01-07 14:16:43.332999	2019-01-05	0	\N	\N	224	1	2	f	\N
190	6	15	羽毛球培训记录	高远球要点： \r\n1，高点击球 \r\n2，立腕 \r\n3，鞭打 \r\n4，放松 \r\n5，一定要高，要远，否则不是高远球，就变成平高球 和 中场球\r\n\r\n2点：\r\n1，球拍要向后倒，加大引拍距离\r\n2，要正身击球，拍子别斜着引过来。\r\n\r\n搓球： \r\n1，是搓，不是弹，参见矛式搓球 \r\n2，前场步伐，最后出右脚，并且不过膝盖，便于收回。\r\n杀球： \r\n1，高点击球 \r\n2，后退充分，确保击球点靠前\r\n反手高球： \r\n1，切记要沉腕，就像正手要立腕一样 \r\n2，同样击球点要高 \r\n3，一定要面对后方，转身\r\n接杀：\r\n后退步伐： \r\n1，蹬转 \r\n2，侧身 \r\n3，并步\r\n李宗伟弹簧步本质就是蹬转快。靠小腿力量和脚的力量\r\n腿部力量，不需要任何额外设备都可以联系，手部也一样。 \r\n随便哪里都可以练习。\r\n12-10:： \r\n其实不仅高远球追求高点，所有球都应该追求高点。 \r\n当然如果想欺骗别人是另外说了。\r\n拉掉就是在普通击球的基础上收力。\r\n步伐是羽毛球的基石，看看李宗伟和林丹的步伐，真的是感觉武林高手的对决。 \r\n轻描淡写一般，但做到这种最简单，却是不容易。大音希声，返璞归真的境界。\r\n\r\n如何方便的接来自各个方位的球：\r\n1，步伐\r\n   大步伐就不说了，主要说说小步伐，尤其是反手球，将身体调整到适当的位置，使得身体可以转动，有足够的空间引拍\r\n2，握拍\r\n   绕8字的正确玩法，是要在绕的时候调整握拍姿势，迅速的转换握拍方式。\r\n3，引拍\r\n   不引拍没速度，有些球要大幅度引拍，有些球要小幅度。\r\n\r\n3-27：\r\n1，击球点应该在加速的末端，击完之后就应该放松\r\n2，击球时，手抓紧发力。\r\n其实不论对于什么球，只要想打远点都是这个道理。\r\n打远球和近球。\r\n\r\n3-29：\r\n1，其实在引拍过程中就要旋转小臂（或者说转手腕）了，不然在最高点拍子就不是正的。\r\n2，体会加速的过程。最响的地方应该在头上方附近。\r\n\r\n3-31：\r\n高远球出师了。\r\n体会：除了引拍向上的过程中，加速发力，并且拍面转正。\r\n其他阶段都是放松的，还有一点就是击球后，如果是放松的拍子应该从正前方往下落拍，而不是斜着落拍，斜着落拍说明发力了。\r\n\r\n倒排到击球应该是一气呵成的，不是先倒了然后掉在那里。羽毛球大部分动作都是三段：\r\n准备，执行，收。\r\n落拍放松的感觉。\r\n\r\n挑球也是要放松，引拍。\r\n\r\n腕力的解读\r\nhttp://bbs.aiyuke.com/thread-2438-1-1.html\r\n\r\n是的，这个youtube上面badminton universe的频道好像是创立还不久，全都是这样的平视角录像，非常便于爱好者观看研究。\r\n要是这样视角的录像多一些就好了，我个人觉得目前的转播视角不利于展现这项运动的美感。虽然上帝视角更加客观了，但是也忽略了大量细节。\r\n步伐原理：\r\n1，稳重心\r\n2，简化步伐（结合手法）\r\n3，启动，降重心，蹬转\r\n4，站位原则\r\n5，回动中如何保持重心，如何简化步伐？\r\n先一个小步子先垫一下，避免重心不稳。 回不是回到场地的中心，而是回到逻辑上最合适的点。\r\nhttps://www.zhihu.com/question/22608330\r\n\r\n\r\n4：14\r\n1，步伐有个基本规律，就是站在球场相当的位置上，并且稍微靠前。\r\n为什么呢？这样容易防直线球，直线距离最短，如果不优先防直线，很可能接不到。\r\n靠前是因为后场球球飞行需要时间，有足够时间去移动。\r\n这才是真正的回中含义。\r\n\r\n步伐总结：稳重心，回中心，快启动，慢收回。\r\n\r\n2，网前应该小退，不应该转身退。\r\n\r\n3，网前跳球，有一个小包的动作。不管打什么球，都有拍面的变化。\r\n\r\n4，高远球的手臂应该是从右上方击球，而不是正上方。\r\n\r\n5，腰部不应该转过，现在腰伤搞不好就是这么来的。各部位发力均称，而不能过度。\r\n\r\n\r\n4：16\r\n发高远球：\r\n不用搞到最低点击球，落球点和身体可以拉开点距离。\r\n网前步伐回来时候，右脚蹬地。\r\n\r\n\r\n关于脚步发力的文章\r\nhttp://bbs.badmintoncn.com/thread-675546-1-1.html\r\n\r\n\r\n\r\n击球速度 \r\n   大臂旋转，小臂内旋发力把球拍加速到非常快的速度。\r\n\r\n移动最短距离，防守最佳线路。移动最快速度\r\n\r\n5.14打球体会：\r\n回球不到位，在各种场景下回球不到位就给对手可趁之机。\r\n双打轮转不到位，没有及时转为防守式。\r\n进攻不具备特色，无进攻。\r\n\r\n体验：\r\n高远球 握紧短促发力的感觉\r\n以及步伐的垫步。\r\n\r\n感受：\r\n感受自己的握拍\r\n感受自己的走位\r\n感受自己的发力\r\n感受球路\r\n\r\n7.8：\r\n反手用大拇指顶，更容易回球，找那种感觉\r\n正手打球，在击球前放松，比如平抽球，想回球有速度就得放松打，一直紧绷打不好\r\n正手各个角度都可以平抽，可以稍微扭转身体。\r\n\r\n8.20：\r\n搓球是前场之母\r\n高远球是后场之父\r\n平抽是中场之子\r\n\r\n速度快才能获得很好的一致性，没有什么假动作，只是占了先机而已。占了先机就有多种选择。\r\n假动作背后的含义是未曾查明。\r\n\r\n9.27：\r\n反手高远球明显打的比以前好了些。但是以下地方需要加强：\r\n1，步伐\r\n2，多拍的放松与正反拍转换\r\n3，球要打到位，高远球就得真的高远。\r\n4，提前准备击球动作，该杀球的就杀球。\r\n\r\n对方出手前，我方就应该准备启动步了，对方出手。我方判断后就开始第二步了。\r\n我方回球后，就立即开始回动了。\r\n所以羽毛球就他妈是一个不停息的四方步运动.....\r\n\r\n击球后的放松过程必须有，否则多排之间无法持续发力。\r\n\r\n球拍带动身体打球，减少不必要的。\r\n\r\n所以再击打球之后，首先想到的应该是回位，放松，准备下一次击球。\r\n\r\n进入第二阶段：\r\n体能锻炼，确保自己能没压力的打完3场比赛。能够打单打。\r\n\r\n10.19：\r\n理解正反手出拍，发力，收拍过程\r\n杀球不能弹后场可能是没握紧导致的，球被弹出去了，虽然你用了很大力。然并卵。\r\n\r\n10.29：\r\n感觉自己对手腕发力的理解好了一些\r\n拿着拍子挥，反手明显手腕放松，甩的速度快很多。\r\n\r\n10.31：\r\n想参加比赛，必须攻克两个难题：\r\n1，后退步伐\r\n2，启动步伐\r\n3，反手防守\r\n\r\n羽毛球击球法：碰撞以及发声的原理\r\nhttp://blog.sina.com.cn/s/blog_51e3655d0100jmw7.html\r\n\r\n11.1：\r\n实现战术1，调动对手。\r\n根据羽毛球运动特征1，调动对手，使其做多点运动。\r\n有意图的实施战略，对于步伐问题大的对手效果必然刚刚的。\r\n正好可练习吊球技术。\r\n\r\n11.3：\r\n今天拉高远球有点感觉了，似乎听到了比较脆的声音。\r\n要点：\r\n1，还是先放松手腕，然后逐节发力，大臂到位后，小臂和手腕各节要发挥起来\r\n2，要从上面过去，不要侧面击球，打高点\r\n\r\n但是比赛的时候仍然有很多问题：\r\n1，平高球回的没有威胁，似乎架拍太慢\r\n2，高远球也没有抢好点，不知道是否为步伐问题\r\n3，前场挑球，要么不到位，要么出界。\r\n     挥拍动作也比较大。\r\n动作小的好处：可以保持重心，让自己快速进入下一回合。\r\n\r\n今天还有点进步的地方是对球的控制，前后场都可以打点小球。\r\n看来常练习各种颠球对手感还是有一定帮助的。\r\n\r\n定个目标：\r\n可以流畅的打单打，不至于出现满场乱跑，回球严重不到位的情况。\r\n能做基本的控球。\r\n\r\n\r\n11.14：\r\n如何能步伐不乱？\r\n步伐的核心不仅仅是控制重心和线路吧，就像手法显然不仅是选择打大球还是小球，控制方向。 更细微的发力是怎么样的呢？ 哪些部位应该放松？才可以更快的移动，仅仅是踮起脚跟么？\r\n当然重心也有讲究，通常重心是偏右脚的，启动步是右脚蹬地，最后一步是左脚蹬地。\r\n\r\n启，动，止。三种形态脚步发力是不一样的，如果脚尖一直用力，得不到放松那肯定会累。\r\n\r\n什么是放松？脚跟着地么？\r\n\r\n\r\n11.26：\r\n步伐快慢除了启动步之后，还有关键的蹬转。昨天练球这个毛病暴露无遗。\r\n快速蹬转的意识非常重要。\r\n另外前场球发力问题仍然没掌握，还得努力。\r\n前场搓球的意识非常弱，基本都是弹过去的。\r\n\r\n打球之前可以热身找下步伐节奏，以及手法放松感觉。\r\n中场击球可以垂下大臂，小臂带动手腕正反手挥拍，体会手腕放松的甩感觉，以及手指顶压的感觉。\r\n\r\n11.27：\r\n注意斜线步伐其实身体只需要转90多度就可以了，而不是180度。\r\n问题出在哪里呢？ 出在反手击球时身体的朝向上。如果身体朝前就不会需要转180度了。\r\n没看到有运动员一次性蹬转180度的，那样还不如搞个小转身先（经观察谌龙和李宗伟都是这样处理的）\r\n\r\n12.3：\r\n切球拍面还是尽可能平的，除非是切对角。太竖了接触面小，容易失误。\r\n步伐和动作要一致，尤其是中前场，基本都是落地击球的，身体要足够伸展。这样才是最快的击球。\r\n自信和放松是发挥最佳自己的不二法门。	\N	\N	17	\N	3	\N	5	1	2018-12-02 12:43:28.403527	2019-01-11 10:21:23.137909	2018-12-02	0	\N	\N	190	1	2	f	\N
316	6	20	职业生涯规划-二丫儿之教育行业探索篇20190309	链接一个人\r\n了解教育行业相关资讯	\N	\N	17	\N	3	\N	6	0	2019-03-18 11:59:07.819869	2019-03-18 11:59:07.819869	2019-03-18	0	\N	\N	316	1	2	f	\N
243	6	6	组织-顶在前面的那个石头	每个组织都有顶在前面的那个石头。后面的人也许可以感受优胜劣汰，但前面那个非常明显。\r\n但是前面的石头好处在于其可以发展状大。而后面的石头其命运可能取决于前面的石头。\r\n\r\n当你想做前面的石头时，想想自己准备好了吗？\r\n艰辛与残酷。想想成吉思汗铁木真的处境。	\N	\N	17	\N	3	\N	5	0	2019-01-21 20:47:44.848411	2019-01-21 20:47:44.848411	2019-01-21	0	\N	\N	243	1	2	f	\N
257	6	15	羽毛球单双打特征	双打人多注定了其打法与单打不一样。\r\n双打慢基本就是死，因为别人可以在网前各种抓。\r\n而且双打的局势变幻更快，需要两个人很好的配合，如果有很大漏洞，则容易被攻破。\r\n\r\n\r\n单打一个人击球，战术可根据自己的想法灵活变化。假动作更多样化。\r\n很难提前预判去抓球。打不死的情况下，四方球比稳定性，比耐心，控制节奏也是很好的打法。	\N	\N	17	\N	3	\N	5	0	2019-01-30 23:17:02.8896	2019-01-30 23:17:02.8896	2019-01-30	0	\N	\N	257	1	2	f	\N
103	6	6	学习与学习方法	h1. 学习的理解\r\n\r\n学习包含两个大的方面，一是掌握知识，二是练习运用。\r\n\r\n掌握知识可以看成去理解现有系统，一个系统中有树根，枝干，树叶。有各种公理，定理，还有原则, 经验。事物为何存在？ 解决什么样的问题？\r\n事物之间的联系是什么？\r\n\r\n练习运用就是形成思考习惯，在遇到问题时能够使用知识来处理新的问题。\r\n\r\nh1. 学习的动机\r\n\r\n学习是一种行为，有行为必然有动机，学习的动机通常是为了适应变化。\r\n为了更好的在环境中生存。\r\n\r\n在生存问题得以缓解之后，很多人就停止了继续学习，这是因为学习本身通常并非一个非常有趣的事情。\r\n只有极少人能从学习中获得满足感，这是人从出身的差异，以及在生长过程有关系。\r\n\r\n如果世界上有1000多个通用领域，每个领域大约有几百万人，但是其中能保持持续学习，不断精进的可能只有一万人。\r\n这一万人基本占了该领域的90%市场。\r\n为什么其他人不能保持持续学习呢？因为他们还不足以狂热，他们把精力耗算在多个领域上，但都不专业。比如玩游戏，听音乐，看电影，旅游消耗了大量时间，\r\n但是大部分人仅仅是在消费时间，他们无法成为这些领域的顶尖人物。也不是在精进，不是在投资自己的时间。\r\n有少数人能从其他领域获取灵感，寻找事物的关系，这其实仍然是在本领域内投资时间的，毕竟他一直在思考相关问题。\r\n\r\n唯有爱和兴趣能让人持续投入，只有这样才会成为顶级高手，压力之下固然也有高手，但这是一种畸变的力量，最终会反噬自己。\r\n\r\nh1. 学习方法\r\n\r\n有了动机之后，学习就简单了。学习就是不断琢磨，熟悉公里，定理，事物之间的关系然后不断练习的过程。\r\n其中关键点我觉得是把基本观念纳入思考习惯，以及对于事物关系的整理和记忆。现在人脑基本不会作为记忆的载体。\r\n但是当出现某种问题，能够联系到相关的知识仍然是需要的。\r\n\r\n持续学习方法，讲究学习结果的累加特性。也就是说我们每天都是进步的。这想想都非常激动。\r\n通过持续学习，我们可以确保自己一直在稳健的进步。\r\n\r\n通过对学习的理解，我们知道持续学习关键在于：\r\n1，持续的积累知识，什么是知识？ 原理，联系，问题，规律都是的。\r\n2，持续的锻炼，无论何时何地我们都可以进行思维锻炼，当然也可以进行身体锻炼。\r\n\r\n但是每一步走扎实非常重要，流于形式或者浮于表面的阅读都无法达到学习的目的。或者说无法实现高效的学习。\r\n通过记录的方式来整理自己的知识非常重要。\r\n	\N	\N	17	\N	3	\N	5	5	2018-10-06 18:49:27.044087	2019-04-03 07:08:06.767609	2018-10-06	0	\N	\N	103	1	2	f	\N
262	6	8	修身齐家治国	修身好理解，断绝各种恶念，以及修复原生家庭伤痛。让自己身心健康，正心，明辨是非。知道该如何做事。\r\n齐家要求就更高，不仅需了解自己，还需了解亲人，能换位。从不同人来看待一个整体。明白每个人的疾苦。\r\n同时还能处理好每个人之间的矛盾纠葛。\r\n治国需要看的不仅是亲人，需要看各种人，利益团队。要平衡好，做成事就更难了。	\N	\N	17	\N	3	\N	5	1	2019-02-12 10:28:54.919612	2019-02-12 10:33:14.471775	2019-02-12	0	\N	\N	262	1	2	f	\N
259	8	1	统一存储合适吗？	我们知道事务之间是有差别的，同时也有共性。\r\n当我们决定将事务统一时，考虑因素是什么？\r\n\r\n对象存储其特征决定了其对存储一致性要求相对低。\r\n甚至丢1，2个对象关系不是非常大。\r\n\r\n对于分布式系统而言，其可用性至关重要。如何在面对大规模集群经常有磁盘故障，网络故障时保持可可用。\r\n同时尽最大可能的找到数据。 这也是人脑存储的模型。\r\n\r\n采用多版本	\N	\N	17	\N	3	\N	5	1	2019-01-31 04:55:46.338309	2019-02-08 12:57:50.114926	\N	0	\N	\N	259	1	2	f	\N
260	3	1	蔚来环境无法恢复暴露的问题	1，ec下节点频繁故障造成内存暴涨无法恢复。\r\n2，ntp服务有且只有一个\r\n3，允许舍弃部分数据，恢复集群可用性。\r\n4，15个host操作效率就已经非常低下。监控运维必须加强。\r\n\r\n	\N	\N	17	\N	3	\N	5	5	2019-02-08 10:25:18.599097	2019-02-15 12:34:20.408739	2019-02-08	0	\N	\N	260	1	2	f	\N
138	8	8	如何改善人际关系？	1，如何打破沉默？你想要什么样的人际关系？ 你需要别人怎么待你？\r\n2，每个人对于人际关系的敏感度不一样，有些人也不会意识到去建立怎样的人际关系，以及其重要性，意义是什么？\r\n3，无法主动建立人际关系，无感一样，就像打羽毛球一样，有些人打了一辈子，但是从未研究过怎么样打合适。在人际关系领域也是一样。\r\n\r\n4，内向的人对别人缺乏信赖，缺乏与他人建立正常关系的经验。比如小时候就很少与朋友游玩，聚餐，聚会等。喜欢用消极心态防御。\r\n5，寻找有趣的灵魂，有意义的交谈，有趣的过往。 这些比独守自己，比无聊的游戏，以及垃圾文章有趣的多。	\N	\N	17	\N	3	\N	5	2	2018-10-26 07:05:25.289584	2019-02-12 10:19:33.385204	\N	0	\N	\N	138	1	2	f	\N
263	6	8	管理与统治的区别	管理者只是被人赋予了管理权限，这种权力是有限的，受控的。比如羽毛球群的群主。\r\n纯粹是提供服务的。\r\n\r\n而统治者是有绝对权力的，是可以干掉，清除被统治者的。\r\n\r\n这体现了2者之间的对等关系。一个强大一方弱化的结果。	\N	\N	17	\N	3	\N	5	1	2019-02-12 10:42:10.226322	2019-02-12 14:16:35.211381	2019-02-12	0	\N	\N	263	1	2	f	\N
264	7	16	2019-2-15	1，蔚来问题总结\r\n2，项目整体进展情况了解\r\n3，BP版本规划讨论\r\n4，5.3.0代码review	\N	\N	19	\N	3	\N	5	0	2019-02-15 07:08:26.643838	2019-02-15 07:08:26.643838	2019-02-15	0	\N	\N	264	1	2	f	\N
266	3	1	系统磁盘空间满时rgw会挂掉？		\N	\N	17	\N	3	\N	5	0	2019-02-15 13:22:29.152868	2019-02-15 13:22:29.152868	2019-02-15	0	\N	\N	266	1	2	f	\N
269	7	16	分析多个站点跑在一个集群上存在的问题		\N	\N	19	\N	3	\N	5	2	2019-02-16 14:02:17.085703	2019-02-19 07:21:22.293188	2019-02-16	100	\N	\N	269	1	2	f	\N
267	6	7	分布式系统面临的一些问题	分布式系统的本质就是扩展与复杂度上升。在组件变多之后，各种问题都变得复杂起来。\r\n\r\n测试\r\n监控\r\n运维\r\n开发：\r\n一致性\r\n数据分布\r\n故障检测\r\n	\N	\N	17	\N	3	\N	5	1	2019-02-16 08:56:35.536197	2019-02-16 14:47:24.945194	2019-02-16	0	\N	\N	267	1	2	f	\N
268	7	16	分析未来汽车leveldb损坏问题	是系统盘满，内存不够导致的？	\N	\N	19	\N	3	\N	5	3	2019-02-16 13:21:46.866648	2019-02-20 14:27:21.848425	2019-02-21	0	\N	\N	268	1	2	f	\N
265	7	16	提供广发V3升级到V5方案		2019-02-21	\N	19	\N	2	\N	5	4	2019-02-15 09:35:23.22653	2019-02-18 15:57:12.92714	2019-02-15	0	\N	\N	265	1	2	f	\N
317	6	20	职业生涯规划-小章鱼之友邦保险了解篇20190315	了解保险代理人行业\r\n认识这个行业的从业人员\r\n	\N	\N	17	\N	3	\N	6	0	2019-03-18 12:07:39.244132	2019-03-18 12:07:39.244132	2019-03-18	0	\N	\N	317	1	2	f	\N
196	6	9	软件项目运作	从角色上产品经理，项目经理，SE，开发人员，测试SE，测试人员 这是基本配置。\r\n其中SE和测试SE负责技术架构，避免产品在架构上犯错误。这其中包括技术选型，升级策略，硬件兼容，产品大的模块设计，整体测试方案等等。\r\n\r\n产品经理的任务是制定目标，确定时间点。\r\n项目经理的任务就是制定计划和trace执行。\r\nSE看护架构，实现架构演进。\r\n开发，测试实际执行者。	\N	\N	17	\N	3	\N	5	1	2018-12-03 12:59:59.021387	2018-12-04 06:17:19.171867	2018-12-03	0	\N	\N	196	1	2	f	\N
226	6	9	从不抱怨，适应规则，改变规则，保持酸疼，保持饥饿，保持虚心	这才是一个强者该有的态度。\r\n别人强我学之，别人不强，正好是机会。\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2019-01-06 21:20:24.190758	2019-01-06 21:20:24.190758	2019-01-06	0	\N	\N	226	1	2	f	\N
197	6	6	商业的思考	商业的本质就是分工与交换。商业成功本质上就是效率的提升。\r\n效率这里含两部分：\r\n分工引起的纵向效率提升\r\n交换引起的横向效率提升\r\n\r\n这里也可以扯出两种产品策略：\r\n1，做精品\r\n2，做生态	\N	\N	17	\N	3	\N	5	1	2018-12-04 13:03:49.346921	2018-12-04 13:09:59.428474	2018-12-04	0	\N	\N	197	1	2	f	\N
198	6	6	笨方法	用一种方法，不断去执行优化，最终会达成目标	\N	\N	17	\N	3	\N	5	1	2018-12-04 13:15:11.31864	2018-12-04 13:16:31.876453	2018-12-04	0	\N	\N	198	1	2	f	\N
229	7	1	讨论员工绩效		\N	\N	19	\N	3	\N	5	0	2019-01-09 08:33:17.813922	2019-01-09 08:33:17.813922	2019-01-09	0	\N	\N	229	1	2	f	\N
203	6	9	听未来简史	自由意志的泡影，人没有机器理性与正确。\r\n人与机器的关系 就像马和汽车的关系。\r\n智人终将被淘汰，可能出现生化人。加强的人，每个人可以轻松的做到正念，达到圣人的精神状态。\r\n没有真实的自我。就像黑客帝国中的运输控制程序。\r\n\r\n一个巨大的数据与逻辑网络。只是目前人类的复杂度尚未全部解释。\r\n现代社会没有剧本，用科技力量取代了农业时代的信仰。\r\n\r\nDNA就像代码一样。\r\n\r\n人类发展的过程就是数据处理方式变化的过程。\r\n数据教派\r\n万物互联\r\n\r\n所有生物都是算法\r\n生物都在处理数据\r\n\r\n智能与意识脱钩\r\n\r\n无意识的机器会比我们更了解自己\r\n\r\n总结：\r\n人的思维具备立体性，比如抽象出新的概念。总结事物的本质。\r\n如果我们知道桌子的制造过程，我们就更容易识别桌子。\r\n\r\n知识，技术就是权力\r\n未来人与算法仍然在很多领域展开竞争。\r\n	\N	\N	17	\N	3	\N	5	0	2018-12-08 14:58:19.574218	2018-12-08 14:58:19.574218	2018-12-08	0	\N	\N	203	1	2	f	\N
205	6	9	2017春节随笔	人生的意义是什么？\r\n\r\n就像代码也许有天会问 我存在的价值是什么？代码的价值是设计他，使用他的人决定的。\r\n这里并不是问 \r\n为什么存在？\r\n而是问存在的意义，\r\n\r\n也不是讨论人存在的价值，意义并不一定就是价值。\r\n\r\n生活的理想就是为了理想的生活。 那就得先搞明白什么是理想的生活。\r\n\r\n有2种基本的观点：\r\n宗教：人是由一个造物主制造的，其意义在于造物主的意图\r\n科学：人是在宇宙中普遍存在的因果网络中的。\r\n\r\n所以有些事情不要去问有什么意义，根本就没有意义，只是有因果。\r\n\r\n\r\n他说大约50年前，当逻辑实证主义者放弃哲学时，哲学就死了。 现在哲学只是在回顾哲学史，而哲学史包含的\r\n主要是失败的大脑模型。我们需要新哲学，以对人类的起源和意义的科学理解为基础的哲学。\r\n\r\n人是怎样的一种生物?\r\n\r\n意识的生理基础，意识是物质过程吗？\r\n\r\n现代心理分析是以关系为基础的，并不是以佛洛依德的个人欲望作为基础的。\r\n\r\n安全感，恐惧，自我防御也是一些行为的原动力。\r\n虚荣心，自满，这些也都是一些原动力。\r\n\r\n地域对人的影响真的非常重。比如我老婆老家的人喜欢聊天，而我们那边的人却不是特别喜欢。我们那边的显得冷漠简单粗暴。\r\n她们那边走亲戚是全家出动，而我们那边却只派一个代表。是什么造成这些差异呢？\r\n\r\n我站在远端，企图跳出自己去看周围的人。只有这样才能跳出自己的偏见。\r\n像卫庄一样，冷眼看着社会的变化并手握利剑，为了权力也是为了生存存在更多的选择，没有为什么，只有因果，存在。\r\n\r\n要理解人。技术只是看能否做到，是否发现，而产品是跟人相关的，有各种可能性。\r\n而且企业市场与个体市场又不一样。\r\n\r\n社会又是怎样的社会？\r\n奴隶社会，\r\n农业社会，土地时代\r\n工商业社会，资本时代\r\n美元时代的结束？\r\n\r\n因果。逻辑时代，数据时代\r\n\r\n\r\n\r\n2个技术：\r\n1，网页的逐渐模糊显示技术，摘要？\r\n2，手机与电脑的文字投射	\N	\N	17	\N	3	\N	5	0	2018-12-08 15:02:15.995144	2018-12-08 15:02:15.995144	2018-12-08	0	\N	\N	205	1	2	f	\N
207	6	15	打墙练习心得1	1，羽毛球全程发力是大臂，带动小臂，手腕，手指完成挥拍击球的过程。\r\n当你确定自己的接球挥拍路径之后，步伐就很自然形成了。虽然最后一步挥拍击球步伐也是最大的。\r\n\r\n2，多拍能力与快速放松能力成正比，发力干脆，快速进入放松阶段。\r\n\r\n3，前中场握拍靠上点可减轻手臂的负担，增强多拍能力\r\n	\N	\N	17	\N	3	\N	5	1	2018-12-08 20:42:52.445037	2018-12-08 21:02:49.633611	2018-12-08	0	\N	\N	207	1	2	f	\N
246	6	10	看问题，看趋势	5G\r\n大数据分析\r\n数据处理\r\n数据训练\r\n\r\n这些岂能不看。	\N	\N	17	\N	3	\N	5	0	2019-01-21 21:10:15.642501	2019-01-21 21:10:15.642501	2019-01-21	0	\N	\N	246	1	2	f	\N
210	3	1	libcurl segmentfault	(gdb) bt\r\n#0  0x00007f48bd4fd23b in raise () from /lib64/libpthread.so.0\r\n#1  0x00007f48be5a9685 in reraise_fatal (signum=11) at global/signal_handler.cc:71\r\n#2  handle_fatal_signal (signum=11) at global/signal_handler.cc:133\r\n#3  <signal handler called>\r\n#4  free (ptr=0x3) at include/jemalloc/internal/arena.h:532\r\n#5  0x00007f48bdb3319d in setstropt () from /lib64/libcurl.so.4\r\n#6  0x00007f48bdb33ef3 in Curl_init_userdefined () from /lib64/libcurl.so.4\r\n#7  0x00007f48bdb33fae in Curl_open () from /lib64/libcurl.so.4\r\n#8  0x00007f48bdb43164 in curl_easy_init () from /lib64/libcurl.so.4\r\n#9  0x00007f48be328612 in RGWHTTPClient::init_request (this=this@entry=0x7f472938abe8, method=method@entry=0x7f488c9406f8 "PUT", \r\n    url=url@entry=0x7f48a48bf798 "10.10.80.84:9200/mos-master/object/afc31178-f10e-4a54-99b3-f5c221db7752.15433.1:myobjects2706299:null", \r\n    _req_data=_req_data@entry=0x7f4724a63b80, send_data_hint=send_data_hint@entry=false) at rgw/rgw_http_client.cc:304\r\n#10 0x00007f48be32bbcf in RGWHTTPManager::add_request (this=this@entry=0x7f4886184c48, client=client@entry=0x7f472938abe8, method=<optimized out>, \r\n    url=0x7f48a48bf798 "10.10.80.84:9200/mos-master/object/afc31178-f10e-4a54-99b3-f5c221db7752.15433.1:myobjects2706299:null", send_data_hint=<optimized out>)\r\n    at rgw/rgw_http_client.cc:723\r\n#11 0x00007f48be4a2744 in RGWRESTStreamRWRequest::get_resource (this=this@entry=0x7f472938abe8, key=..., extra_headers=std::map with 1 elements = {...}, \r\n    resource="mos-master/object/afc31178-f10e-4a54-99b3-f5c221db7752.15433.1:myobjects2706299:null", send_data=send_data@entry=0x0, mgr=0x7f4886184c48)\r\n    at rgw/rgw_rest_client.cc:692\r\n#12 0x00007f48be4a75a8 in RGWRESTSendResource::aio_send (this=this@entry=0x7f472938ab00, outbl=...) at rgw/rgw_rest_conn.cc:365\r\n#13 0x00007f48be55d15a in RGWSendRESTResourceCR<es_obj_metadata, int>::send_request (this=0x7f4729059000) at rgw/rgw_cr_rest.h:112\r\n#14 0x00007f48be2cbe4e in RGWSimpleCoroutine::state_send_request (this=this@entry=0x7f4729059000) at rgw/rgw_coroutine.cc:1004\r\n#15 0x00007f48be2cf0bc in RGWSimpleCoroutine::operate (this=0x7f4729059000) at rgw/rgw_coroutine.cc:982\r\n#16 0x00007f48be2cc13b in RGWCoroutinesStack::operate (this=0x7f4706d81c00, _env=_env@entry=0x7f48807fc610) at rgw/rgw_coroutine.cc:287\r\n#17 0x00007f48be2cf7a2 in RGWCoroutinesManager::run (this=this@entry=0x7f4886184b60, stacks=std::list = {...}) at rgw/rgw_coroutine.cc:601\r\n#18 0x00007f48be2d06ed in RGWCoroutinesManager::run (this=this@entry=0x7f4886184b60, op=0x7f47005c6400) at rgw/rgw_coroutine.cc:744\r\n#19 0x00007f48be391fef in RGWRemoteDataLog::run_sync (this=this@entry=0x7f4886184b60, num_shards=128, sync_status=...) at rgw/rgw_data_sync.cc:1686\r\n#20 0x00007f48be463a82 in run (this=0x7f4886184b28) at rgw/rgw_data_sync.h:170\r\n#21 RGWDataSyncProcessorThread::process (this=0x7f4886184b00) at rgw/rgw_rados.cc:2970\r\n#22 0x00007f48be400944 in RGWRadosThread::Worker::entry (this=0x7f4887cc3780) at rgw/rgw_rados.cc:2776\r\n#23 0x00007f48bd4f5dc5 in start_thread () from /lib64/libpthread.so.0\r\n#24 0x00007f48bcb0176d in clone () from /lib64/libc.so.6\r\n	\N	\N	17	\N	3	\N	5	0	2018-12-17 12:03:13.363432	2018-12-17 12:03:13.363432	2018-12-17	0	\N	\N	210	1	2	f	\N
261	6	7	核心问题-复杂系统的扩展，迁移，容错，故障容忍	一个复杂系统该当如何处理系统生长，局部老坏，扩展等问题。	\N	\N	17	\N	3	\N	5	0	2019-02-08 19:06:57.698157	2019-02-08 19:06:57.698157	2019-02-08	0	\N	\N	261	1	2	f	\N
255	6	6	如何管理更多的人与事	1，分治方法，合时扼要\r\n其重点在于识人用人，以及事的架构设计\r\n\r\n2，抓住本质，深入理解问题\r\n其实一些事情看似复杂，但是问题规模可能也就十几个。\r\n有些人一年就搞定了，而有些人10年都搞不定。\r\n\r\n3，善用工具，机器模型\r\n\r\n4，学会放松，调整精力。\r\n人在任何领域的差距都有百倍之上。精力强的人表现也会百倍于精力差的人。\r\n\r\n这就是人的综合差距有上万倍的原因。\r\n\r\n	\N	\N	17	\N	3	\N	5	2	2019-01-28 08:41:25.777734	2019-02-12 10:12:39.914534	2019-01-28	0	\N	\N	255	1	2	f	\N
503	8	7	关于树	pg的btree算法没有做均衡？是因为中间节点是虚拟节点么？\r\nbtree有类似的查找性能，而且维护更简单，代价是什么？\r\n代价就像数组与指针的区别一样，插入的代价大。 这也是lsm-tree诞生的原因。\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2019-08-27 18:30:34.42197	2019-08-27 18:30:34.42197	\N	0	\N	\N	503	1	2	f	\N
199	6	8	兴趣是什么	兴趣是什么呢？ 是满足欲望么，好像不是。是成功，也不是。\r\n\r\n维基：兴趣是人类在空闲时间喜欢做的休闲活动。兴趣是一种人们在空闲时享受及乐于去做的活动，通常人们不是以赚钱为目的而参与这些活动。\r\n\r\n这个答案似乎也不好，有些兴趣显然不是休闲的。\r\n\r\n我感觉兴趣是人们从事活动时，大脑分泌兴奋物质而导致的行为偏好。\r\n所以兴趣有几点：\r\n1，大脑兴奋\r\n2，容易上瘾\r\n\r\n兴趣可能强化，也可能逐步弱化。这个就像我参与羽毛球活动时，不断有新发现，不断提升自己可以强化兴趣。\r\n\r\n由此可见兴趣是可以培养的，掌握培养方法非常关键	\N	\N	17	\N	3	\N	5	2	2018-12-05 07:19:23.026586	2018-12-05 08:29:01.925777	2018-12-05	0	\N	\N	199	1	2	f	\N
206	3	10	阿里云使用记录	1，选择不同区域，则有不同的endpoint，使用的是host-based的格式\r\noss-cn-beijing.aliyuncs.com\r\noss-cn-shenzhen.aliyuncs.com\r\n\r\n2，创建bucket的时候还可以选择存储类型，acl等等\r\n3，region对应我们的是zonegroup\r\nOSS 将用户的数据以冗余的方式存储在同一区域（Region）的 3 个可用区（Zone）中。提供机房级容灾能力。\r\n\r\n4，用户和bucket名称空间都是跨区域的\r\n\r\n多租户\r\n全球化\r\n多版本数据保护\r\nbucket无限数量和容量\r\n数据检索\r\n数据处理（加密，压缩，转换）\r\n\r\n公有云强化功能：\r\n域名\r\nCDN加速\r\n事件通知\r\n计费功能	\N	\N	17	\N	3	\N	5	1	2018-12-08 16:12:04.827816	2021-06-14 17:31:09.486355	2018-12-08	0	\N	\N	206	1	2	f	\N
228	7	1	近期几个小会	1，讨论filestore目录分裂问题的处理\r\n2，讨论liuqing工作，具体实施\r\n3，讨论v5.3版本如何解决v5.2.1的遗留问题\r\n	\N	\N	19	\N	3	\N	5	1	2019-01-07 07:11:45.075543	2019-01-07 09:01:55.683975	2019-01-07	0	\N	\N	228	1	2	f	\N
978	7	25	存储引擎接口的认知	1，cursor扫描的是结构\r\n2，结构与表的dc无关，关联于结构本身的dc\r\n3，结构不依赖于表。\r\n4，结构的使用者知道其有哪些字段和数据类型。\r\n5，结构本身通常并不感知数据类型，但也可感知，这取决于结构本身是否要支持比较，排序等运算。\r\n   比如索引，稀疏索引，统计信息都需要感知类型。	\N	\N	19	\N	3	\N	5	0	2021-10-24 12:20:27.213385	2021-10-24 12:20:27.213385	2021-10-24	0	\N	\N	978	1	2	f	\N
201	6	9	push上层，trace下层	管理者的职责，不仅是接收目标，任务，安排计划与执行。\r\n有时候还需反推，促进上层改革。\r\n\r\n对于被管理者，也是于此。需要积极push，怎样整体对于问题的理解才能更加深入。	\N	\N	17	\N	3	\N	5	0	2018-12-06 14:17:17.032576	2018-12-06 14:17:17.032576	2018-12-06	0	\N	\N	201	1	2	f	\N
982	6	7	今天我开始学算法	今天我决定开始学算法。\r\n不是学某个算法，而是学算法的根本，一切算法的源头。\r\n基于个人记忆力比较差，目前学习任何东西都需要建立一套系统。\r\n从公理定理出发，导出定理。\r\n\r\n这点可以参考对于数据结构的理解，通过数据结构来理解软件系统以及形式系统，自然世界。\r\n同样我要通过算法来理解这些。	\N	\N	17	\N	3	\N	5	1	2021-11-09 06:57:28.685614	2022-02-09 05:47:41.598715	2021-11-09	0	\N	\N	982	1	2	f	\N
204	6	9	2016春节后所想	二年没回家过年了，今年早早的回家了。\r\n\r\n回家当然是兴高采烈的，想看看故乡的样子，容颜是否还在。\r\n\r\n下城铁之后坐车直奔家里，一路上冬天的萧瑟已经让我觉得有点不习惯了。\r\n灰色是主色调，只有在后来去地里面挖野菜时才知道春将至。\r\n\r\n幸而在老家的几天天气都晴好，温度也比较高。\r\n\r\n中午到家后到隔离邻居坐着聊了下天，似乎没聊什么深入的内容。大家也都是从外地回来。\r\n邻居几家都买了车，有个老远也开回来了。网络也基本快普及了，农村人的生活看上去比城市人更加\r\n轻松惬意。\r\n\r\n村里的老一辈的人有很多都叫不上名字了，也没看到很多老人，年轻人更是不知道去哪里了。中午去运动场\r\n打下篮球也没见几个年轻人。后来才知道大家聚集在村头的几家打牌去了。\r\n\r\n在往年大年30或者初一还有人搞搞集体活动，在运动场打打篮球，跳跳舞啥的，如今这些都没了。\r\n村里的老人逐渐离去，年轻人之间也在不同的圈子，而下一代几乎没啥关联了。\r\n\r\n物理的社会逐渐在瓦解，农村慢慢也变得不识邻居了。\r\n社会关系慢慢的变成 家庭关系，同学关系，同事关系，圈子关系。\r\n\r\n\r\n网络上聊天的内容量估计早超越了现实。如果不去刻意激发，几乎聊不到什么深入的内容。\r\n大都是回忆，家常，寒暄。 聊工作，成长，理想已经算特别深入的话题了。\r\n\r\n由此也可见大家对于生活，对于工作的热爱与研究可能还停留在一个比较浅的层次上，关注点\r\n也比较狭窄。如何才能聊的深入有深度？把自己日常的思考给聊出来？\r\n\r\n现在其他的过年风俗几乎都没了，除了吃团圆饭，回家干的最多的可能就是体验劳动，以及在附近游玩了。\r\n爱人家正好在风景区边上，附近的一些农民也在通过旅游业来致富。\r\n\r\n聊天有深度，跟别人聊天时能够相互学习到一些新东西。家庭教育这块对此影响应该非常大。如果小孩子从小听\r\n长辈聊天中学习到很多新东西，那对小孩的成长影响应该是非常深远的。\r\n\r\n就像二嫂跟她小孩的聊天一样，可以让小孩子学习到很多东西。\r\n\r\n聊天真是一个神奇的东西，如果从外在的角度来看别人说你不能这么老实，你要多说话，但是然并卵。当自己发现聊天真的有趣，并且可以\r\n学习到很多东西，同时分享自己的见解，这样看聊天就特别有意思了。\r\n\r\n如果一个小孩不论说什么，家人都鼓励，接收，并且认真的从她的角度聊聊，那样小孩子就不可能变得沉默。\r\n\r\n于冬寅而言感激付出，但是长辈的付出却变成了一种压力。这样付出不会成为别人的债务。我选择做一件事，并不是期望未来可有可无的收获，\r\n我做好最坏的打算，即便在最差的情况我仍然能够接收，付出爱心，收获爱心。\r\n\r\nopen + 聊天\r\n\r\n冬寅说我:不随大流 不世俗 有独立思考 和 反思精神\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2018-12-08 15:00:02.808663	2018-12-08 15:00:02.808663	2018-12-08	0	\N	\N	204	1	2	f	\N
208	3	1	解决多故障相关干扰的问题	1，osd full只影响相关故障域\r\n2，rgw不应该因为一个故障域卡住而退出\r\n  有些地方超时会抛出异常\r\n  rados op增加超时\r\n  流控增加超时\r\n  循环操作增加超时，如超过4M的读写，list 多个bucket等	\N	\N	17	\N	3	\N	5	1	2018-12-10 19:04:23.279828	2018-12-11 15:39:03.543269	2018-12-10	0	\N	\N	208	1	2	f	\N
200	6	1	s3与rgw框架随想	rgw架构如何调整，以满足快速交付，保证质量。	\N	\N	17	\N	3	\N	5	2	2018-12-06 12:25:37.771421	2018-12-12 13:26:32.715932	2018-12-06	0	\N	\N	200	1	2	f	\N
209	3	1	ceph 注入测试	ms_dispatch_throttle_bytes = 524288\r\nms_inject_delay_type = client\r\nms_inject_delay_max = 2\r\nms_inject_delay_probability = 0.3\r\n\r\n通过在osd消息接收端注入超时，构造osd超慢的情况	\N	\N	17	\N	3	\N	5	1	2018-12-11 14:05:59.270553	2018-12-13 14:43:38.497646	2018-12-11	0	\N	\N	209	1	2	f	\N
149	6	7	软件架构	软件架构的定义: "软件架构代表了一个系统的组织结构， 这包括将系统分解为不同的部分，界定它们之间的连接，确定它们之间的交换机制，并且为后续的设计提供指导性的原则"\r\n英文版：\r\nthe fundamental organization of a system, embodied in its components,\r\ntheir relationships to each other and the environment, and the principles\r\ngoverning its design and evolution.\r\n\r\n重点在于组件，模块独立，同时组件之间相互关联。\r\n独立因而独立发展，快速进化。 关联实现价值	\N	\N	17	\N	3	\N	5	11	2018-11-06 18:07:17.517523	2019-01-02 06:33:15.224863	2018-11-06	0	\N	\N	149	1	2	f	\N
232	6	6	一切都有逻辑，当然也有意外	意外不意味着无法控制，反而你不加以控制，意外会越来越多。\r\n\r\n你得不断优化调试自己的机器，不断升级版本。而不是处于混沌状态。这样才能用“笨方法”把事做成。\r\n不论是学习，管理，还是干其他事都是如此。\r\n\r\n将机器执行逻辑不断分割为更小模块，理解这些模块，以及其关联关系，知道如何牵一发而动全身。\r\n\r\n宏观可以看到方向，目标。 但计划与执行同样重要，微观决定成败。	\N	\N	17	\N	3	\N	5	2	2019-01-11 07:47:48.751325	2019-01-11 07:55:34.365837	2019-01-11	0	\N	\N	232	1	2	f	\N
233	6	6	缺点的思考	注意自己思维上可能存在的漏洞，同时明白自己存在的局限性。 这样经常自省，同时善于与人合作，借用别人的长处。	\N	\N	17	\N	3	\N	5	0	2019-01-11 10:22:45.902736	2019-01-11 10:22:45.902736	2019-01-11	0	\N	\N	233	1	2	f	\N
986	7	16	todo	1，swf支持bulk size 小于63，可按单行方式读取。	\N	\N	19	\N	3	\N	5	0	2021-11-15 12:24:06.163575	2021-11-15 12:24:06.163575	2021-11-15	0	\N	\N	986	1	2	f	\N
234	6	7	关于事务	很多业务系统开发都涉及事务，通常业务处理程序是无状态的，且有很多。\r\n\r\n事务可简化开发逻辑，但是代价也非常高。有时候我们需要的只是cmp，基于原value的+/-运算，以及单调唯一的key等。	\N	\N	17	\N	3	\N	5	0	2019-01-15 14:20:12.788516	2019-01-15 14:20:12.788516	2019-01-15	0	\N	\N	234	1	2	f	\N
270	7	16	解决问题单1127	同时在check_reload的时候，业务与后端rgw不要真正reload。	\N	\N	19	\N	3	\N	5	0	2019-02-16 14:03:27.129626	2019-02-16 14:03:27.129626	2019-02-16	0	\N	\N	270	1	2	f	\N
987	3	25	bug	Spearfish元数据 {\r\n\tSwfSlice状态维护,\r\n\tcurrInsertSlice, //循环使用，高水位？\r\n\tSwd Entry,\t\r\n}\r\n\r\nswf作为预分配的slice而存在，其sliceId不变。\r\n\r\nSpearDict {\r\n    swfDict[]\r\n\tSwdDict\r\n}\r\n\r\n干掉现在的coral子目录。另其一个spf的子目录。上层只看到slice id以及相关操作接口。\r\n\r\n\r\n接口:\r\n\r\nSpearfishCreate\r\nSpearfishDrop\r\nSpearfishTruncate\r\nSpearfishLoadDc\r\nSpearfishNewSliceId\r\nSpearfishGetAllSlice\r\nSpearfishTruncateSlice\r\n\r\nSpearfishMultiInsert\r\n\r\n\r\n内部接口\r\nSpearfishSliceStale\r\n\r\n\r\n\r\n验收标准：\r\n1，支持create,drop\r\n2, 支持插入\r\n3，支持插入数据的查询\r\n\r\n\r\n1，支持CSC，支持指定slice大小，\r\n2，支持drop\r\n3，支持truncate\r\n4，支持插入和查询前端slice\r\n\r\n\r\nspf {\r\n  管理swf数组\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n1，create table\r\n   使用CSC避免影响当前功能，后续合并后再去掉，支持指定slice大小方便测试\r\n\r\n我做的部分：\r\n加入CSC关键字\r\n定义spf结构\r\nspf_active { swf or heap }\r\nspf_stable { coral }\r\nvgd要感知slice，\r\n\r\n可以这样理解，meta模块是给系统和active提供服务的。\r\nactive决定有多少slice，写入哪个。用什么结构存。\r\n\r\n还有一种是spf本身就一定是多个active slice，active只是作为slice存储结构的包装。\r\n但是这样与stable有点不一样，coral可是包装了元数据的，所有stable slice交给了coral管理。\r\n\r\n先按第二种来吧。\r\n\r\n感觉得先重构下sort代码。\r\n\r\nsort作为dc，但是上层能看到，\r\n\r\n接口是通过表得到其排序信息。这个信息的定义放在dc中。\r\n定义新接口，\r\n\r\nsort挂到表的描述符上。是表的一部分\r\nCoralSortContext挂在接口上先不管，但内部不用这个。\r\n内部使用AnkIndexDesc\r\n\r\n!!!在根本上还是存在cursor访问结构的情况，需对此进行封装！！！\r\n\r\n多个swf写入，要考虑事务状态。\r\n自顶而下的编码。\r\ngAccessors\r\ngCursorOperator\r\n\r\n支持CSC的spfDict:dcLoadPartCoralDict\r\nSPF_TABLE,\r\n    SPF_PART_TABLE,\r\n\tIS_CORAL_TABLE\r\n\t\r\n\tdcLoadCoralDict\r\n\t\r\n支持多个entry，并且在entry上\t\r\n\t\r\n\r\n\r\n创建表，删除表流程打通\r\n\r\nswfHeapEntry {\r\n  blockId, offset\r\n}\r\n\r\n从swfHeapDict上拿。\r\n\r\ncoral使用swfdict也得走其接口，构造swfDict\r\n\r\nCREATE TABLE coral_sort_table005(ti INT, si INT) organization CSC ZORDER BY (ti) NULLS FIRST DESC;\r\n\r\n\r\n并行扫描需考虑下，\r\n\r\n由于cursor上没有属性区别cursor要扫描的是一个什么结构，因而出现了上述问题。\r\nankOpenAuxCursor指定了type，但实际上这样并不合适。\r\ncursor上需有地方标识这是一个什么样的segment。\r\n\r\n主要原因还是cursor必须关联一个tableDict，这其实并不合理。\r\ncursor应该关联于结构。 tableDict只是恰好包含了一个表的入口结构。\r\n确定下扫描一个子结构的用法。\r\n一定要把cursor接口调用一遍么？\r\n\r\nspf写入的sliceid怎么设置？\r\nspfSetInsertSlice()? 一个接口同时获取sliceid，并设置到insertCtx上？\r\nankSetInsertRange?\r\n\r\n更正的认知：\r\n1，cursor扫描的是结构\r\n2，结构与表的dc无关，关联于结构本身的dc\r\n3，结构不依赖于表。\r\n4，结构的使用者知道其有哪些字段和数据类型。\r\n5，结构本身通常并不感知数据类型，但也可感知，这取决于结构本身是否要支持比较，排序等运算。\r\n   比如索引，稀疏索引，统计信息都需要感知类型。\r\n   \r\n   主要依赖产生于分区表，因为只有start的时候才知道分区。\r\n   即open只能针对表，说白了还是没有完全脱离。\r\n   open需要dict就决定了不可能解耦，\r\n   要搞一套只传dict的接口。\r\n   \r\n   而且内部接口没必要调用start？实际使用时外部cursor已经start了。\r\n   即内部结构不必支持range？也不支持rescan。\r\n   \r\n作为内部结构时，该结构的访问接口应该包装cursor接口，而不是反过来。\r\n实际上没法使用cursor访问不同的结构。\r\n另外内部结构通常也没rescan的需要。\r\n因而可以考虑使用针对内部结构的cursor接口，并解除对dict依赖(cursor依赖dict，则结构内部使用cursor必然也依赖dict)。\r\n或者不做特殊封装，直接使用结构的初始化。\r\n\r\n\r\nswd接口我在想是不是不暴露cursor的。包括其他内部结构的访问，是不是包装访问接口，在访问接口内使用cursor，而不是暴露cursor接口。\r\n1，cursor接口是针对表的，在内部使用还是得带TableDict。实际内部结构的操作可以不依赖tableDict。仅cursor接口依赖了。\r\n2，内部结构得访问并没有rescan的需要，对外简化一些，不用alloc,open,close,release一套。\r\n3，减少对cursor层回调使用，降低复杂度。\r\n   例如swfSetColAccessorParams，是不是没必要走回cursor做一堆实际明确不可能走到的处理。\r\n   必然是heapScan。   \r\n   \r\n   \r\n\r\n新的子任务：\r\n1，给swf增加记录数量限制。\r\n   \r\n\r\n在自治事务成功后，修改dict。不然dict怎么回滚？\r\n\r\nlockArea先不急，先打通插入和查询，就可以联调。\r\n创建单个vgd结构后刷dc.\r\n\r\n1，首页需要增加partNum\r\n2，lockArea需增加entry block id\r\n\r\n./tools/yasctl init --ip 127.0.0.1 --dn-path /dev/shm/dn --cn-path /dev/shm/cn --mn-path /dev/shm/mn --dn-gnum 1\r\n./bin/yasimp --config-file ./1_test_base_four_sql_queries.toml \r\npython3 build.py build -A --jobs=6\r\npython3 build.py install -A\r\n./bin/yasql sys/sys@127.0.0.1:7778 -f /home/xr/squid/install/create_table_lsc.sql\r\n\r\n\r\n类型大小：如果类型A中可存在一个类型B的成员，则类型A > 类型B。否则A和B不可比较。\r\n自由实体(系统内)，由系统的基本类型，及其关联结构组成的实体。或由其他自由实体组成的实体。\r\n                  这些实体理论上可以出现在系统的任何地方。\r\n所有权实体：被其他实体拥有的实体，其不可随意脱离于其他实体而存在。\r\n实体森林：软件系统由多个自由实体组成，构成了实体森林。\r\n单向依赖：软件中实体只可依赖于比自己更小类型组成的实体与自由实体。\r\n共享原则：所有权实体不可共享，但可以转移。\r\n          自由实体可以共享\r\n\t\t  \r\n\t\t  \r\n    cursor.raw_attribute_mut().action = Action::Insert.into();\t\r\n\t\t\t\t\t\r\n          \t\t\t\t\t\r\n\t\t\t\t  \r\n\t\t\t\t  \r\n\t\t\t\t  \r\n测试场景梳理：\r\n1，并发有vgd未提交场景\r\n2，vgd回收，查询太老\r\n3，vgd锁不够场景\r\n4，转换失败场景\r\n5，查询FREE slice场景\r\n6，并行写入，写到同一个slice场景\r\n\r\n准备一个用例，写入1千万数据，\t\t\t\t  \r\n\r\n\r\n40cc44121ed5a3768d4079ab2bced778ad344551\r\n8321b1767268abdd5dd10e68898199c02281d0ce\r\n\r\n\r\n待办：\r\n1，支持转换失败的事务处理\r\n2，梳理其他原子操作存在的问题\r\n3，分析死锁检测机制\r\n\r\n\r\n行为的原子性\r\n  原子性是动作的内在需求，比如将任务标记为stale，那么就一定要生成task，否则就存在动作遗漏。\r\n  原子性动作中哪些操作不必回滚？\r\n       最后一个动作可以不回滚？ 不行，假设最后一个动作执行完挂了，其他动作回滚了，就这动作没回滚，可能逻辑上也有问题。\r\n\t    \r\n       哪些元数据操作不必回滚？     \r\n  行为的回滚\r\n  是否事务内的每个持久化动作都需回滚？或者说哪些行为副作用是允许在事务中存在的。\r\n      不回滚的前提是对后续行为不产生影响，有些行为本身没有影响，比如设置页面的checksum。\r\n\t  其是依附性动作，数据回滚其也顺带修改，因而不单独回滚。虽然有副作用，但是没人去读取这些数据。\r\n\t  还有一种是通过check的方式，有些值其本身不影响行为。\r\n\t  \r\n  \t  \r\n  \r\n行为的可重复性\r\n行为对于其他行为的可见性\r\n   如果行为A发生就对其他行为可见，则其即便记录undo，也不具备可回滚性。\r\n   即不可见是回滚的前提，不能脏读。\r\n   \r\n1，即便segment 创建成功，写状态这步仍然要支持回滚，否则kill掉重启segment回滚，而状态仍然在。\r\n   动作间的因果关系。\r\n   \r\n1，如果状态为invalid就执行初始化动作\r\n2，初始化动作\r\n2.1 创建一个segment\r\n2.2 修改入口\r\n3，加载dc\r\n4，修改状态为active，变成可用。\r\n\r\n写后读，读与读，读后写\r\n\r\n事务所需处理的问题：\r\n1，掉电\r\n2，并发\r\n3，网络\r\n\r\n语义一致性：\r\n1，原子操作\r\n   redo日志，redo/undo日志。\r\n2，隔离级别(提高并发能力)\r\n   \r\n3，锁\r\n   \r\n   \r\n1，给truncate或init记录undo\r\n  init可以不计，因为create segment动作，与记录entry到vgd没有关联。\r\n  但是truncate有问题，因为truncate会读entry，如果不回滚，则truncate传入错误的segment入口。\r\n  有了这层因果关系。\r\n1.1 合并truncate和init  \r\n1.2 高水位也有问题，直接去掉吧\r\n\r\n\r\ninit步骤：  \r\n  1，read state\r\n  2，create segment -> entry\r\n  3, write entry to vgd meta\r\n  4，load dict\r\n  5, set state to active\r\n  \r\n  第4，5步要满足并发可见性，active之后其他事务就可写，即第5步不可回滚。\r\n  因而将2，3步骤包装为自治事务，其是4，5的前提，因而也不能回滚。\r\n  第2步需回滚，否则失败无法释放空间。\r\n  第3步无所谓，即便第二步失败，重新执行不影响。\r\n  \r\ntruncate步骤：\r\n  1，read state\r\n  2，read old_seg_entry\r\n  3, drop segment\r\n  4，create segment -> entry\r\n  5, write entry to vgd meta\r\n  6，load dict\r\n  7, set state to active  \r\n  这里与init区别主要在于第2步，如果第5步不回滚。\r\n  \r\n  \r\ntruncate slice步骤：\r\n不能set free之后再失败，即free状态必须与任务完成在一个事务。\r\n\r\n转换步骤：\r\n设置状态应该与转换任务生成在一个事务。但由于其会立即对其他事务可见，因而需放在清理步骤中。\r\n\r\n问题在于上述步骤与读写时扫描vgd是否冲突：\r\n关键在于读取状态，\r\n\r\n方案：\r\n1，写一个changeState的undo。支持回滚该标记。\r\n2，读状态时看xslot是否需清理来设置状态。\r\n\r\n\r\n\r\n\r\n状态都是立即可见的，由xslot来清状态，读取状态时也提供接口来读取。\r\nset full除外\r\n  \r\n\r\n2，spfVgdTruncate没有drop segment   \r\n\r\n3，truncate slice期间的读如何确保不被破坏？\r\n\r\n当前写入的vgd，保存在内存中。\r\n插入时顺序找，使用dc锁保护。\r\n因为其不具备可回滚性，如果init失败。\r\n\r\n入口的管理：\r\n\r\n1，首先检查当前vgd状态，如果不可写入。\r\n2，那么进入切换逻辑。\r\n   拿着spinlock\r\n     拿下一个vgd，\r\n\t scn\r\n\r\n并发场景还是得有锁。\r\n1，一个线程在转换且成功，另外一个线程检查状态确定是否可读。\r\n   \r\n   \r\n具体问题：\r\n1，线程1转换\r\n2，线程2读取状态，发现free并回收\r\n3，线程3读取状态\r\n\r\n多次读取状态，其内容怎么保证？   \r\n   \r\n   \r\n有1... N 个VGD。\r\n其上有插入，查询，分配，truncate，转换等操作。\r\n需要满足以下要求：\r\n1，插入尽可能发生在同一个vgd上\r\n2，插入满了且其上所有事务完成，就进行转换。\r\n3，转换可能发生在查询时。\r\n4，truncate后得slice可以重新插入。\r\n\r\n并发2个关键点：\r\n1，决定当前写入哪个vgd必须只能一个线程\r\n2，分配，truncate，转换操作只能一个线程执行\r\n3，获取状态\r\n   \r\n能随时发生得只有获取状态，如何保证获取状态是正确的？\r\n比如查询检查了leastScn，然后再去获取状态，决定了查询vgd，但是查询过程中被truncate了。\r\n导致dataoid不一致报错。\r\n刷leastScn的动作也不能随便放，这动作也不好回滚。\r\n\r\n插入过程\r\n1.1 查找待插入vgd(此步骤不可并发)\r\n1.2 加vgd lock\r\n1.3 写入\r\n1.4 满报错，将vgd状态置为full, 则goto 1.1.\r\n\r\n\r\n插入过程：\r\n1，拿到当前插入slot，slot记录在dict上。\r\n   读取当前可插入slot。\r\n2，写入\r\n3，报错，则进入切换流程。\r\n\r\n切换流程：\r\n1，将某个slot置为full\r\n2，查找可插入位置。\r\n3，初始化，如果需要的话。\r\n4，或truncate，如果需要的话。\r\n\r\n查询流程：\r\n1，判断某个VGD可见性\r\n   如果判断完，vgd被清除那就按照snapshot too old处理。\r\n   问题是多久可以回收呢？目前按尽快回收策略，truncate优先级高于invalid slot。\r\n   \r\n\r\n启动转换流程：\r\n1，在查询或插入时发现转换任务启动。 通过pending锁保证并发。\r\n\r\n结束转换流程：\r\n1，只有一个线程执行。\r\n\r\n下面来考虑并发场景：\r\n1，插入与插入并发\r\n   由vgd内部做并发保护\r\n2，插入和切换并发\r\n   插入拿到vgd后，加vgd lock，然后立即full了，插入失败。\r\n   这里如果vgd已经full，则加vgd lock会失败。\r\n   所以只要vgd lock加成功就说明还没full，不可能进入stale状态。\r\n   \r\n3，插入和启动转换流程并发 \r\n   这里主要是状态处理。\r\n   通过vgd lock确保插入的vgd不会被转换\r\n\r\n4，查询与切换\r\n   如果切换回收了vgd，查询去查，要确保visible的vgd的dict是有效的。\r\n   貌似保证不了，因为是直接更新vgd dict, XXXXX.\r\n   查询自己保留副本。\r\n   \r\n5，ddl与查询\r\n   没有表锁保护，转换过程是否会被多个线程发起？\r\n\r\nmeta模块提供的接口：\r\n1，GetCurrentInsertVgd\r\n2, SwitchVgd\r\n3, IsVgdConvertable\r\n4, isVgdVisible\r\n5, lockVgd\r\n6, delete VGd (标记删除) \r\n7，convertVgd (启动转换)  \r\n\r\n\r\ngetFreeVgdSlot\r\nsetVgdSlotInfo\r\nisVgdVisible\r\n\r\n树状的锁，树状的行为分解。锁的分析方法。\r\n\r\nDict锁有效的前提是没有发生truncate。否则会另外生成dict版本。\r\n这是通过表锁来搞定的。\r\nDict的spinlock的有效期是insert期间，或truncate期间。\r\n但是查询没加锁，因而没保障。\r\n\r\n!!!那些状态应该放在内存，而哪些状态又需放在持久化上。\r\n   用于并发控制的状态通过页面锁来保证是非常扯淡的，这样事务机制会非常复杂。\r\n   状态不好回滚，具备立即可见性。\r\n\r\n1，先把LSC查询的表锁给加上，支持查询期间进行转换。\r\n2，插入dict的有效期是插入期间，因而可以使用dict来维护最新的状态。\r\n   \r\n\r\n\r\n\r\n   \r\n\r\n	\N	\N	17	\N	3	\N	5	0	2021-11-15 17:51:58.69972	2021-11-15 17:51:58.69972	2021-11-15	0	\N	\N	987	1	2	f	\N
273	7	16	完成V5.3.0任务695		\N	\N	19	\N	3	\N	5	0	2019-02-18 07:21:40.514568	2019-02-18 07:21:40.514568	2019-02-18	0	\N	\N	273	1	2	f	\N
135	6	1	关于磁盘的cache	1，RAID卡cache和磁盘cache是两回事\r\n2, 查看raid卡cache:\r\n查询缓存模式：\r\n     /opt/MegaRAID/MegaCli/MegaCli64 -LDGetProp -Cache -LAll -a0\r\n\r\n批量命令：\r\n    for i in {1..8}; do /opt/MegaRAID/MegaCli/MegaCli64 -LDGetProp -Cache -L$i -a0; done\r\n或者\r\n     /opt/MegaRAID/MegaCli/MegaCli64 -LDGetProp -Cache -LAll -a0\r\n\r\n\r\n设置缓存模式：\r\n     /opt/MegaRAID/MegaCli/MegaCli64 -LDSetProp WT  -L0 -a0\r\n或者 /opt/MegaRAID/MegaCli/MegaCli64 -LDSetProp WT  -LAll -a0\r\n\r\n3，查看磁盘cache\r\n查询HDD/SSD的cache是否开关：\r\n关闭HDD/SSD的cache：\r\n/opt/MegaRAID/MegaCli/MegaCli64 -LDGetProp -DskCache -LALL -aALL\r\n/opt/MegaRAID/MegaCli/MegaCli64 -LDSetProp -DisDskCache -LALL -aALL\r\n\r\n4，仅仅关闭raid卡cache，在掉电情况下，仍然可能丢数据\r\nhttps://www.thomas-krenn.com/en/wiki/RAID_Controller_and_Hard_Disk_Cache_Settings\r\n\r\n5，O_SYNC,O_DSYNC不一定靠谱\r\nO_SYNC或者fdatasync时   os会构造一个带REQ_FLUSH的bio  最终会发flush或者FUA命令给磁盘的     所以大部分情况下是会保证磁盘的cache也刷到介质中去。\r\n有的情况  比如flashcache混合盘，根本就不处理flush命令，还有国科微的盘 支持得也不好。\r\n\r\n有RAID卡的环境这块支持可能也有问题，在测试中出现了journal损坏的情况。磁盘cache是打开的，虽然journal open时使用了O_DSYNC仍然靠不住。	\N	\N	17	\N	3	\N	5	3	2018-10-25 12:51:34.547721	2018-12-18 10:32:43.181541	2018-10-25	0	\N	\N	135	1	2	f	\N
247	6	1	明天事务	V5.2.0: 1052问题复现\r\nV5.2.1-tencent:合入unorder list，以及支持从内存读取统计信息\r\nV5.3.0：合入rgw reload修改。	\N	\N	17	\N	3	\N	5	0	2019-01-22 19:53:54.536775	2019-01-22 19:53:54.536775	2019-01-22	0	\N	\N	247	1	2	f	\N
377	6	7	开源协议	https://blog.csdn.net/testcs_dn/article/details/38496107\r\n\r\n一张图即可看明白	\N	\N	17	\N	3	\N	5	1	2019-05-05 12:59:15.750008	2019-10-12 06:41:21.464327	2019-05-05	0	\N	\N	377	1	2	f	\N
214	6	9	平生愿	做一两款用户喜欢的产品，以聚友类。\r\n\r\n精通计算机技术，一方面养家糊口。另外也是做产品必须的。\r\n\r\n其他养好身体，搞搞娱乐，享受世间美好事物即可。	\N	\N	17	\N	3	\N	5	5	2018-12-23 21:42:51.48592	2019-03-06 19:25:17.9675	2018-12-23	0	\N	\N	214	1	2	f	\N
213	6	6	竞争让世界不断前进，但选择的是深渊还是末路未可知	当一个帝国崛起之后，其会稳固其领导地位。\r\n而其他国家则试图在技术，以及其他方面创新从而实现自己的崛起。\r\n\r\n封建时代，中国无疑算是非常成功的，虽然中间几次沦落，但是那时辱民政策的恶果。\r\n如今的机会可能在于打开新的潘多拉魔盒，就像信息革命和工业革命一样。\r\n\r\n但人是否过得更好并非一定是选择方向。尤其是专制政府下。\r\n\r\n中国很可能有机会开启下一个魔盒，释放出新的魔鬼。	\N	\N	17	\N	3	\N	5	1	2018-12-23 21:06:17.259425	2018-12-23 21:06:41.421272	2018-12-23	0	\N	\N	213	1	2	f	\N
248	3	1	bucket海量对象下的风险	1，像gc，usage，notify等默认值都太小，不利于分散到不同的osd。\r\n可缓解在局部osd压力大时，造成请求阻塞的情况\r\n\r\n2，所有删除丢到gc显然不合适。gc压力巨大。	\N	\N	17	\N	3	\N	5	0	2019-01-25 13:02:40.067934	2019-01-25 13:02:40.067934	2019-01-24	0	\N	\N	248	1	2	f	\N
252	6	5	暗礁	当下格局，水下暗礁。这些是需要探明的。\r\n兵者国之大事，软件也是如此。怎么随便漏过，\r\n工程是工程，算法的重要性不言而喻。\r\n\r\n\r\n\r\n\r\n政治，	\N	\N	17	\N	3	\N	5	0	2019-01-28 00:11:40.791467	2019-01-28 00:11:40.791467	2019-01-28	0	\N	\N	252	1	2	f	\N
367	8	17	beas整体架构，能否beas包含pg	beas的实现除了将beas功能内置为pg的子模块内，还有一种可能是将beas作为外部，内部把pg包住。	\N	\N	17	\N	3	\N	5	2	2019-04-28 14:10:41.305659	2019-04-29 07:45:02.257601	\N	0	\N	\N	367	1	2	f	\N
211	3	1	RGW框架调整	多站点：\r\nzone 对应的公有云的region\r\nbucket位于某个zone，就是bucket的源zone。如果数据在其他地方写入，则需同步回源zone。\r\n如果在其他地方读取数据，从默认从源zone拉取数据，应用不必感知。\r\n\r\n可以支持bucket迁移zone，后端数据可通过后台任务同步到其他zone。\r\n\r\nuser是跨zone的，可以查看user在各个zone的使用情况。\r\n\r\n多故障域：\r\nzone里面有st_pool,data pool，ia_pool等，支持数据以随机方式写入一种类型的pool，当\r\n同类型的某个pool故障或使用率过高时，可禁止新对象写入。 应用不需感知placement（实际上对于应用\r\n这也是非常麻烦的）\r\n\r\n\r\nbucket index：\r\n可考虑仍然使用rados存储的方案，但是对象按照范围组织成index，并且支持range split。以\r\n支持bucket的海量数据。	\N	\N	17	\N	3	\N	5	4	2018-12-21 07:11:21.271592	2018-12-28 07:24:50.354908	2018-12-21	0	\N	\N	211	1	2	f	\N
253	3	1	大规模	大规模下如何收集日志，快速定位问题。\r\n大规模下，一些服务的独立\r\n有些地方不必非得一致性，满足业务的当下最佳方案。	\N	\N	17	\N	3	\N	5	1	2019-01-28 00:11:58.19366	2019-01-30 11:48:06.282638	2019-01-28	0	\N	\N	253	1	2	f	\N
376	8	17	PG如何处理各种字符编码？	如何存储不同的字符编码？ 如果系统使用不同编码会有问题吗？	\N	\N	17	\N	3	\N	5	0	2019-05-05 12:29:24.132295	2019-05-05 12:29:24.132295	\N	0	\N	\N	376	1	2	f	\N
217	6	7	vlan学习笔记	1，vlan是用于企业内网络隔离的，隔离的好处就不说了，能解决各种问题。\r\n2，vlan需解决的问题：交换机如何配置支持，路由器如何支持。\r\n因而提出了交换机vlan配置，trunk配置（解决vlan跨交换机的效率问题）。\r\n也有了路由器trunk配置（解决vlan间通信问题）\r\n3，但是路由器trunk设置方式效率不好，因为都得经过trunk端口。\r\n因而出现了三层交换机，vlan之间的包不必经过路由器回转，提高了效率。	\N	\N	17	\N	3	\N	5	1	2018-12-30 12:49:39.082883	2018-12-30 13:26:07.165059	2018-12-30	0	\N	\N	217	1	2	f	\N
218	6	7	vxlan学习笔记	vlan的问题在于其在链路层协议实现，bit位为12，这对于企业是够用的。但是对于云场景不够用。\r\n因为存在大量的虚拟机，需要使用网络隔离。\r\n\r\nvlan的解决方法是在链路层之上，增加8bytes的标示。	\N	\N	17	\N	3	\N	5	1	2018-12-30 13:25:56.588387	2018-12-30 13:37:00.046489	2018-12-30	0	\N	\N	218	1	2	f	\N
220	6	7	学linux具体学什么	任务隔离，多租户。\r\n任务调度，Qos控制。\r\n资源隔离与使用策略。 内存管理\r\n同步协同。\r\n通信\r\n存储\r\nIO	\N	\N	17	\N	3	\N	5	0	2018-12-31 15:43:43.477616	2018-12-31 15:43:43.477616	2018-12-31	0	\N	\N	220	1	2	f	\N
219	6	7	linux 信号		\N	\N	17	\N	3	\N	5	2	2018-12-31 08:34:43.873902	2018-12-31 15:26:13.409004	2018-12-31	0	\N	\N	219	1	2	f	\N
277	8	17	伯克利 serverless概念？		\N	\N	17	\N	3	\N	5	0	2019-02-20 08:45:17.844645	2019-02-20 08:45:17.844645	\N	0	\N	\N	277	1	2	f	\N
276	7	17	熟悉pg 11.2		\N	\N	19	\N	3	\N	5	1	2019-02-20 08:44:35.916893	2019-02-20 09:02:09.236429	2019-02-20	0	\N	\N	276	1	2	f	\N
370	6	7	数理逻辑-命题范式	范式是把命题公式中蕴含，等价，非 进行转换后只包含合取，析取，非的比较精简的格式。\r\n其中蕴含，等价，非可以用相应的等价形式做转换。\r\n\r\n命题范式化是为了方便命题的计算的。	\N	\N	17	\N	3	\N	5	1	2019-04-28 18:13:06.671141	2019-05-06 19:58:11.218308	2019-04-28	0	\N	\N	370	1	2	f	\N
816	6	29	3.19(coral执行计划)	step 1：单机版\r\noos：object operaton system\r\n\r\nsubmodule：interface。\r\nhandler：a handler for oos \r\nobjpool: a uri to describe it\r\nop: object, type, action\r\noplog: record op in order\r\ncursor: take op on a objpool\r\nregister:\r\nlocker：\r\nsubmit_aio: do not wait, release lock here.\r\n\r\n启动1个线程，刷log以及维护内存中object。\r\n启动一个线程，定期读取log并执行。这里还有一个objcache。\r\n对接s3接口。\r\n\r\nlock模块设计：如何按事务组织log\r\nobjectLog模块设计：\r\nobjectCache模块设计：\r\njournal模块设计：怎么管理log文件\r\nsync模块：\r\n\r\n\r\n\r\nstep 2：多机版\r\n支持发送日志给reader。\r\n支持trim\r\n在此基础上实现libcoral，完成stable slice的操作接口。也可以用rust。\r\n\r\n\r\nrust精要，先花一周整理下\r\n4.30 完成liboos, libcoral的大体实现。\r\n5.30 支持coral表的各种操作	\N	\N	17	\N	3	\N	5	0	2021-03-19 06:20:22.898841	2021-03-19 06:20:22.898841	2021-03-19	0	\N	\N	816	1	2	f	\N
215	3	1	rgw当前缺陷总结	1，realm配置变更时，rgw reload，一方面可能中断业务，另外可能因为资源依赖导致reload时rgw挂掉或可能hang住。\r\n2，多站点特性，多边同时执行put和删除操作，可能导致一边对象未删除，多出对象。\r\n3，老版本删除，和多出版本删除等gc操作在前端实现，在并发时可能引起本该删除的老对象没及时删除。\r\n4，rgw使用libfcgi存在风险，libfcgi在accept循环中读取头部数据\r\n5，osd在压力大时，可能出现slow request， peering卡住等问题\r\n6，osd恢复qos控制效果不好\r\n7，在某些场景下，掉电会出现db损坏问题。\r\n8，用户Qos，低tps用户发送大量请求可能阻塞高优先级用户。	\N	\N	17	\N	3	\N	5	15	2018-12-27 11:36:57.971397	2019-04-09 07:47:28.490194	2018-12-27	0	\N	\N	215	1	2	f	\N
230	3	1	多站点数据不一致问题	方案1：\r\n1，在对象删除后，并非立即将bi删除，而是增加删除标记。并且将对象实例丢入待清理列表\r\n2，在获取对象mtime时，获取含删除标记的对象的mtime。\r\n3，后台任务，在一段时间后清理删除标记。这里可启动新的后台任务，而非gc。\r\n\r\n问题：如何确定对象已经被同步？多久之后清理？\r\n注意：需考虑bucket删除等交叉场景。\r\n\r\n方案2：\r\n1，所有删除操作都不直接清除对象实例，而是将实例rename或打标记\r\n2，修改gc实现，gc扫描bi获取已删除对象进行删除。\r\n\r\n方案2的问题在于对于大量对象的bucket，这种遍历代价有点高。\r\n采用rename的方式以目前cls的方式实现问题不大，但是逻辑上稍微复杂些，\r\n除了按instance名字查询对象实例mtime，还得额外查询rename之后的key，后续架构调整的目标是慢慢弱化cls。\r\n\r\n方案3：\r\n1，bucket都启用多版本	\N	\N	17	\N	3	\N	5	2	2019-01-09 15:01:20.671079	2019-01-10 09:45:51.316678	2019-01-09	0	\N	\N	230	1	2	f	\N
337	6	8	刺	人在成长过程中难免遇到很多困境，就像生长过程中遇到的刺一样。\r\n遇到刺，有三种不同方式面对，一是退回来或弯曲生长。二是默默承受，最终刺变成自己一部分。\r\n三是理解刺是成长路上正常存在的，然后积极应对处理。然而在我们还小的时候很难正确应对。\r\n\r\n在往后的机会中，我们仍然有机会自我诊断或寻求帮助，扶正自己或拔出体内的刺。\r\n	\N	\N	17	\N	3	\N	5	0	2019-04-16 07:38:42.069316	2019-04-16 07:38:42.069316	2019-04-16	0	\N	\N	337	1	2	f	\N
231	6	7	解bug的总结	1，科学严谨\r\n必须分析清楚根因，否则就是镜花水月\r\n在什么情况下必现，解决之后，不再出现。\r\n\r\n2，采用非常规手段，创造复现条件\r\n\r\n3，正确的看待问题的价值\r\n问题就是知识，搞透了就是高手。	\N	\N	17	\N	3	\N	5	0	2019-01-10 13:58:03.123803	2019-01-10 13:58:03.123803	2019-01-10	0	\N	\N	231	1	2	f	\N
254	8	7	关于软件工程		\N	\N	17	\N	3	\N	5	3	2019-01-28 07:23:49.989991	2020-06-23 14:20:49.750791	\N	0	\N	\N	254	1	2	f	\N
235	3	1	对象实例的版本是否继承自对象？	目前ACL属性分别在不同的对象实例上。但是ACL控制可能针对的是对象。	\N	\N	17	\N	3	\N	5	0	2019-01-15 15:43:30.375866	2019-01-15 15:43:30.375866	2019-01-15	0	\N	\N	235	1	2	f	\N
237	6	1	tombstone cache	obj_tombstone_cache\r\n\r\n这个cache是解决多站点同步时，一边删除对象。然后同步对象put请求时可能出现的时序混乱问题。\r\n\r\n在我们将业务与同步rgw分离之后，该机制失效了。	\N	\N	17	\N	3	\N	5	0	2019-01-18 15:26:14.257888	2019-01-18 15:26:14.257888	2019-01-18	0	\N	\N	237	1	2	f	\N
385	7	17	Sds改造	1，将sdsnewlen 改为传入一段内存，且包含长度。\r\n   如果长度不够，则截断	\N	\N	19	\N	3	\N	5	1	2019-05-09 15:31:12.370691	2019-05-09 16:40:32.879762	2019-05-09	0	\N	\N	385	1	2	f	\N
242	6	6	战胜之道	战略需考虑趋势，力量的天平，屁民的共识，欺骗的力量。\r\n毛吸收的是老百姓。就像互联网吸收的是屌丝。\r\n这就是淘宝战胜ebay的方法。也是360战胜其他杀毒的方法。\r\n胜利的残忍和嗜血，老毛的阶级斗争，宣扬敌对。	\N	\N	17	\N	3	\N	5	0	2019-01-21 20:40:55.296393	2019-01-21 20:40:55.296393	2019-01-21	0	\N	\N	242	1	2	f	\N
245	6	7	业务系统对于元数据管理的需求	一定要用数据库么? 代价是什么？\r\n非要ACID？ \r\n非常方便的查询是不是很诱人。	\N	\N	17	\N	3	\N	5	0	2019-01-21 21:08:00.937381	2019-01-21 21:08:00.937381	2019-01-21	0	\N	\N	245	1	2	f	\N
249	8	15	关于等待状态下，拍子位置的问题	观察比赛选手，在防守姿态下，通常拍子还是斜下放置的，但是并非排头掉在地下的那种。\r\n而当对方出球后，根据1，落点判断 2，思考的回球位置与线路。然后决定是否提前举拍。\r\n\r\n显然通常来得及的情况下，都是压制。\r\n次之的是调度分球。\r\n最次的就是不到位，迫不得已的起球。\r\n\r\n放斜下是有道理的，可以较好的处理快速的杀球。这是最有威胁的。	\N	\N	17	\N	3	\N	5	0	2019-01-27 21:38:56.98924	2019-01-27 21:38:56.98924	\N	0	\N	\N	249	1	2	f	\N
250	8	15	关于羽毛球中的平衡问题	高手对决，都会有多回合，不断的寻找破绽。平衡不好，则无法连贯。\r\n1，发力过程的平衡\r\n2，收力的平衡\r\n3，站位的平衡\r\n你看盖聂出招，非持剑手是随之而动的。腿的位置与转腰是有关系的。	\N	\N	17	\N	3	\N	5	0	2019-01-27 21:44:40.961616	2019-01-27 21:44:40.961616	\N	0	\N	\N	250	1	2	f	\N
251	6	15	关于身体的放松	放松的感觉是什么？\r\n\r\n你知道击球瞬间还很远，此刻我不必惊慌。\r\n在对手击球后，观察球路，你知道要将爆发力留在击球瞬间，在此之前的跑动，架拍都是放松的。\r\n\r\n心态上，胜负不需看的太重。反正都是促进自己技术进步的。\r\n另外无惧强敌，保持自信非常重要。\r\n\r\n当你想变得更快，更合适时，自然就放松了。	\N	\N	17	\N	3	\N	5	2	2019-01-27 22:03:25.270647	2019-01-27 22:07:01.524607	2019-01-27	0	\N	\N	251	1	2	f	\N
222	6	9	优缺点分析	朋友之间，承诺非常重要。 承诺意味着必须做到。这也是朋友难得的原因，是需要用真诚付出来交换的。\r\n\r\n而我之前表现上有2问题：\r\n1，很少对别人承诺什么，即便是非常亲近的人\r\n这点说明人不是很重情谊，较少考虑别人的感受。\r\n其实设身处地从别人角度看问题， 才能看得更加全面和真实。\r\n\r\n2，在集体行动中，很少trace一些事情。\r\n如果没有负责人，作为队员，至少提出问题。\r\n	\N	\N	17	\N	3	\N	5	1	2018-12-31 22:44:26.835196	2019-03-07 10:05:03.887653	2018-12-31	0	\N	\N	222	1	2	f	\N
212	6	6	计算科学的本质	计算机本质上是逻辑，逻辑在任何行业都存在，所以计算机具备了改在其他各行各业的基础。\r\n\r\n就这是计算的本质。\r\n\r\n哲学与科学是相辅相成的，哲学上提出理性，感性，逻辑这些概念之后。\r\n古典那种模糊的理性就并非真的理性。\r\n\r\n计算机世界塑造万物的内核就是逻辑，事物的表象，呈现是逻辑在外在的表现。\r\n这是一种世界观。在计算机的世界上，人就像上帝一样。\r\n\r\n逻辑依赖于计算机这个实体，实体会因为材料，工艺等技术进步得以升级。\r\n\r\n人工智能是迈向人探索复杂算法的一步，未来毕将走得更远。\r\n如何理解这种复杂性？还是大道至简，使用简单粗暴的方法就能得到智能化。目前看确实走在这条路上。\r\n\r\n我他妈就喜欢简单粗暴。不断迭代逼近。\r\n这世界上有些问题复杂在于人的认知上难以纠正。另外有些问题复杂在于人不知道如何分类分治。	\N	\N	17	\N	3	\N	5	3	2018-12-23 09:49:09.147361	2019-09-22 14:59:18.79284	2018-12-23	0	\N	\N	212	1	2	f	\N
274	6	7	大数据与AI	https://juejin.im/post/5ad4b620f265da23a04a0ad0\r\n文中提及的模型比较有意思。大数据处理是f()/x, 输出是y。\r\nAI输入是x/y，输出是f(). 拟合各种函数。	\N	\N	17	\N	3	\N	5	2	2019-02-18 08:19:02.806912	2021-05-22 15:07:51.80005	2019-02-18	0	\N	\N	274	1	2	f	\N
319	6	20	职业生涯规划-小章鱼之早会篇	时间：2019年3月22日8:30-9:30\r\n地点：能源大厦11楼\r\n人物：友邦保险深圳分公司吉大家族所有人员，分享嘉宾郑先桃\r\n参与理由：想了解保险代理人的工作流程及状态\r\n收获：\r\n友邦周五的早会主要内容是优秀代理人分享，外加业绩及活动的告知！\r\n1、首先人生有很多中可能性，其次就是用尽全力去正在做的每一件事情；\r\n2、从事销售，需要极度的自律，才能收获果子，销售首先是要销售自己，展现出自己的专业度。\r\n3、给自己一个激励自己的长期目标，在困难的时候可以让自己坚持下去，这也许就是信念的力量！\r\n\r\n\r\n行动：\r\n# 目前和小章鱼见面3次，其中1次是职业生涯咨询，1次是下午茶会，1次是每周五早会，她没有太多的去追问我的感受，只是在讲诉她在做些什么，这样一种姿态，虽然背后一定是有一目的性的，但会让人觉得不功利。今天微信表达了对她的感谢！\r\n【今天，谢谢雨晨，给我提供一个参加你们早会的机会，很开心能够看到桃子还有波姐这样优秀的人，还有你。通过第一次见面还有参加早会及下午茶会，给我最大的触动就是人生有很多中可能性，其次就是用尽全力去正在做的每一件事情。你也给了我很多启发，我正在践行、探索及思考，下次再跟你分享哈！】\r\n# 用半个小时的时间文字记录感受。	\N	\N	17	\N	3	\N	6	0	2019-03-22 08:40:54.351721	2019-03-22 08:40:54.351721	2019-03-22	0	\N	\N	319	1	2	f	\N
275	6	9	过程与结果	马老师说 没有过程无法复制，没有结果没有价值	\N	\N	17	\N	3	\N	5	0	2019-02-19 09:50:52.062286	2019-02-19 09:50:52.062286	2019-02-19	0	\N	\N	275	1	2	f	\N
244	6	6	问题与求解	1，问题分析\r\n2，案例查找\r\n3，借用相似案例\r\n4，识别出问题不一样的地方，并理解其本质\r\n5，采用新方案，或改进老方案。	\N	\N	17	\N	3	\N	5	1	2019-01-21 20:56:24.822774	2019-03-23 15:13:51.132536	2019-01-21	0	\N	\N	244	1	2	f	\N
1005	6	24	三大存储引擎	TAC特点：列存 + 可变更\r\n1，高效投影运算，减少无效数据读取\r\n2，利于向量化计算\r\n\r\nLSC特点：列存 + 不可变更\r\n由此扩展的特性：\r\n1，编码压缩\r\n2，重排序，稀疏索引过滤\r\n3，准确的统计信息，预计算，特征分析\r\n\r\n预计算就是第三个引擎，基于LSC数据极少变更的特点做预计算。\r\n比如cub，ac等。	\N	\N	17	\N	3	\N	5	1	2022-01-26 13:40:56.168731	2022-01-27 12:36:13.196246	2022-01-26	0	\N	\N	1005	1	2	f	\N
271	7	16	考虑清楚V6版本多站点这块能做哪些改造	1，采用push方式。\r\n简单模型，同时方便实现向第三方存储同步数据（容灾，备份，以及归档等）\r\n\r\n2，采用独立组件，以及配置来运行。\r\n调用通用的写入接口来实现。\r\n\r\n3，考虑支持优先级队列，Qos控制等等。	\N	\N	19	\N	3	\N	5	5	2019-02-16 14:42:10.635769	2019-02-23 14:59:31.802244	2019-02-16	0	\N	\N	271	1	2	f	\N
694	6	9	延迟满足的本质	延迟满足本质上是让人摆脱杏仁核控制，运行理性思维。\r\n比如玩游戏，比如赌博，嫖娼，贷款都在利用人满足自己欲望的思想。\r\n\r\n立即满足欲望，会让人无法运行最佳算法。	\N	\N	17	\N	3	\N	5	0	2020-09-13 05:58:00.492551	2020-09-13 05:58:00.492551	2020-09-13	0	\N	\N	694	1	2	f	\N
283	6	1	服务框架解决负载均衡问题	在整个系统中设置接入的高可用服务。业务rgw启动后向其注册服务。\r\n该服务可向client分配业务rgw的endpoint。\r\n\r\n1，可制定灵活的分配规则。以及从端站点的利用。endpoint与region有关联。\r\n2，管理业务rgw的状态。根据状态确定endpoint是否可用。\r\n3，单个endpoint可配置HA，当然也可配置负载均衡。\r\n	\N	\N	17	\N	3	\N	5	2	2019-02-25 09:54:38.11807	2019-02-25 10:38:20.96612	2019-02-25	0	\N	\N	283	1	2	f	\N
321	6	8	为何要战	道不同，以光大本道。破除邪道。当人类走在分岔口。意识形态碰撞强烈时，战争就开始了。\r\n\r\n战争还有一种单纯的原因就是利益。在物质并非最贵资源的今天，以争夺资源为目标的战争缺乏存在的基础。\r\n但是利益之战仍然存在，其形态发生了改变。	\N	\N	17	\N	3	\N	5	1	2019-03-24 19:22:33.828936	2019-03-24 19:24:58.958456	2019-03-24	0	\N	\N	321	1	2	f	\N
284	7	16	梳理V5.3.0之前的问题单，分阶段解决	第一阶段：先解决重要且影响巨大的问题单	\N	\N	19	\N	3	\N	5	0	2019-02-26 07:07:59.947528	2019-02-26 07:07:59.947528	2019-02-26	0	\N	\N	284	1	2	f	\N
286	8	7	故障暴力重启 vs 故障细节处理	1，是提前分配内存，还是内存不够直接挂掉？\r\n2，恶性超时是直接退出，还是给客户端返错？\r\n3，watch失败是退出，还是设计重试机制？	\N	\N	17	\N	3	\N	5	0	2019-02-26 14:42:07.825817	2019-02-26 14:42:07.825817	\N	0	\N	\N	286	1	2	f	\N
1006	6	24	记一次内存暴涨，无法释放问题	https://blog.csdn.net/shenhuxi_yu/article/details/73149444?version=2.5.50000.157&platform=win	\N	\N	17	\N	3	\N	5	0	2022-01-27 15:26:11.713221	2022-01-27 15:26:11.713221	2022-01-27	0	\N	\N	1006	1	2	f	\N
272	6	9	什么是我	用数据发现价值	\N	\N	17	\N	3	\N	5	4	2019-02-18 07:19:54.648528	2019-04-04 21:57:58.792582	2019-02-16	0	\N	\N	272	1	2	f	\N
340	6	17	账号	Anew**422\r\n\r\n码云:jerry_xr86\r\njira:xierui\r\n\r\n	\N	\N	17	\N	3	\N	5	1	2019-04-22 11:51:48.034669	2019-04-22 14:33:28.849304	2019-04-22	0	\N	\N	340	1	2	f	\N
341	7	17	熟悉pg整体架构以及存储子模块	1，整体架构\r\n2，存储模块架构\r\n3，数据组织\r\n4，如何自定义系统表或视图	\N	\N	19	\N	3	\N	5	6	2019-04-22 12:35:35.257702	2019-04-23 15:01:52.30496	2019-04-22	0	\N	\N	341	1	2	f	\N
342	7	16	2019.4.23	1，弄清楚数学的发展脉络，离散数学的起源\r\n2，离散数学所能解决的问题。\r\n\r\n下午：\r\n1，学习pg整体架构	\N	\N	19	\N	3	\N	5	2	2019-04-23 06:33:02.212158	2019-04-23 10:41:18.580623	2019-04-23	0	\N	\N	342	1	2	f	\N
345	8	7	如何把理发师悖论描述成集合论的表达方式？		\N	\N	17	\N	3	\N	5	1	2019-04-23 18:31:21.457047	2019-05-02 19:07:01.972029	\N	0	\N	\N	345	1	2	f	\N
988	6	26	Rust类型系统，多态	一切皆类型，就跟我说一切皆实体一样。\r\n行为动作属于类型，因此大家对此的认知是一致的。\r\n\r\n泛型解决的是不同类型的重复行为的效率问题。这对于丰富类型系统的语言来说是必须的。否则需要为每种类型实现很多重复动作。\r\ntrait解决了三个问题：\r\n1，定义接口，对相同行为抽象\r\n2，对泛型的类型进行约束\r\n3，支持动态分发，运行时根据不同的类型调用不同的方法。	\N	\N	17	\N	3	\N	5	0	2021-11-28 21:30:24.485254	2021-11-28 21:30:24.485254	2021-11-28	0	\N	\N	988	1	2	f	\N
517	6	7	coding 为什么不能成为高手1	1，没有专注，写代码但脑中没有逻辑，经常反复修改一些低级错误，更别说高级的坑了。\r\n2，心里障碍，不敢正向推演，只能copy，模仿。\r\n3，并不真心热爱，因而学而不能掌握其本质，没有融会。反复在原地踏步。\r\n4，无法在真实世界中找到技术的存在，没有联想。如看不到数据结构与算法的无处不在。	\N	\N	17	\N	3	\N	5	4	2019-09-18 07:51:56.983751	2019-12-29 21:27:46.08966	2019-09-18	0	\N	\N	517	1	2	f	\N
285	8	7	分布式系统元数据是否应该独立于数据，避免性能干扰	比如rgw中list bucket，user等操作会被其他操作卡住。\r\nosd的消息接收队列长度有限制，其线程调度也有限制。\r\n\r\n而且这些数据IO量不大，不必额外占用磁盘。	\N	\N	17	\N	3	\N	5	0	2019-02-26 08:32:59.863796	2019-02-26 08:32:59.863796	\N	0	\N	\N	285	1	2	f	\N
279	8	7	LVM学习笔记-疑问	1，NAT模式\r\n所有流量都走DS（转发服务器），所以带宽受限。\r\nRS回Client的请求经过DS，因而RS要配置DS为默认网关。\r\n好处是DS控制一切，可以走端口转换。\r\n\r\n2，DR模式\r\n问题1：是否所有包都经过DS？还是仅连接建立的包经过。\r\n问题2：RIP对应网卡出去的包，源IP如何伪装为VIP？伪装为VIP之后是否意味着，后续请求都得经过DS？lo在其中扮演什么样的角色？\r\n问题3：伪装为VIP是因为TCP/IP 4元组要求么？\r\n\r\n3，tun隧道模式\r\n问题1，什么是隧道? \r\n	\N	\N	17	\N	3	\N	5	3	2019-02-21 19:05:58.301505	2019-02-23 09:12:17.648766	\N	0	\N	\N	279	1	2	f	\N
343	8	9	我想有一双眼睛，能看到事务的本质，而不仅是使用形式思维，归纳思维。		\N	\N	17	\N	3	\N	5	0	2019-04-23 14:22:50.206118	2019-04-23 14:22:50.206118	\N	0	\N	\N	343	1	2	f	\N
281	7	16	xx 环境从Jewel升级到L之后bucket list不到部分对象的问题	1，rados对象是否损坏\r\n2，格式不兼容？但是能list到部分是什么情况？\r\n3，纯粹找不到key，db损坏如何解。	\N	\N	19	\N	3	\N	5	1	2019-02-24 13:25:04.959421	2019-02-24 15:28:20.858271	2019-02-24	0	\N	\N	281	1	2	f	\N
282	6	1	rgw cache	特点：\r\n1，是使用system obj来实现的，所以凡是采用类似方法，不论更新频度如何都会使用上cache\r\n所以实际上同步状态的更新不适合用cache\r\n2，cache的通知是用rados watch/notify机制。该机制在watch超时等情况下可能失效。应该额外设计轮询机制\r\n保障其可靠性。或者在watch失败的情况下退出程序（太粗暴，直接影响业务可用性）。\r\n3，cache住的是数据内容，即bufferlist。在内存中使用的是结构体，但是rgw对于很多元数据如zonegroup，zone等信息在cache失效情况下，没有reload。而是采用period更新机制来刷新的。这个机制可能中断业务rgw。动作非常大。\r\n4，bucket和user信息额外设计了结构体的cache，在rgw cache失效情况下会同时使上层cache失效。\r\n\r\n应该将zone相关信息使用聚焦，不去使用cache。或者将zone信息不变部分或变化部分稍微分离。确保业务rgw的简单稳定。	\N	\N	17	\N	3	\N	5	0	2019-02-25 09:46:01.478326	2019-02-25 09:46:01.478326	2019-02-25	0	\N	\N	282	1	2	f	\N
344	6	7	数理逻辑-命题公式-蕴含	如果p,那么q 就是一个命题公式。\r\n\r\n比如狗急跳墙，这就是一个蕴含命题。狗急了，狗跳墙。\r\n你要证明这个命题为假，用反证法，就需要找到一条狗，它急了，但是没跳墙。\r\n\r\n这就是蕴含命题作为命题公式的语义。它表示了作为一个整体，它描述了一个命题作为整体的真值情况。	\N	\N	17	\N	3	\N	5	0	2019-04-23 18:27:32.943197	2019-04-23 18:27:32.943197	2019-04-23	0	\N	\N	344	1	2	f	\N
291	8	7	TO B的选择	我想把多站点做好是因为想打扫自己觉得不舒服的地方么？\r\n还是从研发角度认为该功能比较有价值。\r\n\r\n售前的出发点是做特性拿下更多客户。\r\n而作为研发想出发点是做好产品，推广给客户。	\N	\N	17	\N	3	\N	5	0	2019-03-02 10:08:57.755381	2019-03-02 10:08:57.755381	\N	0	\N	\N	291	1	2	f	\N
287	6	7	关于网卡	1，如何确定系统有几张物理网卡？\r\n2，网卡名称从何而来？\r\n3，如何确定网卡可用？\r\n4，网卡可用与是否连接到交换机有关系么？\r\n5，网卡ifdown本质是什么？\r\n6，ifcfg-eth 配置可以随便改么，该文件的名字一定要和网卡名称对应么？	\N	\N	17	\N	3	\N	5	2	2019-02-28 09:46:12.531481	2019-03-01 07:28:15.409733	2019-02-28	0	\N	\N	287	1	2	f	\N
288	8	1	ceph  degraded or misplaced	degrade的是根据acting set计算的，意思是集群的对象缺少多少份副本。\r\n比如一个3副本的对象，缺少2副本。则degraded就是2.\r\ndegraded = (副本总数 - acting副本数) * num_objects + missing[acting副本]\r\n\r\nmisplaced是根据up计算的。算法比较简单，就是看有多少对象需要调整位置，放到不同的osd上。\r\nmisplaced = （acting副本数 - (acting 与 up交集副本数)）* num_objects.\r\n\r\n所以degraded + misplaced = 需要recovery与backfill的对象总数	\N	\N	17	\N	3	\N	5	0	2019-03-01 14:08:28.916887	2019-03-01 14:08:28.916887	\N	0	\N	\N	288	1	2	f	\N
296	6	18	交流的套路	有4种人，客户，投资人，合伙人，供应商。\r\n与人交流无外乎几种情况。\r\n\r\n把与每个人交流的思路反复演练。把自己的产品定义好，推销出去，搞好营销。	\N	\N	17	\N	3	\N	5	1	2019-03-06 22:54:27.788418	2019-03-08 11:51:36.639655	2019-03-06	0	\N	\N	296	1	2	f	\N
292	6	8	关于人的原则	1，人最深沉的本性就是渴望得到别人的重视。\r\n2，人是恐惧而有贪婪的。\r\n3，人必须伪装，否则无法生活。而大部分人只有在深夜独处时才将内心的野兽释放出来。\r\n4，人通常生活在自己构造的虚假，幻像世界中。真实离人何其遥远。\r\n5，避险与拒绝担责是人的天性。\r\n6，世界上唯一能影响人的办法就是谈论其想要的，而且还要告诉他如何得到想要的。\r\n7，人只有为自己服务的时候才最在状态，这就是兴趣的力量。如果把这种服务分享给其他人就能产生价值。\r\n8，你的管理能力，取决于你能深入了解多少人，并且能从他们的立场来考虑问题。	\N	\N	17	\N	3	\N	5	1	2019-03-03 21:37:22.01719	2019-03-03 21:51:00.513682	2019-03-03	0	\N	\N	292	1	2	f	\N
294	6	9	没有一无是处的人	没有一无是处的人，如果感觉有，可能出现了如下情况：\r\n1，他放错了地方，做着不适合自己的事。\r\n2，他做了不适合自己当下的事，聪明有经验的人不提出自己的建议，新手笨拙的人不提出自己的疑问。\r\n张小龙还想一秒变傻瓜呢，有些人不用变，因为心中没有魔障。\r\n\r\n说起来就是空间与时间，位置领域与趋势时机。	\N	\N	17	\N	3	\N	5	1	2019-03-05 07:50:19.076898	2019-03-05 07:51:48.854283	2019-03-05	0	\N	\N	294	1	2	f	\N
295	6	9	关于第三次换工作的思考	2018年我自己总结是在忙，在学习，但是缺乏归属感，成就感。总之工作中我不算快乐，我的动力纯粹来源于对于问题的好奇心。\r\n不得不说，在推动工作进展，推动其他人共同进步上，我是非常乏力的。当然在面试人看人上同样乏力。\r\n\r\n故而我现在坚持这样的观点，我想确定自己真正热爱的事业是什么。如果这点没想清楚，这个人顶多是高级工程师。\r\n这点决定了在遇到困难时，它可能采取的态度，是去逃避还是面对。\r\n\r\n第二点，选择有想法，坦诚而开放的人。这也许不能直接决定自己的成败。但至少过程会更加快乐。同时也有助于在遇到困难时，直面现实并克服困难。\r\n选择优秀的人，并让他们承担重任。而不是找马虎可用的人，这点非常重要。马虎敷衍的人会让整个团队都拖慢。\r\n\r\n第三点，就是风险，能消除生活环境，以及基本的经济压力。\r\n\r\n马云说的钱不到位，心理委屈。还是有点片面的。\r\n心理不委屈，但是无法持续快速发展的环境人也是待不住的。无法助人达到目标。还有本来就没找到自己目标的人同样也是不稳定的。\r\n在他们看到新的目标之后，可能就会离开。\r\n\r\n目标上，我个人将解决存储问题转移到数据的价值发现问题，用科学工具，收集数据，运用算法分析，得出结论。这样我的智慧就会与日俱增。\r\n而我业余所思的零散想法也可以科学化。如果我将服务提供给其他人，我的财富就会与日俱增。我相信每个人都需要一个智囊团，我可以首先给自己\r\n建立一个智囊，建立起知识的宝库，让人类所有已知的经验，知识为我所用。让人发现知识的方式发生根本改变。\r\n\r\n这次换工作可以说调整为该方向，也许他们最终目标与我有点不一样，但是至少是同路的。\r\n另外从第二点上他们应该算不错的同路人。\r\n\r\n所以这次换工作我在观念上有2个转变：我同时是创业者与打工者。\r\n我将自己的问题通过软件给解决掉，并考虑提供服务。可以找人合作，甚至招人等。\r\n\r\n另外谈点私心，任何人不会把自己最核心的竞争力分享给大众，否则他们将失去竞争力。所以从别人那里拿到的肯定不是\r\n最fresh的，但是这同样有助于我们成长。最世界都是一部分人收着另一部分人的税。如果你把交易也看成对于自己不擅长领域的交税的话。\r\n当然这是正常的。大部分人可能都生活在假象与未知之中。想要收别人的税，我们得看到真实，保持优势。并找到缺乏我们拥有东西的对象，收他们的税。\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2019-03-06 21:15:59.987974	2019-03-06 21:15:59.987974	2019-03-06	0	\N	\N	295	1	2	f	\N
318	6	7	内存存储与磁盘存储的本质区别	内存具备随机访问，每个数据都有地址。速度快，掉电就没了等特点。\r\n\r\n磁盘或SSD存储只能按最小单位读取。掉电没关系。\r\n\r\n其核心区别还有一点：地址的表达形式不一样。内存可使用逻辑地址指针，而磁盘存储必须用用户定义的逻辑地址。	\N	\N	17	\N	3	\N	5	0	2019-03-21 20:55:02.434409	2019-03-21 20:55:02.434409	2019-03-21	0	\N	\N	318	1	2	f	\N
300	7	16	事宜	1，确定4月公积金等是否正常\r\n2，确定加班时间如何算\r\n3，会否有其他补偿，保密协议内容	\N	\N	19	\N	3	\N	5	0	2019-03-08 12:14:37.448123	2019-03-08 12:14:37.448123	2019-03-08	0	\N	\N	300	1	2	f	\N
339	6	7	工具收藏	1，Q-dir 分屏\r\n2，wireshard抓包\r\n3，有道笔记\r\n4，beyond compare	\N	\N	17	\N	3	\N	5	1	2019-04-16 11:49:44.095702	2019-11-02 18:52:04.332287	2019-04-16	0	\N	\N	339	1	2	f	\N
311	6	7	Raft		\N	23	17	\N	3	\N	5	1	2019-03-17 05:56:51.286238	2019-08-17 14:06:09.992767	2019-03-17	0	\N	\N	311	1	2	f	\N
320	6	7	数据结构	数据结构用来管理一定数量的同类对象。\r\n既然有一定数量，自然有增删改查的需求。\r\n\r\n如果对象只有一个，那自然没那么费事。\r\n数据结构就是用于处理数据集，以及相关运算的。\r\n\r\n矩阵可以用来表示图，也可以表示方程组。表示多个变量之间的关系。\r\nhttps://www.zhihu.com/question/19919917	\N	\N	17	\N	3	\N	5	0	2019-03-22 16:26:09.13832	2019-03-22 16:26:09.13832	2019-03-22	0	\N	\N	320	1	2	f	\N
305	6	7	数据可靠性方法	1，多副本\r\n2，多站点\r\n3，多版本，WORM防误删，CDP\r\n\r\n4，Read repair\r\n5，Scrub数据校验与恢复\r\n\r\n检测类：\r\n6，坏道检测\r\n7，SSD健康检查\r\n8，系统监控	\N	\N	17	\N	3	\N	5	0	2019-03-15 16:44:09.498257	2019-03-15 16:44:09.498257	2019-03-15	0	\N	\N	305	1	2	f	\N
327	6	7	注册码	EA：\r\nUser: MTF\r\nCompany: STU\r\nRegistration Key：\r\nADF8D83B-0683-4d1f-BB60-FF66D-WFM1-CHPZ-PII0-HN75-BC	\N	\N	17	\N	3	\N	5	0	2019-04-02 09:01:51.697517	2019-04-02 09:01:51.697517	2019-04-02	0	\N	\N	327	1	2	f	\N
302	6	4	学习思路		\N	\N	17	\N	3	\N	5	3	2019-03-09 15:20:46.47037	2019-03-24 14:37:38.057306	2019-03-09	0	\N	\N	302	1	2	f	\N
312	6	7	epoll的原理		\N	23	17	\N	3	\N	5	1	2019-03-17 05:57:14.957242	2020-02-16 20:58:51.945432	2019-03-17	0	\N	\N	312	1	2	f	\N
324	3	1	顺丰交流总结以及MOS存在的风险	1，业务要求的性能是包含故障，跨区域复制，以及日常数据转移，scrub在内的端到端性能。\r\n这点对于可用性和性能要求就非常高了。\r\n\r\n   感觉BI增量恢复必须实现，否则只要短暂阻塞几秒，整个系统性能就下来了。\r\n\r\n2，系统可靠性要求，必须上3副本。且必须考虑SSD和HDD常态下损坏的情况。恢复的数据量。scrub多久可以完成。\r\n这些对于系统可靠性至关重要。\r\n\r\n3，业务侧不使用bucket list，这对于具体场景而言是很常见的。结合场景可能很容易做出优化N倍的方案。\r\n甚至考虑内存读加速等手段。\r\n\r\n4，性能显然不是单纯的测纯读或纯写。 尤其是对于Rados，混合读写比纯写或纯读都差不少。\r\n	\N	\N	17	\N	3	\N	5	1	2019-03-26 13:53:49.187611	2019-03-26 13:56:40.209716	2019-03-26	0	\N	\N	324	1	2	f	\N
325	8	11	如何进行有效的陪购	#思路及流程\r\n#运用到的知识和工具\r\n#需要注意的细节\r\n	\N	\N	17	\N	3	\N	6	0	2019-03-29 07:21:37.879861	2019-03-29 07:21:37.879861	\N	0	\N	\N	325	1	2	f	\N
297	8	18	创业的本质是什么	创业的本质目标就是雇佣人提供产品或服务。以解除创业者需自己主动劳动获取报酬的情况。\r\n赚取别人的剩余价值。\r\n\r\n或者说更直白点，就是提供产品，赚取税收。这产品不是自己的劳动。	\N	\N	17	\N	3	\N	5	2	2019-03-06 22:57:53.140159	2021-03-17 07:01:33.749072	\N	0	\N	\N	297	1	2	f	\N
329	6	8	人性是什么	那千疮百孔，千面千面。于浩浩汤汤的人世，如水一样的变化适应才能处于有利位置吧。\r\n否则时势变化，所以上善若水，厚德载物。孔子也将君子当有时出，而有时隐。\r\n\r\n水在万物中，而道也在万物中。为何追求美好的品德？为啥善良如愚蠢。	\N	\N	17	\N	3	\N	5	2	2019-04-04 22:35:30.880457	2019-04-04 23:08:28.373572	2019-04-04	0	\N	\N	329	1	2	f	\N
330	6	4	字母起源	http://shaoeryingyu.baike.com/article-183243.html\r\n	\N	\N	17	\N	3	\N	5	0	2019-04-07 20:23:04.000421	2019-04-07 20:23:04.000421	2019-04-07	0	\N	\N	330	1	2	f	\N
333	6	9	【未完成】有温度的团体		\N	\N	17	\N	3	\N	5	0	2019-04-09 16:21:21.747445	2019-04-09 16:21:21.747445	2019-04-09	0	\N	\N	333	1	2	f	\N
336	6	7	RGW开发教训集	1，缺乏充分调研，错用社区不稳定模块。闭门造车。\r\n2，有时候重写比重用更好，多版本，多站点就是典型例子，如果没搞懂，未经验证，最好别用。\r\n3，有时候以为需求明确了，但对于需求的紧急程度，需求的价值缺乏深入理解。\r\n做了很多流产的对接与小功能。\r\n4，没完全搞清楚现有系统就开始设计？你可能一开始就掉入陷阱。桶快照从开始到废弃。\r\n5，除了做对，还得考虑如何做得更好，V5重构就是一个天大的机会。然后错失了优化元数据的一次机会。\r\n6，临时测试验证的东西直接做成方案？小文件优化把这个坑演绎到极致。\r\n7，自动化测试用例应该由开发人员来写，且必须能快速有效的运行。\r\n8，设计review和开发review不仅应该做，而且应该做得很细。	\N	\N	17	\N	3	\N	5	2	2019-04-15 14:07:01.933826	2019-04-15 14:08:26.855568	2019-04-15	0	\N	\N	336	1	2	f	\N
338	6	8	雾霾	1，造物主给了人很多，我们存在非常多的可能性\r\n2，生活就如一面镜子\r\n3，每个人都应该快乐\r\n4，多赢是一种常态\r\n\r\n体察身边的一切，当心念升起时，感受它，与之和谐相处。这便是雨。\r\n心念升起而又未知，莫名，即不在当下，就如程序踩了内存一般。这就是霾。看不清，道不明，不知何时何地升起。\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2019-04-16 07:44:21.852867	2019-04-16 07:44:21.852867	2019-04-16	0	\N	\N	338	1	2	f	\N
353	6	7	数理逻辑-推理与证明	1，命题转换\r\n2，借助其他命题\r\n\r\n前提条件，蕴含的意思是如果前提为真，那么整体是否为真取决于结论是否为真。\r\np->q为真，则p是q的充分条件。\r\n\r\n推理规则就是采用等值变换将命题转换为其他形式。或根据前提来得出结论。\r\n\r\n直接证明：利用定义，以及其他公理，定理。通过推理来得出结论。\r\n反证法原理：p->q 等价于 非p V q 等价于 qV非p 等于于非q->非p。\r\n归谬法原理：证明p为真 等价于 非p->false为真。 false的一种形式为r且非r。 \r\n\r\nso看到没，数理逻辑是数学证明的基础。证明的本质在于运用定义，公理来推理。	\N	\N	17	\N	3	\N	5	3	2019-04-25 09:23:13.664047	2019-05-06 20:10:10.72367	2019-04-25	0	\N	\N	353	1	2	f	\N
388	6	23	名正言顺		\N	\N	17	\N	3	\N	5	0	2019-05-13 06:56:44.658633	2019-05-13 06:56:44.658633	2019-05-13	0	\N	\N	388	1	2	f	\N
391	6	9	不要去抱怨，社会系统已经把我们放在了比较合适的位置		\N	\N	17	\N	3	\N	5	0	2019-05-13 08:13:40.247678	2019-05-13 08:13:40.247678	2019-05-13	0	\N	\N	391	1	2	f	\N
326	6	19	第13周周末活动安排（3/30-3/31）	安排好自己的时间\r\n协调好家人的时间\r\n过一个有意义的周末	\N	\N	17	\N	3	\N	6	4	2019-03-29 07:23:50.720558	2019-05-14 12:47:02.743892	\N	0	\N	\N	326	1	2	f	\N
303	6	4	英语的说文解字	1，说文解字只是学习的初步阶段的工作，在真正记住词义之后，用的越来越少。\r\n2，词素概念是说文解字的理论基础。句子由词素构成。\r\n3，单词由词根与词缀拼装而成。并且在词形，词义，词音与语法上关联。\r\n在词形上为了符合语法构词要求通常会增加连接词，以及在连接的地方做些变化。\r\n词义上通常以词根为主，但是会做一些延伸，变化。\r\n词音，通常重音在词根上。\r\n语法上，根据词根的语法属性，对构词有点要求，同时派生词的熟悉也与词根有关系，当然见的更多的是词缀来转化词的语法属性。	\N	\N	17	\N	3	\N	5	2	2019-03-11 04:42:31.619307	2019-03-24 08:37:29.127242	2019-03-11	0	\N	\N	303	1	2	f	\N
299	6	8	机器模型-荷塘	通过荷塘系统，加强生活节奏，时间管理，心态管理监控\r\n\r\n荷塘系统的目标是让自己每天保持健康的生态，下雨会有，晴天会有。但雾霾，沙尘不能有。	\N	\N	17	\N	3	\N	5	2	2019-03-08 06:59:27.122022	2019-03-08 09:27:21.164398	2019-03-08	0	\N	\N	299	1	2	f	\N
290	8	7	科学研究与工程的区别	科学研究与工程产品，工作范式不一样。\r\n科学研究是纵，犹如在黑夜中穿越森林。http://www.sohu.com/a/278979780_610300\r\n工程产品是横，需在纷繁复杂多领域中折中与取舍。	\N	\N	17	\N	3	\N	5	2	2019-03-02 10:07:50.768426	2019-03-08 09:33:19.400313	\N	0	\N	\N	290	1	2	f	\N
301	6	7	REST 与 RPC	总结：\r\n对外开放给全世界的API推荐采用RESTful，是否严格按照规范是一个要权衡的问题。要综合成本、稳定性、易用性、业务场景等等多种因素。\r\n内部调用推荐采用RPC方式。当然不能一概而论，还要看具体的业务场景。\r\n另外一个因素是人，关键是你有什么人，postgresql、mysql都有用的不错的，迁来迁去，关键是你的人对哪个更熟悉。\r\n--------------------- \r\n作者：王启军 \r\n来源：CSDN \r\n原文：https://blog.csdn.net/douliw/article/details/52592188 \r\n版权声明：本文为博主原创文章，转载请附上博文链接！	\N	\N	17	\N	3	\N	5	0	2019-03-08 16:03:40.934477	2019-03-08 16:03:40.934477	2019-03-08	0	\N	\N	301	1	2	f	\N
993	6	27	模块级别的可变性	最开始我们设计一个模块时，可能只考虑模块在特定上下文中使用。\r\n这样通常会出现这样的接口设计：\r\n1，接口不完备，分离不清晰，没法被其他新的模块集成\r\n2，接口内存和其他使用的资源从内部申请，导致无法与外部系统集成。\r\n   比如日志等。	\N	\N	17	\N	3	\N	5	0	2021-12-12 07:45:34.669962	2021-12-12 07:45:34.669962	2021-12-12	0	\N	\N	993	1	2	f	\N
328	6	5	制度与文化	制度与文化的关系就像机器与润滑油的关系。\r\n\r\n文化能迸发出生生不息的力量。制度与法律就是企业的方，而文化就是企业的圆。	\N	\N	17	\N	3	\N	5	0	2019-04-04 21:52:10.812577	2019-04-04 21:52:10.812577	2019-04-04	0	\N	\N	328	1	2	f	\N
323	6	10	杉岩产品研发的教训	1，苗错市场，未能及时准备与投入\r\n   开始重点投入块存储，后识别对象存储后，也未能果断及时投入。\r\n2，未能识别关键问题，特性投入失误\r\n  看客户做需求，但是看的客户又不够多，没抓住核心痛点重点投入。\r\n  其实对于对象存储就1个大痛点：海量小文件场景下的性能\r\n  另外一个是分布式系统的可用性，性能稳定性。\r\n\r\n  以高打低的方式\r\n\r\n3，技术基础架构方面未能在开始打通产品平台，造成极大的资源浪费。\r\n4，缺乏完善的工程体系，整体效率低下。\r\n   现代复杂软件的模式下，难以想象没有自动化的测试，以及针对分布式系统的各种注入测试。	\N	\N	17	\N	3	\N	5	2	2019-03-25 23:32:05.260507	2019-03-25 23:37:26.704235	2019-03-25	0	\N	\N	323	1	2	f	\N
304	7	16	3.14安排	1，验证迭代三软件包\r\n2，验证trigger方式是否会导致其他rgw挂掉。\r\n3，看还有没问题单可以想办法解决	\N	\N	19	\N	3	\N	5	0	2019-03-14 07:04:01.286585	2019-03-14 07:04:01.286585	2019-03-14	0	\N	\N	304	1	2	f	\N
116	3	1	系统盘满导致s3客户端获取数据异常，获取的数据比期望的长度短	分析半天，才发现nginx日志中打出了关键信息。\r\n\r\nnginx fcgi buffer 机制，当http header部分数据需要写入到缓存目录，当操作系统盘满之后，会导致无法写入磁盘。\r\n数据发送到客户端的内容不完整，所以MD5校验失败。\r\n\r\n什么情况下http header会写入fastcgi_temp目录呢？	\N	\N	17	\N	3	\N	5	1	2018-10-11 19:46:25.619833	2019-03-30 12:56:48.275554	2018-10-11	0	\N	\N	116	1	2	f	\N
306	6	9	头条面试总结	1，LSM-tree\r\n2.Raft协议实现\r\n3.epoll实现，内部算法\r\n\r\n主要考察还是算法和数据结构这块。	\N	\N	17	\N	3	\N	5	0	2019-03-15 17:42:29.032144	2019-03-15 17:42:29.032144	2019-03-15	0	\N	\N	306	1	2	f	\N
293	6	7	测试覆盖的方法	任何软件系统都是函数组成的。函数有涉及输入输出。\r\n，通常函数还会依赖其他函数。\r\n\r\nf(x) = g(x) + kx + m (其中x是输入变量组)\r\n\r\n在该模型下，要测试完整。需要做几件事：\r\n1，覆盖所有的x输入情况\r\n2，对g(x)所有返回值进行打桩\r\n\r\n系统测试的含义可能就是如此。软件系统是有各种输入，一些外部交互组成的。\r\n构造一个测试机器人，通过系统内部的打桩等。\r\n\r\n任何组件都可以设计这样一个测试系统。\r\n实际的情况可能更复杂一点，我们需要考虑在函数执行的某一步失败，需引入序列失败以及随机失败情况。\r\n\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	2	2019-03-05 07:18:53.797404	2019-04-04 21:21:21.364298	2019-03-05	0	\N	\N	293	1	2	f	\N
307	6	7	红黑树		\N	23	17	\N	3	\N	5	0	2019-03-17 05:55:09.558452	2019-03-17 05:55:09.558452	2019-03-17	0	\N	\N	307	1	2	f	\N
308	6	7	哈希表		\N	23	17	\N	3	\N	5	0	2019-03-17 05:55:37.984243	2019-03-17 05:55:37.984243	2019-03-17	0	\N	\N	308	1	2	f	\N
331	6	7	能否证明所有同步复制方式，其复杂度跟raft是一样的	比如ceph的副本同步机制，完全没觉得其复杂度比raft低多少。\r\n其本质就是选举 + 一阶段提交 + 日志补偿	\N	\N	17	\N	3	\N	5	0	2019-04-09 07:54:05.072611	2019-04-09 07:54:05.072611	2019-04-09	0	\N	\N	331	1	2	f	\N
309	6	7	B-tree		\N	23	17	\N	3	\N	5	0	2019-03-17 05:55:52.810127	2019-03-17 05:55:52.810127	2019-03-17	0	\N	\N	309	1	2	f	\N
461	6	17	PG VXID	此机制也由32位的xid引入，针对查询不必消耗xid的优化。真是蛋疼！！！\r\nhttp://itfish.net/article/31621.html	\N	\N	17	\N	3	\N	5	0	2019-07-08 12:12:55.994631	2019-07-08 12:12:55.994631	2019-07-08	0	\N	\N	461	1	2	f	\N
310	6	7	LSM-Tree		\N	\N	17	\N	3	\N	5	0	2019-03-17 05:56:08.882386	2019-03-17 05:56:08.882386	2019-03-17	0	\N	\N	310	1	2	f	\N
334	6	9	【未完成】工作中应该花多少时间做深度思考	我觉得至少有一半吧，把日常开发工作时间压缩，效率提升一倍。\r\n然后通过深度思考，改进工作机器持续改进效率。	\N	\N	17	\N	3	\N	5	1	2019-04-09 16:24:30.454424	2019-04-09 16:25:46.240673	2019-04-09	0	\N	\N	334	1	2	f	\N
335	7	16	2019-4-5	1，完成离职相关事宜，离职证明\r\n<pre><code class="text">\r\n1、身份证、取得的最高学历证书和学位证书、职称证书等原件；\r\n\r\n2、原单位离职证明、社会保障卡，住房公积金卡等原件；\r\n\r\n3、大一寸免冠彩色照片三张；\r\n\r\n4、区级以上医院体检报告原件；\r\n</code></pre>\r\n\r\n2，建行解锁处理\r\n3，人才房事宜\r\n	\N	\N	19	\N	3	\N	5	0	2019-04-15 07:53:20.132628	2019-04-15 07:53:20.132628	2019-04-15	0	\N	\N	335	1	2	f	\N
347	6	18	数据交易市场-让每个人获取更好的数据，让思考不再空穴来风	不同的组织与个人之间交互数据，并进行计费。	\N	\N	17	\N	3	\N	5	3	2019-04-24 09:12:24.188837	2019-07-10 07:59:18.10072	2019-04-24	0	\N	\N	347	1	2	f	\N
393	8	23	gitlab分支提交冲突解决办法	1，在自己仓库分支修改\r\n2，在自己仓库从origin的master分支pull\r\n3，在本地完成merge request，解决冲突\r\n4，将本地master推到自己的仓库master\r\n5，创建merge request	\N	\N	17	\N	3	\N	5	3	2019-05-13 17:38:35.106909	2019-09-12 15:26:50.638205	\N	0	\N	\N	393	1	2	f	\N
911	7	16	近期任务	1，清问题单\r\n   clear问题,告一段落了。内存管理优化效果也很好。\r\n\r\n2，论文项目\r\n\r\n3，确定下半年任务\r\n\r\n4，减少buffer拷贝的优化  	\N	\N	19	\N	3	\N	5	0	2021-07-26 08:37:07.249431	2021-07-26 08:37:07.249431	2021-07-26	0	\N	\N	911	1	2	f	\N
349	6	9	算法与机器	算法是机器的执行逻辑，但机器本身还有其他内容，比如涉及的主体，角色，能量分配等。 可能主要是工程学问题。	\N	\N	17	\N	3	\N	5	0	2019-04-24 09:26:41.51712	2019-04-24 09:26:41.51712	2019-04-24	0	\N	\N	349	1	2	f	\N
348	6	18	算法市场	比如提供基于历史数据，以及当前数据的天气算法。不同的人可定义不同的算法。需要知识信息的人为算法付费。\r\n\r\n比如搜索引擎输入：明天天气情况\r\n如果存在默认算法，输出结果是明天下雨，或者其他情况，而不是一堆天气网站。\r\n\r\n其实针对问题我们可以给出答案。\r\n	\N	\N	17	\N	3	\N	5	1	2019-04-24 09:20:01.690005	2019-04-24 09:31:28.429895	2019-04-24	0	\N	\N	348	1	2	f	\N
994	7	16	2012-12-13	1，继续对cache和预读进行测试验证\r\n  提高预读命中\r\n  内存足够情况下的cache命中。\r\n  验证内存不够场景，引入其他cache和淘汰算法。\r\n\r\n2，ck的调研\r\n  	\N	\N	19	\N	3	\N	5	0	2021-12-13 06:42:09.411335	2021-12-13 06:42:09.411335	2021-12-13	0	\N	\N	994	1	2	f	\N
351	7	17	学习离散数学-数理逻辑这块	命题，谓词，量词，推导，证明	\N	\N	19	\N	3	\N	5	0	2019-04-24 13:39:56.373279	2019-04-24 13:39:56.373279	2019-04-24	0	\N	\N	351	1	2	f	\N
350	6	7	数理逻辑-命题，谓词，量词	命题是逻辑的基本构件，是一个陈述语句，它或真或假，不能既真又假。\r\n谓词：谓词本质就是命题函数，存在变元。含谓词的命题也叫谓词命题\r\n量词：量词就是对于变元的情况做出规范，分为全称量词和存在量词。含量词的命题也叫量化命题	\N	\N	17	\N	3	\N	5	1	2019-04-24 11:35:28.63424	2019-04-25 06:45:05.685826	2019-04-24	0	\N	\N	350	1	2	f	\N
995	7	16	2021-12-20	1，处理loader线程cpu占用高的问题\r\n2，继续性能分析，看还有没其他瓶颈\r\n3，分析clickhouse在实现原理上有没差距	\N	\N	19	\N	3	\N	5	0	2021-12-20 07:39:41.874765	2021-12-20 07:39:41.874765	2021-12-20	0	\N	\N	995	1	2	f	\N
372	6	19	家庭生活的机器	工作日早上：6:30左右起床，完成运动和早餐准备。8点结束。\r\n晚上：7点-10点到家，如7点，则执行配谢震程序，和其他家庭准备事务。 如10点，则稍作休息，启动睡眠程序。\r\n\r\n休息日：安排带谢震活动 或家庭聚餐 或 交际沟通程序 或 个人提升程序（包括学习程序与专项运动程序）。\r\n\r\n饮食程序：1，避免吃过于辛辣，尤其是较晚的时候，影响睡眠。\r\n	\N	\N	17	\N	3	\N	5	1	2019-04-29 07:53:18.130105	2019-05-05 06:36:08.706326	2019-04-29	0	\N	\N	372	1	2	f	\N
358	6	9	程序员与算法	所谓架构就是函数之间的关系。从模块关系，特性关系等维度描述。这样就明确了如何牵一发而动全身。\r\n\r\n算法的本质就是数学逻辑，通过公理，定理，以及事物的定义和规律我们可以找到不同的路径来达到目标。\r\n还有更普遍的情况是我们没有摸清楚整体而犯的错，以及维护整体而做的修补工作。知晓未知而做的假设。\r\n程序员的核心工作当然是发现以及优化算法，并将其落地。数学是程序员的核心。否则就仅仅是执行者。\r\n\r\n具有天赋的人可能未经严密论证，凭直觉就找到了本来需经过很多步推导与转换才能知道的规律或定理。\r\n然后利用汗水去验证。\r\n\r\n工程上的问题同样非常重要。算法通常在存在细节和非常多的边缘情况处理。算法是骨，工程是肉。	\N	\N	17	\N	3	\N	5	1	2019-04-26 06:55:49.294642	2019-04-26 06:58:12.969068	2019-04-26	0	\N	\N	358	1	2	f	\N
360	6	17	PG内存数据的一致性保证		\N	\N	17	\N	3	\N	5	1	2019-04-26 08:47:28.253602	2019-04-26 09:12:04.347157	2019-04-26	0	\N	\N	360	1	2	f	\N
361	6	17	PG SysCache与RelCache		\N	\N	17	\N	3	\N	5	3	2019-04-26 08:47:48.534376	2019-04-28 09:07:33.344752	2019-04-26	0	\N	\N	361	1	2	f	\N
357	8	9	如何深入参加其他人主导，多人参与的讨论，讨论的范围以及结论的把握	讨论的范围完全不发散，那信息量太少，但是过于发散则成本上升。效率才是核心问题。\r\n多人参与的讨论需提前发出讨论主题，参与人应该提前熟悉并思考相关主题，否则就变成了发起人的独角戏。	\N	\N	17	\N	3	\N	5	1	2019-04-26 06:54:07.422094	2019-04-28 14:14:51.271206	\N	0	\N	\N	357	1	2	f	\N
375	6	9	读低风险创业有感	所谓忧虑，就是存在风险\r\n所谓风险，就是能力不足，无法cover住各种情况\r\n所谓创业，就是做一份自己热爱的事\r\n所谓懒惰，就是没有能力掌控自己的精力	\N	\N	17	\N	3	\N	5	3	2019-05-04 04:34:42.784883	2019-05-04 04:39:11.143843	2019-05-04	0	\N	\N	375	1	2	f	\N
378	6	7	windows编译	Cygwin：是poxis模拟环境，提供了一套模拟运行环境\r\nMINGW:是GNU的工具链，用于在windows上像linux一样编译程序。\r\nQt:基于Qt的桌面软件,Qt是一个桌面程序开发框架，就像windows上的MFC等	\N	\N	17	\N	3	\N	5	1	2019-05-05 16:45:54.895617	2019-05-05 16:52:08.993712	2019-05-05	0	\N	\N	378	1	2	f	\N
392	6	23	C语言是静态语言实现不了，结构体类型在执行期间确定的效果	请看这篇文章：\r\nhttps://cloud.tencent.com/developer/article/1152804\r\n\r\n编译时就知道变量类型的是静态类型；运行时才知道一个变量类型的叫做动态类型。\r\n不允许隐式转换的是强类型，允许隐式转换的是弱类型。\r\n\r\nC是静态弱类型语言。\r\n\r\n所以想通过指针，指向一个在执行期间根据变量确定其指向的结构体类型是不能实现的，你只能指向某种值类型。	\N	\N	17	\N	3	\N	5	1	2019-05-13 13:12:01.060616	2019-05-13 13:15:26.275234	2019-05-13	0	\N	\N	392	1	2	f	\N
395	6	19	2019年5月17日家庭活动筹备	# 确定主题\r\n# 制定流程\r\n# 对相关内容以及期望达到的效果进行准备\r\n# 通知相关参与人员以及协助筹备的工作	2019-05-16	\N	17	\N	3	\N	6	1	2019-05-14 12:43:40.13825	2019-05-14 12:45:21.886606	2019-05-14	0	\N	\N	395	1	2	f	\N
394	6	19	2019年5月12日母亲节活动总结	表达对母亲的感谢，促进家庭关系的和谐！	\N	\N	17	\N	3	\N	6	4	2019-05-14 12:13:16.298395	2019-05-14 12:44:25.405862	2019-05-14	0	\N	\N	394	1	2	f	\N
399	6	23	C语言-static	static语义是静态的，描述变量的静态存储特性，静态存储变量会自动初始化\r\n\r\n但是static在c语言中还有另一个作用（有点奇葩，一个关键字2个语义）： 限制作用域在本文件内。对于头文件而言就是包含该头文件的C文件内。	\N	\N	17	\N	3	\N	5	1	2019-05-14 15:22:42.03723	2019-05-14 15:24:17.939241	2019-05-14	0	\N	\N	399	1	2	f	\N
396	8	12	观察日期（15月-16月）	学会做父母，需要用心去体察，用爱去表达，是要用一生去学习、实践的人生大课\r\n# 通过日常的观察来了解谢震的内心世界\r\n# 通过记录来发现自己认知的盲区\r\n# 通过实践来提升自己做妈妈的能力	\N	\N	17	\N	3	\N	6	1	2019-05-14 12:55:09.883706	2019-05-15 12:54:25.01001	\N	0	\N	\N	396	1	2	f	\N
422	6	17	mysql redo调研	1,关于mysql的rowid\r\n2，mysql的redo格式\r\nredo记录的是page上的修改操作。\r\nSpaceID | PageNo  | Offset | OperationType | Changes on that page\r\n\r\nundo格式：\r\nPrimary Key Value |  Old trx id | Old values on that row\r\n\r\ninnodb数据以primary key以btree组织，其他index指向primary index。\r\ninnodb中delete以update方式记录undo，相当于update visible=false。\r\ndelete的记录不会立即删除，而是等到undo被discard的时候做purge。\r\n\r\nSome internal columns are added by InnoDB, such as DB_ROW_ID (row ID), DB_TRX_ID (transaction ID), \r\nand DB_ROLL_PTR (a pointer to the rollback/undo data).\r\n参考：https://dev.mysql.com/doc/refman/5.6/en/innodb-multi-versioning.html\r\n\r\n\r\n第一行数据:\r\n03 02 02 01 /*变长字段*/ ---- 如果没有变长字段，则长度为0\r\n00 /*NULL标志位，第一行没有null的数据*/\r\n00 00 10 00 25 /*记录头信息,固定5个字节*/\r\n00 00 00 03 b9 00 /*RowID,固定6个字节,表没有主键*/\r\n00 00 00 02 49 01 /*事务ID,固定6个字节*/\r\n82 00 00 01 4a 01 10 /*回滚指针,固定7个字节*/\r\n61 62 62 62 62 63 63 63 /*列的数据*/\r\n\r\n问题：\r\n1，primay key与普通列一起存储吗？\r\n  存是存，但是是存在rowid的位置。\r\n2，rowid等列会记录到redo吗？\r\n  primay key会，delete只记录到page/offset\r\n  但是其他非修改列不会记录。\r\n3, redo for undo与undo本身还是有区别的。\r\n  delete操作的redo for undo中并未记录所有old columns。	\N	\N	17	\N	3	\N	5	0	2019-05-23 13:08:29.903269	2019-05-23 13:08:29.903269	2019-05-23	0	\N	\N	422	1	2	f	\N
356	6	17	beas parser分享总结	核心思想就是利用Access Schema来改写查询，缩小查询规模，从而加速查询。\r\n改写的时候有一些坑：比如坑1在同一个表传递schema的时候存在放大的情况。\r\n坑2是多个表之间的schema，在运用时可能存在环。\r\n坑3是利用其他表作为中转，以及大量schema时，如何选择路径，以及如何运用条件等。	\N	\N	17	\N	3	\N	5	3	2019-04-25 19:00:52.357197	2019-04-27 13:45:26.6485	2019-04-25	0	\N	\N	356	1	2	f	\N
362	6	17	PG事务与并发控制		\N	\N	17	\N	3	\N	5	6	2019-04-26 15:15:46.593093	2020-03-26 14:17:50.389055	2019-04-26	0	\N	\N	362	1	2	f	\N
359	7	17	通过Admin Tool对BEAS中增加access schema信息	分解：\r\n1，创建access schema分为哪几步？有哪些操作？\r\n  当作元数据，用户管理schema属于元数据操作。\r\n  比如关联创建constraint index，关联创建衍生的acess schema? 是否需修改beas中保存的元数据？\r\n\r\n2，access schema在哪些阶段使用？怎样使用？\r\n  beas逻辑优化阶段\r\n\r\n3，access schema在什么情况下会被修改或删除？是否需关联删除constraint index？\r\n  当一个表的字段发生修改时\r\n  当一个表被删除时\r\n  \r\n  用户直接修改\r\n\r\n4，显然access schema在内存和外存中分别以什么形态存储？\r\n  hash查找快，但不好扩展。hash用来做均衡分布挺好的\r\n  红黑树可能更适合。\r\n\r\n5，对于access schema的使用做监控管理，比如用户使用怎样的查询语句来使用schema\r\n\r\n6，对于常量到表字段的映射，也需要加入到schema中管理？ \r\n比如select b2，a4 from A，B where a3 = 1. schema有null->a1, a1->b2.\r\nA的fetch sequence：a3=1\r\nB的fetch sequence：a3=1, a3->a1 , a1->a2\r\n\r\n7，关系提前生成？\r\n如a3->c4, c4->b3。从而生成a3->b3.\r\n	\N	\N	17	\N	3	\N	5	10	2019-04-26 08:30:26.433121	2019-05-07 09:18:33.942478	2019-04-26	30	\N	\N	359	1	2	f	\N
364	6	17	PG BufferCache		\N	\N	17	\N	3	\N	5	1	2019-04-28 09:07:55.133534	2019-04-28 14:24:45.016278	2019-04-28	0	\N	\N	364	1	2	f	\N
428	6	17	关于数据库范式	数据库范式是为了解决数据存储的规范引入的。在不满足数据规范时，由于存在内部依赖关系，可能引起数据的更新或删除异常。\r\n\r\nhttps://blog.csdn.net/ljp812184246/article/details/50706596\r\n\r\n一种比较简单的定义数据方法可能是将实体与关系分离。也就是所谓的ER图。	\N	\N	17	\N	3	\N	5	0	2019-05-26 13:59:32.797045	2019-05-26 13:59:32.797045	2019-05-26	0	\N	\N	428	1	2	f	\N
365	6	18	从机器，数据和算法的角度看世界	企业运行就是在执行算法，效率高的企业自动化执行，而效率低的企业人肉执行。是否人力密集型。\r\n企业的核心资产就是数据，当然有些公司在该市场上仅提供算法处理数据。但没有数据的算法就是无本之源。\r\n\r\n由此角度看，兴趣的本质就是人所关心的数据，以及算法。以及背后就是想解决的问题。\r\n\r\nso，比如说你喜欢羽毛球，这是一个市场。我们可以从数据与算法角度来解析这个市场。\r\n\r\n羽毛球拍公司掌握了制作羽毛球的算法，羽毛球，鞋子，衣服，手胶等等分支也是如此。\r\n这些公司实际上也可收集用户数据，但是通常公司做这个。\r\n\r\n球馆其实拥有客户数据，但是通常也没球馆专门分析客户数据。也没球馆分析客户使用的球拍和鞋子等。\r\n球馆提供了硬件环境-场地。\r\n\r\n打球的人作为客户享受了服务。并为此支付了自己其他劳动。\r\n\r\n通常人们说兴趣是指：作为客户享受什么样的服务。但这里想说的兴趣是作为客户，其自己需要什么样的服务，具备自行打造服务的能力，且可能出售自己的服务。这才是完整的兴趣。\r\n	\N	\N	17	\N	3	\N	5	0	2019-04-28 09:27:36.624257	2019-04-28 09:27:36.624257	2019-04-28	0	\N	\N	365	1	2	f	\N
708	6	24	CFileStore	c is common or coral。\r\n1，支持异步\r\n2，调研s3和hdfs接口，本地文件接口\r\n3，中间状态\r\n4，对于元数据的支持	\N	\N	17	\N	3	\N	5	2	2020-11-15 04:33:09.336642	2020-11-15 04:41:20.203244	2020-11-15	0	\N	\N	708	1	2	f	\N
709	6	15	目前的难点	反手重点是贴球打，先打准，再慢慢增大挥拍距离。\r\n吊球一定也是脚部发力，这跟高远和杀球一样。\r\n大臂发力可能是脚下蹬地无力的问题。\r\n抬拍速度慢，举拍习惯，平杀球，接杀需要提前反手握拍么？\r\n腿部运动和身体，手臂运动相得益彰。整体协调性。	\N	\N	17	\N	3	\N	5	1	2020-11-15 20:01:00.456883	2020-11-15 20:02:20.495246	2020-11-15	0	\N	\N	709	1	2	f	\N
430	6	17	执行器分享记录	标哥提及的一个查询扫描page时与vacuum的并发问题。\r\nTupleTableSlot：每次取一条记录。\r\n向量化执行：MPP中采用列存，可一次取一批，从而实现优化。\r\n并行执行，多个pg进程分工完成复杂查询。\r\njit：利用内联优化，加速计算密集型执行效率。\r\n\r\n并行，批量，减少不必要动作。还有啥性能优化手段。	\N	\N	17	\N	3	\N	5	0	2019-05-28 18:18:11.956206	2019-05-28 18:18:11.956206	2019-05-28	0	\N	\N	430	1	2	f	\N
431	6	12	扭扭车	https://detail.tmall.com/item.htm?id=552943690321&ali_refid=a3_430750_1006:1110353589:N:zumN4WFrVyoYFzUISvNddck7t2Iv8CtK:07bb167c79efee9951594235fbe952bb&ali_trackid=1_07bb167c79efee9951594235fbe952bb&spm=a21wu.10013406.0.0&skuId=3392316805043	\N	\N	17	\N	3	\N	5	0	2019-05-29 11:36:55.661701	2019-05-29 11:36:55.661701	2019-05-29	0	\N	\N	431	1	2	f	\N
433	6	6	有限游戏与无限游戏	我将生生不息的参与2个游戏，一个是增强智慧与知识。另一个增强体魄与精气神。\r\n再个就是强化沟通与交流，编织精彩网络。	\N	\N	17	\N	3	\N	5	1	2019-06-01 11:13:49.435828	2019-06-01 11:16:13.880282	2019-06-01	0	\N	\N	433	1	2	f	\N
437	6	7	复杂度-NP	https://www.zhihu.com/question/27039635\r\n通俗理解	\N	\N	17	\N	3	\N	5	0	2019-06-02 20:44:43.85898	2019-06-02 20:44:43.85898	2019-06-02	0	\N	\N	437	1	2	f	\N
240	6	7	软件工程总结	1，设计，代码都应该经过review，探讨。\r\n2，如果没有严密的逻辑验证，设计和开发离目标的距离都可能是一条鸿沟。\r\n3，问题在驱动着系统改进。任何系统都难以滴水不漏，关键在于确保在生命周期内，不会出现无法弥补的问题。\r\n	\N	\N	17	\N	3	\N	5	7	2019-01-21 19:26:49.059496	2019-04-28 07:41:53.631564	2019-01-21	0	\N	\N	240	1	2	f	\N
363	6	17	yy对于数据产品的理解	1，以人为中心\r\n2，数据的关系\r\n3，时序性\r\n4，视图（这是体现数据价值的部分，说视图是从人角度看关注的数据不一样）\r\n\r\n可以基于此思路看看现有产品。。。	\N	\N	17	\N	3	\N	5	0	2019-04-28 08:18:01.303417	2019-04-28 08:18:01.303417	2019-04-28	0	\N	\N	363	1	2	f	\N
355	6	17	beas一期模块分解讨论	1，Access Schema,定义表不同列之间的关系。\r\ntableid/columnid - tableid/columnid - N\r\n\r\nSchema第一阶段是导入的。但是最好能够统计出来用户常用查询涉及的column，并自动分析其存在的关系。\r\n\r\n2，constraint index\r\ntable_column_val - table_column_val - n (表示具体的某个实例对应的另一个实例存在的个数)\r\nconstraint index作用就是额外建立索引，从而实现bound query。\r\n\r\n注意：Schema中的N是比较固定的，可以说是上限。而constraint index中的n表示的是存在具体val映射关系的记录个数。\r\n3，第三方库导入的表在beas中使用pg_class还是其他表存需深入分析。\r\n4，FDW产品可以了解下，FDW在其自身上定义表，并适配访问不同的数据源。\r\n5，执行器还是有讲究的，后面可能是并行执行。	\N	\N	17	\N	3	\N	5	3	2019-04-25 16:54:07.379242	2019-04-28 13:54:11.932591	2019-04-25	0	\N	\N	355	1	2	f	\N
504	8	17	AQP的疑问	AQP是近似查询，与一般的利用采样减少计算规模方法不一样，它能根据数据规模计算出精度。\r\n但是减少数据规模，精度的下降是直线式的。 如果给出的Y正好在中位线附近，则精度高，否则精度低。\r\n\r\n能否有好的办法针对给定的Y，使用其附近的数据来回答查询？并且由此给出精度？\r\n单个索引貌似可以，就像limit下压的效果一样。 相当于给每个查询加个合适的limit。以控制数据访问的规模	\N	\N	17	\N	3	\N	5	10	2019-08-27 18:59:15.597918	2019-10-22 15:24:01.349231	\N	0	\N	\N	504	1	2	f	\N
424	6	17	PG执行引擎听讲笔记	1，执行器拿到的一颗执行树。\r\n2，执行的中间过程被另外保存，与输入的执行计划是独立的。孩子节点作为父节点的输入。\r\n3，存在4类执行节点，每个节点都有开始，执行，结束等方法。	\N	\N	17	\N	3	\N	5	0	2019-05-23 19:59:31.622282	2019-05-23 19:59:31.622282	2019-05-23	0	\N	\N	424	1	2	f	\N
434	6	9	Keep 微酸，Keep 微压	他么还要专门去学英语，明显是学习压力不够么	\N	\N	17	\N	3	\N	5	0	2019-06-01 11:49:11.67486	2019-06-01 11:49:11.67486	2019-06-01	0	\N	\N	434	1	2	f	\N
423	6	17	PG wal	https://paquier.xyz/postgresql-2/postgres-9-4-feature-highlight-replica-identity-logical-replication/	\N	\N	17	\N	3	\N	5	8	2019-05-23 13:41:29.862551	2020-02-23 20:04:17.879797	2019-05-23	0	\N	\N	423	1	2	f	\N
427	6	17	关于列式存储	可以把每个字段看成一个数组，这样同一个下标的不同列数组就构成了一行。\r\n\r\n列式存储只是一种存储形态，但数据的关系仍然是基于行的。这是由数据本身决定的。	\N	\N	17	\N	3	\N	5	0	2019-05-26 13:57:15.708004	2019-05-26 13:57:15.708004	2019-05-26	0	\N	\N	427	1	2	f	\N
439	6	17	PG的mvcc机制	MVCC的解决的问题是事务的隔离性。PG这块搞起来很复杂，一方面是因为事务本身复杂，pg的实现复杂。二是结合事务的各种状态，多版本的管理以及可见性判断复杂。\r\n隔离一种实现方式是加锁，但性能上没法接受。另一种方式就是MVCC。undo也是其中一种实现方案。	\N	\N	17	\N	3	\N	5	11	2019-06-06 08:46:55.07251	2020-05-28 10:27:02.65037	2019-07-25	0	\N	\N	439	1	4	f	\N
435	6	7	幂等特性的理解，与应用领域	https://www.jianshu.com/p/475589f5cd7b\r\n\r\n幂等性原本是数学上的概念，即使公式：f(x)=f(f(x)) 能够成立的数学性质。用在编程领域，则意为对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。\r\n\r\n也即系统允许在出错时，不断重复执行，其结果与成功执行一次的效果一样。\r\n\r\n幂等性是分布式领域的一把利刃，每一个有志与分布式领域的程序员都应该熟悉它的设计思想。\r\n\r\nredo日志的重复执行就需要具备这种性质，这一特性在分布式系统中运用确实非常广泛。	\N	\N	17	\N	3	\N	5	0	2019-06-01 14:22:51.250492	2019-06-01 14:22:51.250492	2019-06-01	0	\N	\N	435	1	2	f	\N
436	6	7	乔姆斯基文法分类	乔姆斯基的文法分类。\r\n首先，应该非常清楚乔姆斯基对于四种文法分类的定义，并能理解其含义。\r\n几种文法中，最基本的是0型文法，读者可以将它理解为其它所有文法的基础，它是可以表示任何语言的文法。\r\n后面的1，2,3三种文法，是分别对于0型文法产生式的两边作了不同的限制之后，形成了新的文法。\r\n比如：规定0型文法的每个产生式中，其左边字符集长度小于右边字符集长度并且同时规定开始符号只可出现于产生式的左边，不能出现在任何产生式的右边，这样，就成为了1型文法(即上下文有关文法)。\r\n其它与此类似，在1型文法的基础上，进一步规定该文法的任意产生式，其左部只允许有一个字符且必须为非终结符，这样就构成了上下文无关文法；\r\n再在上下文无关文法的基础上进行限制：规定除了左部有且只有一个非终结符外，还特别规定右部最多只允许有两个字符，当为两上字符时必须一个为非终结符，另一个为终结符，\r\n而当只有一个字符时，必须为终结符，这样的文法就成了正规文法。\r\n这样一层套一层的限制，就形成了从0型到3型文法的定义体制，每一层都是在前一层基础上进行定义的，所以说前一层一定比该层表示的范围要广，因为其受的限制要少。 \r\n那么，我们在判断一个文法时应该以什么规则来判断呢？这个规则当然是：3->2->1->0.也就是说，我们判断是从高到低来判断的，\r\n比如：一旦判断其属于正规文法之后就没必要再判断其是否属于上下文无关的了(因为它必定属于上下文无关，我们应该以最高规则来判定其属于的文法类型)，其它情况与此类推。\r\n只有当我们判断不属于3型文法时，我们才向下判断，其是不是属于2型的，若不属于2型的，则依此类推再向下判断。最终的结果如果不属于3，2和1三种类型，那就只有属于0型了。	\N	\N	17	\N	3	\N	5	1	2019-06-02 19:59:34.732251	2019-06-02 20:00:31.602804	2019-06-02	0	\N	\N	436	1	2	f	\N
425	6	17	复制技术简介	1，物理复制\r\n有的数据库也叫流式复制。是基于二进制数据的数据复制，这里的二进制数据通常是redo log。	\N	\N	17	\N	3	\N	5	7	2019-05-25 12:38:54.196816	2019-05-27 20:58:14.971219	2019-05-25	0	\N	\N	425	1	2	f	\N
432	6	17	内存数据库调研	关系型内存数据库：\r\nhttp://www.dbgeek.org/Jishu/bloginfo/id/119\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2019-05-29 15:02:16.348828	2019-05-29 15:02:16.348828	2019-05-29	0	\N	\N	432	1	2	f	\N
107	6	6	思维方法	1，围棋思考法 (普遍联系)\r\n2，问题思考法 (发展)\r\n3，本质思考法 （矛盾)\r\n4，原则思考法\r\n      4.1 中庸之道\r\n      4.2 佛家四法印\r\n      4.3 环境选择\r\n5，机器模型思考法\r\n6，换位逆向思考法\r\n7.   金字塔思维组织法\r\n8，科学思维\r\n     不仅是科学的对待，还能科学的研究与推论，还有自我的思辨思维，能够自己得出结论，这非常重要。否则智商税交不完。\r\n9，持续发展法\r\n     一个系统从最初不断累加完善的思维。持续学习，原则的完善都是这种思路。不断积累量变。	\N	\N	17	\N	3	\N	5	4	2018-10-07 22:00:53.351316	2019-06-01 02:54:58.274829	2018-10-07	0	\N	\N	107	1	2	f	\N
913	6	9	从羽毛球领悟做事技巧-减少失误就能取得成就	我们经常看一场比赛下来，可能看上去很勇的一方却经常失误丢分，这能反应真实实力吗？\r\n\r\n能，羽毛球规则如此，它有边界。这社会何尝不是如此呢？不少聪明人因失误而碌碌无为。\r\n又有多少人因恐惧，贪婪而铤而走险。\r\n\r\n有实力的人应该避免这些，以陷自己于绝境。稳扎稳打，步步为营。	\N	\N	17	\N	3	\N	5	0	2021-07-27 06:19:27.774368	2021-07-27 06:19:27.774368	2021-07-27	0	\N	\N	913	1	2	f	\N
400	6	15	羽毛球丢球的情况	羽毛球丢球的情况：\r\n1，失误\r\n1.1 发力的方向与大小出现偏差\r\n1.2 场地的环境引起的偏差\r\n2，速度跟不上\r\n2.1 脚步跟不上\r\n2.1.1 启动步没有双脚做好准备\r\n2.1.2 中间步力量不够，速度跟不上\r\n2.1.3 终止步冗余，回步慢\r\n2.1.4 采用了错误的步伐\r\n\r\n2.2 手上跟不上\r\n2.1.1 挥拍动作过大导致收拍速度收到影响\r\n2.1.2 启动式没做到位\r\n2.1.3 使用了错误发力部位，导致速度跟不上，通常越大部位速度越慢	\N	\N	17	\N	3	\N	5	2	2019-05-14 18:10:15.50777	2019-06-13 16:30:30.094686	2019-05-14	0	\N	\N	400	1	2	f	\N
379	8	7	从数理逻辑到计算机的发明	计算理论导引	\N	\N	17	\N	3	\N	5	0	2019-05-06 20:54:00.038524	2019-05-06 20:54:00.038524	\N	0	\N	\N	379	1	2	f	\N
380	7	17	考虑beas内的共享内存管理		\N	\N	19	\N	3	\N	1	0	2019-05-07 14:54:16.80013	2019-05-07 14:54:16.80013	2019-05-07	0	\N	373	373	2	3	f	\N
406	6	17	Mysql 5.7编译安装	Mysql编译：\r\n1，下载源代码\r\nhttps://github.com/mysql/mysql-server/tree/5.7\r\n2，下载boost 1.59\r\nhttps://www.boost.org/users/history/version_1_59_0.html\r\n\r\n3，安装ncurses\r\nyum install ncurses-devel\r\n\r\n4，mkdir build;cd build; cmake ../ -DWITH_BOOST=/root/boost_1_59_0/\r\n\r\n5，mysqld --initialize 初始化（5.7以后）\r\n\r\n6，在/var/log/mysql/error.log日志里面可以看到随机生成的root密码\r\n\r\n7，登录：mysql -uroot -p'GCIq<iXoo82j'\r\n\r\n8，修改用户\r\nhttps://blog.51cto.com/arthur376/1840353	\N	\N	17	\N	3	\N	5	5	2019-05-21 13:22:17.035384	2019-07-11 07:27:58.862359	2019-05-21	0	\N	\N	406	1	2	f	\N
381	7	17	考虑独立出安全函数	将安全函数独立头文件	\N	\N	19	\N	3	\N	1	0	2019-05-07 14:55:08.244603	2019-05-07 14:55:08.244603	2019-05-07	0	\N	373	373	4	5	f	\N
532	6	9	十一听明朝那些事儿所感	更真切的体会到知行合一。历史就是事实，从事实出发才是知的真切。\r\n人生活在自己的认知构建的世界中，然而这与现实相去甚远。\r\n\r\n所以我们要审视：\r\n1，我看到的世界是真实的世界吗？ \r\n  显然关于阶层以及财富之前的认知是有问题的。阶层没那么好穿越，财富也不好积累。\r\n  活得太天真，太简单\r\n\r\n2，以客观事实为导向，以行的结果调整认知。再以思考组织行动。\r\n3，当你变得更强时，你遇到的对手也更强。当你不想变强时，就得更会低头，会苟且。当你一无是处时，就被无情的抛弃。所以永远不要放弃让自己变得更强，更广阔的生存空间。\r\n4，任何能力的锻炼也不是一会儿的事。\r\n5，哪有什么诗和远方，人是不断寻求刺激的动物，没有人能真正享受一层不变的生活，就算是僧侣也在心灵上寻求新的发现。\r\n一去不复返。	\N	\N	17	\N	3	\N	5	1	2019-10-14 21:30:28.416444	2019-10-20 12:14:19.908343	2019-10-14	0	\N	\N	532	1	2	f	\N
322	6	15	羽毛球反手发力	技术关键点：\r\n1，转体屈膝\r\n2，收肩申肘\r\n3，外旋握紧\r\n\r\n其实正手发力也是如此，道理一模一样。\r\n\r\n最重要的是击球点，必须在右侧或头顶上方。\r\n击球点的把握是最难的。\r\n\r\n开始练习可以把1,2步的力用好、反手纯靠手臂比较难。	\N	\N	17	\N	3	\N	5	4	2019-03-25 23:24:05.0432	2020-01-30 18:28:24.170514	2019-03-25	0	\N	\N	322	1	2	f	\N
384	8	7	大数据，存储生态		\N	\N	17	\N	3	\N	5	7	2019-05-09 13:36:42.543367	2019-12-30 06:45:23.304934	\N	0	\N	\N	384	1	2	f	\N
714	3	27	设计就是领导力的体现	设计体现了人对于事物的看法，愿景，方向的理解。\r\n设计还要求我们去认识新事物，拓展边界。	\N	\N	17	\N	3	\N	5	0	2020-12-07 06:50:28.335774	2020-12-07 06:50:28.335774	2020-12-07	0	\N	\N	714	1	2	f	\N
383	8	17	索引是如何更新的，索引如何记录多个tid/rowid		\N	\N	17	\N	3	\N	5	0	2019-05-09 13:34:34.675413	2019-05-09 13:34:34.675413	\N	0	\N	\N	383	1	2	f	\N
715	6	27	任务执行算法是执行力的体现		\N	\N	17	\N	3	\N	5	0	2020-12-07 06:51:29.235764	2020-12-07 06:51:29.235764	2020-12-07	0	\N	\N	715	1	2	f	\N
387	6	7	计算机理论导引阅读笔记	1，数学领域经常把复杂问题，通过图表等方式描述以方便理解。	\N	\N	17	\N	3	\N	5	1	2019-05-12 19:32:34.339605	2019-05-12 20:00:07.221927	2019-05-12	0	\N	\N	387	1	2	f	\N
373	7	17	考虑beas common，内存管理与字符串操作封装		\N	\N	19	\N	3	\N	5	12	2019-04-29 14:06:04.04455	2019-05-13 06:53:42.15463	2019-05-07	0	\N	\N	373	1	6	f	\N
371	6	7	集合论-为什么说是数学的基础	其实这个说法是有争议的，集合论也有不能涵盖的范围。\r\n所以说数学是发明而不是发现，发明是存在缺陷的。\r\n\r\n集合作为数学基础，是因为集合可以准确定义目前用到数学的很多概念。比如函数	\N	\N	17	\N	3	\N	5	1	2019-04-28 18:23:01.518927	2019-05-14 18:35:30.852072	2019-04-28	0	\N	\N	371	1	2	f	\N
716	3	27	最小知识原则的一次教训	在开发swf过程中，测试人员直接测内核暴露的接口，但是暴露的数据结构的资源管理没有封装。且cursor结构被不同dml动作反复使用。\r\n这样就很容易出现问题。\r\n\r\n即暴露的东西太多了，应该明确每个动作，对于上层使用者，应该暴露什么，不应该暴露什么。\r\n尽量减少暴露出去的信息。	\N	\N	17	\N	3	\N	5	0	2020-12-07 17:05:54.246197	2020-12-07 17:05:54.246197	2020-12-07	0	\N	\N	716	1	2	f	\N
717	8	28	世界是怎样的	世界的真实性，不可知性，可见性，因果性，渐变性。\r\n生存的本质是状态变化，人本质上在追求更好的生存。身体的生存，以及精神上的生存。\r\n梦想是对于状态的一种期望，兴趣是在状态改变中获得的满足。\r\n结构本质上就是将空，分解为有和无，将粒子重新组合。\r\n概念是将对具有稳定性，相似性的结构特性的描述。	\N	\N	17	\N	3	\N	5	0	2020-12-13 07:53:44.613324	2020-12-13 07:53:44.613324	\N	0	\N	\N	717	1	2	f	\N
382	8	23	如何做代码封装	1，接口优于类？\r\n  接口不含数据\r\n2，不同接口优于传参接口？ \r\n	\N	\N	17	\N	3	\N	5	2	2019-05-09 04:00:54.613079	2019-05-13 06:56:13.285765	\N	0	\N	\N	382	1	2	f	\N
389	6	23	软件分工就像并行算法，最大最好的并行化		\N	\N	17	\N	3	\N	5	0	2019-05-13 06:57:25.694986	2019-05-13 06:57:25.694986	2019-05-13	0	\N	\N	389	1	2	f	\N
403	6	7	数据管理系统的方方面面	IO模型\r\n内存数据组织\r\n{\r\n   数据变更的通知\r\n   淘汰机制\r\n   数据加载，数据加载需要锁保护，数据访问也需要锁保护。\r\n}\r\n磁盘数据组织\r\n数据的编解码\r\n事务机制\r\n{\r\n  并发控制\r\n  {\r\n    锁在内存的实现\r\n    锁的层次\r\n\t锁的类型\r\n  }\r\n  一致性保证\r\n  {\r\n    redo机制：提交则数据必然成功修改\r\n  }\r\n  隔离级别\r\n}\r\n数据保护\r\n{\r\n    多版本\r\n    快照\r\n    备份\r\n    容灾\r\n    防篡改\r\n}\r\n副本数据同步\r\n数据分布\r\nGC	\N	\N	17	\N	3	\N	5	1	2019-05-17 15:44:55.872049	2019-05-17 16:10:31.528605	2019-05-17	0	\N	\N	403	1	2	f	\N
534	6	7	github.com 邮箱	xz20180210@163.com	\N	\N	17	\N	3	\N	5	1	2019-11-01 18:21:47.410607	2020-09-03 11:52:21.203787	2019-11-01	0	\N	\N	534	1	2	f	\N
536	6	18	database column crack	Database Cracking 描述了基于访问来组织索引的处理方式。\r\n实际上还可以基于访问来组织列。比如数仓的场景，用户关注的列可能随着时间推移而变化。\r\n即随着时间推移，用户访问的变化，从新组织维度表。	\N	\N	17	\N	3	\N	5	1	2019-11-08 07:16:00.300315	2019-11-08 07:37:04.457566	2019-11-08	0	\N	\N	536	1	2	f	\N
450	6	17	PG ctid	/* A word about t_ctid: whenever a new tuple is stored on disk, its t_ctid\r\n * is initialized with its own TID (location).  If the tuple is ever updated,\r\n * its t_ctid is changed to point to the replacement version of the tuple.\r\n//如果让ctid指向索引，这个or就不成立了\r\n * Thus, a tuple is the latest version of its row iff XMAX is invalid or\r\n * t_ctid points to itself (in which case, if XMAX is valid, the tuple is\r\n * either locked or deleted).  \r\n * One can follow the chain of t_ctid links\r\n * to find the newest version of the row.  Beware however that VACUUM might\r\n * erase the pointed-to (newer) tuple before erasing the pointing (older)\r\n * tuple.  \r\n//follow应该终止如果ctid不指向同一个block\r\nHence, when following a t_ctid link,\r\n\r\n it is necessary to check\r\n * to see if the referenced slot is empty or contains an unrelated tuple.\r\n * Check that the referenced tuple has XMIN equal to the referencing tuple's\r\n * XMAX to verify that it is actually the descendant version and not an\r\n * unrelated tuple stored into a slot recently freed by VACUUM.  If either\r\n * check fails, one may assume that there is no live descendant version.\r\n *\r\n * t_ctid is sometimes used to store a speculative insertion token, instead\r\n * of a real TID.  A speculative token is set on a tuple that's being\r\n * inserted, until the inserter is sure that it wants to go ahead with the\r\n * insertion.  Hence a token should only be seen on a tuple with an XMAX\r\n * that's still in-progress, or invalid/aborted.  The token is replaced with\r\n * the tuple's real TID when the insertion is confirmed.  One should never\r\n * see a speculative insertion token while following a chain of t_ctid links,\r\n * because they are not used on updates, only insertions.\r\n//speculative insertion token仍然可以保留，只是在确定插入的时候，其指向索引信息。\r\n\r\n这仅对于ac而言，ac的数据扫描由自己完成。	\N	\N	17	\N	3	\N	5	1	2019-06-20 12:03:05.232454	2019-06-20 13:25:05.903814	2019-06-20	0	\N	\N	450	1	2	f	\N
451	6	17	PG CI-IOT	IOT使用场景：1，查询基本使用key。 2，除了index key之外表比较短小。 3，尽量少的second index。\r\n从BEAS理论来说这两点都是满足的。\r\n\r\npostgresql不支持IOT可能有两方面原因：\r\n1，通常IOT实现在index上增加可见信息，这与pg目前框架区别太大，代价非常高。\r\n2，IOT适用场景比较有限。\r\n\r\npostgresql clusterd index：\r\nhttps://www.postgresql.org/docs/10/sql-cluster.html\r\n这代价有点大，而且需使用命令触发。\r\n\r\n\r\n如果将index最底层的page换成heap会怎样？\r\n或者说index不变，只是其指向的不再是tuple，而是page。逻辑上会发生什么变化。\r\n\r\n或者说成稀疏index，whatever？ 这样heap里面的tuple格式就与目标一致了，且insert不必总是更新两个页面。\r\n而版本清理后续还能通过undo机制优化。\r\n\r\nIOT的玩法对于scan也是一样，总是index scan。或者说这并非传统意义上的indexscan，这就是ac scan。\r\n如果能用索引，就直接定位到具体的heap page，如果不能，就从最左边的heap page开始。\r\n\r\nheap page仅支持单向扫描，干掉左边的指针。也可不支持指向parent，使得btree代码可以完全重用。\r\n\r\n优点：\r\n1，通常只需更新heap，可加快更新速度。\r\n2，砍掉了index头部，节省部分空间\r\n3，查询时不必额外拼装tuple。写入时也不必拆分。\r\n	\N	\N	17	\N	3	\N	5	9	2019-06-22 09:05:58.556767	2019-06-26 08:13:34.847236	2019-06-22	0	\N	\N	451	1	2	f	\N
455	6	17	PG CI_v2	索引记录的存储结构为\r\nX|Y|Z\r\nZ = heap header | count | pkid, Z是定长结构。\r\n\r\n该方案只需在中间层做些手脚就可以了，不改btree，也不改heap。\r\n\r\n记录格式调整为:\r\nIndexTupleData + [ | IndexAttributeBitMapData] + [ | HeapHeaderData] + fields\r\n\r\n使用ItemPointerData的offset最高位表示是否为AC，对于该offset的使用一定要小心。\r\n这样可直接返回heapTuple。 HeapHeaderData中null部分是变长的。\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	9	2019-06-26 12:01:24.429652	2019-06-28 14:33:46.96595	2019-06-26	0	\N	\N	455	1	2	f	\N
444	6	17	PG heap/storage	1，一个文件多大，如何切换文件\r\n这个实现在md中，_mdfd_segpath。pg对于relfilenode抽象：\r\ntypedef struct buftag\r\n{\r\n    RelFileNode rnode;            /* physical relation identifier */\r\n    ForkNumber    forkNum;\r\n    BlockNumber blockNum;        /* blknum relative to begin of reln */\r\n} BufferTag;\r\n\r\nforkNum：\r\n/*\r\n * The physical storage of a relation consists of one or more forks. The\r\n * main fork is always created, but in addition to that there can be\r\n * additional forks for storing various metadata. ForkNumber is used when\r\n * we need to refer to a specific fork in a relation.\r\n */\r\n因此我们可以定义自己的forkNum实现特殊的存储目的。\r\n\r\n对pg而言页的逻辑number是不断增加的，但是一个文件的大小受限于RELSEG_SIZE。默认是128k，这样一个segment不会超过1GB。	\N	\N	17	\N	3	\N	5	8	2019-06-11 12:51:12.651853	2019-07-05 15:05:35.314571	2019-06-11	0	\N	\N	444	1	2	f	\N
537	6	4	单词本-1	straddle：例句Each stripe contains only entire rows so that rows never straddle stripe boundaries\r\ncipher：密文\r\nidentical：相同，雷同 例句：Run length encode - a sequence of at least 3 identical values	\N	\N	17	\N	3	\N	5	1	2019-11-14 06:45:07.833048	2019-11-15 08:58:48.821351	2019-11-14	0	\N	\N	537	1	2	f	\N
386	8	17	beas的理解	Schema使用例子：\r\n存在一张学生日志记录表，其中日志中有日期，天气，作者，事件等信息。\r\n另外还有一张表记录了某个学生请假的情况，有学生，请假，日期。\r\n\r\n现在想分析学生请假与下雨的关系。\r\n这样可使用schema：日期->天气\r\n学生日志记录表可抽取 日期|天气的子表。其记录数量远小于学生日志记录表。\r\n\r\n由此说来存在子表通常更可能出现在表设计没有充分分解的情况。如果将日志记录表拆开。\r\n日期，作者，事件\r\n日期，天气\r\n这样就不存在问题。	\N	\N	17	\N	3	\N	5	8	2019-05-11 03:48:54.375613	2019-11-15 15:00:48.260744	\N	0	\N	\N	386	1	2	f	\N
1043	6	7	SSDR 28：volatile，内存屏障，原子变量，锁	1，volatile 只能保证写入后的读可以看见最新值。参考 SSDR 27.\r\n2，内存屏障有2个作用：防止指令顺序优化 和 保证CPU cache可见性。\r\n3，原子变量，除了保证原子操作还有内存屏障作用。而且Rust中原子变量支持不同的屏障模式。\r\n4，锁，这个当然更猛了	\N	\N	17	\N	3	\N	5	2	2022-04-12 18:05:12.868677	2022-05-06 20:24:39.768959	2022-04-12	0	\N	\N	1043	1	2	f	\N
604	6	15	羽毛球的精神奥义(也是生活的奥义)	1，放松而积极，是人最好的执行状态。\r\n2，最完美的节奏就是刚好出现在该出现的地方，这是天时地利，不遵守就会吃亏。\r\n3，当你在与别人比较时，你就做了自我限制，同时行为也有了局限，\r\n   真正热爱一项事情，热衷于改进自己。就不会被别人牵绊。同时也能真正看到别人身上的优点与缺点，这是人和。\r\n   观察自己内心升起的感觉，使用少有人走的路的修行方法。\r\n4，有原则才能不犯低级错误。\r\n\r\n每时每刻做最好的自己。不管做什么都是一种修行。	\N	\N	17	\N	3	\N	5	0	2020-04-09 06:01:41.569789	2020-04-09 06:01:41.569789	2020-04-09	0	\N	\N	604	1	2	f	\N
402	6	23	C-内存安全函数封装	C11标准定义的函数是有点奇怪的，其不仅做了防溢出处理，整个函数形式都发生了变化。	\N	\N	17	\N	3	\N	5	5	2019-05-15 12:38:40.543818	2019-05-16 09:37:25.452196	2019-05-15	0	\N	\N	402	1	2	f	\N
398	6	23	C语言-extern	extern的语义是：声明变量或函数在其他地方定义了，避免编译器在编译期间找不到其定义导致编译出错。\r\n\r\n注意：显然这个关键字是不会改变变量/函数的作用域的。	\N	\N	17	\N	3	\N	5	1	2019-05-14 15:01:16.66401	2019-05-14 15:15:19.847724	2019-05-14	0	\N	\N	398	1	2	f	\N
397	6	23	C语言-内联与宏定义	C++ 语言的函数内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作类的数据成员。所以在C++ 程序中，应该用内联函数取代所有宏代码.\r\n\r\n内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联： \r\n（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 \r\n（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 \r\n类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。 \r\n　　一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了inline不应该出现在函数的声明中）。\r\n\r\nhttps://www.cnblogs.com/luntai/p/6251727.html\r\n\r\n使用，但不可滥用。	\N	\N	17	\N	3	\N	5	2	2019-05-14 14:52:40.105597	2019-05-14 18:26:38.352974	2019-05-14	0	\N	\N	397	1	2	f	\N
401	6	9	品格言集	1，散漫只会让人变得骄横，不会真正让人变强。相反每天的自律与更新可以让人变强。\r\n	\N	\N	17	\N	3	\N	5	0	2019-05-15 06:46:24.850985	2019-05-15 06:46:24.850985	2019-05-15	0	\N	\N	401	1	2	f	\N
404	6	17	beas constraint index的管理	1，数理清楚IO模型，使用场景，数据关系特征。\r\n2，初步方案，并结合现有实现细化场景。	\N	\N	17	\N	3	\N	5	18	2019-05-20 06:48:49.155098	2019-06-20 08:35:08.616856	2019-05-20	0	\N	\N	404	1	2	f	\N
453	6	18	大存储-世界普遍存在的问题	人的生活，生产活动中无处不在。存储可以代表实体资源或虚拟资源。围绕资源的关系，维护，访问。\r\n存储，计算，网络构成了整个互联网世界。	\N	\N	17	\N	3	\N	5	0	2019-06-25 06:39:50.260716	2019-06-25 06:39:50.260716	2019-06-25	0	\N	\N	453	1	2	f	\N
449	6	17	PG Scan执行	了解heapscan，bitmapscan，indexscan等各种实现细节。\r\n更加清晰ciscan的地位。	\N	\N	17	\N	3	\N	5	4	2019-06-18 14:37:56.253948	2019-06-22 13:37:31.31779	2019-06-18	0	\N	\N	449	1	2	f	\N
1044	6	7	SSDR 29：变量赋值是原子操作吗？	https://blog.csdn.net/dog250/article/details/103948307?version=2.5.50000.157&platform=win\r\nhttps://www.codeleading.com/article/5702494736/\r\n\r\n没有cache line对齐的变量可能是非原子操作。	\N	\N	17	\N	3	\N	5	1	2022-04-12 19:23:26.821522	2022-04-12 19:26:38.612902	2022-04-12	0	\N	\N	1044	1	2	f	\N
405	6	17	聚簇索引	聚簇索引，其数据根据索引顺序组织，因而其btree的中间节点可指向页面，叶子节点就是实际数据。\r\n非聚簇索引，叶子节点存的是tid。\r\n\r\n\r\n<pre><code class="text">\r\n1、大多数表都应该有聚簇索引或使用分区来降低对表尾页的竞争，在一个高事务的环境中，对最后一页的封锁严重影响系统的吞吐量。\r\n\r\n2、在聚簇索引下，数据在物理上按顺序排在数据页上，重复值也排在一起，\r\n因而在那些包含范围检查(between、<、<=、>、>=)或使用group by或orderby的查询时，\r\n一旦找到具有范围中第一个键值的行，具有后续索引值的行保证物理上毗连在一起而不必进一步搜索，\r\n避免了大范围扫描，可以大大提高查询速度。\r\n\r\n3、在一个频繁发生插入操作的表上建立聚簇索引时，不要建在具有单调上升值的列(如IDENTITY)上，否则会经常引起封锁冲突。\r\n\r\n4、在聚簇索引中不要包含经常修改的列，因为码值修改后，数据行必须移动到新的位置。\r\n\r\n5、选择聚簇索引应基于where子句和连接操作的类型。\r\n</code></pre>\r\n	\N	\N	17	\N	3	\N	5	1	2019-05-20 08:19:55.405042	2019-05-20 08:20:30.817725	2019-05-20	0	\N	\N	405	1	2	f	\N
533	6	7	软件设计与实现	1，按照不同层次画模块图，以及数据组织图\r\n2，在每个图上运行软件可能遇到的流程(使用场景)\r\n3，逐层打开，直到可以作为实现的参考。	\N	\N	17	\N	3	\N	5	13	2019-10-16 06:24:19.770118	2020-12-19 15:09:00.420293	2019-10-16	0	\N	\N	533	1	2	f	\N
452	6	17	PG page/buffer	buffer上有4种锁：\r\npin\r\nread lock\r\nwrite lock\r\nsuper-exclusive lock\r\n\r\npin与最后一个冲突。	\N	\N	17	\N	3	\N	5	0	2019-06-23 21:24:14.928543	2019-06-23 21:24:14.928543	2019-06-23	0	\N	\N	452	1	2	f	\N
515	6	17	PG索引-元数据解析		\N	\N	17	\N	3	\N	5	3	2019-09-17 08:14:50.635999	2019-09-18 16:56:32.31283	2019-09-17	0	\N	\N	515	1	2	f	\N
454	6	17	PG CI	CI is constraint index，我们希望将其作为小规模的数据源来使用。即它是一个可以作为数据源的index。\r\n\r\n这样可以基于普通表来创建AC，也可以基于远程表来创建AC。\r\n\r\n测试方式，创建一个本地表，创建ac。然后在原表中写入数据。\r\nac通过索引方式，引发数据写入，但是ac在最底层会将index tuple转为普通的tuple。	\N	\N	17	\N	3	\N	5	2	2019-06-26 08:18:32.67748	2019-06-26 09:11:32.41991	2019-06-26	0	\N	\N	454	1	2	f	\N
440	6	17	PG术语	TID：tuple id\r\nXID：事务id\r\nLSN：log sequence number，记录在page上，用于确保wal机制.	\N	\N	17	\N	3	\N	5	2	2019-06-06 09:19:24.564355	2019-06-28 07:51:30.034199	2019-06-06	0	\N	\N	440	1	2	f	\N
464	6	7	Succinct Data Structure	https://chuansongme.com/n/2035229\r\nhttp://xszhao.science/blog/Review-SuRF-Practical-Range-Query-Filtering-with-Fast-Succinct-Tries/	\N	\N	17	\N	3	\N	5	0	2019-07-11 21:24:02.697835	2019-07-11 21:24:02.697835	2019-07-11	0	\N	\N	464	1	2	f	\N
535	3	24	整体方案与第一阶段目标	1，coral是什么\r\n2，coral由哪些部分组成\r\n3，每个组成的选型讨论\r\n4，每个组件的详细方案	\N	\N	17	\N	3	\N	5	3	2019-11-02 07:44:25.55005	2019-11-12 13:33:03.947986	2019-11-02	0	\N	\N	535	1	2	f	\N
468	6	17	PG CI_v2 vacuum&analyze	index老版本膨胀问题。火车头 xmax | tid | count | tid | count. 尾巴，尾巴的page可考虑单独管理.\r\npage和tuple的组织结构发生变化。可能需利用btrree\r\n\r\nvacuum效率问题。vm标记也是必须的，要么就在page上标记，这样仍然需加载page。\r\nci全量同步事务id消耗。全量导入期间不启动事务。而不是每个全量包启动一个事务来执行。	\N	\N	17	\N	3	\N	5	6	2019-07-17 07:29:08.476547	2019-07-19 07:50:34.207239	2019-07-17	0	\N	\N	468	1	2	f	\N
465	6	17	PG 索引 pin问题	buffer manager的README：\r\n5. To physically remove a tuple or compact free space on a page, one\r\nmust hold a pin and an exclusive lock, *and* observe while holding the\r\nexclusive lock that the buffer's shared reference count is one (ie,\r\nno other backend holds a pin).  If these conditions are met then no other\r\nbackend can perform a page scan until the exclusive lock is dropped, and\r\nno other backend can be holding a reference to an existing tuple that it\r\nmight expect to examine again.  Note that another backend might pin the\r\nbuffer (increment the refcount) while one is performing the cleanup, but\r\nit won't be able to actually examine the page until it acquires shared\r\nor exclusive content lock.\r\n\r\n那么什么情况下需要pin呢？\r\n<pre><code class="text">\r\nThis is not necessary for correctness in terms of the btree index\r\noperations themselves; as explained above, index scans logically stop\r\n"between" pages and so can't lose their place.  The reason we do it is to\r\nprovide an interlock(互锁) between non-full VACUUM and indexscans.  Since VACUUM\r\ndeletes index entries before reclaiming heap tuple line pointers, the\r\nsuper-exclusive lock guarantees that VACUUM can't reclaim for re-use a\r\nline pointer that an indexscanning process might be about to visit.  This\r\nguarantee works only for simple indexscans that visit the heap in sync\r\nwith the index scan, not for bitmap scans.  We only need the guarantee\r\nwhen using non-MVCC snapshot rules; when using an MVCC snapshot, it\r\ndoesn't matter if the heap tuple is replaced with an unrelated tuple at\r\nthe same TID, because the new tuple won't be visible to our scan anyway.\r\nTherefore, a scan using an MVCC snapshot which has no other confounding\r\nfactors will not hold the pin after the page contents are read.  The\r\ncurrent reasons for exceptions, where a pin is still needed, are if the\r\nindex is not WAL-logged or if the scan is an index-only scan.  If later\r\nwork allows the pin to be dropped for all cases we will be able to\r\nsimplify the vacuum code, since the concept of a super-exclusive lock\r\nfor btree indexes will no longer be needed.\r\n</code></pre>\r\n\r\n这段说明了这种情况。非MVCC好理解，因为他们要看到所有tuple，如果scan page之后访问时，被vacuum修改，\r\n即TID变更，可能出现异常行为。\r\n\r\n那index only scan呢？\r\n按readme中的意思，super-exclusive lock和pin的并发可以确保index对应的heap tid不\r\n被回收。否则可能出现vacuum清理了vm可见，且回收了TID，index only scan还能看到对应的\r\ntuple，这样逻辑上就出问题了。\r\n假设index only scan释放pin之后，vacuum拿到page lock，并且进行清理。然后index only scan拿到scan中缓存的tuple。\r\n以及被vacuum修改的vm visible信息。那index only scan可能看到本来被删除的记录。在index scan的时候这样没问题，可以通过检查判断\r\nTID对应的tuple发生了变化。\r\n	\N	\N	17	\N	3	\N	5	1	2019-07-13 18:36:17.669962	2019-07-31 14:02:49.712596	2019-07-13	0	\N	\N	465	1	2	f	\N
115	6	7	字符编码	研究字符编码相关的问题。\r\n文件系统，软件如何处理编码问题？\r\nstring类型与编码的关系？	\N	\N	17	\N	3	\N	5	10	2018-10-11 13:08:18.394392	2019-11-21 13:52:55.974282	2018-10-11	0	\N	\N	115	1	2	f	\N
1045	6	31	number类型的实现与优化		\N	\N	17	\N	3	\N	5	0	2022-04-13 06:59:04.943993	2022-04-13 06:59:04.943993	2022-04-13	0	\N	\N	1045	1	2	f	\N
493	6	7	bloom filter	https://bean-li.github.io/leveldb-sstable-bloom-filter/	\N	\N	17	\N	3	\N	5	1	2019-08-19 18:17:15.063826	2019-11-11 07:30:52.183504	2019-08-19	0	\N	\N	493	1	2	f	\N
445	6	8	关于幸福与烦恼	1，幸福并非来自目标的达成\r\n2，真正的幸福是现在幸福将来也幸福\r\n3，幸福是对快乐的感知能力，快乐是一种心流体验。\r\n   说得更低点快乐就是需求被满足的感觉。但被满足的幸福这个就是一副毒药。\r\n   就像及时行乐的幸福，这种幸福非常短暂。\r\n\r\n   小孩子的快乐既有被满足的快乐，也有发现与探索的快乐。小孩子因身体限制其一般不会过度，因而其快乐是非常合适的。\r\n\r\n4，结合无限游戏和心流，我们知道快乐真正其实来源于能够产生美好感受的游戏，且这种美好是自己参与其中的。\r\n成就感\r\n身体需要\r\n成长\r\n快乐的事情可能都满足这些标准。\r\n\r\n5，烦恼来自于对过去的不甘和对未来的不安，习得性无阻是活力的屏障。一个没有活力的人通常也是习得性无助的人。\r\n6，不仅要安排好我们的时间，还有我们的体能，以及我们的脑力。使得我们能有节律的生活。就像打球一样，刚开始可能练动作很奇怪，然而没有人天生就会生活。\r\n7，更深的烦恼来自于矛盾，即你想达成的目标，与当下无法去达成的矛盾。这种矛盾简单把现代人逼疯了。不过这个问题在任何时代可能都非常严重，只是现代\r\n诱惑更多，人更容易采用临时性满足的方式去代替，因而人与人的差距也变得更大。\r\n8，如果因人或事而烦恼，且没有阻碍我们去处理的矛盾。那么这本身就不会那么痛苦，反而在处理过程中能够得到快乐。\r\n显然人不是因为生活在记忆或憧憬中而快乐，尽管这种方式看上去很常见，没有多少人能活在当下，体验真实的快乐。	\N	\N	17	\N	3	\N	5	0	2019-06-16 12:52:28.831491	2019-06-16 12:52:28.831491	2019-06-16	0	\N	\N	445	1	2	f	\N
497	6	9	看到-接受-改变	保留带宽，看到自己，看到别人\r\n接受自己，也接受别人的状态\r\n改变需要时机，改变是一种内生的力量	\N	\N	17	\N	3	\N	5	2	2019-08-25 18:47:52.547292	2019-11-23 22:26:10.069017	2019-08-25	0	\N	\N	497	1	2	f	\N
547	6	17	关于剥离Btree以实现AC的原因	1，可以自定义ci tuple header节省空间\r\n2，ci实现脱离index框架，以支持后续其他方式存储\r\n3，不涉及改动btree代码，修改更独立。\r\n	\N	\N	17	\N	3	\N	5	0	2020-01-02 18:58:21.117463	2020-01-02 18:58:21.117463	2020-01-02	0	\N	\N	547	1	2	f	\N
448	6	7	linux时间-唯一id	硬件时间与系统时间\r\nhttps://linux.die.net/man/8/hwclock\r\nhttps://linux.die.net/man/2/clock_gettime\r\n\r\n想在应用程序中使用单调时间，需使用硬件时间。	\N	\N	17	\N	3	\N	5	0	2019-06-18 14:29:34.91606	2019-06-18 14:29:34.91606	2019-06-18	0	\N	\N	448	1	2	f	\N
719	6	15	如何赢球	1，变换节奏，使对方跑不到接球点\r\n2，出其不意的前场吊球\r\n3，重心不稳下的双边击球\r\n4，快速过顶\r\n5，追身球\r\n6，对方不到位的杀球	\N	\N	17	\N	3	\N	5	1	2020-12-18 06:20:10.777414	2021-10-10 20:23:23.111024	2020-12-18	0	\N	\N	719	1	2	f	\N
457	6	17	PG之HeapTupleHeader	了解HeapTupleHeader中每个字段的含义，以及存在的原因	\N	\N	17	\N	3	\N	5	0	2019-07-06 12:07:43.904879	2019-07-06 12:07:43.904879	2019-07-06	0	\N	\N	457	1	2	f	\N
460	6	9	看自己，看当下	如果你球没打好，你会分析自己今天哪里出了问题。\r\n是身体不适，还是某个技术点没掌握好等。\r\n\r\n工作也是如此，当下的现实情况是什么？找到根因，从而突破自己。\r\n如果你不希望自己有某个行为，也要挖清楚内在根因是什么。\r\n\r\n生活就如科学一样，想突破成高手。就需要去研究每个细节，不断的去实践总结。\r\n\r\n	\N	\N	17	\N	3	\N	5	3	2019-07-07 21:44:13.60313	2019-09-09 15:03:41.828014	2019-07-07	0	\N	\N	460	1	2	f	\N
446	6	17	PG测试方法	PGTap看上去很鸡肋，pg测试基本是基于sql的。\r\n\r\n第一阶段，先挂载到一个表上。\r\n表定义包含2列，一是x，另一个是y。在此基础上附上一列count。\r\n并拦截其操作。	\N	\N	17	\N	3	\N	5	1	2019-06-17 13:34:14.144403	2019-08-05 08:53:00.765307	2019-06-17	0	\N	\N	446	1	2	f	\N
491	6	17	数据引擎的100问	1，为什么需要redo\r\n2，为什么需要undo\r\n3，为什么需要checkpoint\r\n4，为什么需要后台wal线程，后台写数据线程\r\n5，为什么需要GC\r\n6，空间管理有哪些形式\r\n7，hash索引与btree索引的优劣\r\n8，内存数据库与磁盘数据库加cache的真正区别是什么\r\n9，为什么需要列存储\r\n10，为什么会出现时序数据库\r\n11，为什么Span需要TrueTime API，时间意味着什么？\r\n12，什么操作不需要WAL，什么操作无法回滚？\r\n13，是否所有wal记录的操作都能具备幂等性?\r\n14，为什么说分布式事务本质上都是使用二阶段提交协议？\r\n15，什么是一阶段提交协议\r\n16，2PC与Paxos什么关系？\r\n17，MVCC,WAL与事务的关系	\N	\N	17	\N	3	\N	5	3	2019-08-12 06:50:17.795079	2019-08-14 13:47:36.149837	2019-08-12	0	\N	\N	491	1	2	f	\N
494	8	17	Postgresql中的money符号	money的单位是跟环境有关系的，如果*LC_MONETARY*="zh_CN.UTF-8"，则显示为￥，在en_US.UTF-8下显示为$。\r\n跟输入法的显示效果一样。\r\n\r\n在编译pg的时候，虽然当前用户设置为zh_CN.UTF-8，但是并没卵用。\r\n[xr@localhost common]$ locale\r\nLANG=zh_CN.UTF-8\r\nLC_CTYPE="zh_CN.UTF-8"\r\nLC_NUMERIC="zh_CN.UTF-8"\r\nLC_TIME="zh_CN.UTF-8"\r\nLC_COLLATE="zh_CN.UTF-8"\r\n*LC_MONETARY*="zh_CN.UTF-8"\r\nLC_MESSAGES="zh_CN.UTF-8"\r\nLC_PAPER="zh_CN.UTF-8"\r\nLC_NAME="zh_CN.UTF-8"\r\nLC_ADDRESS="zh_CN.UTF-8"\r\nLC_TELEPHONE="zh_CN.UTF-8"\r\nLC_MEASUREMENT="zh_CN.UTF-8"\r\nLC_IDENTIFICATION="zh_CN.UTF-8"\r\nLC_ALL=\r\n\r\n\r\n\r\n设置系统的LANG：\r\n[xr@localhost common]$ localectl status\r\n   System Locale: LANG=en_US.UTF-8\r\n       VC Keymap: us\r\n      X11 Layout: us\r\n[xr@localhost common]$ localectl set-locale LANG="zh_CN.UTF-8"\r\n==== AUTHENTICATING FOR org.freedesktop.locale1.set-locale ===\r\nAuthentication is required to set the system locale.\r\nAuthenticating as: root\r\nPassword: \r\n==== AUTHENTICATION COMPLETE ===\r\n[xr@localhost common]$ localectl status\r\n   System Locale: LANG=zh_CN.UTF-8\r\n       VC Keymap: us\r\n      X11 Layout: us\r\n修改之后，重新编译（或许重启即可），money类型默认显示就是￥	\N	\N	12	\N	3	\N	5	3	2019-08-23 06:50:11.172919	2019-08-23 06:51:07.504961	\N	0	\N	\N	494	1	2	f	2019-08-23 06:51:07.504961
496	8	17	关于列存储的问题	列存储与多索引的关系？\r\nhttps://docs.microsoft.com/zh-cn/sql/relational-databases/indexes/columnstore-indexes-overview?view=sql-server-2017\r\nSQL Server有列存储索引，可以基于行表的索引，也可以单独作为表存储\r\n--非聚集列存储索引和聚集列存储索引的功能相同。 不同之处在于，非聚集索引是对行存储表创建的辅助索引，而聚集列存储索引是整个表的主存储。\r\n\r\n区别主要在于列存储本质上是压缩的heap\r\n而索引存储数据组织与行序没关系，但指向行\r\nAC与行毫无关系，也不是压缩的heap，是压缩的cluster表。\r\n\r\n列存储如何表示元组？	\N	\N	17	\N	3	\N	5	0	2019-08-23 15:22:15.160321	2019-08-23 15:22:15.160321	\N	0	\N	\N	496	1	2	f	\N
456	6	9	唯实力论	你可以不计较一时的输赢，但你得有实力。\r\n就像羽毛球技术一样，真正的实力就是碾压式的。互有输赢的时候才有资格说不计较输赢，否则就有点自不量力了。\r\n\r\n就像羽毛球运动一样，很多事情都有衡量实力的尺度。这些尺度显然不近人情，但是客观的，这是游戏有趣的地方，否则就无法衡量实力了。\r\n比如个人经济能力，就看利润和收益比。羽毛球比赛就看输赢，比分。\r\n教育就看综合素养，各方面的评分。\r\n\r\n有尺度并非说是最终目标，这些都是无限游戏，尺度是让我们知道在这游戏中自己水平如何。\r\n\r\n劈开实力去高谈阔论就容易言过其实。\r\n\r\n实力就是知行合一后的尺度，在这真实的世界中如何轻快的飞驰，保持实力是每个直面生活的人都需不断思考的。	\N	\N	17	\N	3	\N	5	1	2019-07-03 22:01:25.620429	2019-07-13 19:01:38.522886	2019-07-03	0	\N	\N	456	1	2	f	\N
919	6	23	C语言，优雅的封装结构体而不是使用void指针	typedef struct StRowDataSetBuilder DataSetBuilder;\r\ntypedef struct StColumnDataBuilder ColumnBuilder;\r\n\r\n这样在c文件中不必转换ColumnBuilder指针，就能当作StColumnDataBuilder方式使用。\r\n同时对外也是不可见的。	\N	\N	17	\N	3	\N	5	0	2021-07-28 08:23:53.379915	2021-07-28 08:23:53.379915	2021-07-28	0	\N	\N	919	1	2	f	\N
1046	6	31	系统表的认知	系统表用于存储系统的元数据，有几点好处：\r\n1，本身可以查询，不用做dump元数据的工具了\r\n2，有多版本支持，可以回滚保证事务原子性。\r\n3，方便dc加载，否则元数据散落各处，离散读性能很差。\r\n\r\n坏处：\r\n1，结构本身缺乏完备性，无法自解析。必须带着dc才能玩得转。\r\n2，依赖关系有点乱，一方面结构需要dc，而dc的加载又来自于结构。	\N	\N	17	\N	3	\N	5	0	2022-04-13 07:09:29.406199	2022-04-13 07:09:29.406199	2022-04-13	0	\N	\N	1046	1	2	f	\N
522	6	8	自由，平等，自尊，博爱	自由就是做自己，然后并不是那么好做，要克服自己的缺陷，保持自己的成长，做一个更好的自己需要坚定的信念。\r\n以及一定的自律。\r\n\r\n自由是平等的前提，如果都做不了自己，谈不了平等。\r\n\r\n自尊隐含了一个概念：我值得拥有幸福。自尊是看到自己，接受自己，改变自己。\r\n一个人有了自我，有了自我的幸福，推及别人。	\N	\N	17	\N	3	\N	5	0	2019-09-22 14:38:49.431989	2019-09-22 14:38:49.431989	2019-09-22	0	\N	\N	522	1	2	f	\N
520	6	8	成瘾的本质	大脑中有通路，在刺激后分泌物质形成快感，从而影响人的行为。持久的刺激形成了记忆，影响了选择判断。\r\n\r\n3.1 慎重的开始，了解事情的性质，并大概限制下时间\r\n3.2 把节奏慢下来，累了就休息\r\n3.3 当幸福感，快乐消失时，自然的停止	\N	\N	17	\N	3	\N	5	3	2019-09-22 13:19:55.336777	2019-09-22 14:43:20.146909	2019-09-22	0	\N	\N	520	1	2	f	\N
523	6	8	书中自有黄金屋-交易的魅力	人的经历有限，带宽有限。在这种限制下，想获取其他最好的办法就是通过交换获得。\r\n直接获取并不容易。	\N	\N	17	\N	3	\N	5	0	2019-09-22 14:40:17.98177	2019-09-22 14:40:17.98177	2019-09-22	0	\N	\N	523	1	2	f	\N
538	6	9	美好在于刚好遇见你	一个对学习失去热情的学生，如何让他重新点燃学习的热情？\r\n我知道一切强制措施都是没有意义的，这里存在人与事的矛盾。\r\n在此刻他恰好没法感受到学习的乐趣和意义，只要没有这种内生的动力，任何外部的努力都事倍功半，甚至会由于扭曲的方式造成更深的伤害。\r\n而如何让他更快的找到自己的热爱，可能只能站在其角度去导引，同时保持耐心。\r\n看到，接受，改变或者\r\n忽视，逃避，轮回\r\n这是一种选择，是刻骨铭心的认真生活，还是稀里糊涂的随遇而安。\r\n\r\n就像当时我读初中，读大学，在华为工作一样，刚好没遇见我。\r\n坚韧不拔，豪情万丈，艰苦拼搏，苦尽甘来。留下足迹才美丽。刚好遇见你。\r\n在遇到的人和事时，我们恰好就是那个合适的我们。\r\n	\N	\N	17	\N	3	\N	5	0	2019-11-23 22:23:32.827475	2019-11-23 22:23:32.827475	2019-11-23	0	\N	\N	538	1	2	f	\N
516	6	7	递归-转换	去递归一个典型的例子就是二叉树。如果将二叉树的node进行编码，可以使用循环来替代递归\r\n\r\n例如kdtree的遍历\r\n\r\n<pre>\r\n/* search kdnode by id , id start from 1 */\r\nKdTreeNode* kdTreeSearch(KdTreeState state, int number)\r\n{\r\n\tint i;\r\n\tbool start = false;\r\n\tbool to_right;\r\n\tKdTreeNode *ret = NULL;\r\n\t\r\n\tfor(i = state->level; i >= 0; i--)\r\n\t{\r\n\t\tto_right = FETCH_BIT(number, i) > 0;\r\n\t\tif (!start)\r\n\t\t{\r\n\t\t\t/* find the first 1 */\r\n\t\t\tif (to_right) {\r\n\t\t\t\tret = state->root;\r\n\t\t\t\tstart = true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (to_right) {\r\n\t\t\t\tret = ret->right;\r\n\t\t\t} else {\r\n\t\t\t\tret = ret->left;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n</pre>	\N	\N	17	\N	3	\N	5	1	2019-09-18 07:45:02.971074	2019-09-28 08:07:29.862712	2019-09-18	0	\N	\N	516	1	2	f	\N
524	7	16	完成一次基本的kv系统的讨论		2019-09-27	\N	19	\N	3	\N	5	0	2019-09-22 15:28:03.393182	2019-09-22 15:28:03.393182	2019-09-22	0	\N	\N	524	1	2	f	\N
539	6	9	看见高山，刻骨铭心的留下自己的足迹，有泪水有欢笑，看到每一个精彩的人生	羽毛球运动的高山，高手在不同的运动速度上，真正的行云流水一般。\r\n软件的高山，几十年长盛不衰。c，linux都是如此\r\n人生的高山，体验各种不一样的精彩，莫愁前路无知己，天下谁人不识君。做一个有意思有趣味的人。知行合一，温文如玉。	\N	\N	17	\N	3	\N	5	0	2019-11-23 22:32:02.258041	2019-11-23 22:32:02.258041	2019-11-23	0	\N	\N	539	1	2	f	\N
525	6	24	kudu存储引擎	Kudu：\r\nhttps://m.toutiaocdn.com/group/6739355978434609678/?app=news_article&timestamp=1569162381&req_id=201909222226210100260770753346EABC&group_id=6739355978434609678&tt_from=weixin&utm_source=weixin&utm_medium=toutiao_ios&utm_campaign=client_share&wxshare_count=1	\N	\N	17	\N	3	\N	5	2	2019-09-23 07:21:55.203987	2019-10-11 18:23:02.775489	2019-09-23	0	\N	\N	525	1	2	f	\N
540	6	24	coral实现阶段细节记录	1，delete位图使用valid表达方式，1表示未删除，0表示删除。\r\n伟超那边处于计算效率的考虑。\r\nvalid & not null & not delete\r\n比\r\nvalid & !(not null) & !(not delete)效率更高。	\N	\N	17	\N	3	\N	5	0	2019-11-27 14:29:35.81232	2019-11-27 14:29:35.81232	2019-11-27	0	\N	\N	540	1	2	f	\N
541	3	24	实施过程		\N	\N	17	\N	3	\N	5	10	2019-11-28 15:33:58.830509	2019-12-26 08:23:52.346232	2019-11-28	0	\N	\N	541	1	2	f	\N
544	6	17	杂记	讨论纪要：\r\nac重复有2个问题\r\n1，全量与增量引起的重复执行问题\r\n2，ac聚集导致的update不可重入问题，表上update是可重入的，因为IK对应的记录只有那一条。\r\n而AC上对重复Ik执行update，会导致count+1. 因而Ac独自去重时，必须通过Ik|X|Y一起确定其存在性，单独的Ik无法办到。\r\n\r\n基于表的AC构建：\r\n重复问题由表的unique约束保证。如果update对应的Ik，Ac列并未改变则跳过Ac上的更新。\r\n\r\n单独Ac构建：\r\n方案1，存储X|Y|Count|Iks,Iks独立存储，使用类似于toast方式，即。 X|Y|Count|Cid， Cid|[Ik]\r\n方案2，Ik|X|Y，X|Y|Count。\r\n\r\n\r\n如何平滑迁移?\r\n2棵树放入一个Relation存储，还是多个Relation？\r\n考虑是放入一个，多个Relation在上层需管理对应关系，不是很好表达。\r\n\r\n\r\n关于Gp：\r\nhttps://gpdb.docs.pivotal.io/6-2/admin_guide/intro/arch_overview.html\r\n1，table数据如何分布到不同segment？\r\nhttps://gpdb.docs.pivotal.io/6-2/admin_guide/ddl/ddl-table.html#topic34\r\ndistribute和partition是2个概念，跟coral中的region和partition关系一样，一个是逻辑上的划分，一个是承载物理数据的。\r\n\r\nPartitioning does not change the physical distribution of table data across the segments. Table distribution is physical:\r\n Greenplum Database physically divides partitioned tables and non-partitioned tables across segments to enable parallel query processing. \r\nTable partitioning is logical: Greenplum Database logically divides big tables to improve query performance \r\nand facilitate data warehouse maintenance tasks, such as rolling old data out of the data warehouse.\r\n\r\n2，Gp的列存表支持什么方式删除数据，列存表的统计信息如何用于加速访问。\r\n3，数据写入时，gp是在master上完成hash计算，然后给segment下发写入任务，还是都下发？\r\n4，To insert large amounts of data, use external tables or the COPY command。gp的批量导入机制？\r\nhttps://gpdb.docs.pivotal.io/6-2/admin_guide/load/topics/g-loading-and-unloading-data.html#topic1\r\n\r\nCOPY is non-parallel: data is loaded in a single process using the Greenplum master instance. Using COPY is only recommended for very small data files.\r\ngpload是利用external table，然后向segment发起命令，但是读数据是从external table读取，因而是可以并行的。\r\n\r\n纯粹导入AC时，可以在内存形成批量，然后按照AC特征进行排序写入临时文件(或非临时文件，类似于append表，如果需支持断点)，再构建Ac。\r\nbuild过程实现不变，仅是数据源头从原表改为临时表。\r\n\r\n问题：如果仅是Ac还是需要支持分区的吧\r\n临时表用于分区，同时还用于全量数据写入，非全量数据写入，直接通过特殊接口进入Ac。\r\n如果导入数据一个事务内，但时间上不属于一个分区，那么就涉及分割。octupos这时就涉及到多节点事务。\r\n或事务内update之前的数据，与插入新数据一起。\r\n5，gp全局事务的实现\r\nhttps://greenplum.cn/2019/07/07/greenplum-distributed-database-kernel-2/\r\n1，为啥分全局快照与本地共享快照。\r\n2，为什么支持不同segment有各自的快照，这样读一致性如何保证\r\n3，为什么slice必须有QE writer？读事务也如此吗？\r\n4，gp允许在segment上启动单机事务写入吗？还是启动分布式事务，只是写入发生的单机上。\r\n这样请求必须经过master。\r\n\r\n\r\n6，ac如何进行分区划分，表的不同ac分区划分不同允许吗？同步ac数据时必须带上表的分区键么？\r\n有没原表的区别仅在于是否存原表数据，这样octupos不必感知ac。但问题在于新创建的ac如何构建数据？\r\n\r\n\r\n数据以时间分区，表的IK是其他字段的话，那Ik的后续修改可能落到其他分区。\r\n分区与Ik不同时，是否有问题？如果按记录插入时间来，则可能划到不同分区。\r\n\r\n问题：1，如何确保所有表都按时间分区？\r\n\r\n7，可以学习下ao，aoc是如何增加am，并且与上层对接的。\r\nao多个关联子表的设计\r\n\r\n\r\n8，ao表\r\n空间管理上，每个segment对应于一个分区\r\n\r\n\r\nCI：\r\n除了提供可见性处理之外。CI不关心count，IKID，以及in与out等。\r\nCI还提供insert search接口，以及给定位置的insert接口。即支持undo方式管理老版本。\r\n\r\n按正规搞法得加ciam，以前是临时替换函数，非常规做法。\r\nIKId的管理：需要满足在一个segment内单调，也可以说是一个table内单调。\r\n或者不搞am，即从ac直接调用ci接口，假设当前不存在其他实现。\r\n没有index relation，pg11才支持cover index。\r\n\r\nAC：\r\nCI\r\n老版本记录，不需要tuple desc。另外用一个文件效果更好，但是需要看工作量。\r\n\r\ngp的shard如何表示：\r\n1，使用表，\r\n2，使用自定义结构\r\n但不管哪种结构对ac没影响，ac还是针对父表的。\r\n\r\nciIsEqual函数不需要，使用bt_compare。主要在于对于null值处理方式不一样。\r\nbuild目前是从单个relation取数据的。\r\nci提供一个暴露分配page的接口\r\n接口：\r\nciInsert\r\nciDelete \r\nciSearch\r\nciInsertAt\r\nciDeleteAt //set as deleted if count = 0, vacuum can gc the space\r\nciAllocPage //分配页面给外部使用\r\n\r\ncivacuum实现区别点；ci没有visible bitmap，因而增加了page visible的xlog.\r\nfreeze这块的数据结构借用之前的。\r\n\r\nci也需要recycle么，ci也需要统计信息。cleanup接口与bulkdelete接口分析。\r\ncycle id主要是用于解决vacuum使用物理页面顺序扫描导致的可能遗漏页面的问题。但是遗漏了有什么关系，极端情况下的freeze问题？确实试想如果每次vacuum正好split，然后导致记录没有freeze，那可能就错过了。\r\n再试想如果heap tuple被删除了，但是index tuple仍然存在的问题。\r\n注意这个函数heap_prepare_freeze_tuple，如果tuple的freeze信息与relatio对不上，会认为data corrupt挂掉。\r\n\r\nvacuum的自动触发机制，ci会被触发么？不会\r\nfreeze是根据表的relfrozenxid，relminmxid来进行判断的。这里当一个表对应多个ac时，如果没有原表数据是否有问题？\r\n针对vacuum，pgstat记录了dead tuples，通过判断dead tuple数量，与vacuum的标准：thresh + factor * reltuples来判断表是否进行vacuum。\r\n在表有变更操作时，需刷新统计信息，从而触发vacuum或analyze。\r\n每个ac需要独自去vacuum么？ac vacuum的统计信息单独于表么？支持给ac设置vacuum周期么？\r\nbeas1.0根本没有支持ac的auto vacuum。以前索引是基于表来vacuum的，索引必须依托于表而存在。\r\n在beas2.0中，先根据relation来，即找到relation对应的ac来执行auto vacuum。后续考虑支持ac上的统计信息并单独vacuum。\r\ngp中每个segment各自vacuum么，表的vacuum配置在所有segment同步？\r\n什么是lazy vacuum。\r\nfsm与vacuum。\r\nvacuum与analyze的交织，这块的控制非常乱。\r\n用户发起的命令有2类vacuum和analyze\r\nvacuum分为full，freeze，analyze。\r\nautovacuum发起时只有2个标记：vacuum，analyze。没有freeze。\r\nbtree等结构支持bulkdelete和cleanup接口。\r\n注意以前index是没有freeze过程的。\r\n\r\n\r\n为什么会有bulkdelete和cleanup接口？\r\n在table没有删除记录时，bulkdelete是不会被调用的。由于pg的mvcc，因而删除总是mark的，这是gc存在原因。\r\n\r\n\r\n分配页面部分：\r\n展开分析btree的空间管理\r\nfsm是一个三层的树结构，不过每个页面内部本身也是一个二叉树。\r\n二叉树是按照编号顺序存储的。\r\nindex的fsm不一样的地方：\r\nvacuum时在释放page之后，会更新fsm level 0对应的空间。对于heap，只要空间发生变化就会更新。\r\n在vacuum完成后，会发起对fsm上层页面的空间更新。\r\n\r\nHotStandby：\r\n1，在btvacuumscan时为什么需要在最后没有vacuum的page上加锁呢？\r\n\r\n问题集：\r\n1，ac是否应该跟表一起vacuum？\r\n2，ac analyze是否能单独执行？\r\n3，在都有可见性的情况下，如何保证ac与table的一致性？\r\n  写入过程因为有事务，不存在不同事务修改同一个heap tuple的情况，这样ac tuple修改可以对应起来。\r\n  但是不同heap tuple可能对应于同一个ac tuple。\r\n  还有ac构建过程中，可能一边从heap写入ac，另外heap上发生delete。如果delete先发生在ac上，则count记录为-1呢？还是怎么处理。\r\n  如果跳过，则可能最终count不对。即存在两个操作顺序需要被保证的情况，\r\n4，只有一个写入者的约束。\r\n5，ac能像索引一样处理吗？统计信息\r\n6，有加锁的索引吗？锁是否总是内存中的\r\n\r\n复杂度的来源：参与者，以及其关系。更细粒度的并发与流程控制。一致性。维度变多。\r\n果敢：看的清晰，切的勇敢。任何事物我们都难以看全整个面目，但是我们可以得出自己的脉络，并做出当下合适的选择。\r\n图灵或冯洛伊曼，IBM等先行者都无法预见未来计算机的面目。但是这不妨碍当下的选择，计算机室一个逐步发展的过程。任何其他复杂系统都是如此。\r\n思考的速度：思考速度的提升有赖于对于问题本质的认识。工程师看问题是看过程，结果，架构师看的是问题，需求与解决方案，科学家看到的是可行性。\r\n抓住问题的本质，去认识事物是自顶向下的。去观察过程，总结提炼的方式认识事物是自下而上的。没有自上而下的思维就如盲人摸象，没有自下而上的\r\n实践就像纸上谈兵。知行合一可以提现这两种思维方式，只是天才选手可能自上而下容易，而一般选手自下而上容易。理论与实践的交融。\r\n工程师：盲人摸象\r\n高级工程师：了解象的全貌\r\n架构师：庖丁解牛\r\n科学家：牛的抽象，牛的定义与本质\r\n\r\n计算机：bool，顺序与跳转，顺序，选择，循环\r\n	\N	\N	17	\N	3	\N	5	1	2019-12-28 18:26:51.69465	2019-12-29 21:22:29.722186	2019-12-28	0	\N	\N	544	1	2	f	\N
459	6	17	PG 锁	二阶段加锁：\r\nhttps://yq.aliyun.com/articles/626848\r\n\r\n锁都是针对资源的。资源可以是任何事物。\r\n锁可以分不同的模式，这是由资源的熟悉决定的。\r\n锁有明确的时间属性。所以分别有不同的实现方式。\r\n\r\n如果不是拿完立即释放就存在死锁的情况。数据库表锁和行锁就是这种。\r\n\r\n理论上锁都是可以是纯逻辑的，比如红绿灯，其实可以不放红绿灯在那，放别的标志也是一样的。重要的是大家都得按锁规则来使用资源。	\N	\N	17	\N	3	\N	5	6	2019-07-07 19:05:47.626652	2019-12-31 08:02:57.778794	2019-07-07	0	\N	\N	459	1	2	f	\N
521	6	8	如何生活	1，幸福快乐是什么？\r\n1.1 健康的身心\r\n1.2 成长与进步的喜悦\r\n1.3 良好的社交\r\n\r\n没有所谓的岁月静好，稀缺会影响人的价值判断。\r\n\r\n2，如何生活？\r\n2.1 改变一个人就像在脑中开辟一条新的河流，新的奖励机制，新的行为模型。\r\n2.2 给自己定一个目标，或一个要攻克的问题\r\n2.3 活在当下，编制美好快乐的可能	\N	\N	17	\N	3	\N	5	6	2019-09-22 13:20:17.055886	2020-01-12 20:01:46.413275	2019-09-22	0	\N	\N	521	1	2	f	\N
390	6	9	达利欧-原则-成功方法论	我们都知道一个缺乏原动力的人是多么的无趣，做事情没有认真严谨态度，对结果无所谓。我们在自己热爱的事情上难以容忍这样的搭档存在。\r\n我们可以有很多美好的目标，并且知道这些目标可以达到。有了激动人心的目标，我们就可以发挥自己的智慧提升自己的效率，自动思考相关问题，我们可以行动起来，不断逼近。\r\n我们不因别人的好恶影响自己的选择，我们选择是因为我们的目标如此，我们不愿错过美好。\r\n我们不去假设自己成为那个最优秀的人，也许天生环境我们无法达到。但我们可以在自己热爱的方向上不断前进，这就足够美好了。\r\n\r\n成功方法论\r\n激励自己的目标 + 逻辑机器构建项目 + 彻底解决项目运转的各个细节问题(一个领域常见疑难问题可能就上千规模)。\r\n\r\n成熟检验方法：\r\n一个人只有当自己完全自由时，直面压力，掌控自己达成目标。才算真正成长起来，成为那个可以在前面遮风挡雨，独当一面的人。\r\n\r\n病痛分析：\r\n每个人因成长环境，原生家庭，可能形成恐惧，麻木，软弱不自信，无力，懒散，安全感缺失，依赖，放纵等等毛病。\r\n焦虑是因为有风险，有风险是因为能力不够或预期不实际。\r\n不去制定目标通常是因为缺乏自信，或者没有痛感，对自己的成长对世界的探索丧失了兴趣。	\N	\N	17	\N	3	\N	5	5	2019-05-13 07:57:54.06441	2019-07-07 21:46:03.014214	2019-05-13	0	\N	\N	390	1	2	f	\N
462	6	17	PG hot standby	官方文档：\r\nhttps://www.postgresql.org/docs/9.0/hot-standby.html\r\n\r\n有个很大的问题是冲突，官方文档中有详细描述。\r\n在master上删除一个tuple 可能是surely dead的，但是在hot standby中可能有事务能看到。这种conflict很常见。	\N	\N	17	\N	3	\N	5	0	2019-07-08 12:59:03.716197	2019-07-08 12:59:03.716197	2019-07-08	0	\N	\N	462	1	2	f	\N
463	6	17	Terark 技术分析	ac中大量重复的x和y是可以做压缩的。这样可以在很大程度上减小数据存储规模，同时保证其查找特性。\r\n最小化编码的可查找树，这样将数据轻松放在SSD或内存中，爽爆	\N	\N	17	\N	3	\N	5	1	2019-07-10 07:49:35.670193	2019-07-10 07:52:18.89985	2019-07-10	0	\N	\N	463	1	2	f	\N
429	6	7	工程师的工作套路，效率	1，理解问题，展开细节，讨论\r\n2，备选方案，理解现有解法，搜论文。\r\n3，理解问题的差异点，并基于某个平台构建解决方案\r\n4，快速构建表达能力\r\n5，天下武功，唯快不破。打球想快，开发过程又何尝不如此呢？	\N	\N	17	\N	3	\N	5	2	2019-05-28 06:15:30.708846	2019-12-29 21:15:32.647651	2019-05-28	0	\N	\N	429	1	2	f	\N
469	8	17	PG 进程被立即终止时，如何释放锁以及恢复局部修改的buffer？	这问题是标哥问的。	\N	\N	12	\N	3	\N	5	5	2019-07-17 08:05:39.098879	2019-08-05 17:53:49.321502	\N	0	\N	\N	469	1	2	f	2019-07-17 09:04:24.035789
447	6	17	PG heap/toast	toast机制工作原理\r\nhttps://blog.csdn.net/liguangxianbin/article/details/80538473\r\ntoast会在创建一个表关联于原表，并将超长数据以压缩/切片方式存储在toast表中。\r\n*可能存在性能问题，如果增加一条记录，就涉及这边的多条记录变更的话。*\r\n尤其是更新的情况下。\r\n\r\n<pre><code class="text">\r\ntest=# select * from pg_class where relfilenode=40963;\r\n    relname     | relnamespace | reltype | reloftype | relowner | relam | relfilenode | reltablespace | relpages | reltuples | relallvisible | reltoastrelid | relhasindex | relisshared | relpersistence | relkind | relnatts | relchecks | relhasoids | relhasrules | relhastriggers | relhassubclass | relrowsecurity | relforcerowsecurity | relispopulated | relreplident | relispartition | relrewrite | relfrozenxid | relminmxid | relacl | reloptions | relpartbound\r\n----------------+--------------+---------+-----------+----------+-------+-------------+---------------+----------+-----------+---------------+---------------+-------------+-------------+----------------+---------+----------+-----------+------------+-------------+----------------+----------------+----------------+---------------------+----------------+--------------+----------------+------------+--------------+------------+--------+------------+--------------\r\n pg_toast_40960 |           99 |   40964 |         0 |       10 |     0 |       40963 |             0 |        0 |         0 |             0 |             0 | t           | f           | p              | t       |        3 |         0 | f          | f           | f              | f              | f              | f                   | t              | n            | f              |          0 |          596 |          1 |        |            |\r\n(1 row)\r\n\r\n\r\ntest=# select * from pg_class where relname='sal_emp';\r\n relname | relnamespace | reltype | reloftype | relowner | relam | relfilenode | reltablespace | relpages | reltuples | relallvisible | reltoastrelid | relhasindex | relisshared | relpersistence | relkind | relnatts | relchecks | relhasoids | relhasrules | relhastriggers | relhassubclass | relrowsecurity | relforcerowsecurity | relispopulated | relreplident | relispartition | relrewrite | relfrozenxid | relminmxid | relacl | reloptions | relpartbound\r\n---------+--------------+---------+-----------+----------+-------+-------------+---------------+----------+-----------+---------------+---------------+-------------+-------------+----------------+---------+----------+-----------+------------+-------------+----------------+----------------+----------------+---------------------+----------------+--------------+----------------+------------+--------------+------------+--------+------------+--------------\r\n sal_emp |         2200 |   40962 |         0 |       10 |     0 |       40960 |             0 |        0 |         0 |             0 |         40963 | f           | f           | p              | r       |        2 |         0 | f          | f           | f              | f              | f              | f                   | t              | d            | f              |          0 |          596 |          1 |        |            |\r\n(1 row)\r\n</code></pre>\r\n\r\ntoast_insert_or_update：这个函数的逻辑就是将row中需要toast的列全部存到toast表中，然后根据toast存储信息填充tuple，存到原表上。\r\n不同的列是单独作为一个chunk存储的，如果一列超过MAX CHUNK SIZE则使用chunk内多个seq表示。\r\n<pre><code class="text">\r\ntypedef struct varatt_external\r\n{\r\n\tint32\t\tva_rawsize;\t\t/* Original data size (includes header) */\r\n\tint32\t\tva_extsize;\t\t/* External saved size (doesn't) */\r\n\tOid\t\t\tva_valueid;\t\t/* Unique ID of value within TOAST table */\r\n\tOid\t\t\tva_toastrelid;\t/* RelID of TOAST table containing it */\r\n}\t\t\tvaratt_external;\r\n</code></pre>\r\n结构存储到原表中。	\N	\N	17	\N	3	\N	5	1	2019-06-17 16:58:02.225222	2019-07-12 15:02:46.960678	2019-06-17	0	\N	\N	447	1	2	f	\N
1047	6	7	SSDR 30：参数实体的接口设计	http://119.23.14.122:10083/issues/910\r\n\r\n其实可以直接参考rust中的基础结构。基础结构在软件中通常都会传递。\r\n其特征是会转移所有权。且生命周期跨越模块。	\N	\N	17	\N	3	\N	5	0	2022-04-13 13:03:17.819764	2022-04-13 13:03:17.819764	2022-04-13	0	\N	\N	1047	1	2	f	\N
466	6	17	PG MVCC之一共有哪些中snapshot，使用场景以及区别是什么		\N	\N	17	\N	3	\N	5	0	2019-07-13 20:33:28.267887	2019-07-13 20:33:28.267887	2019-07-13	0	\N	\N	466	1	2	f	\N
924	7	16	hold buffer不仅是内存管理，不要塞错了地方	更是一种builder形态	\N	\N	19	\N	3	\N	5	0	2021-08-01 05:25:28.308019	2021-08-01 05:25:28.308019	2021-08-01	0	\N	\N	924	1	2	f	\N
467	7	17	2019-7-15	1.完成vacuum和analyze的实现\r\n2，pg的操作有三条线\r\n 用户请求\r\n 后台定时任务\r\n 复制\r\n之前搞rgw也是这三条线路。\r\n3，pg的存储引擎\r\n存储引擎一般有数据格式，内存管理，并发控制与原子性保障，持久化性等主题。\r\n\r\n本月的目标也是把pg搞熟，了然于胸，然后输出相关文档。\r\n三个维度：\r\n1，框架维度，是一棵树\r\n2，流程维度，是算法，执行序列\r\n3，关联维度，是矩阵	\N	\N	19	\N	3	\N	5	0	2019-07-15 06:48:39.950907	2019-07-15 06:48:39.950907	2019-07-15	0	\N	\N	467	1	2	f	\N
470	8	17	PG HEAP_MOVED使用场景？	\t/*\r\n\t * Old-style VACUUM FULL is gone, but we have to keep this code as long as\r\n\t * we support having MOVED_OFF/MOVED_IN tuples in the database.\r\n\t */\r\n	\N	\N	17	\N	3	\N	5	0	2019-07-17 16:24:29.670665	2019-07-17 16:24:29.670665	\N	0	\N	\N	470	1	2	f	\N
471	8	17	PG 关于index空间的回收	1，只有vacuum full，执行reindex，才能真正回收index空间。\r\n2，index recycle page需要page mark delete的事务id小于RecentGlobalXmin,然而如果近期没有事务则该值不变。\r\n   会导致index page无法recycle。这时执行一个简单的插入，再次vacuum就能回收了。	\N	\N	17	\N	3	\N	5	0	2019-07-18 13:42:49.640524	2019-07-18 13:42:49.640524	\N	0	\N	\N	471	1	2	f	\N
473	8	17	PG why need command ID 以及 Combo CommandID	为什么需要command ID，解决什么问题？ AC可以不需要command ID么？	\N	\N	12	\N	3	\N	5	3	2019-07-19 07:48:38.871961	2019-07-19 08:26:13.790952	\N	0	\N	\N	473	1	2	f	2019-07-19 08:26:13.790952
476	6	17	PG tuple sort	重点函数puttuple_common	\N	\N	17	\N	3	\N	5	2	2019-07-19 13:27:43.189017	2019-07-22 07:05:15.716116	2019-07-19	0	\N	\N	476	1	2	f	\N
474	6	17	PG CI_v2 优化	1，AC的写入和读取是分离的。因而同一个事务内的写入可以合并\r\n2，可快速清理ac tuple，减小膨胀。\r\n3，当然最好还是把老版本隔离存储，这样可彻底避免ci膨胀	\N	\N	17	\N	3	\N	5	2	2019-07-19 08:34:00.340898	2019-08-19 15:39:42.786433	2019-07-19	0	\N	\N	474	1	2	f	\N
332	8	7	【未完成】分布式系统的核心问题研究	FLP，CAP，BASE等等研究透。\r\nCAP其实就包含了分布式系统的核心问题，C，A，P。 \r\n\r\n分布式系统另外一个问题是数据分布算法，比如ceph的crush	\N	\N	17	\N	3	\N	5	3	2019-04-09 08:10:28.973141	2020-05-26 07:32:38.44617	\N	0	\N	\N	332	1	2	f	\N
477	3	10	软件开发，羽毛球，江湖	准备好装备\r\n研究对手打发，策略\r\n热身\r\n做好每个球的环节\r\n调整状态，补给\r\n打完之后的放松与拉升\r\n总结\r\n收拾好装备\r\n\r\n-------------------------------------\r\n\r\n找到某个问题\r\n找到有相关问题的人\r\n研究人与问题\r\n了解问题目前所有的解法\r\n了解问题与之前解法中存在不一样的地方\r\n设计解决方案\r\n基于现有可用产品选型，构建新产品\r\n产品的不断迭代，改进，新增的用户需求处理\r\n产品维护\r\n新问题的出现- 下一代产品	\N	\N	17	\N	3	\N	5	1	2019-07-19 15:01:06.707031	2019-07-19 15:08:10.901104	2019-07-19	0	\N	\N	477	1	2	f	\N
479	6	17	PG CI_v2 测试		\N	\N	17	\N	3	\N	5	9	2019-07-23 15:00:42.26385	2019-08-14 09:24:53.524388	2019-07-23	0	\N	\N	479	1	2	f	\N
478	8	17	PG vacuum的触发时机	1，全量在指定时间一定会触发么，如果指定时间内处理不完怎么办？\r\n2，表在什么情况下才需要vacuum，表的vacuum时间配置	\N	\N	17	\N	3	\N	5	2	2019-07-23 14:20:03.111971	2020-01-17 10:20:03.729126	\N	0	\N	\N	478	1	2	f	\N
921	6	23	ssh 异常失效问题	centos下有时候会遇到ssh本来好好的，但是突然出问题了。\r\n通常需要修改配置，重启ssh服务才能好。	\N	\N	17	\N	3	\N	5	0	2021-07-28 08:30:17.493051	2021-07-28 08:30:17.493051	2021-07-28	0	\N	\N	921	1	2	f	\N
484	6	7	外排序算法		\N	\N	17	\N	3	\N	5	1	2019-07-29 17:54:36.840485	2019-07-29 18:19:57.356074	2019-07-29	0	\N	\N	484	1	2	f	\N
475	6	17	PG CI_v2 支持build以及rebuild	AcBuildBegin\r\nAcBuildInsert\r\nAcBuildEnd\r\n\r\n支持在内存中合并，然后批量写入。如果内存不够，可按批次写入。事务ID使用frozen id	\N	\N	17	\N	3	\N	5	8	2019-07-19 08:57:48.777793	2019-07-29 09:29:04.164936	2019-07-19	0	\N	\N	475	1	2	f	\N
480	6	17	PG snapshot 管理机制		\N	\N	17	\N	3	\N	5	0	2019-07-24 15:39:57.409519	2019-07-24 15:39:57.409519	2019-07-24	0	\N	\N	480	1	2	f	\N
482	6	17	PG 事务执行与异常处理	pg执行时要保证：\r\n1，可回滚性，在事务最终未成功提交时，所有操作都具备可回滚性。比如文件的删除，创建。\r\n2，资源释放，在事务出错退出时，其使用的内存，共享内存，锁，句柄等都能正常释放。\r\n   pg在出错时，直接跳转，这点要非常注意。写代码时要注意在存在这种跳转逻辑，考虑到资源的释放。\r\n\r\n<pre><code class="text">\r\n \tpostgres.exe!RelationDropStorage(RelationData * rel) 行 145\tC\r\n \tpostgres.exe!heap_drop_with_catalog(unsigned int relid) 行 1886\tC\r\n \tpostgres.exe!doDeletion(const ObjectAddress * object, int flags) 行 1144\tC\r\n \tpostgres.exe!deleteOneObject(const ObjectAddress * object, RelationData * * depRel, int flags) 行 1039\tC\r\n \tpostgres.exe!deleteObjectsInList(ObjectAddresses * targetObjects, RelationData * * depRel, int flags) 行 263\tC\r\n>\tpostgres.exe!performDeletion(const ObjectAddress * object, DropBehavior behavior, int flags) 行 344\tC\r\n \tpostgres.exe!finish_heap_swap(unsigned int OIDOldHeap, unsigned int OIDNewHeap, bool is_system_catalog, bool swap_toast_by_content, bool check_constraints, bool is_internal, unsigned int frozenXid, unsigned int cutoffMulti, char newrelpersistence) 行 1645\tC\r\n \tpostgres.exe!rebuild_relation(RelationData * OldHeap, unsigned int indexOid, bool verbose) 行 629\tC\r\n \tpostgres.exe!cluster_rel(unsigned int tableOid, unsigned int indexOid, bool recheck, bool verbose) 行 433\tC\r\n</code></pre>\r\n\r\n<pre>\r\n>\tpostgres.exe!smgrdounlinkall(SMgrRelationData * * rels, int nrels, bool isRedo) 行 426\tC\r\n \tpostgres.exe!smgrDoPendingDeletes(bool isCommit) 行 361\tC\r\n \tpostgres.exe!CommitTransaction() 行 2156\tC\r\n \tpostgres.exe!CommitTransactionCommand() 行 2818\tC\r\n \tpostgres.exe!vacuum_rel(unsigned int relid, RangeVar * relation, int options, VacuumParams * params) 行 1604\tC\r\n \tpostgres.exe!vacuum(int options, List * relations, VacuumParams * params, BufferAccessStrategyData * bstrategy, bool isTopLevel) 行 340\tC\r\n \tpostgres.exe!ExecVacuum(VacuumStmt * vacstmt, bool isTopLevel) 行 141\tC\r\n</pre>	\N	\N	17	\N	3	\N	5	2	2019-07-29 07:27:15.700432	2019-07-29 15:18:17.351847	2019-07-29	0	\N	\N	482	1	2	f	\N
483	6	7	资管管理	资管管理类，涉及的问题。\r\n\r\n编号，唯一编号，名称到编号的映射，非编号系统，资源查找，LRU。	\N	\N	17	\N	3	\N	5	0	2019-07-29 17:54:19.763356	2019-07-29 17:54:19.763356	2019-07-29	0	\N	\N	483	1	2	f	\N
485	6	17	PG unlogged table	https://www.postgresql.org/message-id/BANLkTi%3D9eR4C4To9PdJD0ztGvR335PQ6HA%40mail.gmail.com\r\n\r\nunlogged table在vacuum时如何处理索引，会进行修正么？\r\n如何理解这段：\r\nThe current reasons for exceptions, where a pin is still needed, are if the\r\nindex is not WAL-logged or if the scan is an index-only scan.	\N	\N	17	\N	3	\N	5	2	2019-07-31 12:35:31.007243	2019-07-31 12:58:47.050561	2019-07-31	0	\N	438	438	2	3	f	\N
458	6	7	软件性能	评估方式：\r\n   时间复杂度\r\n   空间复杂度\r\n\r\n大维度：计算，存储，网络三大板块。\r\n   \r\n常用手段：\r\n   减小数据规模，砍掉不必要的东西\r\n   压缩减小存储空间\r\n   减少必须执行的步骤\r\n   优化每步的速度，使用不同的硬件，以及改进算法\r\n   批量执行\r\n   并行执行\r\n   预热处理，缓存技术，可以减少在重复执行时的一些步骤\r\n   副本技术，读写分离等减少资源冲突\r\n   最小化锁冲突，无锁数据结构	\N	\N	17	\N	3	\N	5	3	2019-07-06 12:54:59.080752	2019-08-02 14:43:18.75702	2019-07-06	0	\N	\N	458	1	2	f	\N
487	6	7	Bw-tree	https://zhuanlan.zhihu.com/p/29314464\r\n\r\n1，page地址不固定，采用追加写入\r\n2，将btree每次整理推迟，采用追加增量修改，避免加锁\r\n3，copy方式实现页面合并，在最后修改table mapping避免加锁\r\n4，pin机制保护正在访问与回收page并发\r\n5，分裂也是copy，完成后使用CAS更新mapping\r\n\r\n所谓无锁，就是使用CAS，最小化锁冲突	\N	\N	17	\N	3	\N	5	0	2019-08-02 16:02:17.072244	2019-08-02 16:02:17.072244	2019-08-02	0	\N	\N	487	1	2	f	\N
492	6	9	带宽是如何降低的	稀缺 恐惧 自责 压力 风险\r\n八面玲珑，分裂人格，比\r\n\r\n稀缺让人觉得赚不到钱就是没能力。\r\n稀缺让我们看不到人变得更好更快乐本身就具备价值。\r\n负面联想，选择性忽视，情绪屏障。\r\n人有多痛苦，就有多放纵。\r\n人应该花多少时间玩？ 为什么读书不能是玩呢？	\N	\N	17	\N	3	\N	5	1	2019-08-18 09:54:45.57182	2019-08-19 09:18:36.654213	2019-08-18	0	\N	\N	492	1	2	f	\N
481	6	17	PG Transaction Isolation	事务隔离级别\r\n\r\n官方文档已经写的非常细致了\r\nhttps://www.postgresql.org/docs/current/transaction-iso.html\r\n\r\n\r\nPG实际支持的就是SI，通过SI实现RC和RR隔离级别。PG最低级别就是RC。\r\nRC说读到的数据都是提交的，即执行数据修改的事务不能是运行状态。\r\nRC在读取数据时，根据snapshot判断事务是否为提交状态。已提交，则可读。\r\n\r\nRR说读到的数据，下次再读结果应该一样。即在一个事务内不同的CID，读取的数据是一样的。\r\nRR是在事务期间一直使用事务开始时的快照，即在事务执行期间，其读取数据发生的变更对其不可见，因而可以重复读。\r\n\r\nPG的RR级别似乎可以避免幻读问题，在RR事务期间，有新写入或删除的数据，其事务id必然是未提交状态。\r\nbecause a repeatable read transaction cannot modify or lock rows changed by other transactions after the repeatable read transaction began.\r\n不修改别人改过的记录。\r\n举个例子：\r\n事务1：读取当前有多少钱，把数量+100\r\n事务2：读取当前有多少钱，把数量+100\r\n这两事务如果同时提交成功，则数量只会加100. 因为都是基于老的数值。\r\n有人把我之前读取的数据修改了，而我想基于我之前读取的数据进行修改。但这时有冲突，只能撤销当前事务。\r\n这个问题本质上还是不可重复读问题，只不过这个读是为了写。(写的时候要求读取的数据与之前一样，然而数据变了，基于老版本数据进行修改已经没了意义)\r\nNote that only updating transactions might need to be retried; read-only transactions will never have serialization conflicts.\r\n这个是显然的，因为MVCC老版本总是在那。\r\n\r\nSS要求更高，SS不仅是别人不能影响我，而且还得别人的影响我全都看得到。\r\nclass | value\r\n-------+-------\r\n     1 |    10\r\n     1 |    20\r\n     2 |   100\r\n     2 |   200\r\n\r\n事务1：\r\nSELECT SUM(value) FROM mytab WHERE class = 1;\r\ninsert into mytab values(2, 300)\r\n\r\n事务2：\r\nSELECT SUM(value) FROM mytab WHERE class = 2;\r\ninsert into mytab values(1, 30)\r\n\r\n在RR下执行完全没问题，互不干扰。但是SS下，并行的结果不等价于任意一种串行的效果。\r\n这种异常叫serialization anomaly。\r\n\r\nPG的实现这文章讲的还可以：\r\nhttps://www.cnblogs.com/flying-tiger/p/9591583.html	\N	\N	17	\N	3	\N	5	2	2019-07-25 14:44:45.797625	2019-08-20 13:23:11.956698	2019-07-25	0	\N	439	439	2	3	f	\N
562	6	7	关于数据库的思考	存储，计算，控制，网络。\r\n数据库在存储的基础之上，增加了格式，索引，隔离等能力。\r\n应用侧需求：\r\n1，数据格式\r\n2，业务场景\r\n3，部署要求\r\n\r\n关系模型的本质与界限。\r\n如果一个数据库其表与表之间没有任何关联，这还叫关系数据库吗？\r\n列存数据库是关系数据库吗？\r\n关系模型的本质是使用二维表来表达实体之间的关系。\r\n\r\n一个系统如果不用关系模型表示怎样？必须用关系模型吗？\r\n是关系模型决定了事务的原子性吗（多个修改）。\r\nnewsql与sql区别在哪里？\r\nbase\r\n\r\n为什么出现nosql到sql的回归？\r\n\r\nhttps://blog.csdn.net/lxw983520/article/details/78569893\r\n这篇文章讲到：\r\n层次模型与网状模型都是使用逻辑结构来表示数据之间的关系。\r\n而关系模型使用关系来表达数据之间的关系。这样的好处是数据结构与关系分离。\r\n缺点是查询必须经过关系，效率上会降低。\r\n\r\nhttps://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf\r\nCodd的论文，开篇即说明了关系模型需要解决的问题，即层次或网状模型没有屏蔽用户对数据内部表示\r\n的感知。“大型共享数据库数据的关系模型”，注意标题的修饰。\r\n关系数据库的核心在于使用关系表达实体之间存在的关联。从而让逻辑结构与存储结构解耦。\r\n并由此诞生了关系之上的运算，即SQL的起源。\r\n\r\n只要数据库使用关系来表达实体之间的关系，就可以使用SQL。\r\n可以进行实体之间的join运算。\r\n\r\nSQL就是关系代数的自然语言表达。SQL起源于关系数据库理论，发源于IBM。\r\nhttps://blog.csdn.net/zhanghongju/article/details/3314034\r\n\r\n分布式的兴起->CAP理论->Base理论\r\nhttps://yq.aliyun.com/articles/692238\r\nCAP和Base都是好理解的，ceph就是一个典型提供了CP或AP折中的系统。\r\n在P出现时，多少个副本可以工作就是这个选择。而没P的系统即单机系统。\r\n\r\nNosql其实是在ACI特性上的弱化，因为分布式下P是必选项。\r\nnewSql并未完全回归，其ACI仍然弱化RDBMS。\r\nSQL接口并非区分这些系统的核心特征，ACID CAP等特性才是其核心。\r\nhttps://www.jianshu.com/p/82f31bda04b0\r\n\r\n除此之外，数据模型的支持也是数据库一大特征。\r\n这应该称为数据格式：\r\n1，元组格式\r\n2，kv格式\r\n3，文档格式\r\n\r\n另外存储格式也不应该与此混淆：\r\n1，行存\r\n2，列存\r\n3，PIX\r\n\r\n数据库在存储之上提供的核心能力：\r\n1，ACI\r\n这是存储不具备的。\r\n\r\n2，数据组织，索引能力\r\n\r\n3，关系运算能力	\N	\N	17	\N	3	\N	5	4	2020-01-30 10:38:27.652155	2021-03-19 10:17:30.067632	2020-01-30	0	\N	\N	562	1	2	f	\N
518	6	9	僧侣隐士，以及其他人	苏格拉底问：我该如何生活\r\n对所有人通用的是每个人都走在路上，没有岁月静好，真正的停止是死亡。\r\n所以修习者都讲究不找，而且这里的不找是指不向外找，但他们向内找。找是在觉察与发现。绝对不找是不存在的。\r\n僧侣也是如此，他们在走心灵的路径。\r\n\r\n众生要么处于矛盾状态，要么就在求索状态。看清这本来面目，专心求索与执行的人更容易获得世俗上的成功。\r\n\r\n即专注于自己能真正投入精力的领域，剪除其他妄想执著，将带宽全情投入，获取成就。然后与其他人交易。就能获得世俗意义上的快乐。\r\n	\N	\N	17	\N	3	\N	5	0	2019-09-19 06:38:25.674152	2019-09-19 06:38:25.674152	2019-09-19	0	\N	\N	518	1	2	f	\N
426	6	18	关于世界与知识	世界有如万维图，不同的人在不同维度与不同值域上活动。\r\n这个图不知道有没尽头。\r\n世界的复杂就在于即便几个维度的组合运算就超出了人类的范围。\r\n\r\n行存体现的是人类活动，人在不同维度上已经建立的联系。而列存\r\n更好的反应了维度本身。\r\n\r\n知识：存在反应的是在不同维度间建立的知识。\r\n知识可以是隶属关系，推导关系，等价关系。也可以是其他关系	\N	\N	17	\N	3	\N	5	2	2019-05-26 06:45:32.767199	2019-08-01 15:32:22.536809	2019-05-26	0	\N	\N	426	1	2	f	\N
490	6	15	8.11 羽毛球经验(感受放松，反手外旋，手腕，杀球，切球与打球)	全身放松，羽毛球击球是不需要用尽全力的，在发力正常的情况下，成年人应该不用多大力就能打到后场。\r\n基本上需要重的时候很少，即便是杀球(杀球的关键其实是击球点)。\r\n\r\n另外需要放松还因为羽毛球的高强度，羽毛球看似不激烈的运动，至少不像篮球，足球，但其非常快速，一旦疲惫，速度降下来，无法运动到位就很难了。\r\n就跟剑客一样，剑客不需要很强的绝对力量，但是手上力量不弱，其肌肉是保证其快速移动。\r\n\r\n步法，身法，手法都讲究技巧与灵活。因为剑只要触及人基本会受伤。\r\n\r\n\r\n任何反手击球，都是需要一些外旋的。\r\n任何击球，都是需要手腕做一些准备动作的。\r\n任何击球，手指也需要，正手食指，反手拇指。\r\n\r\n打后场球不要切球，一定要打出去，向前。\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2019-08-11 17:38:32.564089	2019-08-11 17:38:32.564089	2019-08-11	0	\N	\N	490	1	2	f	\N
289	6	7	关于混沌工程	看了几篇文章，仍然没有搞清楚混沌工程与注入测试的区别。在手段上也许是接近的。\r\n区别可能是理念上的。\r\n\r\n混沌工程的几个关键词： 生产环境，实验，监控。\r\n\r\n与注入测试手段上类似，但是上述3点观念上的区别很大。 比如你可能在实验环境上做各种注入测试。\r\n但是你考虑过在生产环境做多中心切换实验么？\r\n\r\n实验与测试的区别在于实验是对于结果并非完全确定的，这也许是监控需要的原因。有时候我们在观察系统的反应。因为它太复杂了。\r\n就像社会上施行某一个政策一样。先在一个地方做个实验看看。\r\n\r\n另外普通故障注入 与 多变量注入并不一样	\N	\N	17	\N	3	\N	5	2	2019-03-01 15:15:51.35839	2019-08-11 20:29:14.551544	2019-03-01	0	\N	\N	289	1	2	f	\N
488	6	17	PG 故障注入	在客户端使用命令注入，注入后立即生效。\r\nsetfault NAME [cycle|once|random] step  --inject fault and assign fault mode and param\r\n	\N	\N	17	\N	3	\N	5	3	2019-08-07 15:20:55.054817	2019-08-08 08:23:03.820923	2019-08-07	0	\N	\N	488	1	2	f	\N
486	6	7	关于 int64 格式化，以及DEBUG宏	PRId64正确使用来保证跨平台\r\nhttps://yq.aliyun.com/articles/285029\r\n\r\nDEBUG\r\nhttps://blog.csdn.net/u012707739/article/details/80217959	\N	\N	17	\N	3	\N	5	1	2019-08-01 14:43:49.873999	2019-08-12 18:58:48.095095	2019-08-01	0	\N	\N	486	1	2	f	\N
495	6	7	近似的威力	1，概率\r\n2，bloom\r\n3，抽样\r\n4，最终一致性\r\n\r\n当允许近似时，算法可能出现非常大的简化。\r\n而很多系统或场景是可以采用近似方法的。	\N	\N	17	\N	3	\N	5	1	2019-08-23 06:52:53.3079	2019-08-23 06:53:41.410445	2019-08-23	0	\N	\N	495	1	2	f	\N
499	6	7	排序算法的稳定性，相同key在排序结果中能维持相对次序	稳定性的定义\r\n\r\n      假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。\r\n\r\nhttps://blog.csdn.net/u012501054/article/details/79342580\r\nhttps://baike.baidu.com/item/快速排序算法/369842?fromtitle=快速排序&fromid=2084344\r\n\r\n一个应用场景：比如全量同步，以及全量期间的增量，利用key排重的问题。\r\n虽然根据key进行排序，但是相同key原有的顺序也有意义。\r\n\r\n快速排序不具备稳定性，因而pg的sort算法整体上不符合要求。	\N	\N	17	\N	3	\N	5	0	2019-08-26 08:22:18.451224	2019-08-26 08:22:18.451224	2019-08-26	0	\N	\N	499	1	2	f	\N
501	6	4	英语中关于近似，概率的表达	概率：probability, probabilistic, odds(赔率)\r\n\r\nApproximation：逼近\r\napproximate：近似\r\n近似\tapproximate, approximation, similar, approximately, approximated, proximate\r\n逼近\tapproximation, approaching, approximate, looming, impending, nearing\r\n大致\troughly, generally, broadly, approximately, rough, approximate	\N	\N	17	\N	3	\N	5	0	2019-08-27 17:09:20.40011	2019-08-27 17:09:20.40011	2019-08-27	0	\N	\N	501	1	2	f	\N
513	6	17	PG AQP AT实现	1，构建kdtree，实现距离计算等\r\n   使用copy导入数据测试\r\n\r\n2，存储，将kdtree按照期望存储进去\r\n   使用记录格式   x1|x2|y1|count， 字段类型均为int64\r\n   这样 X，I，N，SUM 表示每层信息，注意没有dy，长度不够，不过可以考虑塞到ci的heap header里面。\r\n   Y，count，RANGE1Y，RANGE2Y 也可以表示。\r\n   因而使用同一个tupledesc，可以进行存储。	\N	\N	17	\N	3	\N	5	9	2019-09-10 12:38:05.354024	2019-10-24 17:28:50.290082	2019-09-10	0	\N	\N	513	1	2	f	\N
506	6	7	kd树-中位数算法-水塘抽样	水塘抽样解决的是不确定数据规模下的等概率抽样问题。\r\n从样本N中抽取K个元素\r\n算法如下：\r\n1，前面的K个元素直接被抽中\r\n2，后面的第m个元素，如果其随机概率< k/m,则随机选取样本K个元素中的一个进行替换。\r\n3，重复上述步骤直到结束。\r\n可以证明每个元素被选中的概率最终都是k/n\r\n\r\n中位数算法：\r\n最容易理解的就是排序\r\nclickhouse使用的是std::nth_element算法。\r\n\r\n抽样完成之后，可以对抽样结果进行快排，然后不停的寻找中位数，最终可以实现KD-tree算法	\N	\N	17	\N	3	\N	5	0	2019-08-29 08:12:35.121418	2019-08-29 08:12:35.121418	2019-08-29	0	\N	\N	506	1	2	f	\N
498	6	9	侠义与文化	武侠，自由与正义，角色扮演与美好的故事，\r\n天马行空，高深莫测，飘逸就是仙，\r\n浪漫主义\r\n\r\n武侠代表人物：\r\n庄子，李白等等。。。	\N	\N	17	\N	3	\N	5	1	2019-08-25 21:21:45.313116	2019-08-27 17:11:30.967762	2019-08-25	0	\N	\N	498	1	2	f	\N
500	6	17	PG CI_v3	AC-CI 是一种IOT存储形态。\r\n有三种形式的IOT：unique，agg，normal\r\n\r\nAC-CI接口仅表示一个Relation。ACAM以及CI的接口都在表示这一点。\r\n以列存储的方式去理解的话，也可以是代表部分列。与标准列存储不一样的是这里没有元组，只有不同列之间的逻辑关系。\r\n我们没有一个列描述符结构，先用Relation表示。\r\n\r\n如果应用层有逻辑Relation需在上层实现。\r\n例如AC的去重需求，拿到Identity Key对应的Relation。\r\n\r\n例如AQP，定义一个AQP，包含Rel(x), Rel(y)	\N	\N	17	\N	3	\N	5	4	2019-08-26 09:30:36.261582	2019-10-10 12:34:50.771735	2019-08-26	0	\N	\N	500	1	2	f	\N
546	6	17	与曹洋教授讨论纪要	1，function db，ac可以看成一种function\r\n2，data mining，index discovery， ac discovery领域的最新研究。\r\n问题的抽象与描述\r\n3，column storage不适合datbase learning，因为这通常同时访问很多列。\r\n4，kdtree动态算法，不维护其平衡性。\r\n5，AQP证明的思路来自于程序正确性证明	\N	\N	17	\N	3	\N	5	1	2020-01-02 18:54:57.277512	2020-01-03 11:51:17.170502	2020-01-02	0	\N	\N	546	1	2	f	\N
502	6	7	skiplist	\r\n\r\n1, 问题是什么\r\n平衡树查询性能好，但是更新插入的性能低\r\n\r\n2，涉及的概念\r\n平衡树\r\n概率\r\n\r\n3，当前的现状\r\n4，出现的机遇\r\n5，趋势\r\n6，解决方案\r\n不做平衡，不保证严格意义上的平衡。\r\n想象所有节点在一条线上，skiplist就是随机生成上面的N层中间树节点一样。\r\n这样生成的是一棵平衡性很随机的树。\r\n\r\n7 实现思路\r\nhttps://blog.csdn.net/ict2014/article/details/17394259\r\n除了节点可以维持多个level的指针外。节点还可以维护步长，或者叫rank，从而可以根据rank查找记录。\r\n\r\n8 关键点\r\nheader自身不含key和value，但是用每个level的head指针，如果某个level的skiplist没有前置节点，则其前置就是head。\r\n随机算法为什么能构建一棵树，可以按概率计算。控制了每层的概率就控制了每层数据之间的比例。\r\n9，验证方法\r\n10，维护	\N	\N	17	\N	3	\N	5	2	2019-08-27 17:54:36.508454	2019-08-28 08:34:43.321997	2019-08-27	0	\N	\N	502	1	2	f	\N
922	6	23	测试用例一例多跑-解耦与组合的力量，多维矩阵	同一个测试用例，在可以在不同部署，不同表类型，以及各种不同背景下运行。\r\n极大增加了测试场景覆盖。\r\n	\N	\N	17	\N	3	\N	5	0	2021-07-31 07:03:11.372062	2021-07-31 07:03:11.372062	2021-07-31	0	\N	\N	922	1	2	f	\N
507	6	8	找到自己	每个人都有多个自己\r\n那个被囚禁的灵魂\r\n你只是嘴上忘记了，你的脑，心，身体都没遗忘。接受他们\r\n\r\n我不是那个腼腆不敢表达的小孩\r\n我也不是那个只能与自己对话的少年\r\n我不是那个被花季抛弃的青年\r\n我也不是那个伤痛的大学生\r\n我不是那个被要求很优秀的人\r\n\r\n想想那时的我是不是比詹更可悲，至少他还敢表达，而我呢？\r\n\r\n找到那个真实的自己，注意把别人的东西变成自己的，也是自己的部分。\r\n不要自我封闭。体察自己，也提擦别人，活得活泼自然。\r\n\r\n接受所有，不去挑剔。每个冷漠的人都有伤心的往事，每个暴力的人都有被暴力对待的过往。\r\n接受这一切，接受无常，让自己的心去感受这世间的一朝，虽然平凡，但不失韵味的渡过短暂的一生。\r\n接受自己的智商一般，接受自己过往的伤害，接受自己一事无成。\r\n\r\n每个男孩都有一颗曾经单纯的心，每个女孩都曾有一颗温柔的心，失去了本就不幸。	\N	\N	17	\N	3	\N	5	0	2019-08-31 22:13:05.089259	2019-08-31 22:13:05.089259	2019-08-31	0	\N	\N	507	1	2	f	\N
509	6	17	带距离的kdtree外部构建方法	1，自顶向下生成距离\r\n2，自顶向下利用中位点生成二叉树\r\n3，变换维度生成二叉树\r\n4，将二叉树使用level,key,range，parent的方式生成表。并且根据range生成索引。\r\n\r\n超出内存部分的构建：\r\n1，在已构建的最底层找到key所属的range，利用之前构建的range索引。\r\n min <= key < max\r\n 多维情况也是类似。不过多维涉及多次查找\r\n2, 如果key切分了range，则删除老的range，分裂成2个range。\r\n3，如果目标节点没有child，则新节点为其第一个child，将level+1.目标节点的range，由其和child分享。\r\n如果目标节点有一个child，则新节点作为另一个child加入，range改为由两个child分享。\r\n\r\n相同于构建了一个扁平的索引。\r\n并且不维护树的平衡性。等到树失衡到一定程序再重建。\r\n	\N	\N	17	\N	3	\N	5	1	2019-09-04 09:12:31.477952	2019-09-04 13:45:18.252611	2019-09-04	0	\N	\N	509	1	2	f	\N
510	8	24	KV存储的理解，以及与行列式存储的转换	Key是什么？字符串么？	\N	\N	17	\N	3	\N	5	4	2019-09-07 13:06:47.148381	2019-10-09 14:50:25.28532	\N	0	\N	\N	510	1	2	f	\N
508	6	17	Build KD tree in PG	1，给出原始记录数组origin，以及描述符Tuple(k1..kn)\r\n2，针对origin，创建k1..kn, ..., kn..kn-1的索引数组，数组的value是origin数组的下标。\r\n   同一个数组，使用不同的比较参数，生成不同的排序结果\r\n3，创建kdtree的根节点root\r\n4，针对kx的索引数组，以及数组的start与end，寻找中位点。\r\n4.1 将中位点对应的origin数组元素加入到kdtree，\r\n\t如果end-start<=2,则把当前节点加入kd-tree。结束递归。\r\n4.2 根据中位点将索引数组ky(y = (x + 1) % k)[start,end]分成大于中位点，以及小于中位点的二部分.\r\n    使用tmp进行上述排序，将与中位点相等的key填充到tmp[middle],小于中位点的从[start-middle),大于中位点的填充到(middle,end]\r\n\tky = tmp\r\n4.3 分别对上述二部分递归调用步骤4	\N	\N	17	\N	3	\N	5	2	2019-09-02 13:23:51.011883	2019-09-04 13:30:52.885379	2019-09-02	0	\N	\N	508	1	2	f	\N
923	7	16	hold		\N	\N	19	\N	3	\N	5	0	2021-08-01 05:24:43.947472	2021-08-01 05:24:43.947472	2021-08-01	0	\N	\N	923	1	2	f	\N
926	10	30	2018-8-2	\N	\N	\N	4	\N	3	\N	5	1	2021-08-01 19:50:05.386841	2021-08-01 19:51:07.946077	\N	0	\N	\N	926	1	2	f	\N
514	6	17	当前工作列表		\N	\N	17	\N	3	\N	5	1	2019-09-12 15:27:16.78027	2019-09-12 15:28:18.808361	2019-09-12	0	\N	\N	514	1	2	f	\N
505	6	17	内存列存引擎学习	1，leastRP，最小恢复点是啥概念？至少要恢复到此处db才算不损坏。否则需从备份恢复\r\n2，控制文件双写解决partial write问题，如果对应的blockpool能提供原子写能力，则不需要\r\n3，并行加载与异步加载优化是需要的\r\n4，localpoolmanager进程内使用，segment在挂到进程时映射的内存空间记录在其上\r\n5，64B对齐是为了与cpu cacheline对齐，加速计算，因而block header不能随意扩展。\r\n\r\n内存列存引擎主要是解决实时计算问题，方便快速更新，快速查询。冷数据会转移到数仓。	\N	\N	17	\N	3	\N	5	0	2019-08-28 19:09:43.194549	2019-08-28 19:09:43.194549	2019-08-28	0	\N	\N	505	1	2	f	\N
519	6	6	羽毛球与软件开发	运动的美看上去动作流畅，如行云流水一般。\r\n其核心在于发力。\r\n其乐趣在于打的过程，犹如打通奇经八脉，畅快淋漓。\r\n其胜负标准在比赛输赢\r\n\r\n代码的美看上去结构清晰，一目了然。 \r\n其核心在于逻辑。\r\n其乐趣在于运行过程，丛横交错，轻快简美。\r\n其标准在于软件的使用量\r\n\r\n逻辑：逻辑涉及命名，层次划分，模块划分，类的定义，作用域各个细节。\r\n发力：发力涉及全身各个关节，手指，手腕，小臂，大臂，肩部，腰腹，腿部等等	\N	\N	17	\N	3	\N	5	0	2019-09-20 07:13:15.581551	2019-09-20 07:13:15.581551	2019-09-20	0	\N	\N	519	1	2	f	\N
512	6	20	2019年9月活动量	「八点定江山」2019.9.2胡冬寅\r\n预约:2\r\n客户接洽：2\r\n需求面谈：0\r\n成交面谈：0\r\n签单：0\r\n新增准客户：3\r\n增员洽谈：0\r\n1.下午到建材市场，随缘3人\r\n2.预约罗姐，美苑，时间待定，明天跟进\r\n3.新邻居2人见面喝茶聊天，加深了解\r\n	\N	\N	17	\N	3	\N	6	1	2019-09-08 22:21:41.356892	2019-09-08 22:22:50.581154	2019-09-08	0	\N	\N	512	1	2	f	\N
526	6	9	一次关于成长课的争论	科学的价值意义，因为其他都没说服力\r\n\r\n人都不会真正接受自己不认可的事物，天下无贼的痛中的痛我能理解一点了。\r\n\r\n欺骗，矛盾，割韭菜普遍存在，信息的不对称，事物的价格围绕价值变动，哪有总是正好的呢，割韭菜是合理的。\r\n\r\n人生算法就是一个局部最优解问题，总会有更优解，但一切都是合理的，该犯的错也逃不掉。\r\n\r\n每个人都渴望被认同，但认同和理解不等价，理解了不认可也让人难受。\r\n\r\n人与人之间的矛盾比我想象的要大，以前会很自然的想这有啥呢，仿佛对的那么明显，然而独立的个人之间真正的认同是非常难的。难在于很多事情没办法用科学解释，难以量化。\r\n经济问题会放大矛盾，接受空间会更小。	\N	\N	17	\N	3	\N	5	1	2019-09-24 06:41:25.145107	2019-09-24 06:44:09.730995	2019-09-24	0	\N	\N	526	1	2	f	\N
527	3	24	星形模式与雪花模式	https://www.cnblogs.com/xiaojianblogs/p/7655458.html\r\n该术语针对数据分析场景下的数据模型。\r\n\r\n雪花模式是星形模式的扩展。	\N	\N	17	\N	3	\N	5	0	2019-09-25 09:10:51.250698	2019-09-25 09:10:51.250698	2019-09-25	0	\N	\N	527	1	2	f	\N
511	6	20	2019年9月活动量		\N	\N	17	\N	3	\N	6	5	2019-09-08 22:21:00.031029	2019-09-08 22:25:41.46832	2019-09-08	0	\N	\N	511	1	2	f	\N
202	6	9	听王阳明大传	听王阳明哲学的解读之后\r\n参 就是不断的询问，一个思考过程。\r\n儒家 道家 佛家都不是宗教，其实都是教人为人处事的。\r\n其思路都是从 心 性 意等角度去了解自己，了解别人，处事。\r\n\r\n感觉王阳明是儒家与佛教的一种碰撞。\r\n\r\n善恶\r\n良知 中庸 正念\r\n\r\n为什么大师说话比较牛逼，因为他能找到那个点，那个恰好的点。\r\n用自己的思想去格物，不断修正理论。\r\n\r\n知行合一，即行即知。这里的知不是知道。\r\n\r\n我们有时候有这样的体验，有时候懂了一个道理，但是做的时候又违背了，这就说明并不知，\r\n也就是说行为与理念不一致，有时候行为可能发自于潜意识。比如说喜欢打游戏的人，即便他知道打游戏损害身体，不可长时间玩。\r\n但是在当时他可能顾不了那么多，控制不住。\r\n\r\n还有一种情况是自己做了合适的事，但是并不明白这是为什么。讲不出道理。\r\n\r\n如果理解知行合一，就是将意识理念 与 行为统一，怎么样就怎么样去做，做的都是所想的。想不清楚就不去做，这样可否算是知行合一呢？\r\n\r\n知是行之始，行是知之成。\r\n知行合一的重要性就在于此，真正的价值体现在行上，如果只是一个理念在脑子里转下，那就没啥意义。\r\n这也是王阳明能做出真正很有价值事情的内在动因。\r\n\r\n\r\n王阳明最后的境界：随时随地都知道对错。时刻秉持良知。\r\n也就是孔子说的吾道一以贯之。也就是老子的道。\r\n这样去看必然随时随地都保持正念。\r\n\r\n良知像是一个普世的价值判断？\r\n良知，是非善恶，心学的基石就是心即理。良知即天理。\r\n克己复礼为仁。礼就是孔子的部分价值观。孔子的言论大部分都是讲什么是对的，也就是一套价值观。\r\n儒家与佛家的根本区别也在于价值观的区别，佛家众生平等。儒家是厚薄有分的。佛家的理念是与世俗不合的，因而佛家要出家。\r\n\r\n致：\r\n醒觉，脱离惯性。\r\n\r\n心中无挂碍，凭良心而行，稳当快乐就是洒落。\r\n\r\n总结：\r\n心学感觉就是为了解决儒家的价值判断问题。这一点孔子并未明述，虽然已有很多案例。\r\n儒家里面有2个问题：\r\n1，何为仁？ 一切的对？ 如何判断对错？\r\n良知 即为仁\r\n2，如何做到仁？ 三月不违仁就是超高的境界\r\n知行合一	\N	\N	17	\N	3	\N	5	2	2018-12-08 14:57:27.816632	2019-10-11 06:29:11.124744	2018-12-08	0	\N	\N	202	1	2	f	\N
529	8	24	Coral方案理解	问题是什么？基于行存的ac存在如下缺陷：\r\n1，无法支持多个ac的使用（这是执行器的问题）\r\n2，列存更利于分析\r\n3，依赖于数据重复，没有利用好ac数据可以blocked的特点。\r\n\r\n1，如何返回某个表的所有记录？\r\n2，如果x，y完全distinct，就如同一个主键表，主键是key。这时如何blocked存储？还是退化成普通存储？	\N	\N	17	\N	3	\N	5	7	2019-10-09 13:39:24.320504	2019-10-11 14:22:16.543394	\N	0	\N	\N	529	1	2	f	\N
531	6	24	coral存储结构草稿	leveldb怎么从level 0重叠的记录生成level 1？\r\n\r\n\r\nRegion\r\n{\r\n\tMemBlock\r\n\tIndexBlock\r\n\tBlock\r\n}\r\n\r\n数据进来之后先按region写入memblock，而不是直接上来使用一个新region。\r\n上来直接搞一个region这种方式适合于leveldb，而且必须分level，不然合并涉及的region太多\r\n\r\n1，部署结构\r\n2，schema\r\n3，数据分区\r\n4，数据索引\r\n5，数据的组织结构\r\n\r\nhbase也是列存储的，为啥kudu说其分析性能不行？\r\nhbase的列存估计主要是为了压缩，实际数据访问模式是行式的，组织成逻辑row，按行访问。即hbase的column family是为了实现宽表。\r\n但是hbase天生就可以支持批量查询\r\n列族存储与列式存储并不一样，列族内部其实仍然采用的行式存储。列族存储是行存储与列存储的折中。\r\n列族还有一个作用就是实现非结构化，可以灵活新增列族，但是不确定列族本身是否可以添加列？\r\n\r\nbase是key+列族数据库，没有表定义\r\nhttps://zhuanlan.zhihu.com/p/44517915\r\n\r\n这点挺有意思的，对于数据版本的处理：\r\n相对于HBase允许多版本的数据存在，Kudu为了提高批量读取数据时的效率，\r\n要求设计表时提供一列或者多列组成一个主键，主键唯一，不允许多个相同主键的数据存在。这样的设置下，\r\nKudu不能像HBase一样将更新操作直接转换成插入一条新版本的数据，Kudu的选择是将写入的数据，更新操作分开存储。\r\n这篇hbase和kudu对比的文章可以看看\r\nhttps://zhuanlan.zhihu.com/p/44517915\r\nkudu没有采用不断增加版本的方式，因而可以减小读取时的扫描规模。\r\n另外其纯正的列存，而不是列族存储更利于批量读取列数据？\r\n\r\nhttps://www.zhihu.com/question/37858641\r\n这篇文章提及的大数据方案比较常用，另外hdfs，hbase，kudu是在查询和随机访问之间的取舍。\r\n\r\n\r\n在tikv，mongodb，hdfs，ceph rados之间有个巨大的差异，就是事务以及schema。但竟然联想不到其巨大的差异。\r\n另外一个问题是rocksdb一个value最大多大？大了没有没问题？ 将64kb的文件存到rocksdb有没问题？\r\n1，有一点如果存在大量覆盖写文件，是不适合用rocksdb的，包括追加写文件。\r\n2，大文件可能会引起compact开销，超级写放大\r\nhttps://blog.csdn.net/weixin_36145588/article/details/78450518\r\n\r\nparquet如何过滤数据？hdfs把数据写入之后如果有重复版本如何处理？\r\n\r\n\r\ncoral选择：\r\n1，采用range分裂方式，而不是leveldb，hbase类似的compact机制\r\n原因是coral不希望文件过大，降低写放大对于coral很重要。\r\nkudu将新增的记录写入new rowset是一种很好的优化方式。在出现大量新增时可能都不必额外合并。\r\n当一个range内的rowset超过一定规模之后，可以对rowset进行合并。但是我们不会搞很多层。\r\n等rowset达到一定规模之后拆分range。\r\n\r\n合并的最大层次就取决于range的最大大小，即leveldb中某个level的size limit\r\n\r\nrange： 1024 block， 256M等规则限制\r\nblock：64kb\r\n\r\n步骤：\r\n1，将数据写入memblock\r\n2，将memblock持久化l0block\r\n3，l0block达到一定数量后，compact，生成l1block\r\n4，将l0block数据作为增量附加到l1block\r\n5，等l1block的delta达到一定规模后，compact，生成l2block\r\n6，后续level的依此类推\r\n7，等l1block的规模超过range size时，产生新的range	\N	\N	17	\N	3	\N	5	2	2019-10-12 15:42:09.260504	2019-10-14 13:47:49.410868	2019-10-12	0	\N	\N	531	1	2	f	\N
239	6	15	羽毛球发力的特征(高手之路)	1，小臂是内外旋运动\r\n2，手腕在垂直方向是抖，但不能压。所以必须在此方面上击球要么屏住手腕，要么将手腕在水平方向上收。\r\n3，手腕在水平方向上可以收和展。\r\n4，手指发力有大拇指顶，食指的压，还有后三指的收紧。\r\n5，击球前手臂要么是横在身前，要么外展。这两种形式其实默认都不好打右手附近的球。这种球最好垂直下肘，蹲下打。\r\n6，击球瞬间是刚性的，否则碰撞效果不好，想像球打到软强会回弹么？\r\n7，羽毛球是一个多节加速运动，越末梢越快。脚部，腰，大臂，小臂，手腕，手指。每样都练好才算发力高手。\r\n	\N	\N	17	\N	3	\N	5	4	2019-01-20 06:18:43.471628	2019-12-01 17:49:44.742741	2019-01-20	0	\N	\N	239	1	2	f	\N
542	7	17	AC全量导入只能使用大事务的问题	每批数据采用小事务，导入过程中临时文件在小事务结束后删除掉。\r\n因而没法完成整个导入过程。\r\n\r\n处理办法：\r\n1，将中间文件采用临时文件，并使用特定的文件名前缀。\r\n如果导入异常失败，在进程未重启时，调用abort正常删除文件。\r\n如果进程异常，在postmaster重启，或fuelpump主动下次停止任务或下次发起同步任务时进行删除。\r\n	\N	\N	19	\N	3	\N	5	0	2019-12-02 17:06:30.790734	2019-12-02 17:06:30.790734	2019-12-02	0	\N	\N	542	1	2	f	\N
543	6	17	PG元数据管理	OID分配：\r\nsrc/include/catalog/unused_oids\r\n其原理就是在固定几个头文件中去查找OID，然后算出一个没有使用的结果。\r\n即要求凡是用户增加系统OID，也需要在这些头文件中。	\N	\N	17	\N	3	\N	5	0	2019-12-24 14:24:51.484605	2019-12-24 14:24:51.484605	2019-12-24	0	\N	\N	543	1	2	f	\N
553	6	7	程序原本	数据的基本特征：\r\n1，值\r\n2，可变性\r\n3，生命周期\r\n\r\n使用数据使得数据具备了：\r\n1，名或标识也即地址\r\n2，作用域\r\n\r\n数据特殊的使用方式：\r\n1，借用\r\n\r\n变量同时具备地址与值的特征。\r\n\r\n函数是计算的名称\r\n\r\n面向对象的本质是将数据与方法绑定，\r\nOOP就是用“纵向增加代码的复杂度”换取“对代码进行增删改时的最小工作量”\r\n\r\n结构化编程弱化了数据方面，对象是对该方式的一种纠正。\r\n结构化编程很多代码难以测试，为什么呢？因为数据难以构造。\r\n对象编程强调数据的完备性，每个对象都有生成方法，可以方便在各个地方使用。\r\n\r\n结构化是计算的划分，对象是数据与计算一起的划分\r\n即对象是结构化之上的增强\r\n\r\n\r\n\r\n分治思想：\r\n独立\r\n组合\r\n\r\n封装思想：\r\n模块化\r\n隔离\r\n可见性\r\n\r\n抽象思想：\r\n多态\r\n接口\r\n比如我们去锤一个钉子，不一定要锤子，而是具备锤能力的东西，这就是接口。\r\n\r\n组织方式：\r\n1，从过程出发的结构化思想\r\n2，从数据出发的对象思想\r\n\r\n图灵机是对人计算方式的一种抽象。\r\n冯诺依曼是从工程上对于图灵机的实现\r\n\r\n数学是科学的语言。\r\n计算机不过是在处理数据。\r\n处理数据有多种含义，控制系统，统计报表系统，分析系统，内容系统都是不一样的。\r\n通信，控制，数据组织，数据计算是我们日常要做的所有事。\r\n组织，控制，运算\r\n\r\n函数-计算能力\r\n库-程序\r\n服务-系统\r\n真正的高级语言形态可能就是数据的服务化，与算法的服务化。\r\n抽象逻辑的世界一日千里，真实的世界仍然缓慢前进。\r\n\r\n编程就是用语法来表达语义，语义是我们对系统以及问题的理解。\r\n所以不去考虑问题本质而上手编码就有点不着边了。\r\n\r\n会编程与掌握某种语言的语法形式是无关的。\r\n编程实质上是一种在语义描述上的能力修养。具备这种能力之后，\r\n语法也就无非是一些规则、限制和对不同计算系统的理解能力上的\r\n差别了。所以“计算机程序设计”这门功课应该教你编程，而不是\r\n教你使用一门具体的语言——我们现在大多把它当成语言课，实在\r\n是本末倒置了\r\n\r\n语法是剑法，但语义才是内功。\r\n\r\nhttps://www.zhihu.com/question/305042684\r\n\r\n知乎这个问题的二答就说明了 面向对象是应对变化而来的。\r\n\r\n但是我觉得面向对象的核心是数据与行为的绑定，以及数据之间的独立。是一种从数据出发来看问题的思考方式。\r\n\r\n\r\n\r\n在结构化编程中，数据通常会比较乱，各个结构体在函数之间传递，注意是数据被传递，并非消息。\r\n\r\n\r\n\r\nhttps://www.liaoxuefeng.com/wiki/1016959663602400/1017495723838528\r\n\r\n面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。\r\n\r\n面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。\r\n\r\n而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。\r\n\r\n\r\n\r\n还从自己过去的分子生物学中汲取了有益养分，创立了“生物类比”理论。\r\n\r\n阿伦在其论文中写道：“我假定未来理想的计算机能够具备生物组织一样的功能，每个‘细胞’能够独立运作，\r\n\r\n也能与其他功能一起完成复杂的目标。‘细胞’能够相互重组，以解决问题或者完成功能。”\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	23	2020-01-11 15:47:21.322046	2021-04-05 06:14:41.544914	2020-01-11	0	\N	\N	553	1	2	f	\N
915	6	27	软件开发技巧之第三人称	我们开发软件时经常以第一人称来写的。这样写出来的程序是 拿着一个handle，我要干这个，我要干那个。\r\n\r\n但更好的方式或许是：A要干这个，B要干这个，C要干这个。\r\n然后我只是串联他们而已。 这样写出来的软件耦合性和复杂度都会更好。\r\n\r\n当然这取决于问题复杂度，如果我自己喜欢同时只干一件事，为什么让软件的各种动作交给一个实体去干呢？	\N	\N	17	\N	3	\N	5	1	2021-07-27 06:26:52.433252	2021-08-01 19:58:01.678601	2021-07-27	0	\N	\N	915	1	2	f	\N
556	6	17	GP上支持ci测试记录	测试用例：\r\n1，测试ci插入功能，使用page inspect验证\r\nok\r\n2，测试表上的删除与更新，验证ci数据是否正确\r\nfailed，update没有触发ac上的操作，问题原因是master-only下走ExecUpdate，此处没有调用ci操作。\r\n\r\n2.1 测试删除后再次插入，应该在原地进行覆盖\r\n3，测试count的效果\r\ncreate table test100(x int, y int, z int, count int);\r\ncreate access constraint ac100 from test100 on x to y bound 10000;\r\ninsert into test100 values(1,1,1,1);\r\ninsert into test100 values(1,2,1,1);\r\ninsert into test100 values(1,3,1,1);\r\ninsert into test100 values(1,2,2,1);\r\ninsert into test100 values(1,3,2,1);\r\ninsert into test100 values(1,4,1,1);\r\ninsert into test100 values(1,4,2,1);\r\nok，在insert和delete时count计算正确\r\n4，测试对于delete的ci tuple进行vacuum操作\r\nok，delete标记的记录成功被vacuum掉\r\n5，测试vacuum功能，pg_class下统计是否准确\r\nok { master-only下 gp不更新统计结果，调试发现结果是准确的}\r\n\r\n6，测试analyze功能，验证统计信息\r\nok，在master-only下测试\r\n\r\n\r\n7，测试不同数据类型下的ci tuple\r\ncreate table test102(x int, y char(30), z char(30), count int);\r\ncreate access constraint ac102 from test102 on x to y,z bound 10000;\r\ninsert into test102 values(1,'lisa','good',1);\r\ninsert into test102 values(1,'lisa','normal',2);\r\ninsert into test102 values(2,'tem','good',1);\r\ninsert into test102 values(2,'tem','normal',2);\r\ninsert into test102 values(1,'lisa','good',1);\r\nok\r\n\r\n8，测试null值\r\ncreate table test101(x int, y int, z int, count int);\r\ncreate access constraint ac101 from test101 on x,y to z bound 10000;\r\ninsert into test101 values(1,null,1,1);\r\ninsert into test101 values(1,null,1,2);\r\ninsert into test101 values(1,1,null,1);\r\ninsert into test101 values(1,1,null,2);\r\ninsert into test101 values(null,1,null,1);\r\ninsert into test101 values(null,1,null,2);\r\ninsert into test101 values(null,2,null,1);\r\nok,通过\r\n\r\n\r\n\r\n注意：\r\n1，目前还不支持copy table数据对ac的导入。	\N	\N	17	\N	3	\N	5	0	2020-01-19 12:56:38.824325	2020-01-19 12:56:38.824325	2020-01-19	0	\N	\N	556	1	2	f	\N
558	6	17	关于GP	讨论纪要：\r\nac重复有2个问题\r\n1，全量与增量引起的重复执行问题\r\n2，ac聚集导致的update不可重入问题，表上update是可重入的，因为IK对应的记录只有那一条。\r\n而AC上对重复Ik执行update，会导致count+1. 因而Ac独自去重时，必须通过Ik|X|Y一起确定其存在性，单独的Ik无法办到。\r\n\r\n基于表的AC构建：\r\n重复问题由表的unique约束保证。如果update对应的Ik，Ac列并未改变则跳过Ac上的更新。\r\n\r\n单独Ac构建：\r\n方案1，存储X|Y|Count|Iks,Iks独立存储，使用类似于toast方式，即。 X|Y|Count|Cid， Cid|[Ik]\r\n方案2，Ik|X|Y，X|Y|Count。\r\n\r\n\r\n如何平滑迁移?\r\n2棵树放入一个Relation存储，还是多个Relation？\r\n考虑是放入一个，多个Relation在上层需管理对应关系，不是很好表达。\r\n\r\n\r\n关于Gp：\r\nhttps://gpdb.docs.pivotal.io/6-2/admin_guide/intro/arch_overview.html\r\n1，table数据如何分布到不同segment？\r\nhttps://gpdb.docs.pivotal.io/6-2/admin_guide/ddl/ddl-table.html#topic34\r\ndistribute和partition是2个概念，跟coral中的region和partition关系一样，一个是逻辑上的划分，一个是承载物理数据的。\r\n\r\nPartitioning does not change the physical distribution of table data across the segments. Table distribution is physical:\r\n Greenplum Database physically divides partitioned tables and non-partitioned tables across segments to enable parallel query processing. \r\nTable partitioning is logical: Greenplum Database logically divides big tables to improve query performance \r\nand facilitate data warehouse maintenance tasks, such as rolling old data out of the data warehouse.\r\n\r\n2，Gp的列存表支持什么方式删除数据，列存表的统计信息如何用于加速访问。\r\n3，数据写入时，gp是在master上完成hash计算，然后给segment下发写入任务，还是都下发？\r\n4，To insert large amounts of data, use external tables or the COPY command。gp的批量导入机制？\r\nhttps://gpdb.docs.pivotal.io/6-2/admin_guide/load/topics/g-loading-and-unloading-data.html#topic1\r\n\r\nCOPY is non-parallel: data is loaded in a single process using the Greenplum master instance. Using COPY is only recommended for very small data files.\r\ngpload是利用external table，然后向segment发起命令，但是读数据是从external table读取，因而是可以并行的。\r\n\r\n纯粹导入AC时，可以在内存形成批量，然后按照AC特征进行排序写入临时文件(或非临时文件，类似于append表，如果需支持断点)，再构建Ac。\r\nbuild过程实现不变，仅是数据源头从原表改为临时表。\r\n\r\n问题：如果仅是Ac还是需要支持分区的吧\r\n临时表用于分区，同时还用于全量数据写入，非全量数据写入，直接通过特殊接口进入Ac。\r\n如果导入数据一个事务内，但时间上不属于一个分区，那么就涉及分割。octupos这时就涉及到多节点事务。\r\n或事务内update之前的数据，与插入新数据一起。\r\n5，gp全局事务的实现\r\nhttps://greenplum.cn/2019/07/07/greenplum-distributed-database-kernel-2/\r\n1，为啥分全局快照与本地共享快照。\r\n2，为什么支持不同segment有各自的快照，这样读一致性如何保证\r\n3，为什么slice必须有QE writer？读事务也如此吗？\r\n4，gp允许在segment上启动单机事务写入吗？还是启动分布式事务，只是写入发生的单机上。\r\n这样请求必须经过master。\r\n\r\n\r\n6，ac如何进行分区划分，表的不同ac分区划分不同允许吗？同步ac数据时必须带上表的分区键么？\r\n有没原表的区别仅在于是否存原表数据，这样octupos不必感知ac。但问题在于新创建的ac如何构建数据？\r\n\r\n\r\n数据以时间分区，表的IK是其他字段的话，那Ik的后续修改可能落到其他分区。\r\n分区与Ik不同时，是否有问题？如果按记录插入时间来，则可能划到不同分区。\r\n\r\n问题：1，如何确保所有表都按时间分区？\r\n\r\n7，可以学习下ao，aoc是如何增加am，并且与上层对接的。\r\nao多个关联子表的设计\r\n\r\n\r\n8，ao表\r\n空间管理上，每个segment对应于一个分区\r\n\r\n\r\nCI：\r\n除了提供可见性处理之外。CI不关心count，IKID，以及in与out等。\r\nCI还提供insert search接口，以及给定位置的insert接口。即支持undo方式管理老版本。\r\n\r\n按正规搞法得加ciam，以前是临时替换函数，非常规做法。\r\nIKId的管理：需要满足在一个segment内单调，也可以说是一个table内单调。\r\n或者不搞am，即从ac直接调用ci接口，假设当前不存在其他实现。\r\n没有index relation，pg11才支持cover index。\r\n\r\nAC：\r\nCI\r\n老版本记录，不需要tuple desc。另外用一个文件效果更好，但是需要看工作量。\r\n\r\ngp的shard如何表示：\r\n1，使用表，\r\n2，使用自定义结构\r\n但不管哪种结构对ac没影响，ac还是针对父表的。\r\n\r\nciIsEqual函数不需要，使用bt_compare。主要在于对于null值处理方式不一样。\r\nbuild目前是从单个relation取数据的。\r\nci提供一个暴露分配page的接口\r\n接口：\r\nciInsert\r\nciDelete \r\nciSearch\r\nciInsertAt\r\nciDeleteAt //set as deleted if count = 0, vacuum can gc the space\r\nciAllocPage //分配页面给外部使用\r\n\r\ncivacuum实现区别点；ci没有visible bitmap，因而增加了page visible的xlog.\r\nfreeze这块的数据结构借用之前的。\r\n\r\nci也需要recycle么，ci也需要统计信息。cleanup接口与bulkdelete接口分析。\r\ncycle id主要是用于解决vacuum使用物理页面顺序扫描导致的可能遗漏页面的问题。但是遗漏了有什么关系，极端情况下的freeze问题？确实试想如果每次vacuum正好split，然后导致记录没有freeze，那可能就错过了。\r\n再试想如果heap tuple被删除了，但是index tuple仍然存在的问题。\r\n注意这个函数heap_prepare_freeze_tuple，如果tuple的freeze信息与relatio对不上，会认为data corrupt挂掉。\r\n\r\nvacuum的自动触发机制，ci会被触发么？不会\r\nfreeze是根据表的relfrozenxid，relminmxid来进行判断的。这里当一个表对应多个ac时，如果没有原表数据是否有问题？\r\n针对vacuum，pgstat记录了dead tuples，通过判断dead tuple数量，与vacuum的标准：thresh + factor * reltuples来判断表是否进行vacuum。\r\n在表有变更操作时，需刷新统计信息，从而触发vacuum或analyze。\r\n每个ac需要独自去vacuum么？ac vacuum的统计信息单独于表么？支持给ac设置vacuum周期么？\r\nbeas1.0根本没有支持ac的auto vacuum。以前索引是基于表来vacuum的，索引必须依托于表而存在。\r\n在beas2.0中，先根据relation来，即找到relation对应的ac来执行auto vacuum。后续考虑支持ac上的统计信息并单独vacuum。\r\ngp中每个segment各自vacuum么，表的vacuum配置在所有segment同步？\r\n什么是lazy vacuum。\r\nfsm与vacuum。\r\nvacuum与analyze的交织，这块的控制非常乱。\r\n用户发起的命令有2类vacuum和analyze\r\nvacuum分为full，freeze，analyze。\r\nautovacuum发起时只有2个标记：vacuum，analyze。没有freeze。\r\nbtree等结构支持bulkdelete和cleanup接口。\r\n注意以前index是没有freeze过程的。\r\n\r\n\r\n为什么会有bulkdelete和cleanup接口？\r\n在table没有删除记录时，bulkdelete是不会被调用的。由于pg的mvcc，因而删除总是mark的，这是gc存在原因。\r\n\r\n\r\n分配页面部分：\r\n展开分析btree的空间管理\r\nfsm是一个三层的树结构，不过每个页面内部本身也是一个二叉树。\r\n二叉树是按照编号顺序存储的。\r\nindex的fsm不一样的地方：\r\nvacuum时在释放page之后，会更新fsm level 0对应的空间。对于heap，只要空间发生变化就会更新。\r\n在vacuum完成后，会发起对fsm上层页面的空间更新。\r\n\r\nHotStandby：\r\n1，在btvacuumscan时为什么需要在最后没有vacuum的page上加锁呢？\r\n\r\n问题集：\r\n1，ac是否应该跟表一起vacuum？\r\n2，ac analyze是否能单独执行？\r\n3，在都有可见性的情况下，如何保证ac与table的一致性？\r\n  写入过程因为有事务，不存在不同事务修改同一个heap tuple的情况，这样ac tuple修改可以对应起来。\r\n  但是不同heap tuple可能对应于同一个ac tuple。\r\n  还有ac构建过程中，可能一边从heap写入ac，另外heap上发生delete。如果delete先发生在ac上，则count记录为-1呢？还是怎么处理。\r\n  如果跳过，则可能最终count不对。即存在两个操作顺序需要被保证的情况，\r\n4，只有一个写入者的约束。\r\n5，ac能像索引一样处理吗？统计信息\r\n6，有加锁的索引吗？锁是否总是内存中的\r\n\r\n复杂度的来源：参与者，以及其关系。更细粒度的并发与流程控制。一致性。维度变多。\r\n果敢：看的清晰，切的勇敢。任何事物我们都难以看全整个面目，但是我们可以得出自己的脉络，并做出当下合适的选择。\r\n图灵或冯洛伊曼，IBM等先行者都无法预见未来计算机的面目。但是这不妨碍当下的选择，计算机室一个逐步发展的过程。任何其他复杂系统都是如此。\r\n思考的速度：思考速度的提升有赖于对于问题本质的认识。工程师看问题是看过程，结果，架构师看的是问题，需求与解决方案，科学家看到的是可行性。\r\n抓住问题的本质，去认识事物是自顶向下的。去观察过程，总结提炼的方式认识事物是自下而上的。没有自上而下的思维就如盲人摸象，没有自下而上的\r\n实践就像纸上谈兵。知行合一可以提现这两种思维方式，只是天才选手可能自上而下容易，而一般选手自下而上容易。理论与实践的交融。\r\n工程师：盲人摸象\r\n高级工程师：了解象的全貌\r\n架构师：庖丁解牛\r\n科学家：牛的抽象，牛的定义与本质\r\n\r\n计算机：bool，顺序与跳转，顺序，选择，循环\r\n\r\n\r\nmirror file replication：\r\nhttps://gpdb.docs.pivotal.io/510/admin_guide/highavail/topics/gprecover-steps.html\r\n\r\nThe gprecoverseg utility prepares the segments for recovery and then exits, allowing the Greenplum file replication processes to copy data from the primary to the mirror.\r\n使用工具来同步？ 这样一致性有保证吗？\r\n最新的6.2版本已经不一样了，连上述相关页面都没了。\r\nhttps://gpdb.docs.pivotal.io/6-2/admin_guide/highavail/topics/g-overview-of-segment-mirroring.html\r\n这里也不提file replication了。\r\n\r\n从这篇文章也可以推断出来：https://yq.aliyun.com/articles/4255\r\n	\N	\N	17	\N	3	\N	5	0	2020-01-20 14:11:32.047292	2020-01-20 14:11:32.047292	2020-01-20	0	\N	\N	558	1	2	f	\N
548	6	8	少有人走的路-阅读笔记	真诚与谎言\r\n真实与表象\r\n扭曲，毁灭，幻影还是改变\r\n逃避还是面对\r\n偏见\r\n\r\n这些性格包括痛苦本身都是治愈手段，但是一些蹩脚的手段，过度了就有负面作用。\r\n这就如同打羽毛球，一开始我们没有学会专业的动作，因而养成了利于自己的运动习惯。\r\n但长此以往会带来运动损伤。\r\n\r\n如果没有直面一切的勇气，我们就没了克服困难所带来的喜悦，以及心智成熟的锤炼机会。\r\n我们也将丧失原动力。\r\n\r\n真正的面对之道并不容易，因而这条路少有人走，但这条路是最美的。\r\n\r\n如果无法正常的看待与他人的关系，分离自我与他人，就难以看到别人的美好。\r\n如果不知道生活的艰辛，直面困难的勇气。就看不到别人真实的一面。\r\n看到人真实的一面，才是开启人际交往的钥匙。\r\n\r\n有人说我们一出生就没携带说明书，即便带了也不一定看，即便看了也不一定看得懂。\r\n不，其实我们一出生就是王者，上帝给我们插上了翅膀。只是在生活环境中我们没学会飞翔。\r\n	\N	\N	17	\N	3	\N	5	2	2020-01-04 05:08:53.436344	2020-01-27 18:07:23.099356	2020-01-04	0	\N	\N	548	1	2	f	\N
563	6	15	羽毛球步法	羽毛球步法的特征是折返非常多，因而其不是那种冲刺型的跑步步法。\r\n而是像舞蹈一样的快速的起承转合的转换。\r\n\r\n步法的核心：\r\n1，重心的控制，重心是靠腰腹力量完成移动的，因而虽然说步法，但是腰腹力量是重点。\r\n   李宗伟弹簧步的核心我觉得也是重心而不是脚步，当然重心的移动除了腰腹力量，腿部也是参与了的。\r\n2，每种步法的脚步位置\r\n3，启动步的运用\r\n4，关于回中的位置	\N	\N	17	\N	3	\N	5	0	2020-01-30 18:39:51.933942	2020-01-30 18:39:51.933942	2020-01-30	0	\N	\N	563	1	2	f	\N
564	6	9	稻盛和夫-干活，活法	1，工作就是最好的修行\r\n2，付出不亚于任何人的努力\r\n3，把事情想到有颜色\r\n4，目标应该有挑战\r\n5，消除其他一切烦恼\r\n6，灵魂注入\r\n7，积极出击\r\n8，不要问我知道什么，要问我不知道什么。\r\n9，专注，把当下在做的事情做到极致，对工作而言，就是把手头上的事做到极致。	\N	\N	17	\N	3	\N	5	3	2020-01-30 18:56:35.603842	2020-02-01 07:23:21.346192	2020-01-30	0	\N	\N	564	1	2	f	\N
566	6	7	关于数据的思考	数据的几个特性：\r\n1，规模与组织\r\n2，生命周期，持久性\r\n3，分布\r\n4，副本与一致性\r\n5，可压缩性\r\n6，有序性\r\n\r\n操作特性：\r\n1，原子性\r\n2，并发性\r\n3，隔离性\r\n4，安全性\r\n\r\n数据本身是对真实世界的抽象，首先这种抽象基于深刻的理解与洞察。\r\n其次在挖掘出数据本身的特征之后，还得考虑其操作特征，以及维护和监控需求，安全等。\r\n这样才能设计出一个完整的数据表达。	\N	\N	17	\N	3	\N	5	0	2020-02-06 20:26:01.577187	2020-02-06 20:26:01.577187	2020-02-06	0	\N	\N	566	1	2	f	\N
572	6	6	想清楚有多么重要	我想得有颜色没，我能看到它的样子么？ 还有我不知道的吗？\r\n由根本出发而发散的思维方式，这世界就是这样发展变化的。\r\n但确知一种发展方向是否合适则需要真正的知识与努力。\r\n如果你看不到本质，就无法知道哪种方法是对的，可能会在各种变种中徘徊，最终做了错误的选择。\r\n智力游戏的乐趣在于一旦你掌握了根本，你就拥有了像上帝一样的能力，当然只能无限接近。\r\n人们对未知的东西充满恐惧，但挑战与战胜这种恐惧让人有了智慧。	\N	\N	17	\N	3	\N	5	0	2020-02-16 13:56:19.288039	2020-02-16 13:56:19.288039	2020-02-16	0	\N	\N	572	1	2	f	\N
567	6	7	算法的本质	为什么一些算法比另外一些更好？\r\n\r\n算法其实反应了我们对问题本质的探索，是事物内在关系的运用。\r\n就像数学家追求问题更好的解法	\N	\N	17	\N	3	\N	5	1	2020-02-06 20:50:01.517715	2020-02-20 18:45:17.090946	2020-02-06	0	\N	\N	567	1	2	f	\N
577	7	16	支持gp上的ci	TODO list:\r\n1,超过配置时间的事务自行abort\r\n2，ci vacuum逻辑修正。\r\n3，delete需要遍历ci tree上多条记录，存在相同key不在同一个链上的情况。\r\n4，hint的设置\r\n5，宏改为参数	\N	\N	19	\N	3	\N	5	7	2020-02-27 16:18:37.871981	2020-03-03 07:12:16.540471	2020-02-27	0	\N	\N	577	1	2	f	\N
578	7	16	2020.3.4	1，完成添加ci清理进程，顺便把参数加进去。\r\n2，弄清楚gp的分布式事务与本地事务的对应关系\r\n3，完善对coral的理解，找出疑问。why need coral？ what is coral？\r\n4，合入欧博代码，开始测试。	\N	\N	19	\N	3	\N	5	3	2020-03-04 06:51:22.612452	2020-03-05 00:39:10.990653	2020-03-04	70	\N	\N	578	1	2	f	\N
605	6	15	抽墙练习	抽墙只有球速达到了才容易，否则球的方向难以控制就很难持续抽。\r\n\r\n发现的问题：\r\n1，正反手都得采用正确发力方式，即旋转鞭打。\r\n2，注意发力行程，到击球末尾时握紧没意义，一定是在拍面与球垂直的击球瞬间握紧。\r\n3，下蹲与步法移动很关键，平抽球与身体高度差不多，不下蹲很难发力。	\N	\N	17	\N	3	\N	5	0	2020-04-12 09:09:01.597992	2020-04-12 09:09:01.597992	2020-04-12	0	\N	\N	605	1	2	f	\N
280	6	9	谢锐3.0版本	3.0版本要求：\r\n硬件：\r\n1，修复牙齿\r\n2，羽毛球达到纯业余中高级水平\r\n\r\n操作系统：\r\n1，时间管理做到天级别\r\n2，正式做心态管理，持戒清念\r\n3，进一步完善认知和规则，并在日常工作和交流中加以运用。\r\n4，能进行流利的英文论文，杂志阅读。\r\n5，能进行非正式的会谈，建立起技术联系网。\r\n\r\n服务：\r\n1，启动第一个正式个人项目\r\n2，工作上继续完成工程能力，但同时也提升理论高度。	\N	\N	17	\N	3	\N	5	12	2019-02-23 06:40:10.417236	2020-06-21 21:07:42.912307	2019-02-23	0	\N	\N	280	1	2	f	\N
1049	6	7	SSDR 31: 扩展编程&泛型编程	扩展编程是指实体具备多种变种，或行为具备多个变种。\r\n常见手段就是使用接口，即通过抽象来封装变化。\r\n在rust中可以使用trait来实现。而且扩展编程与泛型编程有想通之处。可以看到rust使用trait给泛型做限定。\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2022-04-24 06:40:03.079209	2022-04-24 06:40:03.079209	2022-04-24	0	\N	\N	1049	1	2	f	\N
929	7	16	近期任务	1，实验项目\r\n2，修复vcs、vrs可见性问题\r\n3，外键约束问题\r\n4，性能问题，性能CI继续搞起\r\n	\N	\N	19	\N	3	\N	5	0	2021-08-06 14:30:49.021048	2021-08-06 14:30:49.021048	2021-08-06	0	\N	\N	929	1	2	f	\N
550	6	17	PG Column Add/Drop	pg支持在table末尾追加column，不支持指定位置。\r\npg支持drop任意column，在pg_attr中标记删除。\r\n\r\ntuple格式中infomask2记录了属性数量这个关键信息。一旦tupledesc中属性数量超过tuple natts，则对末尾进行NULL填充。	\N	\N	17	\N	3	\N	5	0	2020-01-06 12:38:25.206203	2020-01-06 12:38:25.206203	2020-01-06	0	\N	\N	550	1	2	f	\N
549	6	17	PG 事务ID	事务ID，VXID，Subtransaction ID\r\n\r\n<pre>\r\nOne important point regarding subtransaction handling is that several may need\r\nto be closed in response to a single user command.  That's because savepoints\r\nhave names, and we allow to commit or rollback a savepoint by name, which is\r\nnot necessarily the one that was last opened.  Also a COMMIT or ROLLBACK\r\ncommand must be able to close out the entire stack.  We handle this by having\r\nthe utility command subroutine mark all the state stack entries as commit-\r\npending or abort-pending, and then when the main loop reaches\r\nCommitTransactionCommand, the real work is done.  The main point of doing\r\nthings this way is that if we get an error while popping state stack entries,\r\nthe remaining stack entries still show what we need to do to finish up.\r\n\r\nIn the case of ROLLBACK TO <savepoint>, we abort all the subtransactions up\r\nthrough the one identified by the savepoint name, and then re-create that\r\nsubtransaction level with the same name.  So it's a completely new\r\nsubtransaction as far as the internals are concerned.\r\n\r\nOther subsystems are allowed to start "internal" subtransactions, which are\r\nhandled by BeginInternalSubtransaction.  This is to allow implementing\r\nexception handling, e.g. in PL/pgSQL.  ReleaseCurrentSubTransaction and\r\nRollbackAndReleaseCurrentSubTransaction allows the subsystem to close said\r\nsubtransactions.  The main difference between this and the savepoint/release\r\npath is that we execute the complete state transition immediately in each\r\nsubroutine, rather than deferring some work until CommitTransactionCommand.\r\nAnother difference is that BeginInternalSubtransaction is allowed when no\r\nexplicit transaction block has been established, while DefineSavepoint is not.\r\n</pre>\r\n\r\n事务ID：按需分配，不论事务还是子事务，需要时分配。 子事务分配事务ID时，也必须给父事务分配。\r\n子事务ID：事务内用于标识不同子事务，TopSubTransactionId为1.\r\nVXID：多个进程之间使用的虚拟事务ID，用于不需要写入的事务，VXID不会持久化。在全部进程重启后重置。	\N	\N	17	\N	3	\N	5	1	2020-01-06 08:17:03.747369	2020-01-06 15:26:03.832133	2020-01-06	0	\N	\N	549	1	2	f	\N
552	6	6	科学，数学与神学	可证伪性是一个理论系统的属性，其中的公理如果具备可证伪性，说明这个系统是严格意义上科学的。\r\n但可证伪性不代表实际上一定具备环境来验证，比如牛顿第一定律。\r\n如果没法证明公理，则系统的可信度就是公理级别，而不是真理。\r\n\r\n可证伪性没必要作为科学的划分界限，其实基于公理之上的研究也是广义上科学的。\r\n人会死是公理，三段论也是公理。很多科学研究基本的那几条都是公理。\r\n\r\n\r\n逻辑与数学是抽象的，不具备可证伪性，因而不是侠义的科学。\r\n纯逻辑的事物其实都是自己的理论系统。\r\n\r\n比如神学与马克思哲学，其都没有提出完备的公理，其结论也未经某个公理系统推导，\r\n因而其结论也不具备广泛的可信度(至少与公理同样的可信度)	\N	\N	17	\N	3	\N	5	2	2020-01-11 08:20:39.539104	2020-01-11 11:56:23.38248	2020-01-11	0	\N	\N	552	1	2	f	\N
555	6	8	改变的主题生活会	改变\r\n1，触发点\r\n2，直面问题\r\n3，吃直面问题，克服困难的苦，不吃逃避问题的苦。当知道该吃什么苦时，其他的苦都是不必承受的了，比如焦虑，抱怨，嫉妒，虚荣。实际上反而会轻松不少。\r\n4，你知道什么时候应该快乐吗？\r\n5，做一个正常人很难，所以很多人都选择了奇妙的避开了困难，\r\n   但避开问题也是有代价的，这是各种心理疾病滋生的温床，这样一条直面问题，理智选择的路这成了少有人走的路。	\N	\N	17	\N	3	\N	5	0	2020-01-15 10:31:49.915724	2020-01-15 10:31:49.915724	2020-01-15	0	\N	\N	555	1	2	f	\N
554	6	17	ci(btree)上支持include column	引入非key attr的影响：\r\nIn B-tree indexes INCLUDE columns are truncated from pivot index tuples\r\n(tuples located in non-leaf pages and high keys).  Therefore, B-tree indexes\r\nnow might have variable number of attributes.  This patch also provides\r\ngeneric facility to support that: pivot tuples contain number of their\r\nattributes in t_tid.ip_posid.  Free 13th bit of t_info is used for indicating\r\nthat.  This facility will simplify further support of index suffix truncation.\r\nThe changes of above are backward-compatible, pg_upgrade doesn't need special\r\nhandling of B-tree indexes for that.\r\n\r\nSHA-1: 8224de4f42ccf98e08db07b43d52fed72f962ebb\r\n\r\n* Indexes with INCLUDE columns and their support in B-tree\r\n\r\n\r\n\r\nSHA-1: 40dae7ec537c5619fc93ad602c62f37be786d161\r\n\r\n* Make the handling of interrupted B-tree page splits more robust.\r\n\r\n\r\nSHA-1: 0c504a80cf2e6f66df2cdea563e879bf4abd1629\r\n\r\n* Remove dedicated B-tree root-split record types.	\N	\N	17	\N	3	\N	5	0	2020-01-14 06:40:21.019989	2020-01-14 06:40:21.019989	2020-01-14	0	\N	\N	554	1	2	f	\N
557	6	8	苦与乐	除了承受直面问题，克服困难的艰苦，其他苦都不必承受。比如焦虑，嫉妒，空虚，麻木。\r\n即正是因为选择主动承担的苦，苦中也有了甜味。并且乐的范围也扩大了。\r\n\r\n不承担苦的人，感受不到快乐，看不到真实，这种变得麻木，空虚。\r\n承担太多不该承担的人，就会进入焦虑，抑郁。\r\n\r\n没有人应该承担不自信，身体疾患带来的苦，但前提是他们懂得克服困难，懂得珍惜身体，热爱生命。	\N	\N	17	\N	3	\N	5	0	2020-01-20 06:56:30.419319	2020-01-20 06:56:30.419319	2020-01-20	0	\N	\N	557	1	2	f	\N
607	7	16	imch的方案	x, 为什么叫imch？\r\n1，表空间和块之间是否有一层，用于管理同一个列使用的块\r\n2，列与其存储空间的元数据如何管理\r\n3，表种所有变长列使用同一个heap来存储，列中保留tid指向heap\r\n4，原子操作会跨多个列的块么\r\n5，是否支持批量写入接口\r\n6，块内的空闲空间管理	\N	\N	19	\N	3	\N	5	5	2020-04-13 12:42:33.206665	2020-04-29 05:35:22.486257	2020-04-13	0	\N	\N	607	1	2	f	\N
551	6	8	创世者宣言	创世者宣言：\r\n我们立志成为创世者，\r\n秉持科学精神，知行合一\r\n我们坚信直面问题，克服困难就是在制造快乐。\r\n以真诚对待生命，看到自己，看到别人，接收自己，接收别人，改变自己。\r\n我们时刻活在当下，生机畅达。\r\n我们从不焦虑，因为我们已经在行动。\r\n我们从不被动挨打，因为我们在主动出击。\r\n我们从不虚度时光，因为那是在浪费美好。	\N	\N	17	\N	3	\N	5	3	2020-01-10 06:29:45.614281	2020-01-30 20:39:15.287017	2020-01-10	0	\N	\N	551	1	2	f	\N
559	6	15	奥义	打羽毛球的根本在于追求一种健康的生活，一种顽强的精神，一种完善自我的追求。\r\n君子厚积薄发。只需发出70%力即可，留下30%给自我完善与调整。70%就是最好的发挥了。\r\n1，首先养成健康的生活方式\r\n2，其次注重核心力量等训练\r\n   腿部并非发力的核心，腰腹才是。\r\n3，完善动作，最美的动作，练习肌肉记忆\r\n\r\n重心是步法的核心，而控制重心得依赖于核心力量。\r\n攻防转换\r\n球路组织\r\n细节对于局势的影响等	\N	\N	17	\N	3	\N	5	2	2020-01-27 20:02:58.158477	2020-03-28 16:06:58.348365	2020-01-27	0	\N	\N	559	1	2	f	\N
187	6	15	羽毛球水平的阶段	我的理解：\r\n第一阶段：知道发球规则，不会发力。飞琳乐等都这水平\r\n第二阶段：高远发力稍微好些，可以把球打到底线了。反手可以回回直线网前，没什么步伐。 阳俊这水平\r\n第三阶段：高远发力轻松，但不到位，杀球基本能压住，反手可以打到半场，偶尔还能玩玩网前小球，但是非常糙，步伐容易站死。 目前我们都这水平。\r\n第四阶段：高远发力清脆，主动反手可以打任意位置，小球稳定性提高。有了基本的控制能力。步伐基本能到。 \r\n第五阶段：四方球非常精确到位，球速X2. 有了预判。\r\n第六阶段：球速x2,有多套技战术，各种短板得到补齐，鱼跃，劈杀。\r\n\r\n每个阶段跟上一个阶段比，估计都不会超过7个球（21个球）。11个球不超过4个。\r\n\r\n几个指标：\r\n1，力量，体能，步伐基本功 （力量）\r\n2，发力与速度（敏捷）\r\n3，战术能力 （智力）\r\n4，成败系数（经验，当然也可以纳入智力范围，经验体现了临场应变能力，情绪控制能力影响技能发挥）\r\n\r\n每个不仅用强弱来划分，而是用数值来衡量，从0到100.\r\n而总分是三位相乘。\r\n比如林丹巅峰期。\r\n80*90*90 = 648000\r\n比如我当前：\r\n5*10*10 = 500\r\n最高业务水平：\r\n60*60*60 = 216000\r\n\r\n也就是说业余最高水平跟林丹打，单个球胜率为 1/4. 21个球不会超过7个。	\N	\N	17	\N	3	\N	5	1	2018-12-02 12:36:32.318049	2020-01-28 07:04:20.098099	2018-12-02	0	\N	\N	187	1	2	f	\N
932	6	9	读《随机漫步的傻瓜》	1，人比自己想象的迷信\r\n2，人会产生非理想的因果判断\r\n3，人会情绪化\r\n4，人看不到完整数据下的概率\r\n5，人喜欢模糊思考，而非精确计算	\N	\N	17	\N	3	\N	5	0	2021-08-12 05:48:37.805379	2021-08-12 05:48:37.805379	2021-08-12	0	\N	\N	932	1	2	f	\N
560	6	8	少有人走的路-成长陷阱	个人集体成长的陷阱：\r\n1，关爱，安全感缺失\r\n2，暴力，没规则\r\n3，恐惧，对于失去的担心，人成长过程中在不断的失去。\r\n4，逃避困难，缺少肯定与耐心\r\n5，谎言下的自我保护，过多的责备\r\n6，懒惰，简单思维\r\n7，恶习，大脑工作机制在有害癖好上的发挥\r\n\r\n爱与暴力\r\n恐惧与自信\r\n逃避，懒惰-面对，改变\r\n真实与谎言\r\n善与恶\r\n生与死\r\n神经官能症，人格失调症，移情	\N	\N	17	\N	3	\N	5	4	2020-01-28 10:10:25.216653	2020-03-12 07:45:00.377425	2020-01-28	0	\N	\N	560	1	2	f	\N
610	6	6	深入理解一切	做一个有心的人，聪明的人。这实际上不难，只要我们多点观察与思考。\r\n\r\n天地人数变，行为产生关系，吃的行为形成了食物链。\r\n行为本身在改变事务，改变了的事务具备了新的行为。\r\n沟通是一种特别的行为，可以形成虚拟关系，这是一种特殊关系。\r\n\r\n关系在软件上体现为数据上的引用，行为上的调用。\r\n关系表明了可见与依赖。\r\n\r\n结构化：\r\n概念图反应了对软件的分割，由此行为由多个小零部件提供的方法组合来完成。\r\n对象编程的思想就是让概念(对象)与其提供的方法绑定一起。\r\n模块编程的思想就是用模块来表达概念，通常模块提供的方法也表现为模块内的函数。\r\n\r\n发展树：\r\n改变源自于一个简单的思想，只要这个思想涉及基础，改变将会非常大。就这就是发展树。\r\n就像春风，春风生万物变。\r\n\r\n数据结构与算法：\r\n核心的数据结构与算法就是软件的根。	\N	\N	17	\N	3	\N	5	5	2020-04-20 05:56:51.205254	2021-03-18 06:31:34.770648	2020-04-20	0	\N	\N	610	1	2	f	\N
581	7	16	2020.3.5	1，清理编译错误\r\n2，合入欧博代码，进行vacuum和scan测试。	\N	\N	19	\N	3	\N	5	0	2020-03-04 22:45:39.115723	2020-03-04 22:45:39.115723	2020-03-04	0	\N	\N	581	1	2	f	\N
609	6	15	反手平高球	平高球是球速较快的，要防守反手位平高球就得跟上速度。\r\n可以采用正手绕头顶击球，或反手击球，取决于球的位置。\r\n\r\n赵建华：高远球不是为了给别人送球，平高球更不是，其目的在于调动对方，平高球之后如果回位不及时则陷于被动。\r\n另外在未打球时，身体要非常放松，可以做任意动作。而发力的核心就是集中于最后一点，其他时间也是放松的。	\N	\N	17	\N	3	\N	5	0	2020-04-18 01:41:37.335062	2020-04-18 01:41:37.335062	2020-04-18	0	\N	\N	609	1	2	f	\N
561	6	9	修行之道	心外无物，移情法则，注意到自己的意识，让潜意识变成意识。\r\n心外无物，我们要注意到别人的意识，因为没有一个统一的上帝视觉，让大家看到完全一样的东西。\r\n因而在与其他意识体沟通时，应该先拉通概念，理解对方的意识。\r\n\r\n传习录：今人未能有发而皆中节之和，须知是他未发之中亦未能全得。\r\n说的就是这个意思，我们在未发之时都不能觉察与了解事物的本质，了解人的意识。\r\n又如何做到发而中呢？\r\n\r\n在起心动念的时候，就让意识介入。	\N	\N	17	\N	3	\N	5	4	2020-01-28 14:10:56.11674	2020-02-27 14:38:02.514169	2020-01-28	0	\N	\N	561	1	2	f	\N
583	7	16	2020.3.6	1，完成基本功能测试\r\n2，处理包家鹏的问题\r\n3，处理ci代价评估	\N	\N	19	\N	3	\N	5	2	2020-03-06 09:48:50.047949	2020-03-07 00:09:28.838624	2020-03-06	0	\N	\N	583	1	2	f	\N
612	6	15	打球心得4.21	高远球时鞭打确实很容易，另外鞭打后击球点好像也发生了变化。\r\n反正很轻松。\r\n\r\n感觉可以进入下一阶段了：当把球打到位很容易后。\r\n重点就是身法了，即如何以最轻松最稳定最快的方式把球打到目标位置。\r\n这不仅是手法，步伐，而是二者的结合。步伐移动到某个位置，手肘在某个位置，以什么轨迹挥拍。	\N	\N	17	\N	3	\N	5	2	2020-04-22 07:19:41.407995	2020-04-22 20:56:57.449229	2020-04-22	0	\N	\N	612	1	2	f	\N
611	6	17	GP在segment支持分区计算与分布计算	1，分布计算相对简单，只需要GP_Policy，这个segment节点的relation上有。\r\n2，分区计算，由于pg_partition和pg_partition_rule原生在segment上没有，需修改支持。\r\n\r\n改动点：\r\n1，在add_part_to_catalog中限制了executor不写partition和partition rule，取消该限制。\r\n   去掉其他相关assert，断言该操作不在segment上执行。\r\n2，在_outPartitionBy和_readPartitionBy中加入对于AlterTableCmd中partitionBy结构parentRel的编解码。\r\n否则add_part_to_catalog函数得到的pby->parentRel无效，无法正常执行。\r\n3，RelationNeedsSynchronizedOIDs中去掉partition和partition rule。\r\n\r\n\r\n另外通过该修改发现调试执行器代码也不难，至少Plan通过gdb NodeTag是很容易解析整个plan tree的。	\N	\N	17	\N	3	\N	5	2	2020-04-21 21:26:08.397724	2020-04-23 09:18:23.694357	2020-04-21	0	\N	\N	611	1	2	f	\N
670	6	7	知识结构化	1，它是什么，目的与功能。for example。\r\n2，怎么使用它？接口\r\n3，怎么调优，运维，解决使用问题。\r\n4，它的本质是什么，为什么存在\r\n5，它在外围系统中的位置\r\n6，它内部的结构，划分\r\n7，它涉及的动作流程与状态\r\n8，关键点，踩坑记。关键选择，为什么这样选择\r\n9，它的历史与未来。	\N	\N	17	\N	3	\N	5	0	2020-08-02 05:32:44.13109	2020-08-02 05:32:44.13109	2020-08-02	0	\N	\N	670	1	2	f	\N
568	6	8	人的心智成熟度	1，撒谎者\r\n           生活在情绪的漩涡之中，并且身心遭受伤害，无法面对，只能逃避，撒谎，扭曲的方式来处理。\r\n2，体制者，依存，麻木，自我怀疑，迷失自我，边界感缺失。\r\n           容易因别人观念而做出选择，价值取向于所在集体相关。\r\n3，独立者，具备独立人格，开始直面个人之外的所有问题，以及基本的自信。\r\n           有了一定个人修为，能觉察自己，情绪控制与行为自律能力。\r\n\t\t   完全独立的人不再有对于人和事不在有因个人原因的恐惧。\r\n4，传世者，有了能力协助他人，散播爱的能力。1，觉知爱并因爱而行动 2，心外无物，能感知别人，并帮助其成长。	\N	\N	17	\N	3	\N	5	1	2020-02-07 13:00:58.563255	2020-02-07 13:41:27.507359	2020-02-07	0	\N	\N	568	1	2	f	\N
662	6	6	大脑的功能	外层：\r\n左脑：逻辑和抽象思维\r\n右脑：形象思维，想象力，图像处理。\r\n\r\n杏仁核：主情绪\r\n海马体：主记忆\r\n	\N	\N	17	\N	3	\N	5	1	2020-07-20 05:38:02.176425	2020-07-20 07:21:27.228305	2020-07-20	0	\N	\N	662	1	2	f	\N
571	6	17	关于snapshot too old	pg也有类似处理：https://postgresqlco.nf/zh/doc/param/old_snapshot_threshold/\r\n这不是oracle的专利：http://blog.itpub.net/29209660/viewspace-1416834	\N	\N	17	\N	3	\N	5	0	2020-02-11 22:10:28.16981	2020-02-11 22:10:28.16981	2020-02-11	0	\N	\N	571	1	2	f	\N
570	6	7	把领域问题研究到深入骨髓，下次遇到就不必重新思考了	比如空间管理，循环使用的空间管理，与不断增长的空间管理，把里面的问题想透彻，以后遇到联想下就行了。\r\n再比如这次搞的undo segment，把问题想透彻，其实也就那些问题，下次再遇到直接套上去即可。\r\n包括锁的问题等等。	\N	\N	17	\N	3	\N	5	1	2020-02-11 22:05:28.347368	2020-02-11 22:31:56.309895	2020-02-11	0	\N	\N	570	1	2	f	\N
664	6	15	踮起脚根来打球	垫起脚，跑得快，这是必然的。	\N	\N	17	\N	3	\N	5	0	2020-07-22 05:36:36.660036	2020-07-22 05:36:36.660036	2020-07-22	0	\N	\N	664	1	2	f	\N
668	6	9	个训(校训总结)	轻松自信\r\n积极主动\r\n热情团结\r\n\r\n校训分析总结，单词出现次数：\r\n求是：13次\r\n创新：28次\r\n求实：29次\r\n团结：16次\r\n知行：5次\r\n求真：5次\r\n行：18次\r\n德：24次\r\n强：9次\r\n勤：20次	\N	\N	17	\N	3	\N	5	0	2020-08-01 05:05:58.448095	2020-08-01 05:05:58.448095	2020-08-01	0	\N	\N	668	1	2	f	\N
574	6	9	一个寓言-盗墓的梦	昨天我做了一个梦，梦中我是一个盗墓者。挖掘了很多宝藏，心中欣喜万分，然后把他们在一个高端展馆中展示，还有我的朋友们来参观。\r\n我把其中一部分卖掉，成了非常富有的人。有了一个非常大的房子，很宽敞，我在其中和朋友聊天。\r\n\r\n啊，多美的一个梦，我想这是在启示我去与真正有真知的人交流，宝藏在他们的脑中，在他们的言谈中，在论文和文章中。\r\n等我挖掘到，我就有了宝藏。可以分享给我的朋友，同时我也变得很富有。	\N	\N	17	\N	3	\N	5	1	2020-02-18 06:22:15.781168	2020-02-18 06:30:35.113624	2020-02-18	0	\N	\N	574	1	2	f	\N
674	6	7	OLTP与OLAP	事务处理\r\n分析，推理\r\n是人们运用计算机的二类大场景。\r\n后面可能还会有想象，创新	\N	\N	17	\N	3	\N	5	0	2020-08-05 10:13:04.541902	2020-08-05 10:13:04.541902	2020-08-05	0	\N	\N	674	1	2	f	\N
565	6	15	高远挥拍心得	1，快速抬肘架拍\r\n2，蹬地转腰的同时开始倒拍\r\n3，腰转正之时也差不多是最高速挥拍，在完成蹬转发力链条期间内完成倒排挥拍动作。\r\n4，手腕手指在前面阶段是不必介入的，等大臂带小臂把速度甩起来，最后击球阶段手腕手指介入。	\N	\N	17	\N	3	\N	5	5	2020-01-31 09:53:00.466982	2020-03-30 21:24:58.363165	2020-01-31	0	\N	\N	565	1	2	f	\N
569	6	17	CI隔离级别	证明：\r\n1，如果heap tuple实现了SI，ci tuple上实现RC，整体上仍然满足SI。\r\n(注：结论是不成立)\r\n\r\nT1： \r\n step1: read ci tup A(v1)\r\n step2: update heap tup 1\r\n step3: update ci tup A(v3)\r\n step4: read ci tup A(v3?)\r\nT2: \r\n step1: insert heap tup 2\r\n step2: update ci tup A(v2)\r\n\r\n如果ci按照RC规则，先t2.step2 commit，执行t1.step3. \r\n则按照SI可以看到自身尚未提交修改的特点，t1.step4应该看到其最新修改v3版本.\r\n但按照SI不能看到事务开始后其他事务修改的规则，则t1.step4不应该看到t2.step2的修改。而v3版本包含了v2的修改。这与上述要看到v3版本矛盾。\r\n\r\n\r\n如果上述推导成立，则说明CI仅满足RC，保证不了整体的SI。\r\n另外一种处理方式就是一旦事务内有写入，则不允许该事务使用该ac来读，可以退化为使用Ik或其他扫描方式。\r\n即回归使用heap上的可见性。\r\nrule： 即禁止在含AC更新的事务中使用AC扫描。\r\n更详细：如果当前版本的事务id为本事务，且当前是使用RC以上隔离级别的读操作，则报错。\r\nrule的目的是避免将AC的读降低到RC级别。\r\n\r\nMysql的RR：\r\nhttps://yq.aliyun.com/articles/286071\r\n看上去RR隔离下写操作采用的是RC隔离级别。并且不解决幻读问题。\r\n这样RR隔离下一个事务看到另一个提交事务的部分修改(继承修改部分)，看到另一个事物的写入记录\r\n\r\n2，证明在新增上述规则下，在事务中使用CI不会破坏SI\r\nci读取版本链，如果当前版本的tid在snapshot中已提交，则可见。\r\n对于update的scan，ci采用的RC级别，即凡是提交，则可在其基础上继续更新。\r\n对于abort的事务，则需找到上一个commit版本，并在其基础上更新。\r\n\r\n上述rule的判断：如果当前版本的事务id为本事务，且当前是使用SI级别的读操作，则报错。\r\n但是无法杜绝先R ac，然后W ac的情况，显然这与pg的RR隔离级别是不一样的。\r\n举个例子：\r\nT：\r\n1，Read满足某个条件的记录数\r\n2，如果没达到某个数量，则追加\r\n\r\n在SI(串行化)下，并发执行两个T行为的事务，原PG可以避免出现超过的现象。\r\n但是在AC下保证不了(AC的写仅支持RC级别)。\r\n\r\n按照RR的逻辑，如果第2步修改该记录时，如果该记录已被人修改，则撤销事务。\r\n但ac比较特别，实际上第2步在表上没有冲突，则说明语义上是没有冲突的，这时更新ci是可接受的。\r\n\r\n还有一种情况：\r\nT：\r\n1，scan\r\n2，update ac\r\n1在2更新ac之后，scan到更新后记录。同样，这时如果是RC以上隔离，则报错。\r\n如果是RC级别，需根据commandID来判断。\r\n问题：\r\nT：\r\n1，update ac tup （c1）\r\n2, scan （c2）\r\n3, update ac tup （c3）\r\n4, update ac tup （c4）\r\n按snapshot，t.2的scan应该看到c1版本。但是如果同一个事务内采用覆盖式修改，则可能看不到本事务内修改的版本。\r\n如果不采用覆盖式修改，则可以用cid判断。	\N	\N	17	\N	3	\N	5	1	2020-02-10 22:24:15.390802	2020-05-27 13:35:52.704472	2020-02-10	0	\N	\N	569	1	2	f	\N
675	6	15	发高远球	几点：\r\n1，同样也是甩腕发力\r\n2，正手的特点是范围是9点到12点的区间，因而发球不是从下而上。\r\n而是在9点钟处击球。\r\n3，要侧身转腰。	\N	\N	17	\N	3	\N	5	1	2020-08-05 21:37:29.38994	2020-08-05 22:03:52.535295	2020-08-05	0	\N	\N	675	1	2	f	\N
678	6	10	对象存储规划		\N	\N	17	\N	3	\N	5	0	2020-08-13 20:49:33.263378	2020-08-13 20:49:33.263378	2020-08-13	0	\N	\N	678	1	2	f	\N
679	6	8	山与海，与自己相处	身体是地壳土壤，山是旅途，海是情欲，太阳月亮是心，田园是言行，道路是思考。\r\n人们展现给外人的通常就是田园。但我们能模糊的看到别人的山，也能嗅到别人海的气息。\r\n\r\n山就像人的三观，它在慢慢生长，孕育着财富。充满的风景也有险峰。\r\n海就像人的情欲，它难以驯服，有时风平浪静，有时波涛汹涌。\r\n自我就是这个世界中的小孩，他偶尔来田园看看，也偶尔在山边，海边逛逛。\r\n但他不一定准备好登山，也不一定准备好出海。\r\n\r\n他偶尔还会迷路，不知道自己在哪里。他惊慌失措，恐惧不安。\r\n直到有天他搞清楚了方向和目的地。\r\n\r\n有时别人想进来看看山和海的风景，但小孩拒绝了，他自己还没领略，也没准备好约人一起登山，一起下海。\r\n\r\n\r\n学会与自己相处，就是找到自我在自我世界中的路。\r\n让那个小孩成长，从迷途，困惑中走出，与山妖海兽斗争。最终得以领略风景同时也能避开危险。\r\n\r\n向外找无法让自己安定祥和，情志不安本是内部问题。\r\n	\N	\N	17	\N	3	\N	5	2	2020-08-17 05:15:06.495003	2020-08-17 05:48:01.723119	2020-08-17	0	\N	\N	679	1	2	f	\N
677	3	25	cicount问题++++	 现象：\r\n 1，34条差的记录都在同一个事物内更新\r\n 2，这34条记录有两字段完全一样，且log中有update语句正好是使用该字段条件，且表中只有34条满足该字段的记录\r\n 由此推断，该事务很可能是update ws_item_sk。\r\n 并且update并未失败。\r\n 3，所有ac的记录数量相等。都与表差了34条记录。	\N	\N	17	\N	3	\N	5	5	2020-08-07 15:49:29.409741	2020-08-12 17:18:44.720618	2020-08-07	0	\N	\N	677	1	2	f	\N
661	6	6	论认知	认知的特征：\r\n1，是主动发出的\r\n意识和观点可能会冒出来，即快思考的过程。\r\n但认知是慢思考出来的。即主动发起思考。\r\n2，认知有维度和深浅\r\n即不同人认知到的世界是不一样的。\r\n3，认知有主观性\r\n比如这片树叶是绿色的，这不是认知，是知识。\r\n即认知是你主观认可的，具备个体判断色彩的。\r\n因而认知需要实践的检验，是一种动态知识，具备可变性。	\N	\N	17	\N	3	\N	5	0	2020-07-20 05:36:01.537591	2020-07-20 05:36:01.537591	2020-07-20	0	\N	\N	661	1	2	f	\N
576	6	8	人的认知世界，比喻	有两个有趣的比喻：\r\n1，人的认知地图与真实世界地图\r\n2，身边发生的一切就如球面，我们的心在球心，但我们只观察到部分球面区域。	\N	\N	17	\N	3	\N	5	0	2020-02-21 08:12:34.874596	2020-02-21 08:12:34.874596	2020-02-21	0	\N	\N	576	1	2	f	\N
575	6	9	修行者，Coder，羽毛球爱好者	修行者：辨善恶，明责任，成为一个有自信，有自爱，踏实，安定，成熟强大的人。\r\nCoder：明逻辑，理关系，探新路，成为一个有灵魂的程序员。\r\n羽毛球爱好者：会发力，能跑动，善策略，成为一个身体健康的人。	\N	\N	17	\N	3	\N	5	1	2020-02-20 14:00:55.861997	2020-02-27 19:11:05.160545	2020-02-20	0	\N	\N	575	1	2	f	\N
663	6	15	架拍的重要性	快速架拍之后，我们可以足够时间做小臂外旋动作，然后击球过程才能内旋。\r\n启动抬手，到位架拍，转体引拍击球，收回。	\N	\N	17	\N	3	\N	5	0	2020-07-22 05:35:26.220952	2020-07-22 05:35:26.220952	2020-07-22	0	\N	\N	663	1	2	f	\N
665	6	15	练球心得-7.19(反手平抽)	反手平抽要注意4个问题：\r\n1，要用手腕手指发力，球来了再打。贴着球打。\r\n凡是发力部位，在发力之前都是放松的。\r\n\r\n2，击球之后收回来，要送出去\r\n这个可能是习惯，也可能是小臂力量不够的问题\r\n\r\n3，击球拍子往下翻\r\n这可能是小臂外旋了，直接平推就可以了，不必旋。	\N	\N	17	\N	3	\N	5	0	2020-07-22 05:43:24.341908	2020-07-22 05:43:24.341908	2020-07-22	0	\N	\N	665	1	2	f	\N
1009	6	7	读书笔记《代码整洁之道》	1，架构的目的是为了投入尽可能少的资源来完成系统，维护系统。\r\n   由此看构建成本当然非常重要。程序员每天都消耗于安装环境，构建，运行测试用例，生命都白白浪费了。	\N	\N	17	\N	3	\N	5	7	2022-02-11 06:21:15.684512	2022-02-18 07:28:57.11994	2022-02-11	0	\N	\N	1009	1	2	f	\N
1095	6	23	错误处理与断言	错误：表达了因规格限制或物理限制(资源不足等)等原因导致行为失败。\r\nPANIC：没有妥当处理的错误。\r\nASSERT：表示不可打破的逻辑规则或约束。把这些潜在的规则或约束显式化。\r\n        \r\n\r\n问题：ASSERT与错误的区别是什么？能否用错误处理代替ASSERT？\r\n     区别是规则是否可能打破，可能则必须用错误处理。\r\n     如果规则经过很多层，难以确保在以后演变中保证该规则不被打破，那也可以使用错误处理。\r\n\r\n     那么不可打破的规则能否使用错误？\r\n     可以，但是要考虑代价，性能代价和错误处理编写维护的代价。\r\n     如确实不可打破且明确以后也不可打破，还是使用ASSERT。\r\n\t \r\n\t \r\n问题：什么时候不需要对潜在的约束或规则使用assert保护？\r\n     首先如果能逻辑证明该规则在现有代码下可以确保没问题。\r\n\t 其次以后改动打破规则的可能性也不存在。	\N	\N	17	\N	3	\N	5	5	2022-07-21 14:26:00.957048	2022-07-25 13:18:04.805542	2022-07-21	0	\N	\N	1095	1	2	f	\N
666	6	9	锐问	世界的分化，让人待在了那个找不回自己的位置上。就像软件世界的复杂化最终导致人们无法维护它。智者殚精竭虑只是让它变得跟复杂，\r\n当然也许也变得更强大。\r\n人内心真正追求的是快乐，还是强大？\r\n人真的在选择自己的路吗？还是被惯性推着走。\r\n既然每个人都在过自己的生活，为何人们不去选择自己喜欢的方式？人难道不应该尝试各种生活方式吗？是被恐惧支配了吗？\r\n恐惧面对失去，恐惧于未知。\r\n那最初童真般的快乐还能找回吗？快乐缺乏是因为想象力贫乏，人做一些事必然匮乏，这时需要切换到其他事情上？\r\n你怎么区分逃避还是选择？此可我想睡觉是我真实的感受，还是我应该坚持工作，这才是面对？\r\n黑人的不管明天怎么样是因为其基因中有物质丰富的记忆吗？\r\n资本社会的发达是因为其找到了更合理的财富分配方式，当生产力继续发展，资本不是社会推进的主动力，\r\n而是资源与需求。	\N	\N	17	\N	3	\N	5	2	2020-07-27 05:37:49.72504	2020-07-30 12:20:43.377836	2020-07-27	0	\N	\N	666	1	2	f	\N
667	3	25	CI和Undo开发过程中犯过的错误	1，分布式事务2阶段提交，如果prepare失败，在prepare abort过程没有执行undo rollback，导致数据不一致。\r\n2, rollback动作执行的位置不对，没有放在释放锁之后，导致执行时出现锁已经获取的错误。	\N	\N	17	\N	3	\N	5	1	2020-07-30 19:23:05.054261	2020-07-30 19:48:25.702862	2020-07-30	0	\N	\N	667	1	2	f	\N
1008	6	7	SSDR17 如何定义接口	1，当然最简原则，单一职责等要有\r\n2，如果接口传入的结构比较复杂，可以暴露builder，而不是把内部结构暴露出去。\r\n   但是也非绝对，尽量暴露稳定的数据结构和接口吧，\r\n3，扩展性，接口要考虑扩展性，现在不做将来肯定会做的一定要预留好，接口变更代价比较大。\r\n   为啥协议是复杂的，问题就在这里。\r\n\r\n接口是一道墙，没立好就乱了。	\N	\N	17	\N	3	\N	5	2	2022-02-10 18:49:38.453159	2022-02-17 06:58:37.924238	2022-02-10	0	\N	\N	1008	1	2	f	\N
669	6	7	有道云笔记	186***\r\nA***@wy	\N	\N	17	\N	3	\N	5	0	2020-08-01 05:09:44.619529	2020-08-01 05:09:44.619529	2020-08-01	0	\N	\N	669	1	2	f	\N
1098	6	9	提问2022.7.28	1，意识起源是什么?\r\n2, 如果意识也是物质，那如何提升精神力量？\r\n3，结构发展到尽头是智能？结构之美深入了解每种结构。\r\n4，行为，行为是如何复杂化，如何发展的？	\N	\N	17	\N	3	\N	5	0	2022-07-28 07:08:29.142385	2022-07-28 07:08:29.142385	2022-07-28	0	\N	\N	1098	1	2	f	\N
671	6	9	个人能力模型		\N	\N	17	\N	3	\N	5	4	2020-08-02 09:40:50.43647	2020-09-09 16:56:37.897591	2020-08-02	0	\N	\N	671	1	2	f	\N
1099	6	23	curl的多线程安全问题	https://blog.csdn.net/weiyuefei/article/details/51866296\r\nhttps://www.cnblogs.com/edgeyang/articles/3722035.html\r\n\r\n1，要保证curl_global_init在单线程环境，这个好说\r\n2，设置超时	\N	\N	17	\N	3	\N	5	0	2022-07-28 11:53:36.784458	2022-07-28 11:53:36.784458	2022-07-28	0	\N	\N	1099	1	2	f	\N
659	6	15	甩的秘密	羽毛球发力关键在于鞭打，甩鞭。\r\n甩有两个含义：\r\n1，放松，没人甩棍子\r\n2，回环，往前甩先要做往后的运动，这样末端仍然在前，而发力端在后，此处在发力。\r\n明显发力的距离增大。\r\n\r\n看反手视频有点很明显，并非一开始把拍子放低的，而是先高后低，为什么低就是为了回环。	\N	\N	17	\N	3	\N	5	5	2020-07-16 05:20:32.538418	2020-12-02 14:46:02.531638	2020-07-16	0	\N	\N	659	1	2	f	\N
582	6	7	程序员&架构师的核心能力		\N	\N	17	\N	3	\N	5	5	2020-03-05 08:40:09.428305	2020-11-02 08:02:34.28699	2020-03-05	0	\N	\N	582	1	2	f	\N
580	6	17	PG guc配置项	<pre>\r\n/*\r\n * Certain options can only be set at certain times. The rules are\r\n * like this:\r\n *\r\n * INTERNAL options cannot be set by the user at all, but only through\r\n * internal processes ("server_version" is an example).  These are GUC\r\n * variables only so they can be shown by SHOW, etc.\r\n *\r\n * POSTMASTER options can only be set when the postmaster starts,\r\n * either from the configuration file or the command line.\r\n *\r\n * SIGHUP options can only be set at postmaster startup or by changing\r\n * the configuration file and sending the HUP signal to the postmaster\r\n * or a backend process. (Notice that the signal receipt will not be\r\n * evaluated immediately. The postmaster and the backend check it at a\r\n * certain point in their main loop. It's safer to wait than to read a\r\n * file asynchronously.)\r\n *\r\n * BACKEND options can only be set at postmaster startup, from the\r\n * configuration file, or by client request in the connection startup\r\n * packet (e.g., from libpq's PGOPTIONS variable).  Furthermore, an\r\n * already-started backend will ignore changes to such an option in the\r\n * configuration file.  The idea is that these options are fixed for a\r\n * given backend once it's started, but they can vary across backends.\r\n *\r\n * SUSET options can be set at postmaster startup, with the SIGHUP\r\n * mechanism, or from SQL if you're a superuser.\r\n *\r\n * USERSET options can be set by anyone any time.\r\n */\r\ntypedef enum\r\n{\r\n\tPGC_INTERNAL,\r\n\tPGC_POSTMASTER,\r\n\tPGC_SIGHUP,\r\n\tPGC_BACKEND,\r\n\tPGC_SUSET,\r\n\tPGC_USERSET\r\n} GucContext;\r\n</pre>\r\n\r\n\r\n*生效方式*\r\nOption 1: From the command-line shell\r\nsu - postgres\r\n/usr/bin/pg_ctl reload\r\n\r\nOption 2: Using SQL\r\nSELECT pg_reload_conf();\r\nUsing either option will not interrupt any active queries or connections to the database, thus applying these changes seemlessly.\r\n\r\nSession内有效\r\nset命令\r\n\r\n查询：\r\nselect * from pg_settings;\r\nshow variableName;	\N	\N	17	\N	3	\N	5	1	2020-03-04 16:15:33.718395	2020-03-04 16:16:14.429486	2020-03-04	0	\N	\N	580	1	2	f	\N
672	6	8	昨夜我做了一个梦，梦中有一幅画	我住在宾馆或什么地方，早上我从房子走出来，外面是非常大的一片草地，碧绿碧绿的。\r\n在左前方远处有一座高山，也是绿的，在右边近处有山，远处有更高的山。\r\n我呼吸了一口空气，非常舒畅。	\N	\N	17	\N	3	\N	5	0	2020-08-05 06:01:09.144294	2020-08-05 06:01:09.144294	2020-08-05	0	\N	\N	672	1	2	f	\N
936	6	27	pthread 栈内存，C程序自定义栈内存	在ADB的handler上有维护应用程序线程的栈内存，这个编程方法可以深挖下。\r\n	\N	\N	17	\N	3	\N	5	0	2021-08-17 06:38:53.08005	2021-08-17 06:38:53.08005	2021-08-17	0	\N	\N	936	1	2	f	\N
673	6	9	同看世界，每个人看到的都不一样	读一本书，低水平和高水平会读出不一样的内涵，\r\n怎么才叫真正的读书，读到能与作者进行对话，读到看到作者看到的一切，以及他看不到的东西。\r\n是为读书也\r\n\r\n同样对于现实世界，读出来的东西也千差万别。\r\n\r\n世上多是一些庸俗不堪愚昧的人。看不清真相	\N	\N	17	\N	3	\N	5	0	2020-08-05 06:06:02.350258	2020-08-05 06:06:02.350258	2020-08-05	0	\N	\N	673	1	2	f	\N
586	7	16	2020.3.9(ac scan功能测试)	测试场景：\r\n1，未提交的事务  不可见\r\n2，多个未提交版本 不可见\r\n3，未提交，本事务内可见(但只能支持RC以及一下隔离级别，RS及以上隔离级别会报错)\r\n3，提交  可见\r\n4，abort\r\n5, 异常结束\r\n5，正常清理\r\n\r\n分别测试：\r\n1，cleanup引发的rollback\r\n2，写入引发的rollback	\N	\N	19	\N	3	\N	5	1	2020-03-11 09:09:55.315481	2020-03-12 07:45:29.10126	2020-03-11	0	\N	\N	586	1	2	f	\N
603	6	7	网络之TCP协议	https://mp.weixin.qq.com/s/pqUFksNEwT9UWDpcKdGpQg\r\n这篇文章讲的比较好。\r\n\r\n另外一个问题：\r\nhttps://www.zhihu.com/question/27564314	\N	\N	17	\N	3	\N	5	0	2020-04-08 20:59:23.192635	2020-04-08 20:59:23.192635	2020-04-08	0	\N	\N	603	1	2	f	\N
587	7	16	2020.3.12 (ci rollback功能与代码review)		\N	\N	19	\N	3	\N	5	3	2020-03-12 07:46:54.883289	2020-03-12 16:48:43.143761	2020-03-12	0	\N	\N	587	1	2	f	\N
676	6	7	编码之前想清楚所有数据组织与分解动作	比如说1万行代码，每个函数30行。\r\n则可能分解为30个大动作，每个大动作分10个子动作。\r\n详细设计到这步就可以精确评估时间了。	\N	\N	17	\N	3	\N	5	1	2020-08-05 21:40:47.298351	2020-08-23 13:58:27.280322	2020-08-05	0	\N	\N	676	1	2	f	\N
1007	6	24	字典结构	DictId：\r\n按写入顺序的字典序\r\n\r\nsortId：\r\nsortIndex存放的是排序过的DictId。\r\nsortId是sortIndex的数组下标。\r\n\r\ninvert sort index：\r\n存放的是对应DictId在sort index中的下标。\r\n其数组下标本身是DictId。\r\n\r\n1，写入时根据DictId排序得到sortIndex，再从sortIndex得到revert sort Index。\r\n  关系是 revertSortIndex[sortIndex[i]] = i;\r\n2，写入时还有动作是根据hash map计算输入值的DictId\r\n\r\n2, 读取时，根据查询条件的value和字典，以及sortIndex可以得到DictId。\r\n   根据DictId,以及已有值的DictId，都统一通过invert sort index转换得到sortId。\r\n   然后使用sortId来比较大小 	\N	\N	17	\N	3	\N	5	0	2022-02-10 17:40:24.165842	2022-02-10 17:40:24.165842	2022-02-10	0	\N	\N	1007	1	2	f	\N
606	6	6	对于一次把事情做对的思考	1，很多事情只有一次机会\r\n2，很多事情，历史将不可忽略，比如已经上线的软件。\r\n\r\n一次把事情做对，就是追求在当下做到最合适。这非常难，但是确实是一种非常高的追求。\r\n	\N	\N	17	\N	3	\N	5	1	2020-04-13 05:49:01.384494	2020-04-13 05:49:35.269495	2020-04-13	0	\N	\N	606	1	2	f	\N
940	6	7	软件系统研究室	SSRD，SSRD staff，软件系统研究员	\N	\N	17	\N	3	\N	5	1	2021-08-23 06:30:58.107988	2021-08-23 07:13:26.975361	2021-08-23	0	\N	\N	940	1	2	f	\N
608	7	16	octupus导入分区表的问题处理		\N	\N	19	\N	3	\N	5	3	2020-04-13 14:07:27.770513	2020-04-15 13:53:46.420568	2020-04-13	0	\N	\N	608	1	2	f	\N
1101	6	23	使用Markdown将文档写到git	markdown有个好处是其完全是文本格式，可以很方便的看到修改记录。	\N	\N	17	\N	3	\N	5	0	2022-07-28 12:04:09.936327	2022-07-28 12:04:09.936327	2022-07-28	0	\N	\N	1101	1	2	f	\N
354	8	17	进程间通信-共享内存	pg中用到两种共享内存使用方式mmap与system v.\r\n\r\nmmap:由于pg多个进程是父子进程，因而使用的是匿名的共享内存。其实现原理大概是在fork产生子进程时，虚拟地址（内存地址）被子进程共享，由于共享的正好是共享内存，因此操作系统不会额外的给其生成拷贝。也就是说多个\r\n进程使用的是同一片内存，从而达到共享目的。\r\n\r\nsystem v 是采用特殊文件系统的方式实现的（https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html）\r\nsystem v创建的共享内存空间受系统限制。	\N	\N	17	\N	3	\N	5	4	2019-04-25 15:30:42.077578	2020-04-27 14:05:02.756213	\N	0	\N	\N	354	1	2	f	\N
615	6	7	计算模式	计算的模式：\r\n1，内存计算\r\n2，流计算\r\n3，分布式计算\r\n4，云计算\r\n5，边缘计算\r\n6，弹性，有界计算\r\n\r\n计算模式与存储模式相关联	\N	\N	17	\N	3	\N	5	1	2020-04-30 15:35:42.066548	2020-05-04 12:13:55.489784	2020-04-30	0	\N	\N	615	1	2	f	\N
937	6	27	编程如临深渊，如履薄冰，怎么破 (如无约束即可为)		\N	\N	17	\N	3	\N	5	2	2021-08-19 07:49:45.441041	2022-04-06 07:39:18.502024	2021-08-19	0	\N	\N	937	1	2	f	\N
617	6	15	练球心得5.4	降低重心以利于防守，提升重心以进攻。\r\n双腿平行防左右，双腿前后防前后场。\r\n击球时人体以击球腿分为2侧，从而保持平衡。所有的击球都有部分侧身，到平衡线上击球，击球时脚尖指向击球点。\r\n稳定重心比位置更重要，重心分为上下重心和前后重心。	\N	\N	17	\N	3	\N	5	0	2020-05-04 13:58:37.29564	2020-05-04 13:58:37.29564	2020-05-04	0	\N	\N	617	1	2	f	\N
1103	6	23	开发工具系列：CI	新型编程语言rust直接集成了测试能力，非常方便。\r\n\r\nCI要解决的问题是：如何快速的发布软件。	\N	\N	17	\N	3	\N	5	0	2022-07-28 12:07:17.274516	2022-07-28 12:07:17.274516	2022-07-28	0	\N	\N	1103	1	2	f	\N
1105	6	23	定位工具系列： vtune	增强的perf工具，内存和并发分析利器。	\N	\N	17	\N	3	\N	5	1	2022-07-28 12:10:59.612323	2022-11-16 06:42:34.82202	2022-07-28	0	\N	\N	1105	1	2	f	\N
584	7	16	2020.3.7	1，page inspect增加对于ci undo head的处理\r\n2，继续定位包家鹏的问题\r\n3，合入欧博代码，开始测试\r\n4，拟定性能测试方案	\N	\N	19	\N	3	\N	5	0	2020-03-07 01:19:15.807022	2020-03-07 01:19:15.807022	2020-03-07	0	\N	\N	584	1	2	f	\N
585	7	16	3月份计划	完成ci undo测试：\r\n1，vacuum，scan功能测试\r\n2，恢复与复制测试\r\n3，性能测试\r\n\r\n确定coral方案，开始编码。	2020-03-31	\N	19	\N	3	\N	5	1	2020-03-09 07:28:41.792874	2020-03-09 08:38:19.89175	2020-03-09	0	\N	\N	585	1	2	f	\N
588	6	15	打球心得3.14	1，前后场握拍位置真的有效果\r\n后场握末端杀球，高远都轻松多了。前场握前端快如闪电。\r\n\r\n2，打高远球时手腕放松，让拍子垂下去。以扩展有效挥拍距离。\r\n这招打高远球非常有效，但是网上有帖子说此法根因在于没有立腕，立腕之后就不需要此动作。\r\n此动作隐藏的弊端可能是会拖慢引拍节奏。	\N	\N	17	\N	3	\N	5	0	2020-03-16 08:54:37.974961	2020-03-16 08:54:37.974961	2020-03-16	0	\N	\N	588	1	2	f	\N
589	7	16	京东购物体验_客服	你好 沫沫达拼购店，这个店子东西超过一个多月没发货，是在搞诈骗吧\r\n京东智能客服\r\n\r\n非常理解您的心情，请不要着急哦，请点击下方按钮即可为您转接人工，我们一定会尽全力为您解决问题的~\r\n京东智能客服\r\n\r\n联系人工客服\r\n上次聊到这里\r\n18:38\r\njerry_x86\r\n\r\n这都没人管\r\n京东智能客服\r\n\r\n怎么了呢，请问有什么JIMI可以帮到您的呢	\N	\N	19	\N	3	\N	5	0	2020-03-16 16:09:54.066329	2020-03-16 16:09:54.066329	2020-03-16	0	\N	\N	589	1	2	f	\N
1013	6	7	SSDR 18: 设计原则的理解	里氏替换原则描述了继承原则。\r\n但是从更深的角度看，我们经常会违背这一原则。\r\n比如ADB中作为表存储结构的不同实现。\r\n如果有人想去加一种新的存储结构，可能根本搞不清楚要实现哪些功能。\r\n\r\n不同功能的实现者适配了不同的表类型，到处都是适配代码。没人能简单的描述出加一个表结构到底工作量多大。\r\n存储结构的接口也变得模糊，收集统计信息的功能直接看到结构内部的细节。\r\n	\N	\N	17	\N	3	\N	5	4	2022-02-20 07:59:33.977154	2022-03-13 20:15:52.604842	2022-02-20	0	\N	\N	1013	1	2	f	\N
592	6	17	PG 关键代码路径	收集一些关键路径，便于快速定位调试	\N	\N	17	\N	3	\N	5	1	2020-03-20 14:24:53.524371	2020-03-20 14:28:23.963526	2020-03-20	0	\N	\N	592	1	2	f	\N
730	6	29	2021.1.4	1，定位并发相关问题\r\n2，提交bug fix，以及miner代码	\N	\N	17	\N	3	\N	5	1	2021-01-04 06:20:01.080128	2021-01-04 12:53:59.48064	2021-01-04	0	\N	\N	730	1	2	f	\N
600	6	7	DOET读书笔记	设计原则：\r\n1，功能可见性\r\n2，恰当的提示clue\r\n3，反馈，动作应该有反馈\r\n4，因果，不要提供不对应的因果。	\N	\N	17	\N	3	\N	5	0	2020-03-30 21:26:52.885143	2020-03-30 21:26:52.885143	2020-03-30	0	\N	\N	600	1	2	f	\N
597	7	16	etcd	dedicated \r\nrevisions：修改，修订\r\ncredentials：凭证，证书\r\nprompt：促使，导致，提示\r\n\r\n问题：\r\n1，etcd实现根据用户的资源隔离吗？\r\n  不支持，不必经过用户授权，其他用户可以看到别人修改。\r\n2，etcd也有用户组？角色可以付给用户组吗？这样组内用户可以继承角色？\r\n  没有用户组\r\n3，用户可自定义角色吗？\r\n  不支持\r\netcd权限控制与s3的对比	\N	\N	19	\N	3	\N	5	2	2020-03-29 16:07:51.205945	2020-03-31 19:58:10.156453	2020-03-29	0	\N	\N	597	1	2	f	\N
601	6	4	doet2-市长病毒的阴谋	官方政策群体感染，缺乏医疗设备，提高免疫力，大家不必恐慌\r\nthe gv spokesman convey the strategy to the virus, because lack of sophistication instruction and elevate immunity.\r\nno need astonishment to this.\r\n引发游行，拉起巨幅画像游行，失望灰心弥漫，咒骂警察等公职人员\r\nthe parader pervasive the road，they has a dramatic magnificent painting of the figure。\r\nthey are dismay of the government,and have a torrent of abuse to the police. \r\nThe crowd tried to smash down the door of the police station.\r\n知识分子对此政策也非常吃惊，认为其不可理解，希望得到解释。\r\nsome conscientious intellectual also in consternation, they think the behave of gv is incomprehensible.\r\nthey dial the major to interpret the causality.\r\n\r\n警长关紧门，市长则坐在火炉旁吃着一盘葡萄。\r\npolice sergeant close the knob，the mayor near the stove eating a tray of grape.\r\nthey are conscious to set the trap to infect more people. \r\n	\N	\N	17	\N	3	\N	5	1	2020-03-31 22:21:07.501601	2020-04-06 19:17:46.534146	2020-03-31	0	\N	\N	601	1	2	f	\N
725	3	29	2020.12.28	1，review阿港代码，合入自己代码  花费2小时\r\n2，分析单表并行性能上不去问题，去掉spinlock尝试，1小时。	\N	\N	17	\N	3	\N	5	1	2020-12-28 08:42:17.191661	2020-12-28 17:51:36.678815	2020-12-28	0	\N	\N	725	1	2	f	\N
596	6	4	doet1-兽人在村庄抓小王子的故事	场景1：\r\na police fumble a  child。he conceive he is here，as if perceptible。\r\n场景2：\r\ninferior bar clerk shudder in apprehension。\r\nthe village become confusion from harmony。\r\n场景3：\r\nacute observer perceive the emphasis child， and hidden under an mediocre and aesthetic mechanism with fancy。\r\n场景4：\r\nhe sacrifice himself and distration the police in another way\r\n场景5：\r\nthey found neglect the mechanism。feeled inept/incompetent， and kill the observer。	\N	\N	17	\N	3	\N	5	0	2020-03-26 21:49:12.586579	2020-03-26 21:49:12.586579	2020-03-26	0	\N	\N	596	1	2	f	\N
593	7	16	2020.3.24	1，改进一个地方，如果事务结束了，则它应该可以清理，为什么一定要下一个事务来触发\r\n2，明确对于事务和子事务的支持情况	\N	\N	19	\N	3	\N	5	7	2020-03-24 04:53:07.733236	2020-03-27 08:33:15.644261	2020-03-24	0	\N	\N	593	1	2	f	\N
727	3	29	2020.12.30	1，完成rust代码生成器，并将代码用于swf。 6小时\r\n2，修复编译告警 1小时\r\n3，同步truncate在swf表上更新dataobjectid修改。 1小时	\N	\N	17	\N	3	\N	5	0	2020-12-30 18:14:12.003829	2020-12-30 18:14:12.003829	2020-12-30	0	\N	\N	727	1	2	f	\N
599	7	16	2020.3.30 本周整体计划	1，分析gp事务，整理出一篇可以讲的文档\r\n2，完成通用undo的改造\r\n3，分析列存实现，整理出一遍文档\r\n4，etcd角色模块的设计\r\n\r\n任务非常艰巨	\N	\N	19	\N	3	\N	5	0	2020-03-30 07:02:35.322908	2020-03-30 07:02:35.322908	2020-03-30	0	\N	\N	599	1	2	f	\N
728	6	15	第一阶段目标	可以参加社区或公司级比赛。混双或男双\r\n\r\n差距：\r\n1，发力基本功到位\r\n2，步伐基本功到位\r\n3，小球技术\r\n4，观察对手，发现并攻击漏洞的作战能力。\r\n5，战术调整能力	\N	\N	17	\N	3	\N	5	1	2021-01-04 05:51:43.133586	2021-01-04 05:54:18.737611	2021-01-04	0	\N	\N	728	1	2	f	\N
737	6	10	AP存储形态	1，即时分析\r\n数据要方便修改。\r\n\r\n2，海量静态数据\r\nAP的主战场，快速写入，快速读取，难以更新。\r\n\r\n3，模式访问。\r\ncube，计算缓存技术。	\N	\N	17	\N	3	\N	5	0	2021-01-06 15:08:44.098098	2021-01-06 15:08:44.098098	2021-01-06	0	\N	\N	737	1	2	f	\N
590	6	7	编程总结：结构体的使用，内联函数	在Greenplum上实现undo segment时，起初在定义undo vacuum的清理位置时使用了4个变量。\r\n然而情况有变，实际根据位置进行rollback时，需保留rollback位置，这样也得使用几个变量，刚开始我以为是3个变量，但发现不够。\r\n最终有一个函数使用了很多局部参数记录状态。但是细想rollback位置和clean的位置完全是一样的表达。\r\n\r\n最终我引入了VacPos结构体把这一组相关变量归集起来，发现代码写起来简单清晰了不少。\r\n\r\n由此过程回想我们为什么定义结构体？\r\n程序中所有状态都声明为全局变量或都挂载一个全局结构下并非不可行。\r\n但是这样的程序就是一盘散沙，就像你看到的不是房子，而是组成房子的零部件。这会疯掉的！！\r\n\r\n有了结构体，我们就可以很自然的使用结构体的引用或指针，这样不必在全局去找状态。\r\n\r\n关于函数：\r\n有时候我们不想写小函数，有时候我们不知道给函数一个什么名字，它好像干了这个，又干了那个。\r\n这说明我们对函数的分割不好，函数应该有一个清晰的注释，说明这个函数是干什么的，应该一句话能说清楚。\r\n\r\n内联函数就是一种语法糖，让我们可以定义小的函数，这非常棒！\r\n\r\n编程的要义就是：\r\n1，定义好核心数据结构与算法，这是程序的灵魂。\r\n2，定义良好的架构，执行框架。 这是骨骼。\r\n3，明确整个软件的数据组织，状态管理，模块划分，函数定义，变量命名。 这些是程序的血肉。\r\n\r\n高内聚低耦合，修复封闭扩展开放原则。	\N	\N	17	\N	3	\N	5	0	2020-03-16 22:19:59.172117	2020-03-16 22:19:59.172117	2020-03-16	0	\N	\N	590	1	2	f	\N
949	6	9	灵魂是什么	灵魂就是自我意识，作为观察者的我。\r\n灵魂可以观察，审视我们以及周身，可以有良知。\r\n灵魂可以与人所生活的环境进行连接，如果把生活系统看成主体，那就是个人与之的连接。\r\n\r\n智慧源自灵魂。而灵魂损坏人将变得麻木愚昧。\r\n人的智慧知识当然来自于生活的系统，即未学习仅进行体验的人也是具备发现某些知识的。\r\n\r\n先哲们都是非常重要灵魂健康的人，是智慧与幸福的真正源泉。\r\n也是人真正区别于他人的标志，我思故我在。未经审视的生活不值得过，人应该升级畅达都在说这个。\r\n	\N	\N	17	\N	3	\N	5	0	2021-09-14 11:50:36.478113	2021-09-14 11:50:36.478113	2021-09-14	0	\N	\N	949	1	2	f	\N
595	6	4	英语学习感悟之-翻译不可取	谢锐:\r\nhttps://www.bilibili.com/video/BV1ZW411C7Mw?from=search&seid=853336488209509095\r\n\r\n谢锐:\r\n最后一句很经典，翻译的方式学外语不可取还在于翻译方式没法学到一个语言的精髓!!!!\r\n	\N	\N	17	\N	3	\N	5	1	2020-03-26 20:57:31.520119	2020-03-26 20:59:56.757871	2020-03-26	0	\N	\N	595	1	2	f	\N
591	7	16	2020.3.17	coral方案疑问整理：\r\n1，count在TPC-DS数据集下的效果，如果按时间维度组织数据。聚集效果会怎样？\r\n2，非基础ac的支持方式，非基础ac数据也按照时间维度分区，但是insert时也得检查是否已存在。如果存在则合并。\r\n   这样插入的代价会不会大到无法接受。非基础AC就像跨节点索引。\r\n\r\n3，coral的核心技术点在于？多维索引？ac划分数据？ 基于列存的IoT组织数据。\r\n4，用户怎么知道如何拆分AC，用户定义表。	\N	\N	19	\N	3	\N	5	2	2020-03-17 09:04:58.810162	2020-03-18 08:49:35.294466	2020-03-17	0	\N	\N	591	1	2	f	\N
472	6	17	PG log	log_destination 语义并不准确，实际上是log格式。配置了stderr，但是下面配置collector，以及文件就能输出到指定文件。\r\n\r\n<pre><code class="text">\r\n#log_destination = 'csvlog'\t\t# Valid values are combinations of\r\n\t\t\t\t\t# stderr, csvlog, syslog, and eventlog,\r\n\t\t\t\t\t# depending on platform.  csvlog\r\n\t\t\t\t\t# requires logging_collector to be on.\r\n\r\n# This is used when logging to stderr:\r\nlogging_collector = on\t\t# Enable capturing of stderr and csvlog\r\n\t\t\t\t\t# into log files. Required to be on for\r\n\t\t\t\t\t# csvlogs.\r\n\t\t\t\t\t# (change requires restart)\r\n\r\n# These are only used if logging_collector is on:\r\nlog_directory = 'pg_log'\t\t\t# directory where log files are written,\r\n\t\t\t\t\t# can be absolute or relative to PGDATA\r\nlog_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'\t# log file name pattern,\r\n\t\t\t\t\t# can include strftime() escapes\r\nlog_file_mode = 0640\t\t\t# creation mode for log files,\r\n\t\t\t\t\t# begin with 0 to use octal notation\r\n#log_truncate_on_rotation = off\t\t# If on, an existing log file with the\r\n\t\t\t\t\t# same name as the new log file will be\r\n\t\t\t\t\t# truncated rather than appended to.\r\n\t\t\t\t\t# But such truncation only occurs on\r\n\t\t\t\t\t# time-driven rotation, not on restarts\r\n\t\t\t\t\t# or size-driven rotation.  Default is\r\n\t\t\t\t\t# off, meaning append to existing files\r\n\t\t\t\t\t# in all cases.\r\nlog_rotation_age = 2d\t\t\t# Automatic rotation of logfiles will\r\n\t\t\t\t\t# happen after that time.  0 disables.\r\nlog_rotation_size = 100MB\t\t# Automatic rotation of logfiles will\r\n\t\t\t\t\t# happen after that much log output.\r\n\t\t\t\t\t# 0 disables.\r\n</code></pre>\r\n	\N	\N	17	\N	3	\N	5	6	2019-07-18 15:21:38.619189	2020-03-20 14:09:15.670415	2019-07-18	0	\N	\N	472	1	2	f	\N
594	6	3	ctrl+z挂起程序与恢复	在linux中使用matlab的时候，常常用ctrl+z将matlab挂起，一开始并不知道怎么处理，也关不掉\r\n\r\n后来发现用fg再回车就可以将后台挂起程序切换的前台来。	\N	\N	17	\N	3	\N	5	0	2020-03-24 12:55:06.17789	2020-03-24 12:55:06.17789	2020-03-24	0	\N	\N	594	1	2	f	\N
680	6	8	自然才能自由	当一个人不自然时，就不得自由。不得自由的人是不会生活的人。\r\n他们不知道自己喜欢什么，不知道享受什么。\r\n	\N	\N	17	\N	3	\N	5	0	2020-08-17 05:43:21.725167	2020-08-17 05:43:21.725167	2020-08-17	0	\N	\N	680	1	2	f	\N
1106	6	23	定位工具系列：wireshark + tcpdump	分析协议的必备工具	\N	\N	17	\N	3	\N	5	1	2022-07-28 12:11:31.705309	2022-11-25 08:30:54.827755	2022-07-28	0	\N	\N	1106	1	2	f	\N
598	6	12	2020年3月29日记录		\N	\N	17	\N	3	\N	6	0	2020-03-29 18:39:31.876839	2020-03-29 18:39:31.876839	2020-03-29	0	\N	\N	598	1	2	f	\N
681	6	5	经济危机的本质	经济危机本质上并非生成过剩，生产过剩是现象。\r\n背后根本是经济分化之后的依存关系危机。\r\n\r\n一旦依存关系某个环节出问题，其他依赖环节相应就会问题，从而形成系统性问题。\r\n经济出现局部停滞与倒退。	\N	\N	17	\N	3	\N	5	1	2020-08-19 06:41:32.198391	2021-02-20 19:01:31.402087	2020-08-19	0	\N	\N	681	1	2	f	\N
602	6	15	打球心得4.4	1，身体在球后方，保证击球点在身体的前方合适位置是步伐的意义所在。\r\n有了此保证功力立马提升一倍，这需要有熟练的步伐，良好的体能和击球意识。\r\n\r\n2，打球不需要很大力，保持全程放松积极的态度去打球，其实其他事情也是如此。\r\n减少大发力动作，这样提升稳定性，并且把每个动作做完整。\r\n注意前中场架拍与引拍的变化，不必内旋发力，直接挥拍+手腕手指力量即可。\r\n内外旋动作偏慢了。\r\n\r\n3，羽毛球需要速度，是一个偏敏捷和智力的运动。速度来自于发力技巧。尤其是手腕手指的发力技巧。\r\n反手在架拍之后应该是大拇指顶住球拍，后三指搭住。正手是食指抗住，后三指搭住。最终击球前握紧。\r\n	\N	\N	17	\N	3	\N	5	0	2020-04-06 19:13:54.288164	2020-04-06 19:13:54.288164	2020-04-06	0	\N	\N	602	1	2	f	\N
613	6	17	ORCA打开后用例失败	diff expect/ci_rollback.out result/ci_rollback.out\r\n6a7,8\r\n> psql:../test/st/common/sql/ci_rollback.sql:9: NOTICE:  One or more columns in the following table(s) do not have statistics: test100\r\n> HINT:  For non-partitioned tables, run analyze <table_name>(<column_list>). For partitioned tables, run analyze rootpartition <table_name>(<column_list>). See log for columns missing statistics.\r\n16a19,20\r\n> psql:../test/st/common/sql/ci_rollback.sql:17: NOTICE:  One or more columns in the following table(s) do not have statistics: test100\r\n> HINT:  For non-partitioned tables, run analyze <table_name>(<column_list>). For partitioned tables, run analyze rootpartition <table_name>(<column_list>). See log for columns missing statistics.\r\n24a29,30\r\n> psql:../test/st/common/sql/ci_rollback.sql:21: NOTICE:  One or more columns in the following table(s) do not have statistics: test100\r\n\r\n处理办法：\r\n1，在用例中关闭orca\r\n2，过滤掉orca输出的日志\r\nstatusNum = parsecmd('diff '+RESULT_PATH+'/' + sys.argv[2]+'.out  '+EXPECT_PATH +\r\n                          '/'+sys.argv[2]+'.out' + ' -I " grade) already exists" -I "NOTICE" -I "HINT" ')	\N	\N	17	\N	3	\N	5	0	2020-04-27 12:00:12.923804	2020-04-27 12:00:12.923804	2020-04-27	0	\N	\N	613	1	2	f	\N
690	6	5	道家，杨朱，墨子，孟子	道家讲无为，是现代社会是相反的，现代社会强调竞争，分化。当然也更残缺。\r\n无为当然有大智慧，就算是有为，在何处无为仍然是非常必要的。\r\n比如讲功成身退，就描述了行为与状态的关系。\r\n道家的朴素辩证法很有价值，有和无是同出的，是相生变化的，这种统一状态就是玄，状态变化就是众妙之门。\r\n减轻感官：五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋（tián）猎令人心发狂，难得之货令\r\n人行妨。是以圣人为腹不为目，故去彼取此。\r\n分化得到有，也必然得到无。老子讲最初那个状态就挺好了，这是从自然的角度看。从人的角度看，人有欲，也有苦。\r\n真回到如石头一般无为，于自然而言很好，于人类社会就会被抛弃。\r\n人类有欲，欲有成就，也必有苦，承担改造自然的恶果。不断疲于应对。\r\n\r\n杨朱继承了无为思想，有点自由主义的思想，即不去过多干预，人自私的但不会有问题。\r\n墨子则是慈善主义者，有点后社会主义的感觉。\r\n现代社会其实是结合了2者的，就像孟子说的杨朱和墨子都是极端。\r\n\r\n礼和法分别是儒家和法家重视的。其实都是管理社会的方法，分别在不同地方发挥作用。\r\n\r\n	\N	\N	17	\N	3	\N	5	1	2020-09-10 05:03:46.85894	2020-09-10 05:22:08.657363	2020-09-10	0	\N	\N	690	1	2	f	\N
614	7	16	imcs执行	计划五一期间完成space的所有接口，包括load	\N	\N	19	\N	3	\N	5	7	2020-04-29 14:02:29.03508	2020-05-09 15:32:55.735737	2020-04-29	0	\N	\N	614	1	2	f	\N
616	6	18	增量式计算	如果一个系统要计算1年的数据形成表格，那么前面月的结果可以缓存起来。这样只用算最新的这个月的数据即可。\r\n	\N	\N	17	\N	3	\N	5	1	2020-05-04 12:00:25.474277	2020-05-04 12:00:54.887815	2020-05-04	0	\N	\N	616	1	2	f	\N
623	3	25	ud page溢出问题处理	构造一个简化的必现用例\r\n1，针对undo page写溢出情况\r\n2，针对ckpt的各种情况，在执行中间触发ckpt	2020-05-15	\N	17	\N	3	\N	5	0	2020-05-14 06:52:44.403641	2020-05-14 06:52:44.403641	2020-05-14	0	\N	\N	623	1	2	f	\N
629	3	25	ud在gp下的测试困难	1，虽然有pageinspect，但是这个必须直连segment节点才能看到。regress框架不支持。\r\n需要支持去任意节点执行某个命令的能力\r\n2，支持在命令执行的某个步骤触发checkpoint等后端行为。\r\n\r\n行为模拟器的思路开发c程序真的可以很厉害。无误的C编程方法。	2020-05-22	\N	17	\N	3	\N	5	2	2020-05-18 12:40:30.732676	2020-05-23 18:59:40.46641	2020-05-18	100	\N	\N	629	1	2	f	\N
628	6	15	羽毛球练习5.17	手法：\r\n1，高远球挥拍时没有超前挥，挥拍方向有时在侧方。尤其是右后方的球。\r\n原因分析：1，正后方的球是手拍太早。因而发生切击。\r\n         2，右后方的球是因为挥拍方向的问题，右后方的球挥拍轨迹与正后方不一样，倒排不用那么靠后。另外手臂要打开。\r\n2，挥拍的后段发力不集中\r\n原因分析：1，引拍时放松不够，要充分放松，到了小臂手指发力阶段再用力。另外动作要正确，给小臂手腕手指留发力空间，\r\n想想甩的感觉。 \r\n         2，手指没握紧，最后击球时拳握有助于集中发力。\r\n\r\n步法：\r\n1，侧后方的球，第一步右脚跨出来，然后跳步击球。即中国步。\r\n要注意右脚跨步的大小。\r\n2，左侧后方的头顶球，第一步右边蹬转，左脚垫一步，然后右边到后方，起身击球。即马来步。\r\n	\N	\N	17	\N	3	\N	5	1	2020-05-17 19:00:09.603212	2020-05-20 06:16:51.923669	2020-05-17	0	\N	\N	628	1	2	f	\N
624	7	25	完成imcs的功能调试	1，增加扩展以验证基本功能，含space，session，atomic模块	\N	\N	19	\N	3	\N	5	5	2020-05-14 06:53:51.790971	2020-05-20 13:14:24.129023	2020-05-14	0	\N	\N	624	1	2	f	\N
630	7	25	将ci，ud, imcs的扩展改造为分布式的并应用于单元测试		\N	\N	19	\N	3	\N	5	1	2020-05-20 13:17:48.596642	2020-05-23 19:01:49.953374	2020-05-20	100	\N	\N	630	1	2	f	\N
631	6	15	羽毛球练习5.24	今天终于优点发力的感觉了，明显发力集中了。这感觉就是在大臂挥拍完成后，小臂手腕手指才逐步发力。\r\n前面不发力，后面才能集中发力。\r\n\r\n练习内容：\r\n1，头顶区不充分引拍的高远球\r\n要点：举起来就打，大臂小范围引拍，主要靠小臂手指爆发来打。\r\n不必收拍，挥完由大拇指来减速，拍子停止，没有收拍下身下的环节。\r\n其实非受迫高远球也可以这样打，但杀球不能这样打。杀球要收拍。\r\n\r\n2，反手的中前场抽球\r\n有两种握拍方式，一是需要外旋击球，但是旋必须快，否则容易出现切球。\r\n另外一个明显问题是挥拍没有向前，有点向下挥拍。\r\n我总结要点：\r\n1，肘要基本固定\r\n2，小臂要把拍子甩起来\r\n3，小臂甩到位之后，运用手腕手指瞬间发力。\r\n4，脚应该要迈出去。\r\n这样才不是反手推球，是反手抽球，抽出响声。\r\n\r\n其他收获：\r\n今天注意蹬地发力后，果然步法好了那么一点。	\N	\N	17	\N	3	\N	5	3	2020-05-24 15:13:00.464257	2020-05-25 05:27:01.240178	2020-05-24	0	\N	\N	631	1	2	f	\N
622	6	7	低效率案例集	1，临时方案\r\n临时方案的本质是没有直面一些问题，有一些没有摸清楚的地方，一些没有看到的部分，草率思考的结果。\r\n例如：\r\n1，beas的ac存储方案，在btree tuple的尾部增加事务信息。\r\n2，beas2.0的ci undo，一开始就回避建立事务的undo链表，导致了这个过渡方案\r\n\r\n2，考虑不周带来的bug\r\nci很多bug都是来源于此，认真的思考真的很难。\r\n函数的每个变量被正确使用了吗？ 这个流程与其他流程还有交织吗？\r\n这个if还有其他可能性吗？\r\n例如：天真的以为undo replay就是从undo tracker记录的位置开始，可是哪里有保证这个呢？	\N	\N	17	\N	3	\N	5	1	2020-05-14 06:48:49.521346	2020-05-28 14:08:46.301227	2020-05-14	0	\N	\N	622	1	2	f	\N
346	6	7	数理逻辑的起源	　逻辑（logic）一词源于希腊文logoc，有“思维”和“表达思考的言辞”之意。数理逻辑是用数学的方法来研究推理规律的科学，它采用符号的方法来描述和处理思维形式、思维过程和思维规律，进一步的说，数理逻辑就是研究推理中前提和结论之间的形式关系，这种形式关系是由作为前提和结论的命题的逻辑形式决定的，因此，数理逻辑又称为形式逻辑或符号逻辑。\r\n　　最早提出用数学方法来描述和处理逻辑问题的是德国数学家莱布尼茨（G.W.Leibnitz），但直到1847年英国数学家乔治·布尔（George Boole）发表“逻辑的数学分析”后才有所发展。1879年德国数学家弗雷格（G.Frege）在《表意符号》一书中建立了第一个比较严格的逻辑演算系统，英国逻辑学家怀特海（A.N.Witehead）和罗素（B.Russell）合著的《数学原理》一书，对当时数理逻辑的成果进行了总结，使得数理逻辑形成了专门的学科。 \r\n　　1938年，克劳德•艾尔伍德•香农（Claude Elwood Shannon）发表了著名论文《继电器和开关电路的符号分析》，首次用布尔代数对开关电路进行了相关的分析，并证明了可以通过继电器电路来实现布尔代数的逻辑运算，同时明确地给出了实现加，减，乘，除等运算的电子电路的设计方法。这篇论文成为开关电路理论的开端。其后，数理逻辑开始应用于所有开关线路的理论中，并在计算机科学等方面获得应用，成为计算机科学的基础理论之一。 	\N	\N	17	\N	3	\N	5	3	2019-04-24 06:45:39.033312	2020-08-26 06:52:08.931338	2019-04-24	0	\N	\N	346	1	2	f	\N
619	7	16	imcs第一次review意见	1，在原子操作结束时将脏页串联起来，然后把头部挂到checkpoint。\r\n脏页链的访问主要就是checkpoint和写，通过原子操作来保护。\r\n这样就可以仅使用一个锁了，而不是每个page都用锁。\r\n\r\n2，page上的lock和latch放在一起会引起cache miss\r\n\r\n3，trace stack可以优化，脏的页面不必加入到trace，因为其一定在trace stack中。\r\n另外原子操作不可能涉及非常多的页面，即便block重复加入也没关系。\r\n\r\n4，给block增加double write机制。\r\ndouble write还有一个好处是flush时，可以尽快的释放block上的锁\r\n\r\n5，每个block都使用统一的原子操作模式，好处时可以统一处理。\r\n代价是原子操作不宜过长，否则可能增加pool首页的冲突\r\n\r\n6，统一使用cursor，不管读写，cursor是一个池子，这里的cursor对应于一个scan。\r\nsession的第0号cursor总是用于写操作。\r\n\r\n7，在启动阶段不能扫描系统表，因而这里还是得使用配置文件。\r\n注意控制文件只有一个，控制文件很特殊，其中记录了checkpoint位置等信息。\r\npg只写了一份，如果读取时校验失败，则db无法启动。控制文件写多份时，只要其中任意一份是正常的就可以了。\r\n只是恢复的起点会不一样。\r\n\r\n8，使用内存屏障保护atomic flag\r\n\r\n9，将写日志之前的pool类型判断移到日志函数中\r\n\r\n10，spaceExtend调用放在分配空间外面，分配和释放空间完全是原子操作内的。\r\nspace分配共享内存，创建文件，初始化共享内存在原子操作外。\r\n\r\n11，ckp顺序刷block优化\r\n\r\n12，cursor中将page拷贝出来，利用undo恢复到某个快照版本，这个mirror page可考虑在不同cursor共享，否则每次都得构建。	\N	\N	19	\N	3	\N	5	2	2020-05-09 13:04:55.470018	2020-05-12 09:53:09.363692	2020-05-09	0	\N	\N	619	1	2	f	\N
620	6	15	打球心得5.12	高远球的高在于无法拦截，过人头顶，要观察对方的站位。\r\n网前球的前在于低和贴网，这样就不容易被人封，也得看别人站位。\r\n当前这都有前提就是出球速度与移动速度。\r\n\r\n身法手法决定了出球速度，步法决定了移动速度。核心还在于稳定性。\r\n发力感悟：\r\n1，鞭打一定要侧身，挥拍过程的前期一定要放松小臂手腕手指，后期握紧。\r\n速度来自于挥动过程，鞭打追求的不是力，羽毛球首先追求的都不是力，而是速度和位置。\r\n对观念中融入一点：羽毛球要的是速度和碰撞，鞭打概括了这2个特点。\r\n\r\n2，反手更是如此，你要速度，则必然要引拍，引拍就得收肩。\r\n\r\n单纯使用臂力不是打不了，但是容易累，而且容易受伤。\r\n\r\n前场球只需手腕手指的力，讲究轻柔。	\N	\N	17	\N	3	\N	5	0	2020-05-13 05:07:49.143009	2020-05-13 05:07:49.143009	2020-05-13	0	\N	\N	620	1	2	f	\N
625	7	25	摸清楚pg的checkpoint实现	到底记录的点在哪里，分哪几步	\N	\N	19	\N	3	\N	5	0	2020-05-15 06:22:04.341842	2020-05-15 06:22:04.341842	2020-05-15	0	\N	\N	625	1	2	f	\N
626	3	25	摸清楚pg_rewind的实现	怎么保证一致性。	\N	\N	17	\N	3	\N	5	0	2020-05-15 06:22:27.040551	2020-05-15 06:22:27.040551	2020-05-15	0	\N	\N	626	1	2	f	\N
627	6	26	C语言细节	1，数据类型的本质是内存长度与运算的支持，枚举类型其数据无类型，长度与编译器实现有关，但不过超过int，实际上大多数编译器下其长度为4.\r\n2，相乘溢出问题，两个u32类型相乘，如果不指明数据类型，即将赋值给u64，在c中会得到一个截断值。\r\n所以正确写法是 c = (uint64) u1*u2; 或  c = u1 * （uint64)u2;等\r\n	\N	\N	17	\N	3	\N	5	0	2020-05-17 07:51:51.607221	2020-05-17 07:51:51.607221	2020-05-17	0	\N	\N	627	1	2	f	\N
621	6	15	羽毛球入门-鞭打(发力终极篇)	羽毛球的中后场发力都是鞭打，鞭打就是逐节发力过程，起源于脚，末于手指。每节给上一节提供初始速度，但下一节想利用这个速度必须放松。\r\n如果从中间节启动也不是不可以，只是会消耗那一节更多的力量，同时也会失去上半身的部分稳定性。\r\n因为上一节重量大，加速应该使用大块肌肉。\r\n\r\n凡是纯粹掌握了鞭打发力的都可以算到中羽5级水平，也就是业余中高手了。\r\n要成为绝对业余高手还要有移动速度。这样就来到了6级。6级对球路也有一些要求。\r\n7级对球路，战术有更高的要求。是准专业级的入门水平。	\N	\N	17	\N	3	\N	5	1	2020-05-14 06:12:37.028575	2020-05-29 05:18:48.398714	2020-05-14	0	\N	\N	621	1	2	f	\N
636	7	16	为什么说共享内存要使用大页？	小页面增加了哪里的开销?\r\ncpu的不同层次cache对性能提升效果，MESI？\r\n执行框架与程序模型的关系，为什么非要多线程。\r\n虚拟页面咋回事？进程在内存管理上做了什么？都是系统完成的吗？\r\ndocker的本质？	\N	\N	19	\N	3	\N	5	2	2020-06-03 11:39:59.31805	2020-06-03 18:11:27.883079	2020-06-03	0	\N	\N	636	1	2	f	\N
637	6	15	羽毛球训练6-7	今天主要练习了两边的推压抽球。\r\n重点：\r\n1，动作要小，能手腕手指就不必甩小臂了。此处球速快且动作大容易出界。\r\n集中发力的短促既能让球有一定速度，同时不容易出界。\r\n2，反手握拍可以更松点，更侧向握拍，挥拍过程不必转动手腕。\r\n\r\n反手挥拍可以多练下，正手基本问题不大。\r\n\r\n末尾练了下步法：\r\n教练提出我的问题是1，前场踩得太死。 2，蹬转慢。\r\n我想这里主要原因可能还是小腿力量和核心力量弱了导致的。\r\n	\N	\N	17	\N	3	\N	5	0	2020-06-07 14:46:21.015227	2020-06-07 14:46:21.015227	2020-06-07	0	\N	\N	637	1	2	f	\N
639	6	15	打球心得6.9	新的发现:\r\n1,提前举拍，打球会轻松很多，尤其是高远球，杀球。\r\n提前举拍，有了做动作，尤其是放松动作的时间，可以更好的集中发力。\r\n\r\n2，蹬转前先下蹲，给脚掌一个弹性势能。这样蹬转会更快，更轻。	\N	\N	17	\N	3	\N	5	0	2020-06-09 20:59:46.101179	2020-06-09 20:59:46.101179	2020-06-09	0	\N	\N	639	1	2	f	\N
1010	6	7	软件开发问题集	1，作为接口的数据结构其复杂度应该维持再多少？是暴露接口还是暴露结构？\r\n2，如何提前判断核心结构有无变化的可能性，从而导致接口无法适应？\r\n   比如undo接口，原来用法是prepare一次，把页面内的undo和xslot一起写入。\r\n   但是列存下，多个cbu都单独写undo，不能每次写一条undo就更新xslot。\r\n  原方案做成感知undo内部格式的，造成了强耦合，且逻辑上存在风险，判断undo页面复用有问题(需要在链上记录上一条undo 页面的version，然而方案中undo链没了)\r\n   这种情况实际上只能考虑在上层封装了，上层不应该直接遍历undo页面。这种最强耦合模式导致代码腐烂。\r\n   每个模块都有自己的接口，除了接口之外，使用者不应该有其他依赖。   \r\n\r\n   比如Dc假设对象不会频繁truncate导致膨胀？当这种变化出现的时候，新需求原模块并没考虑到。如果仅仅为了功能糊上去就会有各种问题。软件随之腐烂。\r\n    	\N	\N	17	\N	3	\N	5	1	2022-02-11 06:34:11.370745	2022-02-11 07:12:43.492627	2022-02-11	0	\N	\N	1010	1	2	f	\N
634	6	9	修行笔记-6.1 (成为强者)	做任何一件事，都必须要有强烈的欲望驱使，同时不断付诸行动。\r\n生活的编织者，练习过往不念，未来不追，着手当下，不断行动的能力。\r\n觉察自己，觉察自己的思考，动作是否符合标准。\r\n就像打羽毛球一样，去掉那些不必要的东西，让自己变得更强大，最终才能千变万化，随心所欲。\r\n\r\n你得知道规则，规律的精髓，并且时刻遵守它，才能做到随心所欲的自由，随心所欲而不逾矩的境界，发而皆中节。\r\n\r\n这世界上90%的弱者是因为没有目标，自然也没有行动。没有想成为一个强者。\r\n还有9%的人天赋不够，在挑战中遇到挫折，自我设限，即停留在自己的舒适区。这些人中有一些已经是高手了。\r\n只有1%的人有良好的天赋，并且持之以恒，不断的挑战自己，最终达到高手的境界。	\N	\N	17	\N	3	\N	5	1	2020-06-01 05:46:47.139053	2020-06-01 05:47:37.002011	2020-06-01	0	\N	\N	634	1	2	f	\N
644	6	6	编程中的陷阱	1，思考遗漏\r\n设计遗漏，实现遗漏，测试遗漏\r\n\r\n2，错误\r\n放在了错误的地方\r\n把孩子和洗澡水都倒掉了\r\n\r\n3，创意\r\n避免了上述2个陷阱之后，还有一个就是缺乏创意，即方案无竞争力，不够巧妙。\r\n\r\n思考的全面性，清晰性，创新性。	\N	\N	17	\N	3	\N	5	1	2020-06-16 06:34:07.434868	2020-06-16 06:35:05.7325	2020-06-16	0	\N	\N	644	1	2	f	\N
635	6	9	认清现实	现在很多人看各种资讯，学习了各种知识，以为自己很了不起。\r\n但是在现实世界中，连开一个公司都做不到。\r\n公司是麻雀虽小，五脏俱全。这里涉及外交，消息，技术，交流，财务等各个方面。\r\n\r\n现实世界是很多人都不够强，也没有足够的行动。却有者不与自己能力不匹配的欲望。\r\n\r\n还有一些人被现实击打之后，进行自我约束。	\N	\N	17	\N	3	\N	5	2	2020-06-02 04:32:18.037589	2020-06-02 04:49:31.647011	2020-06-02	0	\N	\N	635	1	2	f	\N
682	6	7	如何学习科学知识	可以沿着前人走过的路，来研究一个领域内存在的问题，以及前人选择的道路与解决方案。\r\n知识树是一个扩展的过程，当然可能有新的分叉出现，但是在不理解历	\N	\N	17	\N	3	\N	5	0	2020-08-26 06:54:50.913511	2020-08-26 06:54:50.913511	2020-08-26	0	\N	\N	682	1	2	f	\N
638	6	15	改善打球习惯	1，启动时就引拍，手与脚同步动。\r\n2，前中场引拍动作小而快。不然就只会挑球。\r\n3，越前面就越高动作越小。\r\n这有一个前提就是相信自己的手腕手指发力。\r\n\r\n步法上意识：\r\n1，启动快\r\n2，借力回动那一步要快	\N	\N	17	\N	3	\N	5	2	2020-06-09 04:02:01.14141	2020-06-09 04:34:41.095373	2020-06-09	0	\N	\N	638	1	2	f	\N
647	6	15	羽毛球的原则	1，球速取决于击球是拍子的速度与击球面\r\n2，羽毛球的挥拍动作是越小的部位越快越稳定，但是需要的爆发力也越强。\r\n3，越前场的球越需要小动作，前场的扑球，平抽，以及打给对方的吊球，都讲究小动作。\r\n4，如果球速快，则对方可以借力从而快速回球。好的击球是初速度快，然后速度降速。\r\n5，如果失去重心，则难以完成动作。\r\n6，调动对方，让对方产生某种行为，进入我们的节奏，就是控制。\r\n   对手的可控性，有趣。	\N	\N	17	\N	3	\N	5	3	2020-06-21 19:59:44.248067	2020-09-23 21:03:05.582616	2020-06-21	0	\N	\N	647	1	2	f	\N
655	7	25	coral讨论点	1，存储节点有状态与snowflake一样的存储节点无状态。\r\n这决定了存储节点的弹性扩展能力\r\n存储节点如果仅把数据存到s3，那就相当于一个外部存储。	\N	\N	19	\N	3	\N	5	10	2020-07-07 15:53:30.793864	2020-10-26 06:27:47.775969	2020-07-07	0	\N	\N	655	1	2	f	\N
650	6	6	论觉察	觉察是一个概念，你听到了吗？ 你看到了吗？\r\n信息默认情况很容易被过滤掉，这样大脑可以以非常低能耗的方式工作。\r\n\r\n你是不是错多了很多美好，那些痛彻心扉的回忆。\r\n明察是智力起端。	\N	\N	17	\N	3	\N	5	0	2020-06-27 16:39:19.15835	2020-06-27 16:39:19.15835	2020-06-27	0	\N	\N	650	1	2	f	\N
579	6	17	如何在postgres中添加一个后台进程	如何在postgres中添加一个后台进程。\r\n\r\nAuxiliaryProcess进程的生命周期。\r\n1，启动\r\n通过postgresMaster在serverloop中启动。\r\npostgresmaster随后不停监听进程状态。\r\n\r\n2，停止\r\nSIGCHLD，在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程，按系统默认将忽略此信号，\r\n如果父进程希望被告知其子系统的这种状态，则应捕捉此信号。\r\n\r\nreaper函数处理该信号，调用waitpid，得到退出的进程id，然后将该进程设置为0.\r\n这样postmaster在serverloop中检查到，就重新启动该类型进程。\r\n\r\n3，crash处理\r\ncrash之后共享内存可能处于不一致的状态，这时需要重新加载。\r\nHandleChildCrash函数处理这种情况，会给所有进程发送退出信号。\r\n然后修改pmState。\r\n\r\n添加一个后台进程步骤：\r\n1，增加一个pid\r\n2，增加启动和退出处理\r\n3，增加处理函数	\N	\N	17	\N	3	\N	5	5	2020-03-04 09:32:35.959631	2020-06-30 07:37:52.280222	2020-03-04	0	\N	\N	579	1	2	f	\N
656	7	25	讨论纪要2020-7-8	1，明确了模块划分\r\n   server\r\nsql  对象管理(含cache)\r\n   存储引擎\r\n   基础框架(内存管理，线程池等)\r\n变化点：将对象管理从存储引擎层独立开，可切换存储引擎。\r\n\r\n2，升级\r\n只有4个核心系统表采用硬编码。其他系统表采用类似普通表存储。\r\n升级时，通过升级sql脚本升级非核心系统表，从而保证升级过程中主端系统表上的dml操作的redo能在从端正常replay。\r\n然后升级备。\r\n\r\n物理格式：\r\n通过预留的方式支持升级\r\n	\N	\N	19	\N	3	\N	5	0	2020-07-08 09:22:27.920587	2020-07-08 09:22:27.920587	2020-07-08	0	\N	\N	656	1	2	f	\N
640	6	15	羽毛球训练6-14	打球技巧：\r\n1，双打身体是前倾的，尽量寻找高点击球。确实都是迎上去打。\r\n2，中前场击球都是不必甩大臂的，这样才能有稳定性，而且身体总是尽量面向对方场地的，即脚尽量平行站。\r\n\r\n技术动作：\r\n1，反手击球的手腕是先放松甩出去，手指动作是拧瓶盖动作，其实多练习一样可以做到很快。\r\n2，正手抽球注意要送点手腕，不是纯粹的旋转，否则很容易下网，毕竟不是点杀。\r\n3，网前的扑球可以用苍蝇拍，苍蝇拍顾名思义就是快，打苍蝇的。\r\n凡是采用正手握拍击球，都要注意拍面的转正。\r\n\r\n步法与重心：\r\n1，打球其实更应该关心别人的重心位置，而不是物理位置。\r\n2，不要使用腰腹力量来击球，业余的腰腹力量维持身体平衡就已经不错了。\r\n看专业选手身体主体都是非常平稳的，杀球等会使用腰腹力量，但作为业余的我觉得可以放弃这个，\r\n毕竟双打直接杀死的情况非常少，还是以打点连贯为主。这也是现在男双的风格。\r\n\r\n体能：\r\n1，教练提到脚踝力量很弱，步法很重\r\n2，我自己感觉核心力量也很弱\r\n	\N	\N	17	\N	3	\N	5	0	2020-06-14 16:25:03.67471	2020-06-14 16:25:03.67471	2020-06-14	0	\N	\N	640	1	2	f	\N
648	6	6	思辨与立场(批判性思维)	如果把人脑想象成电脑，那么内存计算就是快速部分，磁盘计算是慢速部分。\r\n快速部分虽然快，但是思考不深入，如果未经长期训练很容易陷入各种陷阱。\r\n\r\n而我们要做的就是觉察思考过程，不断优化操作系统，让系统更加透明的进行慢速或快速的思考。\r\n并且不断的对知识概念动作进行整理，结构化，标准化。使得动作可以复制，知识概念能被思考调用。\r\n\r\n然后不断重复练习，抽象，使得我们理解更加深入，更加准确。\r\n\r\n这样我们就能成为心灵的高手，成为自己心灵的真正主人，更邪恶一点还能操控别人，成为别人心灵的主人。\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	4	2020-06-21 20:44:03.729666	2020-07-20 05:20:09.369875	2020-06-21	0	\N	\N	648	1	2	f	\N
643	6	9	生长是世间最强大的力量，爱是世间最惊艳的美丽		\N	\N	17	\N	3	\N	5	2	2020-06-16 06:28:59.797736	2020-07-31 05:05:43.71837	2020-06-16	0	\N	\N	643	1	2	f	\N
855	6	29	swf支持常量条件下推	目前不论对于行还是列都是生成完整数据后，再进行过滤。\r\n如果过滤效果好，这种执行方式对于列存不是很友好。额外多读取了很多无效数据。\r\n考虑将swf内部执行分为2个阶段：\r\n1，过滤阶段\r\n     read filter columns， generate valid bits vector。\r\n2，fetch阶段 \r\n     fetch other columns, but need revert again.\r\n对于变长列，如果在filter中，则一次性完成了所有变长列读取。\r\n如果不在filter中，则没用额外代价。	\N	\N	17	\N	3	\N	5	0	2021-04-19 14:03:41.53122	2021-04-19 14:03:41.53122	2021-04-19	0	\N	\N	855	1	2	f	\N
642	3	25	ci-undo问题		\N	\N	17	\N	3	\N	5	2	2020-06-15 17:11:17.774244	2020-06-15 20:00:52.15235	2020-06-15	0	\N	\N	642	1	2	f	\N
685	6	8	未来简史之人真有灵魂吗？自由意志吗？	科学打破了灵魂与神的联系。\r\n而仅科学又说人可能连自由意志都没有，如果这样，则人文主义只是一个表象。\r\n人除了皮囊之外，还有一些被情感，理性一并操控的算法。除此之外，没有其他。	\N	\N	17	\N	3	\N	5	0	2020-08-30 06:24:35.669878	2020-08-30 06:24:35.669878	2020-08-30	0	\N	\N	685	1	2	f	\N
641	3	25	undo遗留问题	1，udtracker在slave的维护\r\n2，undo rollback与修改的并发，此处应该有事务锁。tuple rollback不一定都符合要求。	\N	\N	17	\N	3	\N	5	1	2020-06-15 05:39:09.534809	2020-06-17 17:47:38.478835	2020-06-15	0	\N	\N	641	1	2	f	\N
645	6	6	思考能力根本-思考的要素	https://www.zhihu.com/question/54197987\r\n\r\n知识就是关联关系，结构化思考，知识本身就是结构，如果缺少知识，思考就会在未知连接点停滞。	\N	\N	17	\N	3	\N	5	2	2020-06-17 06:41:54.81433	2020-06-19 12:25:47.96364	2020-06-17	0	\N	\N	645	1	2	f	\N
856	6	27	怎么写文档？		\N	\N	17	\N	3	\N	5	0	2021-04-20 07:11:39.9579	2021-04-20 07:11:39.9579	2021-04-20	0	\N	\N	856	1	2	f	\N
684	6	7	rust high perf		\N	\N	17	\N	3	\N	5	0	2020-08-28 20:37:37.744426	2020-08-28 20:37:37.744426	2020-08-28	0	\N	\N	684	1	2	f	\N
997	6	7	逻辑学与编程语言	逻辑学是人认知事务的根本。\r\n一切的知识的源头。\r\n\r\n堆和栈的根本区别在于栈中数据是定长的，而堆是变长的。\r\n即根本问题在于数据长度的可变性。\r\n\r\n数理逻辑 是编程语言的基础。\r\n只是很多人没经过过，不知道怎么过渡而来的。\r\n为什么有函数，有谓词，量词。\r\n为什么只要三种控制语法就可以表示任意逻辑？\r\n变量是谁发明的？\r\n谓词是一个返回bool值的函数或者仿函数。\r\n结构体是谁发明的？\r\n弗雷格给出对数学归纳法的纯逻辑分析，同时也是谓词\r\n一阶谓词逻辑：称为一阶谓词逻辑的原因：量词只能作用在个体上，如果量词可以作用在谓词上，那就是二阶逻辑谓词。	\N	\N	17	\N	3	\N	5	0	2021-12-22 19:33:50.415217	2021-12-22 19:33:50.415217	2021-12-22	0	\N	\N	997	1	2	f	\N
686	6	6	论程序与意义	意义是人追求的一种状态，在这种状态下人会觉得幸福。\r\n所以每个人的意义并不一样。这就是生物多样性。\r\n\r\n同一性对于生物通常是灾难。\r\n\r\n人生就如程序，区别在于人赋予了自己运行程序的意义，而软件程序的意义是人赋予的。\r\n这样其本质上是人的延申与增强。\r\n\r\n人执行各种操作，各种言行都是程序，其自由意志赋予程序意义。\r\n所以没有找到意义的人本质上就跟计算机一样，是他人驱动的人生。	\N	\N	17	\N	3	\N	5	1	2020-08-31 05:50:02.568008	2020-08-31 05:53:59.540363	2020-08-31	0	\N	\N	686	1	2	f	\N
688	6	7	面向对象编程的本质	面向对象与过程的核心区别在于组织软件的方式不一样。\r\n面向过程的软件是通过流程分解，得到子流程即各种函数。然后把相关的函数放在一起作为模块。\r\n\r\n面向对象编程是抽象概念，该概念对象能提供的行为是由概念本身决定的。\r\n然后通过对象的行为来组合实现外部行为。	\N	\N	17	\N	3	\N	5	0	2020-09-02 16:35:58.793517	2020-09-02 16:35:58.793517	2020-09-02	0	\N	\N	688	1	2	f	\N
683	6	8	论自由	1，心灵自由\r\n不被压制，也不被心魔控制，自然，生动活泼\r\n2，精神自由\r\n相信有一个理性的外在世界，意识追随理性，科学。\r\n人的非理性也是理性的部分，据此处理自我与世界，他人的关系。即独立联系。\r\n不从精神上依恋个人或组织，君王，鬼神，也不以自我为中心。\r\n这一点也是西方科学起源的根因。即存在一个外在的中心，即理性世界。\r\n3，物质，身体自由\r\n4，交易自由\r\n交易是在公开互利原则下进行。自愿交易被允许。\r\n受迫交易是非自由交易状态。\r\n5，行动自由\r\n知行合一，能按照自由的精神来行事。\r\n即要有一致性，不矛盾。有矛盾就解决矛盾，\r\n这样对于个人才是一个不断延展的世界。	\N	\N	17	\N	3	\N	5	4	2020-08-27 07:27:33.890508	2020-09-08 10:24:22.175181	2020-08-27	0	\N	\N	683	1	2	f	\N
689	6	7	nginx上搭建ASP网站	https://blog.csdn.net/qq136501564/article/details/76889693	\N	\N	17	\N	3	\N	5	0	2020-09-09 06:09:54.586737	2020-09-09 06:09:54.586737	2020-09-09	0	\N	\N	689	1	2	f	\N
654	7	25	IMCS讨论点	系统目标：\r\n热数据与温数据的快速分析。\r\n\r\n关键点：\r\n1，定长与变长分离存储\r\n这样可以确保定长总是inplace更新，即每列的rowid在更新时维持不变性。\r\n这点对于分离出的heap维护到定长部分的rowid也很关键。\r\n\r\n解决行式更新与列式查询的矛盾。\r\n\r\n2，in memory\r\n引入in memory的目的是为了提高更新效率。\r\n改变了buffer管理方式，这点影响了整个后端，包括刷脏，checkpoint机制。\r\n大块内存，device/segment方式管理内存，而不是hash查找。\r\n\r\n3，一致性问题\r\ncolumn隔离级别\r\n\r\n4，索引\r\n跨变长与定长部分的索引\r\n\r\n5，接口层\r\n抽象am层，这样方便提供不同的表访问方式\r\n抽象md层，对接不同存储\r\n\r\nimcs单独刷脏页机制，等checkpoint刷可能太久。\r\n\r\n其实核心主要3点：\r\n1，行锁与列锁的选择\r\n2，列式存储\r\n3，批量操作	\N	\N	19	\N	3	\N	5	27	2020-07-07 15:01:31.517395	2020-11-21 05:54:47.135861	2020-07-07	0	\N	\N	654	1	2	f	\N
651	6	6	论竞争	竞争对于很多人意味着恐惧，一个刻骨铭心的对于生存与失败的恐惧，紧张。\r\n竞争对于另外一些人意味着兴奋，嗜血。\r\n\r\n理想主义者希望这世界没竞争，人人和谐的理想国。\r\n现实主义者认为这世界就是优胜劣汰，物竞天择，适者生存。\r\n\r\n这两种方式都不合适，一方面每个人在社会上都需要变得更强大。\r\n否则人性的弱点只会让人变得堕落。\r\n另一方面也不能过去紧张，这样也无法很好的生活，也无法变得很强。\r\n\r\n所以竞争的意义在于保持集体的活力，而过度的竞争则压制了人性。\r\n对于个人过高的要求必然抑制人性，使人变得紧张。\r\n而无要求则人变成废材，退化。\r\n例子:暴秦\r\n	\N	\N	17	\N	3	\N	5	1	2020-06-27 18:12:44.368799	2020-06-27 18:14:38.008856	2020-06-27	0	\N	\N	651	1	2	f	\N
817	6	7	AnchorBase底座设计优点与缺陷	1，在xslot上的设计缺陷，anchorBase没有很好的封装xslot，导致其相关逻辑每个struct都得实现一遍。\r\n\r\n谢锐 2-26 08:49:38\r\nZHEAP：重造PostgreSQL的存储引擎\r\n谢锐 2-26 08:51:38\r\n我之前也考虑把anchorbase中元祖事务信息抽离成独立页面 看上述介绍zheap是这样实现的\r\n谢锐 2-26 08:52:46\r\n把抽出的事物信息页面作为具有行概念结构的通用机制。\r\n\r\n而且这是存储底座最复杂的部分。\r\n\r\n2，undo模块的设计也存在瑕疵：\r\n谢锐 3-19 14:56:12\r\nundo这地方目前还有点别扭，目前涉及加锁的undo格式是 UndoRow + Xslot(option) + Ura + Head + Data。与其他改页面的格式不一样。 Xslot这部分的添加放入了undo底层。Ura在各个模块自己的undo里面。 但是Xslot的undo逻辑不在undo底层，而且xslot与页面关联，能否执行跟DataObjectOid也有关系。。 我觉得顺一点是 UndoRow + | BlockHead + Xslot(option) + Ura(option) | + Data，如果不考虑极致空间效率(实际也浪费不了多少，大部分undo都涉及页面) 可以把中间部分也纳入undo底座。增加的undo主要是关心data部分\r\n谢锐 3-19 14:57:45\r\nxslot，ura跟undo确实有些关系，但是这2者又都属于页面内容\r\n谢锐 3-19 15:02:46\r\n其实考虑空间使用也没问题，在UndoRow中加个flag，把BlockHead也变成option\r\n谢锐 3-19 15:03:37\r\n现在我写undoLock函数，没法按记录的顺序来弄，得先找到Head判断能否执行，然后执行undo xslot，ura。\r\n现在相当于每个模块自己实现相关逻辑了。\r\n\r\n如果页面提供了获取xslot位置的能力，则undoXslot就可以落入底座，或者说xslot独立页面直接放入undo模块之中。\r\n这样结构层完全不感知。\r\n页面提供2个接口：1，遍历xslot。 2，获取xslot地址\r\n\r\n3，原子操作的封装是经典\r\n4，PCR机制很经典\r\n5，segment，undo经典\r\n6，底层对字段无感，与元数据解耦很经典。	\N	\N	17	\N	3	\N	5	1	2021-03-19 12:50:59.638592	2021-03-19 12:59:25.750659	2021-03-19	0	\N	\N	817	1	2	f	\N
652	6	6	论道德与交易	秉持公开交易原则，不抢不骗，也不送。\r\n因此支持未成年人保护，反对暴力。	\N	\N	17	\N	3	\N	5	0	2020-06-27 18:17:17.678872	2020-06-27 18:17:17.678872	2020-06-27	0	\N	\N	652	1	2	f	\N
1011	6	23	IDE该是怎样	IDE的核心功能：\r\n1，方便快速的在最近工作中来回切。\r\n  最近的文件应该以栈方式出现，方便找到。\r\n  应该能很方便的显示当前文件所在的目录，以及跳转到目录\r\n2，应该很方便的展示调用关系，查找使用的地方\r\n  Clion贴心的是把读写也分开了。\r\n  VS有个收费工具FastFind还不错\r\n3，要方便编辑，补全，提示，拼写检查，格式化等\r\n4，要能方便调试\r\n  Clion支持运行单个用例，VS也有，但是经常识别不了。  	\N	\N	17	\N	3	\N	5	3	2022-02-17 13:11:22.56843	2022-03-02 20:05:50.231184	2022-02-17	0	\N	\N	1011	1	2	f	\N
742	6	8	再谈不着相-我们的目标应该在哪	工作有时候不知道干嘛，但是打羽毛球总知道自己要干嘛，为什么呢？\r\n打球目标放在提升自我的球技上，让自己更深入的理解羽毛球，完善每一个动作。\r\n所以每个动作点都是训练目标，自然有不少事情干。\r\n而工作是在找任务，任务干完了似乎就没了。但实际想下工作的最根本并非任务，其实是在锤炼自己的技能。\r\n任务只是一个短期成果而已，能力才是冉冉不断的动能。\r\n设计巧妙而合理的结构，精密高效的动作序列，编写思路清晰的文档，展开深入的讨论各种技能都是需要不断锻炼的。\r\n这样看自己时间就非常稀缺了，劝君惜取少年时	\N	\N	17	\N	3	\N	5	5	2021-01-08 07:14:39.992466	2021-02-18 06:52:23.469194	2021-01-08	0	\N	\N	742	1	2	f	\N
653	6	8	商君书-以恶治国	https://www.bilibili.com/video/BV1ps411d7xJ?from=search&seid=13311887597223836984	\N	\N	17	\N	3	\N	5	1	2020-07-06 21:50:57.768258	2020-07-09 06:56:49.78218	2020-07-06	0	\N	\N	653	1	2	f	\N
859	6	27	能动实体，以及门提供open方法为什么是合适的	门提供open方法是合适的，这并非说门有open的动作。\r\nopen是一个抽象接口，其实它表达的意思是调用之后门会处于开着的状态。\r\n而开着或关着是门的核心特征。\r\n\r\n而具体怎么动作则存在很多变化，比如有的门是推的，有的门是拉的，还有的门是自动的。\r\n即open是具体动作的封装。\r\n\r\n另外这并非说门有主动行为，门如果不是自动门，其行为当然是被动的。\r\n是人这个能动实体，调用(操作)了门的open方法。\r\n\r\n同样关门也是如此，关门通常都是半自动行为，门在打开后的一旦时间借用推开的动力回弹。\r\n\r\n也就是说他们通常将实体的状态改变封装为实体的方法，然后让具备能动的实体调用，从而\r\n改变被动实体的状态。\r\n\r\n当然，接口本身就是行为抽象，接口具体那设计上就有问题了。	\N	\N	17	\N	3	\N	5	0	2021-04-25 08:15:32.686061	2021-04-25 08:15:32.686061	2021-04-25	0	\N	\N	859	1	2	f	\N
1012	6	18	公司是一个平台，国家亦如此	搭建一个让大家更好，更容易做某件事的平台。\r\n而做某件事则是公司的目的，也是战略。\r\n\r\n如果一个人能带领5个人，发挥10个人的效率，那就是很不错的领导/管理者了。\r\n这当然非常有意义。	\N	\N	17	\N	3	\N	5	1	2022-02-18 07:24:26.646571	2022-02-18 07:35:15.493317	2022-02-18	0	\N	\N	1012	1	2	f	\N
857	6	27	大牛	Joe Erlang\r\nRich Hickey Clojure	\N	\N	17	\N	3	\N	5	0	2021-04-20 07:15:51.686488	2021-04-20 07:15:51.686488	2021-04-20	0	\N	\N	857	1	2	f	\N
818	6	15	羽毛球步伐	1，并发用于短距离和快速\r\n2，交叉步用于长距离和慢速\r\n3，如果出球快则用并步回位，否则用交叉步。\r\n   交叉步的好处是可以随时启动，而并发则需静止启动。\r\n4，没有启动则没法移动，击球后就进入待启动状态。\r\n5，脚尖发力，脚跟承重。\r\n6，如对方无进攻机会则使用前后站，防守步左右站。用蹲腿降低重心，不要弓腰。\r\n\r\n李宇轩2视频:\r\nhttps://www.bilibili.com/video/BV1Ev411i7ZS?zw\r\nhttps://www.bilibili.com/video/BV1Ut4y1U7x9/?spm_id_from=autoNext	\N	\N	17	\N	3	\N	5	6	2021-03-20 15:49:42.162956	2022-03-10 06:52:31.340628	2021-03-20	0	\N	\N	818	1	2	f	\N
151	8	5	为何中华没走向科学繁荣之路	在封建时代社会的一切都是为了皇室和官僚体系服务。\r\n学校不会教授科学技术。决策和权力决定了社会的发展方向。\r\n\r\n试想如果当今学校不教授科学，那会是什么状态？ 一样的结果，科学无法进步。几代下来社会就会倒退。\r\n\r\n在技术保护上，现代和以前的只传嫡系并无大的区别。为什么开源那么可贵，且不可能始于中国？\r\n开源只会起源于生存压力小的地方。这是必然的。\r\n	\N	\N	17	\N	3	\N	5	1	2018-11-11 14:51:09.70136	2021-12-22 19:46:08.778237	\N	0	\N	\N	151	1	2	f	\N
952	6	18	一个助手	我想写一个程序，它是我的助手，可以帮我去收集资料，整理资料，以及寻找答案。\r\n这样还可以利用闲置的机器和带宽。	\N	\N	17	\N	3	\N	5	1	2021-09-24 07:21:12.467912	2021-09-24 07:22:14.23771	2021-09-24	0	\N	\N	952	1	2	f	\N
691	6	6	论成败，论改变	有一天我去打羽毛球，刚开始输了一局，虽然我内心平静，但是可能仍然有想赢的心。\r\n于是我打的非常积极，尽力。然后我赢了。但是后来才知道扭伤了大腿。\r\n\r\n我想说明什么呢？成败只是暂时在某个维度比对方好一点，其得到的奖品是什么？ 要考虑下争取胜利付出的代价。\r\n即通盘考虑。 为了战争的胜利，损失一个胳膊值得。为了打赢别人，损失一个胳膊不值得。\r\n\r\n所以算法要考虑下成本，代价。不要为虚无的东西付出太多。\r\n自然而然的成，当然是最好的。\r\n\r\n\r\n在这点上世界是残酷的，天地不仁，胜利者采用各种手段去成功，即便这成功鲜血淋漓，阴险无比。\r\n这就看人怎么定位自己，怎么选择了。\r\n\r\n\r\n改变：持续练习，人终将改变。\r\n大脑以某种方式思考问题，可以练习。比如我以自己对于程序本质的理解去编程，以动作与结构关系考虑程序，明显思路就活跃起来了。\r\n打羽毛球也很明显，多练习就能更轻易的做好，还能解锁新的能力。\r\n\r\n	\N	\N	17	\N	3	\N	5	1	2020-09-11 05:59:43.508248	2020-09-11 06:12:07.773056	2020-09-11	0	\N	\N	691	1	2	f	\N
692	3	24	AnchorBase的架构思考	1，anchorBase架构上很关键的一点就是存储引擎底座。\r\n在此基础上应该很容易实现各种struct。\r\n实际上目前并非此状态， 每种struct都得感知事务，undo接口。\r\n\r\n理论上能否做到上层只需定义数据结构，以及在此结构上的修改，以及对应的undo操作。\r\n读的可见性问题也由存储引擎底座来解决。	\N	\N	17	\N	3	\N	5	0	2020-09-11 07:40:34.216081	2020-09-11 07:40:34.216081	2020-09-11	0	\N	\N	692	1	2	f	\N
1014	6	7	SSDR19：纵向的遗漏(在对象创建时交代背景)	如果说模块划分是横向的，那么模块还有一个纵向的维度。\r\n而且这个维度经常被遗漏。\r\n\r\n每个动作都有一定背景，比如Scan，其背景可能有什么表，操作类型下进行的扫描，\r\n动作的环境应该在参数中传递。\r\n背景有点像cfg，跟option有点类似但不完全一样。option是参数，是动作需要的输入。\r\n\r\n背景是一种特殊的输入，其可能影响行为。\r\n\r\n输出 函数(self, 背景, 参数)\r\n通常背景可能包含于self之中，即在对象创立之时交代背景。\r\n	\N	\N	17	\N	3	\N	5	0	2022-02-20 08:18:49.245994	2022-02-20 08:18:49.245994	2022-02-20	0	\N	\N	1014	1	2	f	\N
693	6	9	开卷有益	为什么说开卷有益？ 因为书中的观点，概念，故事能引发人思考。\r\n如果你不借助外部信息就能进行新的思考，那也有效果。	\N	\N	17	\N	3	\N	5	0	2020-09-13 05:56:07.649965	2020-09-13 05:56:07.649965	2020-09-13	0	\N	\N	693	1	2	f	\N
695	6	7	软件从业者困境(论996)	1，知识就是权力\r\n2，领导者不希望员工掌握非常多的知识\r\n3，公司要求员工产出\r\n\r\n其中2和3是一个矛盾。\r\n不懂政治，无法斗争。\r\n\r\n最终模式就是华为这样的，所以国内流行996.	\N	\N	17	\N	3	\N	5	2	2020-09-15 06:09:25.780568	2020-09-15 06:10:19.984105	2020-09-15	0	\N	\N	695	1	2	f	\N
998	7	16	2022年工件	问题处理：\r\n1，处理obs loader cpu占用高问题 (12.22)\r\n2，处理max rowsize问题(进行中)\r\n\r\n性能优化：\r\n1，yasdb与ck性能对比分析，确定优化点(12.24)\r\n\r\n方案设计：\r\n\r\n功能实现：\r\n\r\n方案讨论：\r\n代码review：\r\n\r\n	\N	\N	19	\N	3	\N	5	1	2021-12-24 06:55:43.559232	2021-12-24 06:59:58.019886	2021-12-24	0	\N	\N	998	1	2	f	\N
703	6	6	世界-社会-人概览	世界是怎样的：\r\n知识树，知识是前人不断努力的结果，不是凭空而来的。\r\n发展分化树，世界是在不断分化的，结构越来越复杂，以复杂度换取了某些特性。但复杂度本身可能走向灭亡。\r\n\r\n方法论：\r\n逻辑法则\r\n归纳法与科学验证\r\n\r\n社会游戏的规则：\r\n1，社会是等级化的，分层的。力量是不对等的。强大即选择权。\r\n2，个体之间本质上是利益交换。从而产生新的利益或资源配置的合理化，语言，商业经济促进了交换的达成。\r\n3，社会危机的根本在于分化结构的破坏，会导致整体性问题。社会危机还有一种是无法形成更多利益而导致的\r\n利益分配问题，即底层人饿死效应。这个有赖于科学进步来创造更多利益。\r\n\r\n心灵：\r\n1，放松法则\r\n2，中庸法则\r\n\r\n个人成长的规则：\r\n1，训练就会变得更强，不论是大脑还是身体。\r\n2，直面问题原则\r\n3，算法原则\r\n3.1 批判性思维\r\n3.2 对等性原则，算法应该将其他人也作为智力正常的人来看待。这样知道自己达到某个程度也是需要时间的。\r\n按同等智力计算的正常时间可能是接近的。破除超人，神秘的思想观念。	\N	\N	17	\N	3	\N	5	2	2020-10-05 09:15:24.988122	2020-10-05 09:16:26.019133	2020-10-05	0	\N	\N	703	1	2	f	\N
1015	6	8	<被讨厌的勇气> 佛洛依德与阿德勒	这两个流派的关系就像接受与改变的关系。\r\n应该结合起来用，关注因果告诉我们为什么走到了这里。\r\n而关注目的，告诉我们如何改变。	\N	\N	17	\N	3	\N	5	1	2022-02-20 08:40:28.693925	2022-05-08 13:59:53.448399	2022-02-20	0	\N	\N	1015	1	2	f	\N
1113	7	33	周末工作-云原生湖仓		\N	\N	19	\N	3	\N	5	0	2022-08-12 15:43:49.923946	2022-08-12 15:43:49.923946	2022-08-12	0	\N	\N	1113	1	2	f	\N
1001	6	7	SSDR15：数据库存储编程的特殊性	存储也讲ACD，但是通常是立即可见的。\r\n数据库讲I。\r\n都需要讲的是安全可靠和性能。CPU cacheline特性的影响。\r\n\r\nACD是存储逻辑正确性与其他程序上的差异点。\r\n如：\r\n1，要考虑哪些动作不具备回滚性，这对于整体操作的影响。\r\n2，要考虑约束，考虑为了加速性能而做的各种共享或副本是否具备一致性。且这种一致性是否影响程序正确性？\r\n3，D要考虑编译器对齐的不同，可能导致持久化文件无法跨平台。编解码的正确性。	\N	\N	17	\N	3	\N	5	9	2022-01-15 06:57:01.832997	2022-08-08 12:09:05.213925	2022-01-15	0	\N	\N	1001	1	2	f	\N
1114	6	10	数据湖还是数据仓	数据仓库：一个面向主题的、集成的、相对稳定的、反映历史变化的数据集合，主要用于支持管理决策和信息的全局共享。\r\n数据仓库：一个集中式存储库，允许您以任意规模存储所有结构化和非结构化数据。您可以按原样存储数据（无需先对数据进行结构化处理），\r\n          并运行不同类型的分析 – 从控制面板和可视化到大数据处理、实时分析和机器学习，以指导做出更好的决策。\r\n\t\t  \r\n数据仓库有一个或多个数据源，当前和历史数据。统一分析能力。\r\n\r\n数据仓库适合结构化数据。\r\n数据仓库将不同分析业务的数据放在一起，相互影响。因而发展出数据集市。\r\n就是专门搞自己的业务。\r\n\r\n数据仓库的成长性很好，而数据湖更灵活。数据仓库支持的数据结构种类比较单一，数据湖的种类比较丰富，可以包罗万象。\r\n数据仓库更加适合成熟的数据当中的分析和处理，数据湖更加适合在异构数据上的价值的挖掘。\r\n\r\n\r\n数据湖虽然适合存储数据，但缺少一些关键功能：它们不支持事务处理，不保证数据质量，\r\n并且缺乏一致性/隔离性，从而几乎无法实现混合追加和读取数据，以及完成批处理和流式作业。\r\n由于这些原因，数据湖的许多功能尚未实现，并且在很多时候丧失了数据湖的优势。\r\n\r\n\r\n\r\n随着Hadoop与对象存储的技术成熟，数据湖的概念应用而生。\r\n数据湖是一种不断演进中、可扩展的大数据存储、处理、分析的基础设施。\r\n\r\n\r\n直接在用于数据湖的低成本存储上实现与数据仓库中类似的数据结构和数据管理功能。\r\n\r\n\r\n数据湖的本质，以数据为中心，集中数据管理，满足各种计算要求：\r\n1，多模数据\r\n2，数据转换，ELT\r\n3，多模计算\r\n   分析，科学计算，AI\r\n   \r\n数据管理，数据生命周期，权限（所有权与使用权），加密，血缘，质量等。\r\n\r\n数据中台：统一的数据安全、管理和治理。\r\n\r\n元数据，即数据的语义是最难的一点。比如两个csv文件，我们怎么知道其中的某列含义是否一致？\r\n可能都是城市信息，或其他信息。\r\n1，是计算处理各种数据模型，数据转换模型用于计算？\r\n2，是移动数据，还是移动计算\r\n3，是集中计算，还是分离计算   \r\n   计算具有差异性，就像公有云包打天下一样，实际还是各种差异化。\r\n   这世界不应该只有一种范式，在曲折中前进。\r\n4，是集中存储，还是分散存储\r\n   存储跟着计算走。\r\n   数据可计算都应该是可移动的，在哪里执行取决于矛盾。\r\n5，是全量计算，还是增量计算\r\n6，是独立产品，还是提供服务\r\n7，是开源，还是闭源\r\n8，是自研，还是集成\r\n\r\n多种数据模型，多种计算范式，跨模型数据交换（交流），协同计算。	\N	\N	17	\N	3	\N	5	0	2022-08-15 07:30:03.16013	2022-08-15 07:30:03.16013	2022-08-15	0	\N	\N	1114	1	2	f	\N
1121	6	23	必须用软件来解决软件问题	性能勘测，兼容性，安全性，问题定位，软件设计，软件编码，软件测试，文档，好用性，资源消耗等。\r\n\r\n我们如何知道做得好不好，现在都是靠人，靠人就必须依赖管理，就必须对抗人性的矛盾。\r\n必须有办法自动进行软件设计的审视，软件实现的审视，以及对于软件测试的审视。\r\n并且这种审视一旦通过，则软件就可以发布。\r\n\r\n这就是软件自身的根本矛盾，即软件构造与软件发展需要的矛盾。\r\n	\N	\N	17	\N	3	\N	5	1	2022-09-02 15:57:04.618191	2022-09-04 14:07:17.350334	2022-09-02	0	\N	\N	1121	1	2	f	\N
1110	8	24	为什么新的OLAP/HTAP都采用LSM		\N	\N	17	\N	3	\N	5	2	2022-08-08 09:30:59.112463	2022-11-02 04:06:04.928691	\N	0	\N	\N	1110	1	2	f	\N
1120	6	9	论斗争与生存		\N	\N	17	\N	3	\N	5	2	2022-09-01 06:45:29.197972	2022-12-12 20:31:52.266674	2022-09-01	0	\N	\N	1120	1	2	f	\N
702	3	25	dataset模块	dataset重构：\r\n1，其实区别就是一点，是否为该列分配内存。\r\n将数据来源改为 allocMem参数。\r\n2，ColumnDataSet对外可见，但进行简化。即外部需要方便的获取元数据\r\n即便作为切片本身，其也需要知道基本的元数据信息	\N	\N	17	\N	3	\N	5	3	2020-09-29 12:30:51.300689	2020-10-14 18:06:21.385539	2020-09-29	0	\N	\N	702	1	2	f	\N
819	6	9	心学的理解	谢锐:\r\n心学，在内心建立起基本概念，在遇到事物时将其与内心概念和原则规则对照运行，就能找出其中的问题。通过完善内心概念和规则等来达到进步。\r\n比如看一遍文章，如何知道自己懂了，可以用自己建立的概念来复述，通过运转自己的规则就会对文章有评价。所以核心在于建立自己在一个领域的概念和规则体系，由此才能从内观外。\r\n着眼点不在于一件事，而在于一切，要理解相关的一切就得在内心构建体系\r\n\r\n谢锐:\r\n我觉得王阳明就是这套路，所以他说心即理，不必外求，真理就在心中\r\n\r\n谢锐:\r\n通常最稀疏平常简单的道理，以及最常见的概念，以及总结的规则，就可以推知复杂情况。在实践中完善规则，理解事物分化的途径\r\n\r\n谢锐:\r\n比如我以前说软件，无外乎是行为，实体，关系，状态这些基本概念上分化，实体分解成更多存在各种关系的实体，动作分解为更小的动作，实体通过动作发生状态改变。\r\n最终软件是都是达成某个行为，比如购物，订餐，出报表，聊天等等\r\n\r\n谢锐:\r\n由此基础上，可以知道设计是在干嘛，设计模式是什么，软件开发是在干什么\r\n\r\n谢锐:\r\n找到本质的东西，然后找到规则，就能看清这些，当然也是需要不断实践锻炼的\r\n	\N	\N	17	\N	3	\N	5	1	2021-03-21 07:32:11.121868	2021-03-21 07:32:25.95994	2021-03-21	0	\N	\N	819	1	2	f	\N
697	3	10	企业的本质	企业有两种类型：\r\n1，赋能\r\n赋能是递归结构的，公司内也有一部分给另外一部分人赋能，一个模块给另一个模块赋能。\r\n2，服务，体验，娱乐\r\n\r\n就是让人爽或让人强。\r\n	\N	\N	17	\N	3	\N	5	0	2020-09-23 05:49:52.961527	2020-09-23 05:49:52.961527	2020-09-23	0	\N	\N	697	1	2	f	\N
698	6	7	哪些特性适合作为接口而存在？	为什么可以把ACID独立封装？\r\n数据的管理操作，与数据要求具体的特征分离？是一个好的实践？	\N	\N	17	\N	3	\N	5	0	2020-09-23 07:25:44.233325	2020-09-23 07:25:44.233325	2020-09-23	0	\N	\N	698	1	2	f	\N
545	6	7	复杂性问题思考法	复杂性是软件架构的核心\r\n关键点：沟通，分层，分块。\r\n多个参与者，复杂的行为，为了特殊目的而引入的偶然复杂性，加入了不必要的东西。\r\n复杂性分类：\r\n根本复杂性\r\n历史复杂性\r\n偶然复杂性\r\n\r\n为什么要求不可打断？\r\n思考的速度，精度，技巧的比拼。这是智力游戏。\r\n问，分，隔，连。思考不能前行与羽毛球打球不去移动一样，并非是不愿意，不够放松等原因。还有技巧在。一次只考虑一个点。要么考虑链接点，要么就考虑模块内。切记紧，散，乱。\r\n\r\n本质思考方法：\r\n1，为什么存在？\r\n2，核心特征？\r\n\r\n\r\n搞清本质是分的前提。	\N	\N	17	\N	3	\N	5	6	2019-12-29 21:28:55.139697	2020-09-23 21:14:35.717821	2019-12-29	0	\N	\N	545	1	2	f	\N
1111	8	24	snowflake的云原生与其他方案的根本区别是什么？		\N	\N	17	\N	3	\N	5	1	2022-08-08 09:31:30.845493	2022-08-29 08:27:03.897572	\N	0	\N	\N	1111	1	2	f	\N
699	6	15	羽毛球与孙子兵法	1，体能和力量储备是羽毛球的基本面\r\n没有体能手法再好都没卵用。\r\n\r\n人也是一样，没有好的身体和精神状态，是不可能成为顶尖高手的。	\N	\N	17	\N	3	\N	5	0	2020-09-27 05:37:35.163961	2020-09-27 05:37:35.163961	2020-09-27	0	\N	\N	699	1	2	f	\N
700	6	7	基本算法问题分类与研究	1，胜负强弱问题\r\n孙子兵法\r\n2，最优选择问题\r\n3，管理类问题\r\n数据库引擎\r\n4，动态规划问题\r\n5，语言解析问题\r\n6，统计分析	\N	\N	17	\N	3	\N	5	0	2020-09-27 05:41:27.668467	2020-09-27 05:41:27.668467	2020-09-27	0	\N	\N	700	1	2	f	\N
701	6	7	十一计划	1，思考离散数学如何运用于编程\r\n2，总结现有问题，以及常用算法的解法。\r\n3，总结编程方法\r\n如何最有效率的实现一个系统，并且支持在实施过程中纠偏。\r\n及时编译和测试的重要性。局部性问题原理。独立性原理。软件的根本特性。\r\n3.1 如何利用现有系统借力。\r\n4，平时看什么，提高路径。\r\n5，我的奇兵在哪？以何为副业。\r\n	\N	\N	17	\N	3	\N	5	1	2020-09-27 05:44:45.200941	2020-09-27 05:46:08.377247	2020-09-27	0	\N	\N	701	1	2	f	\N
1155	6	24	存储引擎想法	存储引擎：\r\n1，基于可变长block，固定每个页面的最大记录数。\r\n   本质上每个页面都是一个数组。反应页面关系的页面也是数组。\r\n2，统一事务块，行列均采用独立的事务块集合，数据块集合。\r\n3，采用lsm思想，支持物理分区，支持对数据块采用编码压缩加密等等。\r\n4，除了事务控制块，其他页面不涉及MVCC，每次都写新页面。\r\n   每个列都单独文件存储。支持预读。\r\n5，支持各种存储介质，内存，磁盘，远端存储等。\r\n6，感知基本数据类型，支持简单条件下推。\r\n\r\n优势：\r\n1，不论什么结构的表都很方便的支持事务。\r\n   当然也可以不支持事务，或大粒度的块级事务。\r\n2，顺序读写，超级快的扫描速度。\r\n3，实现简单。	\N	\N	17	\N	3	\N	5	0	2022-12-09 14:02:44.905192	2022-12-09 14:02:44.905192	2022-12-09	0	\N	\N	1155	1	2	f	\N
749	6	9	心里有了一杆寸：真，善与恶的力量	善良与柔软的力量\r\n柔软善良是生机的力量。\r\n强硬，丑恶是枯槁，死亡的力量。\r\n但请注意在善与恶之前，还有真实的力量，这是自然之力比善恶的人之力更基本。	\N	\N	17	\N	3	\N	5	0	2021-01-15 07:18:25.880186	2021-01-15 07:18:25.880186	2021-01-15	0	\N	\N	749	1	2	f	\N
750	6	29	2021.1.15	1，解决dataset复用问题\r\n2，补充日志	\N	\N	17	\N	3	\N	5	1	2021-01-15 09:05:43.366958	2021-01-15 09:07:11.471971	2021-01-15	0	\N	\N	750	1	2	f	\N
751	6	27	程序员常用网站	10大技术社区\r\n第1名：Github https://github.com\r\n\r\nAlexa全球指数：63\r\n\r\nGitHub，程序猿应该都很熟悉，全球最知名的代码托管服务平台，又名程序猿的“交友”平台。截止2020年1月的统计，Github已拥有两千多万开发者和一亿多个代码仓库。在Social Coding大行其道的今天，对程序猿来说，无论寻找开源代码还是托管自己的作品，Github算是每个程序猿心中的圣地和伴侣了。最近好消息是， GitHub 私有仓库对团队也开始完全免费啦，对，你没看错，完全免费！ 下面是两个作者关注GitHub趋势方式：\r\nhttps://github.com/trending 查看Github上项目最新趋势。\r\nhttps://github.com/search?q=stars%3A%3E10000 查看Github中star数超过1万的优质项目。\r\n第2名： StackOverflow http://www.stackoverflow.com/\r\n\r\nAlexa全球指数：41\r\n\r\nStack Overflow是一个与程序相关的IT技术问答网站。用户可以在网站免费提交问题，浏览问题，索引相关内容，在创建主页的时候使用简单的HTML。在问题页面，我们不会弹出任何广告，销售信息，JavaScript 窗口等。\r\n程序猿遇到编码问题时，Googl搜索答案的推进结果排第一大多来自StackOverflow网站，可以说程序猿遇到的问题，在StackOverflow都可以找到答案，这是一个高效、热心的社区，有很多大牛在线帮小白帮解决问题。\r\n第3名：Medium https://medium.com\r\n\r\nAlexa全球指数：85\r\n\r\nMedium是近几年崛起的一个专注于写作和阅读的平台，主打良好阅读体验和优质内容，没有任何广告。上面有很多免费或收费的优质内容，作者梳理些技术牛叉的独角兽公司在平台上开通的博客分享给大家，强烈推荐大家多逛逛这个平台，肯定有收获。\r\nNetflix: https://medium.com/netflix-techblog\r\nTwitter https://blog.twitter.com/engineering/en_us.html\r\nAirbnb https://medium.com/airbnb-engineering\r\ninstagram https://instagram-engineering.com/\r\nPinterest https://medium.com/@Pinterest_Engineering\r\n第4名： InfoQ https://www.infoq.com https://www.infoq.cn\r\n\r\nAlexa全球指数：85\r\n\r\nInfoQ是一个在线新闻/社区网站，旨在通过促进软件开发领域知识与创新的传播，为软件开发者提供帮助，除了英文还有中文网，比较知名的有其例行举办的QConf会议。这个也是作者常去的网站，值得推荐！\r\n第5名： CSDN https://www.csdn.net/\r\n\r\nAlexa全球指数：25\r\n\r\nCSDN大家应该很熟悉，号称最大的中文IT技术社区。现在业务有很多，其中他们出版的《程序猿》杂志让我印象深刻。但现在线上Web网站广告比较多，经营的积分换电子书下载业务为人诟病！\r\n第6名： Reddit http://www.reddit.com/r/programming\r\n\r\nAlexa全球指数：19\r\n\r\nreddit 也是一个非常富有个性的社区，你可以在 reddit 上提交一些感兴趣的话题，也可以和其他程序员讨论一些编程开发的问题和当前的 IT 热点资讯，reddit 是一个用户粘性比较强的开放社区，编程开发板块只是其中的一小部分。\r\n第7名： Stackexchange https://stackexchange.com/\r\n\r\nAlexa全球指数：114\r\n\r\nStackExchange可以说是 StackOverflow 的升级版，创始人都是同一拨人。StackOverflow主要关注编程问题解决，而StackExchange板块更多，除了编程领域之外，还有烹饪啊、摄影啊等其他领域。\r\n第8名： Quora https://www.quora.com/\r\n\r\nAlexa全球指数：235\r\n\r\n国外最大的问答社区，类似国内知乎。同样是问答社区，它和StackOverflow不同点在于：StackOverflow关注问题的具体答案，Quora则是引发问题发散讨论，另外Quora问题范围更广。\r\n第9名： 思否 https://segmentfault.com/\r\n\r\nAlexa全球指数：679\r\n\r\n思否是一个面向中文开发者的专业技术社区。社区采用良性、合理的机制来让开发者自由生长，希望通过最干净、简洁、优质的产品体验，来吸引国内优秀的开发者和技术人员，一起打造一个纯粹的技术交流社区。\r\n第10名： V2EX https://www.v2ex.com\r\n\r\nAlexa全球指数：854\r\n\r\nV2EX定位为一个技术创意的网站，V2EX是有些另类的，包括界面简单但用户活跃度却很高（Alexa排名可见一斑），整个网站一个人维护。虽然没什么名气，但内容却都很有价值，这些也是作者推荐的原因。\r\n名人博客\r\nMartin Fowler 博客 https://martinfowler.com/\r\nMartin Fowler:《重构: 改善既有代码的设计》、《企业应用架构模式 》（ 2003年Jolt生产力大奖） 作者， 世界十大架构师之一，现在ThoughtWorkers工作。\r\nChris Richardson 博客 https://microservices.io/\r\nChris Richardson：《POJOs in Action》、《Microservice Pattern》作者，世界十大架构师之一\r\nRobert C. Martin 博客 http://blog.cleancoder.com/\r\nRobert C. Martin:《整洁代码》作者 ，又名 Bob大叔， 又出了一本《整洁架构》，其中关于编程范式和反转控制模式背后的解释让人受益匪浅。\r\nJoel Spolsky https://www.joelonsoftware.com/\r\nJoel Spolsky：Stack Overflow 和 Trello 联合创始人，他的博客更新很频繁\r\nTim Bray博客 https://www.tbray.org/ongoing/\r\nTim Bray: XML之父， 博客一直更新	\N	\N	17	\N	3	\N	5	0	2021-01-15 17:46:06.085212	2021-01-15 17:46:06.085212	2021-01-15	0	\N	\N	751	1	2	f	\N
696	6	15	羽毛球腿法研究	脚有三种运动：\r\n1，抬起放下\r\n2，旋转\r\n3，平移\r\n\r\n其运动目的有2个：\r\n1，变向\r\n2，移位\r\n3，垂直移位，挑起或蹲下\r\n\r\n但不管是水平移位还是垂直移位，都是先变向，这就是为什么脚跟抬起是前奏。\r\n\r\n1，提起脚跟是为了身体转向，转向首先是脚踝的转向。\r\n	\N	\N	17	\N	3	\N	5	3	2020-09-22 06:26:02.945024	2021-01-24 19:50:17.155726	2020-09-22	0	\N	\N	696	1	2	f	\N
704	6	9	最重要的人生算法定律	1，熵增定律，事物朝着结构无序化发展，结构复杂化让其获得了更好的特性，但失去了稳定性。\r\n2，逻辑及因果规律，人类智慧建立的基础\r\n   知道为什么，才能慢慢深入事物。\r\n3，人生规律，活在当下，直面问题，人们太喜欢生活在过去的感觉，而过去只能带点经验，无法直接改变当下的状态。\r\n            练习可以改变身体，也可以改变大脑。\r\n3.1 沉默成本法则\r\n    沉迷于过去就无法改变未来。\r\n3.2 交易法则\r\n    与他人主要是交易，感情也算的话。\r\n3.3 丛林法则\r\n    强者有更好的生存空间，但是强者不一定快乐。但如果你在讨论生存空间，那就应该以丛林法则行事。\r\n    这就是公司的算法。你是领导者也会这样决策。\r\n3.4 快乐法则\r\n    唯有直面问题，突破困难，获得进步，才有快乐。这与起点没关系，与状态更新有关系。新奇与进步才能让人快乐。\r\n3.5 训练原则\r\n    大脑和身体都需训练，雕刻，否则难以改变。\r\n4，算法规律，行为与状态，就是我们当下生活的世界，执着于状态是无法成为高等生物，算法与数据更重要。\r\n                       他人也是人，是算法系统的部分。\r\n4.1 批判性思维算法，改变算法本身	\N	\N	17	\N	3	\N	5	5	2020-10-18 05:41:35.536254	2020-10-30 06:36:02.681408	2020-10-18	0	\N	\N	704	1	2	f	\N
1122	6	7	SSDR 39：需求与软件存在性	辨证唯物主义观点：\r\n事物是螺旋上升的方式发展的。\r\n矛盾普遍存在，矛盾即是事物的运动发展。\r\n\r\n没有发展就会衰亡，所以不怕没有需求，真正没需求的地方是缺乏生命力的。\r\n还有一种是矛盾过于激烈，这样就会重生。重生代价是昂贵的。\r\n\r\n事物是由其主要矛盾定义的，因而想要长久，就得抓住主要矛盾。\r\n飞机有轮子，可以移动为啥不说其是汽车的，因为其主要矛盾在于空中的运动。	\N	\N	17	\N	3	\N	5	0	2022-09-04 14:19:06.589374	2022-09-04 14:19:06.589374	2022-09-04	0	\N	\N	1122	1	2	f	\N
729	6	10	商业机会与生物进化	计算机正在经历生物演化的进程。\r\n生物从进化出能动性而分化出头，身体，尾部。\r\n因为基因进化需要而有了有性繁殖。\r\n因适应环境而发展了视觉，声音等能力。\r\n\r\n更复杂的结构，更优良的特性，对环境也更苛刻。\r\n\r\n基础实施从最初的大型服务器到现在的云计算。\r\n数据从最初的表格文件，到数据库，到如今的大数据。\r\n软件从最初的单机版，在向互联化，智能化迈进。\r\n\r\n从整体来说趋势是：\r\n1，结构复杂化\r\n2，社群化\r\n3，智能化\r\n\r\n编程语言也从早期的汇编到现在逐步的平台化，生态化。\r\n比如rust就是分化路径上一个有趣的例子。它提供了安全性这个有趣的能力。\r\n软件也从项目，到产品，到平台，到生态。\r\n\r\n数据共享平台建设。\r\n现在人的活动数据分离在各个软件平台上。\r\n各种设备产商也可收集用户数据，家庭也会产生一些数据。\r\n微信群体也产生一些关联数据。\r\n\r\n软件本质上就是完成特定行为的数据处理过程。\r\n\r\n领导力就是洞察并寻找路径的过程。	\N	\N	17	\N	3	\N	5	0	2021-01-04 06:19:04.86667	2021-01-04 06:19:04.86667	2021-01-04	0	\N	\N	729	1	2	f	\N
820	6	10	现代社会的结构	农业是生活原料\r\n工业是科学，探索发明问题\r\n商业是技术，行为价值问题\r\n金融本质上是策略，资产配置问题\r\n\r\n国家投资一般都是在工业上，即作为商业的基石。\r\n工业概念也是变化的，实际上商业中的部分基础也成为国家投资了。\r\n\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	1	2021-03-21 08:16:32.560577	2021-04-15 07:06:54.657937	2021-03-21	0	\N	\N	820	1	2	f	\N
731	6	15	最终目标	1，掌握羽毛球的三种发力\r\n  全身发力，甩小臂的短距离发力(反手)，手指发力\r\n2，掌握基础步伐\r\n\r\n后面阶段的玩法：\r\n3，掌握技战术，能运用多套战术，善观察，抓漏洞。\r\n\r\n体验羽毛球的流畅动作与美感，同时锻炼身体。	\N	\N	17	\N	3	\N	5	0	2021-01-04 13:31:18.76716	2021-01-04 13:31:18.76716	2021-01-04	0	\N	\N	731	1	2	f	\N
732	6	27	奥卡姆剃刀法则	如无必要，勿增实体。\r\n\r\n任何系统都应该遵守该法则。	\N	\N	17	\N	3	\N	5	0	2021-01-05 16:46:35.458613	2021-01-05 16:46:35.458613	2021-01-05	0	\N	\N	732	1	2	f	\N
734	6	27	墨菲定律，28法则，马太效应	墨菲定律在软件bug上几乎是真理\r\n28法则即突出重点，这也是普遍适用的。\r\n马太效应在很多集体中都存在。\r\n人之道就是一种聚集效应，天之道是离散效应。	\N	\N	17	\N	3	\N	5	0	2021-01-06 06:45:28.795918	2021-01-06 06:45:28.795918	2021-01-06	0	\N	\N	734	1	2	f	\N
735	6	29	2021.1.5	1，解决内存越界问题 2小时\r\n2，review代码  2小时\r\n3，整理后续要做的事情 1小时	\N	\N	17	\N	3	\N	5	1	2021-01-06 13:27:07.807714	2021-01-06 13:27:29.43154	2021-01-06	0	\N	\N	735	1	2	f	\N
736	6	29	2021.1.6	1，解决超长字段写入异常问题，2小时\r\n2，review代码  1小时\r\n3，整理分析clickhouse，4小时。	\N	\N	17	\N	3	\N	5	0	2021-01-06 13:28:30.056521	2021-01-06 13:28:30.056521	2021-01-06	0	\N	\N	736	1	2	f	\N
720	6	8	天道，人道，王道，魔道	道即选择，核心是以什么规则为准，捍卫谁的利益。\r\n王道和魔道其实都是讲规则和利益混为一体，这样是无法出现科学的，更别谈人文主义。\r\n\r\n浑浊雾霾的世界仿佛也遮蔽了我的双眼，我的身体跟着一起坠落，灵魂亦被杂乱的信息噪声熏晕。\r\n\t我们总以为需要的更多，然而多出的东西却成了我们的累赘。\r\n\t远离了花香鸟语，也远离了清澈明灵。我们总是需要更大剂量才能满足。\r\n\t香水高清的人造世界与自然世界，这就是人类的潘多拉魔盒，然世间已然如此。\r\n\t自古邪魔蛊惑人心，欲乱尘世，这是魔道。\r\n\t汉帝出，游侠死，舍已为公，捍卫王权。这就是王道。\r\n\t天地浩然正气，损有余而补不足。这就是天道。科学主义\r\n\t人能弘道，就是人道，利天下众生，依天道而行的。即人道主义	\N	\N	17	\N	3	\N	5	2	2020-12-19 07:25:19.184651	2021-01-07 06:33:28.023464	2020-12-19	0	\N	\N	720	1	2	f	\N
740	6	29	下周计划	1，预读\r\n2，当前插入页面cache\r\n3，并行spinlock优化\r\n4，性能trace	\N	\N	17	\N	3	\N	5	0	2021-01-07 16:21:26.21056	2021-01-07 16:21:26.21056	2021-01-07	0	\N	\N	740	1	2	f	\N
722	6	8	第二重境界_不着相	如果说人的第一重境界是直面问题。\r\n第二重境界就是不着相。不着相的情况下人应该追求什么？应该去干什么？\r\n兴趣仅仅是一方面，不着相的人必须有坚定而宏伟的目标，才能持之以恒。\r\n不着相容易进入虚无境界，即无意义无作为。就像说空并非没有，空是变化。\r\n\r\n本来无一物 何处若尘埃 比 时时勤拂拭，勿使若尘埃境界不一样，前者不着相。	\N	\N	17	\N	3	\N	5	3	2020-12-24 07:21:00.726836	2021-01-08 06:37:39.638956	2020-12-24	0	\N	\N	722	1	2	f	\N
744	6	29	2021.1.11	1，review代码 2小时\r\n2，思考pg和anchorbase事务机制差异 3小时\r\n3，听西安讲heap 2小时\r\n4，修改支持并行 2小时	\N	\N	17	\N	3	\N	5	0	2021-01-12 07:00:03.193267	2021-01-12 07:00:03.193267	2021-01-12	0	\N	\N	744	1	2	f	\N
733	6	27	分化与生长法则-系统演进	系统生长受限于当前环境，生长总是在做局部最优的选择。\r\n但生长不会做毫无逻辑的选择，美的事物是遵守分化与生长法则的。\r\n中间或许出现丑陋的中间态，但其是不稳定性的，缺乏平衡的，最终会走向局部稳定态。	\N	\N	17	\N	3	\N	5	1	2021-01-05 16:54:11.983492	2021-01-14 06:28:39.374803	2021-01-05	0	\N	\N	733	1	2	f	\N
745	6	29	2021.1.12	1，完成单表并行验证\r\n2，实现预读支持	\N	\N	17	\N	3	\N	5	2	2021-01-12 07:21:50.183238	2021-01-14 06:47:37.320997	2021-01-12	0	\N	\N	745	1	2	f	\N
823	6	29	swf获取的最大行数	要尽可能贴近max。\r\n\r\n与伟超讨论：\r\n1，冲突时目前先用行式过滤，批量不是很大，效率上也不好说。\r\n2，coral底层内存格式使用crab，并且尽可能多的代码使用rust实现。然后暴露少量接口给anchorBase中的实现部分。\r\n   这里涉及crab内存格式与parquet对接，\r\n   使用rust实现objectstore。等功能。\r\n	\N	\N	17	\N	3	\N	5	0	2021-03-21 16:11:45.627041	2021-03-21 16:11:45.627041	2021-03-21	0	\N	\N	823	1	2	f	\N
847	6	10	OLAP，大量数据处理技术的发展，历史，现在，未来		\N	\N	17	\N	3	\N	5	5	2021-04-14 12:27:31.654263	2022-09-14 08:34:40.14488	2021-04-14	0	\N	\N	847	1	2	f	\N
824	6	8	梦见心魔	下午喝咖啡，夜不能寐，持正念，待凌晨时梦见心魔，遂将其杀死，早起神精气爽。\r\n\r\n梦中采地菜于山间，突然到一桥下，桥下有水，水中有鱼，然其中一个异常之大，数米之长远超成人。我欲离去，然鱼跃而起，凶残之至，遂与之搏斗。\r\n杀之。思之，其肉可吃否？此时场景切换，突闻村中有人中毒，盖此鱼亦有毒乎？ 晨起，精神气爽，不知何故，或此鱼乃心中之欲念？ 吾之心魔？杀之而身轻乎\r\n\r\n最近在思考正念问题，或许是心魔自动复现了。有意思。\r\n人如果去掉压制，除去心魔，或许就能一身轻松了吧。\r\n去压制得自己努力提高，去心魔需修炼内心，维持正念。	\N	\N	17	\N	3	\N	5	0	2021-03-22 06:30:05.016568	2021-03-22 06:30:05.016568	2021-03-22	0	\N	\N	824	1	2	f	\N
658	6	9	谢锐5.0	换成5.0的大版本，意味着与过去的诀别。\r\n这诀别是于过去的依赖心理，此时我已完全独立，我愿对自己的行为和选择负责。\r\n我以自己的耳朵，眼睛，思考为准则。绝不迷恋于任何权威和神秘力量。我赋予自己的时间以意义，并去达成这种意义。\r\n比如当下工作的意义，我的目标是通过3年努力，实现财富能力的倍增，这样才能解除当下个人和家庭的经济压力。\r\n这诀别也意味着我将明确践行自己的价值观，利己和利人都是自然行为，都是策略。\r\n物质，情感和精神都是人的目标，而不仅仅是物质。\r\n\r\n我将奉行自由交易原则。这社会奖品80%分给前面20%的人，所以想办法成为那20%，才能让自己更轻松达成自己和家人的私利目标。\r\n圣母行不同，圣父也行不通，我奉行自由交易只是保留自己的人性。\r\n\r\n另外一个就是世界观，这世界浩浩汤汤，不以任何人意志而转移，我不知道他将去何方，\r\n它是被全体人的生存和发展意志推动的。前方或许是断崖，我奉行保留20%的原则，保持敬畏之心于自然。\r\n\r\n至此，即说明我的三观的转变。\r\n如果是思考，情绪是人的底层操作系统。\r\n语言，行为是外围的应用。\r\n那么哲学思考就是对于操作系统的改进。唯有哲思可以让人升级换代。否则只是增强版本。\r\n\r\n	\N	\N	17	\N	3	\N	5	15	2020-07-13 05:39:27.084837	2021-04-18 04:24:44.364628	2020-07-13	0	\N	\N	658	1	2	f	\N
706	6	9	技术的4个层次，程序员等级，评级	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n      而且作为职业他们压力很大，直接面临失业风险，或尝试更换职业，得不到很好的尊重，对于老板他们创造价值太小。\r\n      但反过来看这些都是促进他进步的因素，直面问题解决问题得到提高，否则继续面对压力。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考。\r\n或名：衣带渐宽终不悔，为伊消得人憔悴。\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n或名：独上高楼，望尽天涯路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n      以此为职业可以独立从容生活了。继续提升是出于个人追求。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n或民：默然回首，那人却在灯火阑珊处。\r\n特点：快，出招就是合适的，就那么自然。他们窥探了造物主的奥秘，掌握了物理事物原理或数学规律。因而明了事物为何需如此的缘来。\r\n      他们是最顶级的架构师，能设计出经历时间考验的系统。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的来源。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	\N	\N	17	\N	3	\N	5	20	2020-10-31 07:38:18.29537	2022-03-24 07:09:07.721532	2020-10-31	0	\N	\N	706	1	2	f	\N
707	6	15	羽毛球等级	4级：有基本步法意识，实战中可以运用高远球，杀球，吊球等，但质量不高。没有启动步。也没掌握发力的关键动作。\r\n     4级是随便玩玩的顶级水平了。\r\n5级：纠正了发力，以及步法，在练习以及强度不高的情况下动作完整，且能打到位。（足不出户，还是练习阶段）\r\n6级：步法和手法娴熟，实战中都能基本到位。刚开始有了打点战术意识。（初出茅庐，社区比赛）\r\n7级：有了专长打法，可以说是一技之长了。即7级仍然会有打法克制。（崭露头角，市区级比赛）\r\n8级：完善了各种短板，多个技术点都很优异。可以运用多套战术了，因人而异。（闪亮登场，全国性比赛）\r\n9级：技战术运用灵活，切换得当。身体，心理素质一流。（国际比赛）\r\n\r\n纯业余只能到7级。因为没有足够的时间投入弥补各种短板，且进行有效的战术变换训练。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	2	2020-11-06 05:53:19.001719	2021-04-23 05:56:44.688017	2020-11-06	0	\N	\N	707	1	2	f	\N
858	6	18	rust性能优化-软件的未来	程序员专注于正确性与扩展性，性能优化的事交给优化器。\r\n极致优化版。\r\n就像跨平台的需要一样，被编程语言解决了。\r\n安全性问题被rust部分解决了。\r\n\r\n也许有一天软件的复杂度，扩展性问题也得以解决，那程序员就退出历史的舞台了。\r\n事情都交给了程序体，可以想见那时的人类将大不一样？是好还是坏，说不清楚，但技术的车轮必然这样走过。\r\n\r\n未来会怎么样？\r\n变得更好或者更坏？\r\n没人能够预见，也没人能设定\r\n我们只能在这特定的时空下\r\n生生不息\r\n演绎仅属于我们的故事\r\n	\N	\N	17	\N	3	\N	5	1	2021-04-25 06:34:20.583988	2021-04-25 07:31:55.341361	2021-04-25	0	\N	\N	858	1	2	f	\N
1126	6	24	面向列存的并发控制专利总结	并发控制当然会用到锁。\r\n事务锁的本质实际就是2点：\r\n1，状态，冲突判断，可见性判断。\r\n2，锁，这里是内存锁，确保在事务期间是锁定的。\r\n\r\n并发控制策略的不同主要在于如何使用锁。\r\n1，比如mvcc，通过多版本支持了读不加锁。\r\n2，比如行锁与块内共享锁，体现了不同的锁资源管理方法。\r\n    行锁与块锁都不适合列存。\r\n   行锁，数量太多，不利于批量查询。\r\n   块锁按块组织，其数量变化太大，不利于列存的空间管理。\r\n	\N	\N	17	\N	3	\N	5	2	2022-09-26 08:45:51.009473	2022-09-28 07:09:02.285362	2022-09-26	0	\N	\N	1126	1	2	f	\N
1128	6	5	《让子弹飞讲了什么》	跪着走路慢，借力可以跑。但是风险从小到大。\r\n跪着被人借力。	\N	\N	17	\N	3	\N	5	0	2022-10-11 07:14:20.061827	2022-10-11 07:14:20.061827	2022-10-11	0	\N	\N	1128	1	2	f	\N
1130	6	23	面试题：mmap以及其与共享内存的关系	https://www.cnblogs.com/huangfuyuan/p/9476951.html\r\n\r\n总结：mmap通过文件映射到内存，除了共享之外，其读写代价比一般内存低，少了拷贝。\r\n      shm是共享物理内存，显然mmap可以覆盖shm的能力，即提供一个特殊的内存文件，posix共享内存基于mmap实现。\r\n\r\nhttps://zhuanlan.zhihu.com/p/357820303	\N	\N	17	\N	3	\N	5	0	2022-10-12 09:26:40.29726	2022-10-12 09:26:40.29726	2022-10-12	0	\N	\N	1130	1	2	f	\N
1131	6	7	SSDR 43：常用结构之哈希表	冲突解决办法：\r\nhttps://blog.csdn.net/qq_32595453/article/details/80660676\r\n\r\n哈希表的缺点：\r\n哈希最大的缺点是内存分配得小，可能元素就会冲突，冲突的元素大于8个成链表，效率还不如红黑树。\r\n\r\n哈希表与红黑树对比：\r\nhttps://www.yisu.com/zixun/13735.html	\N	\N	17	\N	3	\N	5	0	2022-10-17 07:11:51.595378	2022-10-17 07:11:51.595378	2022-10-17	0	\N	\N	1131	1	2	f	\N
1125	6	7	SSDR 41：实体的性质研究	实体兼容性，可分布性。持久性。\r\n行为的并发性，可分布性。开放性。监控性，可追踪性。\r\n\r\n如果只有单一实体，那么实体本身就不具备分布性，那么该实体的行为就难以具备分布性。\r\n比如分布式的集中元数据设计\r\n	\N	\N	17	\N	3	\N	5	6	2022-09-25 17:49:07.400398	2022-11-08 18:36:21.670185	2022-09-25	0	\N	\N	1125	1	2	f	\N
710	3	25	pg add column	adding DEFAULT now() will put the transaction’s current value of now() into atthasmissing \r\nand all existing rows will inherit it,\r\n\r\nvolatile function like random() won’t set atthasmissing and adding \r\nthe default will have to rewrite the table like it did before。\r\n\r\n Some functions in Postgres are explicitly marked as VOLATILE to indicate that their value can change within a single table scan like random() or timeofday(). Most functions are not volatile including many time/date functions like now()\r\n \r\n \r\n Fast ALTER TABLE ADD COLUMN with a non-NULL default\r\n\r\nCurrently adding a column to a table with a non-NULL default results in\r\na rewrite of the table. For large tables this can be both expensive and\r\ndisruptive. This patch removes the need for the rewrite as long as the\r\ndefault value is not volatile. The default expression is evaluated at\r\nthe time of the ALTER TABLE and the result stored in a new column\r\n(attmissingval) in pg_attribute, and a new column (atthasmissing) is set\r\nto true. Any existing row when fetched will be supplied with the\r\nattmissingval. New rows will have the supplied value or the default and\r\nso will never need the attmissingval.\r\n\r\nAny time the table is rewritten all the atthasmissing and attmissingval\r\nsettings for the attributes are cleared, as they are no longer needed.\r\n\r\nThe most visible code change from this is in heap_attisnull, which\r\nacquires a third TupleDesc argument, allowing it to detect a missing\r\nvalue if there is one. In many cases where it is known that there will\r\nnot be any (e.g.  catalog relations) NULL can be passed for this\r\nargument.\r\n\r\nAndrew Dunstan, heavily modified from an original patch from Serge\r\nRielau.\r\nReviewed by Tom Lane, Andres Freund, Tomas Vondra and David Rowley.\r\n\r\n https://github.com/postgres/postgres/commit/16828d5c0273b4fe5f10f42588005f16b415b2d8\r\n\r\nhttps://www.postgresql.org/docs/13/sql-altertable.html	\N	\N	17	\N	3	\N	5	0	2020-12-02 04:54:20.651871	2020-12-02 04:54:20.651871	2020-12-02	0	\N	\N	710	1	2	f	\N
822	6	29	用rust实现锁	1，locker，这里可能是事务持有锁。在结束时释放。\r\n2，objectLockContext保存objectLock\r\n3，objectLock描述了对象上存在哪些锁。其中存放了智能指针。	\N	\N	17	\N	3	\N	5	1	2021-03-21 14:52:49.766199	2021-03-22 15:29:06.576313	2021-03-21	100	\N	\N	822	1	2	f	\N
718	6	8	人的能量值	人的能量值来源于2个方面，一是能力，二是认知与行动。\r\n认知和行动本身也会积累能力。\r\n即人的能量来自于不断的认知与行动。\r\n\r\n按人的能量值人可以分为4类：\r\n1，寄生者 （无问题，陷于局部状态）\r\n2，逃避者 （因逃避问题，而忙于解决问题）\r\n3，行动体验者 （执行行动，算法），生存得以改善\r\n4，探索者 （思考追求行为与算法），生命得以升华，追求某个领域的最高境界，超神的美妙，恢复殿堂的荣光。\r\n	\N	\N	17	\N	3	\N	5	1	2020-12-13 08:14:50.982818	2020-12-19 06:43:46.30412	2020-12-13	0	\N	\N	718	1	2	f	\N
1017	6	7	SSDR20：也谈编程范式	结构化编程相对指令编程的好处在于没有了goto，随便跳转，使得对部分测试成为可能。\r\n对象编程消除了函数指针，使用多态表表达。对象对于可以随意乱指的指针做了限定，可以更加安全的表达。\r\n函数编程限定可变性。\r\n\r\n对象编程我觉得与结构化编程区别很大的一点在于对象二字：即封装，体现出封装的重要性。\r\n对称，完备。或者说怎么样的结构是合理的？结构应该提供什么方法。对象这个概念对此进行了加强。	\N	\N	17	\N	3	\N	5	1	2022-02-21 06:15:35.823503	2022-03-20 06:48:53.360587	2022-02-21	0	\N	\N	1017	1	2	f	\N
712	6	27	如何定义接口	1，接口的宽与松\r\n2，数据定义的规范\r\n3，动作规范\r\n\r\n接口是沟通力体现最明显的地方。	\N	28	17	\N	3	\N	5	2	2020-12-07 06:22:32.652784	2021-04-10 15:57:59.442025	2020-12-07	0	\N	\N	712	1	2	f	\N
713	6	27	设计模式本质上是对象关系的范式	对事务的抽象以及关系理解是编程的核心之一，另外一个是对动作的理解。\r\n而设计模式就是对象组织关系的范例。\r\n\r\n有时候动作不对，也是对象关系没理清楚导致。	\N	\N	17	\N	3	\N	5	0	2020-12-07 06:48:56.567791	2020-12-07 06:48:56.567791	2020-12-07	0	\N	\N	713	1	2	f	\N
1057	6	23	Clion使用技巧	1，Find与Find in Path功能差异。\r\nFind in path搜非代码很好用。	\N	\N	17	\N	3	\N	5	0	2022-05-10 09:05:47.928372	2022-05-10 09:05:47.928372	2022-05-10	0	\N	\N	1057	1	2	f	\N
721	6	8	如何生活v1.0(避免内卷的方法)	人如果去跟别人比较，可以得到满足感。但也可能被盛名所累。\r\n专营成功学的人必然内卷。人的一生当选择一个伟大的理想，做成某件事或达成某个状态。\r\n然后每天如斯，坚持不懈。不着相。\r\n\r\n个人所能做好的不过是打理好自己的时间，去做成各种事情而已。	\N	\N	17	\N	3	\N	5	0	2020-12-24 06:27:20.447388	2020-12-24 06:27:20.447388	2020-12-24	0	\N	\N	721	1	2	f	\N
723	6	29	不着相	1，并发update问题分析，4小时。 \r\n成果：发现undo的回收并非是按使用顺序，即后面的undo block可能先回收，这样需检查undo版本，并且在跨块时需要机制发现需要的undo被回收的情况。\r\n\r\n2，单表并行与多表在相同总数据量下性能低的原因分析。 2小时\r\n成果：无，运行时间很短，不适合perf分析。\r\n猜想：spinlock影响，考虑将其屏蔽看看。\r\n\r\n3，volador讨论。 1小时\r\n成果：加速作为一种产品形态，是特定模式的优化。 coral和swordfish提供通用的数据存储和使用能力。\r\n\r\n4，coral架构思考，1小时\r\n成果：明确采用新架构，并提出了几个待解决问题。	\N	\N	17	\N	3	\N	5	1	2020-12-24 19:10:38.837992	2020-12-24 19:11:56.319125	2020-12-24	0	\N	\N	723	1	2	f	\N
726	3	29	2020.12.29	1，定位并发truncate问题\r\n结果：是handler上的block cache在truncate之后未清理导致，liyanqiong修改为truncate之后，更换dataobjectid，从而间接让cache失效。\r\n\r\n2.使用rust写print函数生成器。\r\n结果：完成parse部分编码\r\n	\N	\N	17	\N	3	\N	5	0	2020-12-30 18:12:53.917998	2020-12-30 18:12:53.917998	2020-12-30	0	\N	\N	726	1	2	f	\N
724	6	29	2020.12.25 起	1，分析并发挂掉问题。 2小时\r\n2，修复bug， 2小时\r\n3，review代码， 2小时\r\n4，继续分析性能问题。2小时	\N	\N	17	\N	3	\N	5	2	2020-12-25 06:55:37.664502	2020-12-25 15:26:44.383566	2020-12-25	0	\N	\N	724	1	2	f	\N
778	6	15	如何在意识中打出好的高远球？	保持意识：\r\n1，用身体甩动肘\r\n2，击球发力主要在身后\r\n3，打完后身体形态\r\n\r\n不断用此意识训练身体。	\N	\N	17	\N	3	\N	5	2	2021-02-22 06:11:08.882385	2022-05-13 04:46:22.395531	2021-02-22	0	\N	\N	778	1	2	f	\N
687	6	15	反手高远球	反手高远球核心是把小臂速度甩出来，手腕手指放松，这样自然可以打很远。\r\n要能展开，则要计算好距离，以及击球点。	\N	\N	17	\N	3	\N	5	4	2020-09-01 20:40:44.511655	2022-05-20 06:36:52.104891	2020-09-01	0	\N	\N	687	1	2	f	\N
743	6	9	从孔子身上学习什么	古代人虽然不处在当今时代，但是在个人修养的功夫上做得非常足。\r\n修身齐家治国。每个能力强大的人都必然克服身上很多问题，不断修习所致。\r\n这是我们可以从他们身上学习的。\r\n\r\n比如学习：1，立志，2，知行合一，3，有恒，日日不断，温故知新，举一反三。\r\n如今学习大体也是如此，区别在于很多新技术的运用，还有知识渠道的丰富。\r\n\r\n再如齐家：孔子说已所不欲勿施于人，不恐人不知己，而恐已不知人。真诚，诗经三百，思无邪等。\r\n\r\n孔子的人生目标是成为饶舜一样的圣人。\r\n在日常生活上通过不断的学习，实践让自己的能力变得非常强大，以足完成一些事情。\r\n	\N	\N	17	\N	3	\N	5	1	2021-01-11 06:45:10.865802	2021-01-14 06:45:30.166855	2021-01-11	0	\N	\N	743	1	2	f	\N
746	6	29	2021.1.13	1，整理代码 4小时\r\n2，听西安将recovery 2小时	\N	\N	17	\N	3	\N	5	0	2021-01-14 06:49:42.731098	2021-01-14 06:49:42.731098	2021-01-14	0	\N	\N	746	1	2	f	\N
826	6	29	数据分布管理讨论纪要	dataspace：管理一组资源并实现chunk划分，将物理节点与逻辑概念合在一起了。\r\ntablespace set：划分表于不同的存储空间，实现了空间隔离。\r\n                根据所属的dataspace划分为很多不同的chunk，每个chunk在一个节点上就是一个tablespace。\r\n\t\t\t\t从水平角度看，chunk包含多个tablespace set的tablespace。\r\ntablespace：具体节点上的tablespace\r\ntable：可指定tablespace set或tablespace(如无shard，replicated表)。\r\n       key->partition->chunk\r\n可将外部空间也采用上述方式映射，如：\r\ndataspace-> s3用户空间\r\ntablespace set-> s3 bucket\r\ntablespace->  s3 bucket(无chunk)/s3 bucket下的"目录"\r\n\r\n概念体系：产品-服务-节点组-节点\r\n弱化集群和实例的概念，but这2概念似乎用的最广泛。\r\n我倾向于：产品实例-集群-节点组-节点\r\n实例下可以多个集群，多个不同类型的集群。	\N	\N	17	\N	3	\N	5	0	2021-03-22 14:44:47.38089	2021-03-22 14:44:47.38089	2021-03-22	0	\N	\N	826	1	2	f	\N
748	6	27	程序员就是coder，创造者	你很难教一个人如何去创造，只能告诉他这里不对，不符合力学。\r\n那里不太好之类。但软件一旦被创造然后在此基础上生演，完全去重构这个世界的代价就非常大。\r\n	\N	\N	17	\N	3	\N	5	0	2021-01-14 07:13:59.295394	2021-01-14 07:13:59.295394	2021-01-14	0	\N	\N	748	1	2	f	\N
747	6	29	2021.1.14	1，继续review ucvhar的代码 2小时\r\n2，合入性能优化代码  2小时\r\n\r\nTableDict是否违反依赖关系？\r\n\r\n学习anchorBase代码：\r\n3，将anchorBase代码分责任田进行深圳这边的讲解。\r\n	\N	\N	17	\N	3	\N	5	2	2021-01-14 06:52:34.576547	2021-01-15 06:09:21.979416	2021-01-14	0	\N	\N	747	1	2	f	\N
828	6	29	项目结构	工程结构：\r\nobjectstore\r\nobject format (4.15)\r\nsort \r\n\r\n工程结构：\r\noos (3.30有雏形)\r\ncoral {\r\n  meta mgr\r\n  index mgr\r\n  slice accessor\r\n}\r\n\r\n最顶层接口：\r\nredo rlog\r\nget_rlog\r\nslice dml接口(创建)	\N	\N	17	\N	3	\N	5	0	2021-03-23 14:27:07.022293	2021-03-23 14:27:07.022293	2021-03-23	0	\N	\N	828	1	2	f	\N
829	6	9	善且强	自胜者强，君子至强。强而有生机。\r\n一定要区别勇和强，勇者是有自我的，即克服的是自我障碍。\r\n\r\n而强是要在本我阶段，去克服自我在行动上的缺陷。这是一个人在某个领域达成内功高手的必经之路。\r\n看现在羽坛高手明显比林李等差距，这也是一方面。内功可以大成，但是不深厚的时候效果不明显。\r\n外功来得快。\r\n\r\n没有生命当被压制，也没有生命该被奴役。\r\n民主之下亦有乌合之众，专制之下也有生生不息。\r\n	\N	\N	17	\N	3	\N	5	4	2021-03-26 07:09:39.728045	2021-04-19 05:57:37.337864	2021-03-26	0	\N	\N	829	1	2	f	\N
831	6	15	羽毛球策略	1，稳定优先\r\n1.1 不要轻易杀球\r\n1.2 使用小发力精确控制\r\n1.3 持续的制造机会，保持耐心\r\n1.4 保持动作连贯\r\n\r\n2，对于弱点的观察，变化的理解。\r\n\r\n3，基本面\r\n发力到位，每个球都能达到目的。	\N	\N	17	\N	3	\N	5	1	2021-03-28 16:01:30.094077	2021-03-28 16:06:00.966991	2021-03-28	0	\N	\N	831	1	2	f	\N
832	6	7	7个概念	每次只跟人讲7个以内概念，超过了不讲。\r\n写代码也是如此，每层不超过7个概念	\N	\N	17	\N	3	\N	5	0	2021-04-01 06:16:37.265657	2021-04-01 06:16:37.265657	2021-04-01	0	\N	\N	832	1	2	f	\N
830	6	29	rust中关于获取锁内成员	问题可能出在unwrap这部，LockResult拥有其中成员的所有权，因为其生命周期有限制。\r\n\t   不，根本原因是里面一层guard没了。\r\n\t   RwLock<HashMap<String, Arc<RwLock<Talk>>>> 不行\r\n\t   HashMap<String, Arc<RwLock<Talk>>>可以。\r\n\t   那怎么实现一种效果 \r\n\t   lock\r\n\t     得到其中的对象，对象上有锁。\r\n\t   unlock\r\n\t   \r\n\t   与锁相关的对象其生命周期不能超过锁。但是里面锁的生命周期也不能超过hashmap\r\n\r\n	\N	\N	17	\N	3	\N	5	4	2021-03-26 16:25:11.391675	2021-03-29 18:06:53.241576	2021-03-26	0	\N	\N	830	1	2	f	\N
825	6	7	围绕方法，实体，状态，可变性等来编程	rust中对于实体的数据增加了所有权，生命周期概念，以及借用的限定，因而将思考提前了，这是非常好的。\r\n而且在多线程编程中强迫你思考共享问题。	\N	\N	17	\N	3	\N	5	2	2021-03-22 06:42:53.998412	2021-04-26 07:18:53.573358	2021-03-22	0	\N	\N	825	1	2	f	\N
834	6	7	软件开发人员的核心能力	1，抓住事物本质，认知能力而形成的设计，学习以及决策能力\r\n2，快速高质量的编码能力，执行力\r\n3，耐心，解决问题，达成目标的能力，自我管理的能力\r\n4，发现与探索的领导力 （高手）	\N	\N	17	\N	3	\N	5	1	2021-04-01 21:05:34.755043	2021-04-01 21:08:32.048081	2021-04-01	0	\N	\N	834	1	2	f	\N
833	6	7	实体划分，避免不清晰的思维，死胡同	有的人能力具备但是做事很难，可能问题就出在这。\r\n前期设计各种方案翻来覆去，抓不住问题本质。看不出各种变种，做不到举一反三\r\n\r\n	\N	\N	17	\N	3	\N	5	2	2021-04-01 21:00:59.781328	2021-04-05 05:58:18.369278	2021-04-01	0	\N	\N	833	1	2	f	\N
827	6	29	实现前端执行框架	支持在对象上注册行为，然后客户端发起行为的执行。定义log结构能把操作记录下来。\r\n定义handler，cursor来执行。	\N	\N	17	\N	3	\N	5	10	2021-03-22 16:03:57.507261	2021-04-10 16:07:54.707111	2021-03-22	0	\N	\N	827	1	2	f	\N
753	6	9	谈人情-君子和小人	君子爱结交，但群而不党。\r\n什么意思呢？与人交往要尊重人，不强行改变别人。即不因观念差异而分。又说君子和而不同。\r\n\r\n那君子会不会太清高？因为无利益往来而导致没人帮助？\r\n非也，这种人不算君子，君子别人会爱惜，有友情，自然有人来帮助。\r\n这种人因为不考虑别人感受，有点自了汉的感觉。\r\n\r\n帮不帮助，其实主要在于人情。君子无情，小人有义，非真君子。	\N	\N	17	\N	3	\N	5	0	2021-01-17 07:31:41.258796	2021-01-17 07:31:41.258796	2021-01-17	0	\N	\N	753	1	2	f	\N
754	7	30	打卡	1	\N	\N	24	5	3	\N	5	2	2021-01-18 06:02:16.579623	2021-01-18 06:03:49.542046	2021-01-18	100	\N	\N	754	1	2	f	2021-01-18 06:03:49.542046
755	10	30	开始	\N	\N	\N	12	\N	3	\N	5	1	2021-01-18 06:15:52.091087	2021-01-18 06:16:04.410994	\N	100	\N	\N	755	1	2	f	2021-01-18 06:16:04.410994
757	6	29	2021.1.19	1，做coral on anchor的整体设计\r\n	\N	\N	17	\N	3	\N	5	1	2021-01-19 05:54:39.624832	2021-01-19 18:20:49.025903	2021-01-19	0	\N	\N	757	1	2	f	\N
759	6	29	2021.1.20	完成2 bug fix，以及测试用例添加。 预期上午完成。3小时\r\n考虑下支持异步预读， 1小时。\r\n下午继续刷coral文档，完成大体框架，总结如何写设计文档。	\N	\N	17	\N	3	\N	5	1	2021-01-20 06:24:14.381378	2021-01-20 16:01:20.119395	2021-01-20	0	\N	\N	759	1	2	f	\N
763	6	27	软件中可能存在的bug类型	# 意外的数据或行为组合\r\n# 遗漏的动作\r\n# 不理解的已知代码\r\n# 坏味道\r\n# 不充分合理的设计\r\n# 数据或行为的边界效益\r\n# 资源泄漏\r\n# 未加保护的并发\r\n# 纯逻辑错误，业务错误	\N	\N	17	\N	3	\N	5	0	2021-01-21 15:34:59.701285	2021-01-21 15:34:59.701285	2021-01-21	0	\N	\N	763	1	2	f	\N
764	6	27	OO vs function	OO的最根本特征是多态，多态实现了依赖倒置，即上层依赖接口，而非直接依赖下层。\r\nFunction的最根本特征是不可变性，数据流，不存在状态。在传统语言中这种函数是线程安全，可重入的。\r\n所以Rust既是function也是OO，这并不矛盾。\r\n\r\nThe net result is that in order to be robust a system must \r\nemploy polymorphism across significant architectural boundaries.\r\nhttp://blog.cleancoder.com/uncle-bob/2014/11/24/FPvsOO.html\r\n\r\n其中还提到一点，OO的根本并非将数据和行为绑定在一起，OO的根本是封装行为。以及实现多态。\r\n所以新生代语言Go和Rust都是对过往对象编程的一种纠正。\r\n在系统中有各种全局数据，数据的集合是struct，数据结构。 行为的集合才是Object。\r\n\r\n试图以数据的行为来理解OO都是错误的，编程永远是行为操作数据，行为不是数据的。即开门并非门提供的行为，开门是一个接口。\r\n但是我们还是会问谁的行为？\r\n这区别不仅仅在于o.op() 还是c语言的op(o).问题在于在软件中我们该如何组织状态? 如何传递数据？这个数据是栈上的？还是堆上的？是参数还是状态？\r\n	\N	\N	17	\N	3	\N	5	0	2021-01-22 06:31:48.620518	2021-01-22 06:31:48.620518	2021-01-22	0	\N	\N	764	1	2	f	\N
766	6	27	软件结构(当存心中)，SOLID与软件结构	软件包含2部分，一是数据，二是动作。\r\n数据分为状态与参数，状态按存储特征可以分为持久化与非持久化，按可变性可分为可变与不可变等等。\r\n按生命周期分为全局的与局部的。\r\n\r\n动作要注意其入参是参数还是状态。\r\n如果是状态，则说明函数实现绑定了数据。即动作与数据存在依赖。\r\n\r\n数据的关联关系组成了软件的数据结构，其中有同一个结构体的内聚关系，\r\n有指针的关联关系，还有没有关系的。系统中的全局状态本质上是一个森林结构。\r\n\r\n动作的集合构成了模块，模块之间存在依赖关系，即没有中间接口层。如果有中间接口层，则可以转换为弱依赖关系。\r\n\r\n所以准确的说：软件包含3部分，1数据，2动作，3关系。\r\n关系包含数据与数据的关系，数据与动作的关系，动作与动作的关系。\r\n其中参数与动作是弱关系\r\n状态与动作是强关系\r\n函数与函数是强关系\r\n函数与接口是弱关系\r\n结构体内是强关系\r\n结构体关联是弱关系\r\n当然是相对的。 关系决定了很多东西。\r\n\r\n可以以此角度来解释SOLID原则：\r\n单一职责：动作应该只修改一个状态，或返回一个出参。\r\n接口分离原则：多个接口也应该按关系分组\r\n开放封闭原则，应该是变化部分使用弱关系，不可变或可变性低的部分使用强关系。\r\n依赖倒置原则：该使用接口的地方需使用接口。解除依赖关系。\r\n最小知识原则：模块对外的函数应该尽可能少，对外可见的状态应该尽可能少。\r\n\r\n还有一类原则是知道如何划分数据与动作的：\r\n1，奥卡姆剃刀法则\r\n如果没有必要，不必增加状态与动作\r\n2，生长法则\r\n数据与动作都应该是合理的，不能说随着生长其就得消失或砍掉。或随意变化。\r\n3，效率法则\r\n动作和数据应该是最精简效率的，这是生存之道。\r\n4，安全法则\r\n接口不应该有副作用，不容易误用。	\N	\N	17	\N	3	\N	5	2	2021-01-24 06:18:36.831993	2021-01-26 06:01:08.569332	2021-01-24	0	\N	\N	766	1	2	f	\N
761	10	30	2021.1.21	\N	\N	\N	4	\N	3	\N	5	2	2021-01-21 06:37:52.312108	2021-02-01 06:13:06.032769	\N	0	\N	\N	761	1	2	f	\N
777	6	9	2020过年总结	过年，家人之间社交，最重要的当然是乐了，当时要乐得有质量不是那么容易。\r\n2020年过年我是缺乏全局规划的，中间几次出游还是二嫂安排的，我习惯作为一个参与者。\r\n另外2个明显的活动是看电影，打牌，打了下游戏。\r\n\r\n我觉得还缺乏的活动：\r\n1，说唱环节\r\n2，琴棋书画\r\n3，益智活动\r\n\r\n设计游戏，让大家一起玩。构建一种家庭文化。	\N	\N	17	\N	3	\N	5	0	2021-02-21 06:24:56.345398	2021-02-21 06:24:56.345398	2021-02-21	0	\N	\N	777	1	2	f	\N
779	6	10	2021年度工作计划	1，要出色完成coral开发，完善swordfish\r\n2，考虑下一代存储引擎技术\r\n3，寻找周边有没事件可以做。	\N	\N	17	\N	3	\N	5	0	2021-02-22 06:23:46.249117	2021-02-22 06:23:46.249117	2021-02-22	0	\N	\N	779	1	2	f	\N
781	6	29	2021.2.22	1，处理问题单\r\n2，将coral设计细化进行讨论。\r\n   讨论元数据模块，今天完成。	\N	\N	17	\N	3	\N	5	1	2021-02-22 06:47:20.458101	2021-02-23 07:09:45.987534	2021-02-22	80	\N	\N	781	1	2	f	\N
787	6	5	朝代兴衰的原因	\r\n假设一个朝代因为结构性失衡，导致大量18~60期间需自己养活自己的人没法生存。\r\n那么就会暴乱，这种整体结构失衡很难因一两个人的善意化解。就像黄四郎一样，个体很难将自己获得的果实分给别人。\r\n虽然别人没吃的，最终自己会受损。但他分更多给别人，则自己也一样变穷，而社会却无法改变。\r\n所以最后战争成了唯一手段。通过战争一方面杀死很多人，另外权贵因为战队问题，也会被消灭大部分。\r\n最终完成洗盘，游戏从新开始。\r\n\r\n现代国家解决这个问题的一个办法就是给穷人发钱，让其维持基本生存。然后自然淘汰掉。\r\n而钱从哪里来，只能是通胀了，钱当然没有资本家愿意给。\r\n随着科学技术的进步，效率的改进，国家干预，以及自然调整。可以渡过经济危机。\r\n只要国家在危机时能解决穷人的生存问题，使得其自然死亡，就不会爆发全面战争。\r\n\r\n即根本上是国家效率提升来解决这个问题。	\N	\N	17	\N	3	\N	5	1	2021-02-28 14:48:33.151278	2021-02-28 14:48:43.665058	2021-02-28	0	\N	\N	787	1	2	f	\N
108	6	5	权力	权力的本质就是选择，选择决定了未来的方向，集体的兴亡，甚至是物种的发展，历史的车轮。\r\n\r\n权力来自于集体的馈赠，或者野蛮的剥夺。这是斗争的核心。\r\n\r\n所以于个人而言，政治形态是首要的，其次是经济形态。\r\n\r\n个人如果不具备独立精神与意志，就不具备独立的政治认知。也不会参与zz斗争之中。\r\n但不选择也是一种选择，麻木的观众是绝大多数的存在。	\N	13	17	\N	3	\N	5	2	2018-10-07 22:25:46.323543	2021-02-28 14:49:23.978823	2018-10-07	0	\N	\N	108	1	2	f	\N
793	6	15	平抽球	反手平抽球目前是手腕主动发力推的。\r\n实际应该是用小臂甩腕，击球瞬间握紧。	\N	\N	17	\N	3	\N	5	1	2021-03-04 06:19:00.455531	2021-03-20 16:12:13.655196	2021-03-04	0	\N	\N	793	1	2	f	\N
835	6	29	李辉雄面试	前期准备：\r\n1，从简历看，他能独立完成模块开发，但还没到独立负责系统的能力。\r\n2，从其blog看，其有一定的主动性，而且文档写的比较有条理，但是更新周期比较长\r\n3，从每份工作的时间看，后2份工作都干了3年，还算稳定。\r\n\r\n面试点：\r\n1，考察实际项目情况，设计和开发能力，以及达成的成就。\r\n2，考察其潜力，是否有强烈意愿进一步开拓。\r\n3，考察其品德\r\n\r\n面试准备：\r\n1，就其项目展开讨论，对设计模式，开发方法，操作系统基础等。\r\n2，就其对于编程的理解和目标来讨论，工作方向。\r\n3，就其对于换工作意图\r\n\r\n时间大约在30分钟。	\N	\N	17	\N	3	\N	5	0	2021-04-02 08:14:14.899556	2021-04-02 08:14:14.899556	2021-04-02	0	\N	\N	835	1	2	f	\N
837	6	7	数据库引擎技术发展史		\N	\N	17	\N	3	\N	5	0	2021-04-07 06:09:37.036473	2021-04-07 06:09:37.036473	2021-04-07	0	\N	\N	837	1	2	f	\N
790	6	7	bug之源	1，错误的理解，导致错误的结构。\r\n2，没有引入概念，封装而引起的复杂度。\r\n3，共享状态引起的一致性问题。\r\n4，缺乏的步骤。即动作步骤缺失引起的一致性问题.\r\n5，做错的步骤,如错误的动作顺序，错误理解变量范围\r\n6，离开作用域的数据。\r\n7，边界效应，累计效应。\r\n8，不合适的依赖，被依赖的地方改变了，但是依赖其的地方无法感知。\r\n9，没有沟通约定好的接口	\N	\N	17	\N	3	\N	5	2	2021-03-01 17:08:34.410101	2022-12-29 15:06:21.951815	2021-03-01	0	\N	\N	790	1	2	f	\N
838	6	7	元数据管理方案的研究		\N	\N	17	\N	3	\N	5	1	2021-04-07 06:10:10.841564	2021-04-07 06:11:17.792207	2021-04-07	0	\N	\N	838	1	2	f	\N
788	6	9	每个人都能值一个亿	按人从18岁开始工作，每年收入10万，工作50年即500百万，可以独立生活。\r\n这里不计算养育小孩，以及赡养老人，假设是等价的。\r\n\r\n即正常生活的人价值500万。以此为标准，价值一个亿，则需要提升20倍。\r\n就是说年收入要到200百万。而且考虑到有些工作没法持续，实际上要求更高。\r\n\r\n这里谈价值而不谈钱，因为实际钱能多少不好说，但人的价值是可以模糊衡量的。\r\n\r\n比一般人强20倍难不难？有点难，但是并非不可实现。效能提升20倍，只要坚定的不断提升自己，10年足以。	\N	\N	17	\N	3	\N	5	2	2021-02-28 14:49:59.432982	2021-02-28 14:52:19.187784	2021-02-28	0	\N	\N	788	1	2	f	\N
758	10	30	2021.1.20	\N	\N	\N	12	\N	3	\N	5	5	2021-01-20 06:19:05.957316	2021-01-21 06:37:31.29681	\N	100	\N	\N	758	1	2	f	2021-01-21 06:37:31.29681
760	6	27	写代码的技巧	1，写代码时注意力一定要集中，脑中运行完善逻辑\r\n2，设置提醒人，定期提醒自己进行某些检查，反思。彷佛在直播写代码。	\N	\N	17	\N	3	\N	5	4	2021-01-20 16:00:01.879343	2021-04-17 17:58:55.369588	2021-01-20	0	\N	\N	760	1	2	f	\N
756	6	27	软件设计的原则	软件设计的原则：\r\n\r\n软件设计面临的挑战\r\n1，不可见性\r\n2，可变性\r\n3，复杂性\r\n4，一致性\r\n\r\n其实也是人做任何事都面临的挑战。\r\n\r\n为了更好解决上述问题，引导软件设计。\r\n建议有如下原则：\r\n1，奥卡姆剃刀原则\r\n2，开闭原则\r\n3，最小知识原则\r\n4，单一职责\r\n5，依赖倒置原则\r\n细节依赖于抽象\r\n6，生长法则\r\n软件是生长的，需要进行合理分化。\r\n合理分化是应对复杂度，一致性的武器。也是满足功能的需要。\r\n7，效率法则\r\n动作并非多好，也并非少好，是在达到效率的基础上少\r\n8，安全法则\r\n接口不应该不容易误用，不容易引起安全危险	\N	\N	17	\N	3	\N	5	1	2021-01-18 08:05:49.781023	2021-01-21 13:15:32.651921	2021-01-18	0	\N	\N	756	1	2	f	\N
762	6	29	2021.1.21	今天先把bool和bit类型处理完 上午\r\n继续coral设计文档，或被review打断。	\N	\N	17	\N	3	\N	5	1	2021-01-21 06:39:55.30863	2021-01-21 18:58:53.128841	2021-01-21	0	\N	\N	762	1	2	f	\N
789	6	9	对人不论对错，但有真假利弊	人的选择是不存在对错的，对错是评论者的主观行为，对错通常是道德评价，但道德没有统一准则。\r\n况且我们不应该以道德来挟持个人。\r\n但从客观角度，是有真假利弊的。即从多参考系下看，这个都是一样的。\r\n	\N	\N	17	\N	3	\N	5	0	2021-02-28 15:25:07.30769	2021-02-28 15:25:07.30769	2021-02-28	0	\N	\N	789	1	2	f	\N
792	6	15	吊球	吊球和杀球类似，有几点区别：\r\n1，握拍稍微往内，以便切球\r\n2，使用手腕手指来推好控制力道	\N	\N	17	\N	3	\N	5	0	2021-03-04 06:16:35.223002	2021-03-04 06:16:35.223002	2021-03-04	0	\N	\N	792	1	2	f	\N
801	6	7	线程安全	线程安全\r\n显然动作本身是安全的，安全是指资源，包括文件句柄，socket，状态等。\r\n1，资源的线程安全\r\n   即资源可以被线程共享，比如一个只读的资源。\r\n2，方法的线程安全\r\n   方法必然访问一些资源，如果资源本身线程安全，\r\n   或方法对资源的使用进行了并发保护，则方法是线程安全的。	\N	\N	17	\N	3	\N	5	0	2021-03-09 12:53:40.821078	2021-03-09 12:53:40.821078	2021-03-09	0	\N	\N	801	1	2	f	\N
795	6	6	思考力	https://mp.weixin.qq.com/s/Q5ABvk5of77m0defEeFE2A\r\n\r\n思考能力：\r\n1，首先刨除个体情感因素\r\n2，理性和灵感都很重要，关键是有想法\r\n3，例子隐喻是一种很好的思考手段\r\n4，思考是围绕问题而展开的，这是思考的聚焦点，问问题的技巧\r\n要尽量简单，且见血。\r\n5，思考的广度和深度是思考能力的衡量指标，人类通过工具来简化思考\r\n常用的如符号，图等。事物的复杂度是一个重要背景。	\N	\N	17	\N	3	\N	5	2	2021-03-07 16:18:31.098735	2021-03-08 06:07:57.11158	2021-03-07	0	\N	\N	795	1	2	f	\N
797	6	29	2021.3.8 (开源objectstore实现，如何支持更新删除)		\N	\N	17	\N	3	\N	5	0	2021-03-08 06:32:23.419018	2021-03-08 06:32:23.419018	2021-03-08	0	\N	\N	797	1	2	f	\N
799	6	7	保证原子性的2种动作执行方法	1，修改实体，记录undo，写redo。\r\n2，记pending op log，在提交时将log写入journal。然后提交之后修改实体。	\N	\N	17	\N	3	\N	5	0	2021-03-08 06:38:02.774244	2021-03-08 06:38:02.774244	2021-03-08	0	\N	\N	799	1	2	f	\N
836	6	7	行为的层次划分，避免二义性与副作用	在软件中有2种行为：\r\n1，具体行为，包括无状态的运算和有状态的行为。\r\n    但行为切记不要有副作用，即行为不应该改变在其目标范围外的状态。\r\n    同样状态应该有明确的含义，不应该有多个含义。\r\n    \r\n2，抽象行为，即将行为封装的行为。比如做饭分很多步骤。\r\n\r\n软件编程应该将相同层次的多个步骤封装为抽象行为，抽象行为分为不同层次。\r\n上层调用下层，下层调用具体函数。\r\n\r\n行为要找到依附的实体：\r\n比如大家庭出游，那么做烧烤这个就是大家庭的行为。	\N	\N	17	\N	3	\N	5	0	2021-04-05 05:54:12.92264	2021-04-05 05:54:12.92264	2021-04-05	0	\N	\N	836	1	2	f	\N
767	6	27	质量概念与精确表达	有质有量，方有质量。\r\n\r\n质描述事务的根本，为何存在，根本特征是什么？\r\n量是数，就是程度。\r\n\r\n表达要有质量就得从这2方面入手，生活要有质量也得从这2方面入手。\r\n\r\n当质无法保证时，我们无法做到关注量。\r\n不偏离质时，我们就可以关注量了。	\N	\N	17	\N	3	\N	5	1	2021-01-26 06:11:50.933999	2021-01-26 06:13:14.63229	2021-01-26	0	\N	\N	767	1	2	f	\N
772	6	29	2021.2.1	继续coral设计分几大部分：\r\n1，本地元数据设计与子模块划分\r\n2，coral文件格式设计\r\n3，objectstore设计\r\n4，元数据同步设计\r\n5，本地存储设计\r\n6，通用接口设计	\N	\N	17	\N	3	\N	5	2	2021-02-01 06:14:53.536897	2021-02-01 18:18:29.583978	2021-02-01	0	\N	\N	772	1	2	f	\N
840	6	15	驭物驭人	羽毛球的物包含：1，场地，2，球拍，3，球\r\n研究物就得研究场地，以及围绕场地的规则。\r\n球的运动特征：比如击球瞬间最快，然后迅速减速。\r\n球拍：可形变\r\n球和球拍：是碰撞关系，有各种不同的碰撞。\r\n\r\n人：自己和对手\r\n人在这里面主要涉及肢体运动，沟通，以及策略。\r\n\r\n要驭人就得观察对方的运动特征，技战术特点，配合能力等。\r\n	\N	\N	17	\N	3	\N	5	0	2021-04-09 08:12:21.379802	2021-04-09 08:12:21.379802	2021-04-09	0	\N	\N	840	1	2	f	\N
769	6	9	君子如何与人相处	君子追求真善美，至强，无私，心平。\r\n\r\n听人说话，但不评价，不给建议，不加干预。\r\n讨论问题，给出自己的观点\r\n说服别人，有理有节	\N	\N	17	\N	3	\N	5	0	2021-01-29 06:06:37.319803	2021-01-29 06:06:37.319803	2021-01-29	0	\N	\N	769	1	2	f	\N
771	10	30	2021.2.1	\N	\N	\N	4	\N	3	\N	5	1	2021-02-01 06:12:31.840973	2021-02-01 06:12:48.894642	\N	40	\N	\N	771	1	2	f	\N
774	6	15	身法(核心肌肉的发力问题)	人击球前身体会后仰，展肩。\r\n腰部的核心作用是维持稳定性，而非主动扭转发力，扭转发力主要靠胸肌和背阔肌等。腰腹是对抗扭转，维持稳定性的。否则身体整个不稳定。\r\n臀部是传导蹬地之力的关键，所以要练深蹲，负重农夫走等。\r\n腰腹要练习稳定性动作，如侧拉。\r\n	\N	\N	17	\N	3	\N	5	1	2021-02-04 06:30:18.167932	2021-02-04 18:08:11.947642	2021-02-04	0	\N	\N	774	1	2	f	\N
768	6	9	谈宽容与感恩，君子与小人	宽容和感恩的好处在于怀此心态的人其有明确的人生目标，并且热切希望达成自己的理想。\r\n而这本来就是自己要做的事，如果有人帮助自然心生感激。而这些事本就是自己的事。\r\n如果遇到现实困境，也是需要自我改进去面对，所以能宽容。\r\n\r\n追求自我改进的人遇到困难首先从自己身上找原因，找解决办法，因而能宽容别人，如果有人帮助自己会心怀感激。\r\n因为大家都在自我改进，这样能促进每个人的成长，这也是谦虚的好处，谦虚的在于看到自己不足，他人长处，根子在于改进自己。否则谦虚就成了虚。\r\n而追求自我满足的人则容易将问题归于他人，或他看别人也是在自我满足，这样就看不到自身需要对面的问题，以及别人的帮助的意义。\r\n君子求助己，小人求助人。\r\n所以光谈要宽容，要感恩的心是没用的，最根本还是在于人得明确自己的理想，自己所认定的人生观。\r\n	\N	\N	17	\N	3	\N	5	4	2021-01-28 07:33:33.67094	2021-02-01 17:45:15.782839	2021-01-28	0	\N	\N	768	1	2	f	\N
773	6	15	如何与低水平的人打出自己的水平	与低水平打球，容易站立不动。\r\n可以学林丹的走位，等人击球后，慢慢动，因为低水平其最大特点就是击球动作慢，球速慢。\r\n可以多用交叉步慢慢提速。\r\n\r\n说白了根因还是步伐节奏不会控制，只会在一个节奏上打，不懂变换节奏。	\N	\N	17	\N	3	\N	5	0	2021-02-02 06:51:19.937673	2021-02-02 06:51:19.937673	2021-02-02	0	\N	\N	773	1	2	f	\N
839	6	7	封装与实体依赖，妙哉	一个模块与另一个模块在什么层次上依赖是非常重要的，这决定了2个实体之间的关系模式。\r\n比如mos中，上层对象如果依赖于mos的执行接口，即mos的用法对于object可见。\r\n如果mos接口变动则所有上层对象使用方式都得变。\r\n\r\n而如果将mos能力包装成一个trait或属性，mos只是赋予了对象这种能力，而属性和能力是不变的。\r\n其实现是变化的。	\N	\N	17	\N	3	\N	5	2	2021-04-09 07:36:34.890181	2021-08-24 06:32:26.949579	2021-04-09	0	\N	\N	839	1	2	f	\N
891	7	16	我想做一个App，如何让自己成为更好的系统	https://book.douban.com/review/9965517/。\r\nhttps://zhuanlan.zhihu.com/p/26573072。\r\n\r\n在精神，情感，思考，体能等各个方面都能非常合适的运转。\r\n\r\n思考的首要是一种方法，然后让其他的留给时间，不断训练，运用该方案提升。\r\n这样多付出时间，获取一些能力，信心和各方面得以增长。\r\n\r\n1，放下生活焦虑\r\n2，放下工作搞不好的感觉，做到自己当下能做到的程度，并完善方法。\r\n	\N	\N	19	\N	3	\N	5	2	2021-06-20 13:12:01.936868	2021-07-03 19:48:34.494346	2021-06-20	0	\N	\N	891	1	2	f	\N
776	6	9	2020过年想清楚最重要的一件事	我所不能前行者，因为不知道往前走，去实现自己所想要的。\r\n我所不能结缘者，因为不知以乐待人。\r\n我所不能强大者，因为没有把精力放在人，物，事上，不断的探索。	\N	\N	17	\N	3	\N	5	1	2021-02-21 06:19:45.798793	2021-02-22 06:19:51.388774	2021-02-21	0	\N	\N	776	1	2	f	\N
780	6	9	意识-训练-下意识	我打羽毛球的时候，在无意识时，动作会自然做错。\r\n即下意识中该动作还是错误的。\r\n\r\n而要练成下意识就是对的，我想可能需要在意识中反复训练。\r\n练成下意识后才是真正熟练了。\r\n\r\n但下意识有点要注意：很多隐形错误来自下意识。	\N	\N	17	\N	3	\N	5	0	2021-02-22 06:44:27.981844	2021-02-22 06:44:27.981844	2021-02-22	0	\N	\N	780	1	2	f	\N
711	6	7	程序员的6种能力	在《程序原本》中我提到程序员的4种能力：\r\n1，逻辑推理\r\n2，算法\r\n3，数据结构\r\n4，沟通\r\n\r\n现在我要加上2种能力：\r\n1，执行力\r\n2，领导力\r\n\r\n关于执行力：\r\n1，在工作中我们经常求快的心理不会去弄清楚事情的本来面目，分析清楚各个细节就开始行动了。\r\n2，还有一点就是沟通上，有些地方需要与其他模块沟通的，也未进行充分沟通就开始行动。\r\n3，执行力还需要全局的视野。\r\n真正合格的模块开发者首先必须是对模块最了解的人，而不是架构师一问三不知。\r\n模块开发者应该主动去了解本模块涉及的所有细节，与其他模块存在的各种交互，就像打球一样，不停琢磨动作该怎么做，\r\n还有那些地方可以完善，想到有颜色，想到兴奋睡不着。。。\r\n\r\n所以编程执行力要求我们有条不紊的做好每个细节，将未展开的地方展开，将该做到位的动作做到位。\r\n“开发软件的难点在于弄清楚它应该做什么，而不是如何让它工作。有一个关于 10x 程序员的神话，\r\n但它并不是指程序员在实现问题时有多英勇，而是指他们重述问题的能力。”\r\n\r\n执行力还有一个方面是不断推进的能力，有时候我们未展开时，以为自己在高歌猛进，实际上我们由于没细分而踌躇不前。\r\n执行力就是关于如何把大的事情完成的方法论。\r\n\r\n执行力要克服迷恋，要求我们活在当下，"过往不恋，未来不迎，当下不负"。\r\n执行力还要克服内心的恐惧，过往生活带给我们的深藏于身体的伤，让我们内心充满了恐惧。对于他人的恐惧，对于可能面临指责的恐惧，\r\n对于可能失败的恐惧，对于未知的恐惧。恐惧让我们甚至不能完成一些本身能够去做的事，去积累能力，知行脱节，也让我们无法改变以得到自己想要的状态。\r\n逃避以及其痛苦的记忆化作隐形的伤埋入我们的身体，梦想成了遥不可及的梦。\r\n执行力就是当我们决定了执行这个计划(算法)，就要客观求实的解决问题，我们自身的改变也是计划的一部分，计划本身的达成是第一位的。\r\n最终事情磨炼升华了我们，终有一天俗世不再是我们的囚笼。\r\n\r\n关于领导力：\r\n领导力是指在做一件事情时能够引领自己和别人。\r\n领导力要求一个人具备开拓精神，创新精神，独立自由精神(选择与担当)，以及博爱精神。\r\n这样才能做出具有领导力的软件。	\N	\N	17	\N	3	\N	5	9	2020-12-02 06:14:25.9391	2021-01-26 06:50:10.161521	2020-12-02	0	\N	\N	711	1	2	f	\N
812	6	7	设计，设计模式，开发的关系（如何掌握事物）	如果将实现行为作为软件的根本。\r\n则设计对应于实体的划分与组合。将系统中的过程抽象为一个组件并不容易，尤其是一个全新系统。这就是创造的过程。\r\n设计模式是实体关系的一些常见模式。\r\n开发是实体行为以及状态的实现。	\N	\N	17	\N	3	\N	5	3	2021-03-17 06:35:30.673194	2021-03-21 07:10:54.243603	2021-03-17	0	\N	\N	812	1	2	f	\N
649	6	7	软件设计是什么	软件设计到底是在干什么？\r\n\r\n参考程序原本，软件设计就是制造程序的设计环节，设计本身是属于计划的，而且是一种大体的计划。\r\n因此根据计划的详细程度分为概要设计和详细设计。\r\n如果从内部来看，可以分为方案设计，架构设计，详细设计。\r\n其中方案是整体战略，架构设计是方案落地的设计，详细设计是局部实现的设计。考虑的问题都略有不一样。\r\n按打仗来看，方案设计是军师统帅做的，架构设计是将军做的，详细设计是军官做的。\r\n\r\n设计的目的是做出满足现在以及未来一段时间内需求，同时又尽可能降低成本的方案。\r\n1，限制\r\n这里包含业务限制，人员限制，成本限制等等\r\n\r\n2，可变性\r\n用户行为的可变性，对系统理解的可变性\r\n事务是发展变化的，一个系统必然具备可变性，否则就不会有生命力，竞争力。\r\n\r\n3，业务逻辑\r\n从需求而来，软件是改善行为的，业务即用户行为。\r\n\r\n解决问题通常不是从头开始，这就涉及利用当下的产品和技术方案。\r\n所以设计过程涉及很多背景知识：\r\n1，组件选取，组件的成熟度\r\n2，其他经典方案借鉴	\N	\N	17	\N	3	\N	5	8	2020-06-22 09:07:40.167793	2021-04-25 08:24:01.253097	2020-06-22	0	\N	\N	649	1	2	f	\N
800	6	7	并发控制之乐观锁与悲观锁	https://segmentfault.com/a/1190000016611415\r\nhttps://www.jianshu.com/p/d2ac26ca6525\r\n\r\n乐观锁本质就是把加锁操作推迟到提交时集中处理，并且不采用事务级别的锁，而是采用冲突检查的方式，只要冲突检查失败，就简单粗暴的回滚。\r\n而悲观锁是前面执行时每次去检查下有没冲突，冲突就等待。\r\n\r\n即本质上并非锁的实现区别(事务锁还是CAS)，而是冲突检查时机的区别。是时机的不一样，处理方式的不一样决定了锁的使用方式。\r\n如果悲观锁遇到冲突也直接失败，那也可以用CAS。\r\n\r\n这里重点强调下：\r\n乐观锁与事务的执行模型没关系。但是乐观锁下的执行通常会分2阶段，执行阶段，加锁阶段(检查阶段).这样似乎跟先提交后执行的模型比较搭配。\r\n长事务，涉及多对象的事务可能不适合乐观锁。	\N	\N	17	\N	3	\N	5	0	2021-03-08 15:28:20.035581	2021-03-08 15:28:20.035581	2021-03-08	0	\N	\N	800	1	2	f	\N
1127	6	7	SSDR 42：如何写专利	专利的核心是创新且有益的发明。如果把技术发明看成科技树，那么专利就是点亮一个新的路径。\r\n但是通常这个路径最好不是一步，而是走了两三步，专利保护的就是这种路径。\r\n\r\n有益性：要阐述清楚问题是什么，新发明的价值在哪。\r\n\r\n此外就是专利不能是已有的。也不能是拼装的，比如将已有技术A和技术B组合。\r\n必须找到根基。不然很难写保护点。	\N	\N	17	\N	3	\N	5	1	2022-10-08 12:11:17.772711	2022-10-08 12:12:41.309254	2022-10-08	0	\N	\N	1127	1	2	f	\N
784	6	15	良好击球的几个指标	1，击球前后重心稳定，可连贯\r\n2，击球点精确\r\n3，击球速度快	\N	\N	17	\N	3	\N	5	0	2021-02-25 06:26:27.406633	2021-02-25 06:26:27.406633	2021-02-25	0	\N	\N	784	1	2	f	\N
785	6	29	2021.2.25	1，继续识别coral方案中的难点。\r\n2，调研bit类型的使用。行和列在其语义上应该保持一致。\r\n   表示可以不一样，上层语义应该一样。\r\n	\N	\N	17	\N	3	\N	5	0	2021-02-25 07:46:38.821471	2021-02-25 07:46:38.821471	2021-02-25	0	\N	\N	785	1	2	f	\N
775	6	10	可编程存储引擎	目前存储引擎样式万花八门，开发周期非常长。\r\n除了软件开发期(约2年)，还有试用稳定期。一套下来基本5，6年过去了。\r\n另外开发人员时间一长也难以记住自己当时写的代码。维护成本非常高。\r\n能否开发一种存储结构具备可编程性，且其效率也足够好？\r\n或者能否像编辑DNA一样，有一些基本组件，只需编辑DNA就能完成	\N	\N	17	\N	3	\N	5	1	2021-02-18 07:36:06.72992	2021-02-26 07:16:08.99436	2021-02-18	0	\N	\N	775	1	2	f	\N
803	6	7	Http长连接	http是无状态的，本质上是tcp长连接。即一个请求完成后不立即关闭tcp连接。并且中间通过keepalive心跳来确定连接关系。	\N	\N	17	\N	3	\N	5	0	2021-03-09 13:06:37.080272	2021-03-09 13:06:37.080272	2021-03-09	0	\N	\N	803	1	2	f	\N
808	6	18	对象行为-数据库	为啥业务和数据库是分离的？\r\n程序员面向对象编程，持久化只是状态的特征。\r\n\r\n能否开发一门编程语言，不用让程序员写sql？\r\n专注于行为。\r\nrust将并发封装起来，是一种很好的做法。\r\n\r\n在程序级别可配置数据持久化方式。\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	1	2021-03-16 13:04:35.401609	2021-03-16 13:05:17.525517	2021-03-16	0	\N	\N	808	1	2	f	\N
810	6	18	代码交易市场，代码计费	让代码变得可交易\r\n比如rust上的库。但是得有一个强大的基础。这本质上跟应用计费差别不大。\r\nwhy程序模块不可计费？why必须去上班，我的目标是每个人都在家办公。	\N	\N	17	\N	3	\N	5	0	2021-03-16 13:21:42.867196	2021-03-16 13:21:42.867196	2021-03-16	0	\N	\N	810	1	2	f	\N
809	6	18	对象执行器	对象存储支持在对象上定义Action。\r\n对象执行器在前端执行Action，记录操作日志，并且将日志发送给远端的对象存储执行。\r\n	\N	\N	17	\N	3	\N	5	1	2021-03-16 13:09:27.291878	2021-03-17 09:10:07.778566	2021-03-16	0	\N	\N	809	1	2	f	\N
765	6	27	TDD与敏捷的精髓	My problem with the recent blogs is that some readers may infer two things that are, in my view, incorrect.\r\n\r\nTDD means don’t think ahead of time.\r\nThinking ahead of time is better than thinking at any other time.\r\nThe first point is a meme that has made the rounds many times; and is often mentioned by both critics and fanatics of TDD. It is, however, patently false. Forethought is in no way excluded by the rules of TDD. I, as an avid TDDer, strongly encourage you to think ahead.\r\n\r\nLet me state that even more forcefully. If you want to draw UML diagrams because they help you think, then draw the diagrams! If you want to sketch out your thoughts about a problem-solution pair, you should of course do so. You should take every opportunity to think. Coding is not the only, nor always the best, way to think.\r\n\r\nThe second point is also false, and this is critically important to understand. Your early thoughts are not better than your latter thoughts! Indeed, quite to the contrary, your latter thoughts are almost always better.\r\n\r\nWhat this means is that no matter how much effort you put into thinking ahead, once you start to code, you’ll have better thoughts. While coding you’ll very probably discover things your forethoughts missed. Indeed, you may even discover that your some of your forethoughts were just plain wrong.\r\n\r\n关键在于拥抱变化，想法是变的，总是有更好的想法出来，应对之道在于保持开发扩展性，但也并非随便变化。	\N	\N	17	\N	3	\N	5	2	2021-01-22 06:37:02.659394	2021-04-07 06:22:04.271733	2021-01-22	0	\N	\N	765	1	2	f	\N
782	6	10	人脑与神经网络	1，有没可能将神经网络作为一种通用的存储结构？\r\n2，人脑存储效率比计算机强么？\r\n3，人脑的近似记忆? 还是近似计算？\r\n4，人脑对信息的编码，人处理视频信号时会选择性过滤掉很多信息，留下轮廓。\r\n   就像打码恢复一样，这或许是一种压缩算法。人工智能领域的“稀疏编码”(Sparse Coding)。\r\n5，神经网络成了生产特定程序的方法。即拟合方式实现函数功能。\r\n   由此可以想见，仅当函数的处理比较复杂时才用得上。\r\n6，还有一种编码方式是抽象，比如图片可以从颜色，形状，方位等各种属性进行抽象。\r\n \r\n人类自发明电脑起来做的事情主要是：\r\n1，将信息数字化，从而可以存储。\r\n2，设定模型，将工作场景程序化。从而可以进行传输和计算。\r\n3，将更多的场景进行模型化，使得可以用计算机模拟计算。\r\n\r\n不得不承认的是除了人类尚未搞清楚机制的地方，计算机都将碾压人类。\r\n人的想象力，创造力。神经元的数量，以及层次是人类有着特殊能力的原因。\r\n而为什么人类会有如此多的神经元，可能也是慢慢进化而来，其中一个重要原因或许是食物。\r\n使得有足够能量供应大脑。人缺乏动物的运动能力，但大脑因此受益。	\N	\N	17	\N	3	\N	5	0	2021-02-23 06:16:22.75234	2021-02-23 06:16:22.75234	2021-02-23	0	\N	\N	782	1	2	f	\N
783	6	29	2021.2.23	1，完成问题333的处理\r\n2，基于数据结构推导动作，完善文档。	\N	\N	17	\N	3	\N	5	0	2021-02-23 07:13:56.010748	2021-02-23 07:13:56.010748	2021-02-23	0	\N	\N	783	1	2	f	\N
845	6	29	version 0.0.2	支持rlog，executor,writer\r\n\r\n重复执行问题：\r\n部分对象可能已经apply，且其版本已更新不能重复执行redo，但是rlog的checkpoint点并非立即持久化。因而造成对象上动作重复执行的问题。\r\n使用lsn解决重复执行问题。\r\n相关子过程：\r\n1，handle提交时从rlog得到lsn，并设置到tranaction上。\r\n2，executor根据op_map得到对象上的op。执行完对象所有op后，更新对象的lsn，释放锁，标记为dirty。\r\n   执行前判断lsn。\r\n\r\n\r\n外部checkpoint问题：\r\nanchorBase完成checkpoint之后，rlog可能尚未flush，这时如挂掉，则anchorBase的redo可能没法完全恢复rlog。\r\nrlog需提供flush接口\r\n\r\n读写的版本：\r\n由于对象通常更新很少，且比较大。因而参考采用写时复制技术。\r\n在写时拷贝一份出来。等写入完成后，替换回去。\r\n由于原对象是arc管理的，因而直接替换没有问题。	\N	\N	17	\N	3	\N	5	2	2021-04-13 14:52:25.92437	2021-04-20 14:56:26.696718	2021-04-13	0	\N	\N	845	1	2	f	\N
1019	6	7	分解分化设计法-例1，句柄缓存	需求，目的：减少线程重复打开相同句柄的开销\r\n场景：主语分解：读线程， 预读线程。（限定）\r\n       谓语分解：打开句柄，哪些文件的句柄？（限定）\r\n\t   谓语修饰语分解： 重复，什么情况下会重复。\r\n\r\n解决方法： 通过缓存句柄来减少线程重复打开相同句柄的开销。\r\n        分解：缓存句柄  缓存放哪里？是独占还是共享？缓存多少？\r\n\r\n最终我们决定在树的哪个层次引入实体，并确定其接口。\r\n以及规格，配置项，错误码。\r\n然后就可以开始实现了。\t\t\r\n\t   \r\n现状：读线程读多列，每列可能是一个文件，也可能共享一个文件。\r\n      有个文件只读一次，有的文件读多次。\r\n分析：有哪些文件，各是怎么读的，是否都需要缓存句柄？是否跟扫描的情况有关系，比如只扫一个extent的。\r\n      多少句柄合适？太少，被其他列淘汰没效果。太大容易把句柄消耗完。是否允许共享句柄资源配额？配额是不是要区别读线程和预读线程？\r\n\t  或者扫描开始申请好？	\N	\N	17	\N	3	\N	5	2	2022-02-24 15:59:58.030827	2022-03-13 20:18:52.03421	2022-02-24	0	\N	\N	1019	1	2	f	\N
843	6	29	mos的封装	方案一：\r\nStruct A {\r\n}\r\n\r\n用一个宏\r\nas_meta!(\r\n Struct A {\r\n }\r\n \r\n impl A {\r\n    add()\r\n\tadd2()\r\n }\r\n) \r\n\r\n不用任何修改，A就具备了可持久化能力。\r\n外部使用还是调用A.add()\r\n产生A需调用handle::get::<A>(pool,name)\r\n或 handle::new::<A>(pool,name)\r\n把handle藏到A的原数据里面。\r\n\r\n方案二：\r\n#[derive(Serialize, Deserialize, Debug, Default, Clone, MetaObject)]\r\nstruct Add {\r\n\tmeta: Meta,\r\n\tsum: i32,\r\n}\r\n\r\nimpl Add {\r\n\t#[persist]\r\n\tpub fn init(&mut self, sum: i32) {\r\n\t\tself.sum = sum;\r\n\t}\r\n\r\n\t#[persist]\r\n\tfn add2(&mut self, a: i32, b: i32) {\r\n\t\tself.sum = a + b;\r\n\t}\r\n\r\n\t#[persist]\r\n\tfn add(&mut self, a: i32) {\r\n\t\tself.sum -= a;\r\n\t}\r\n\r\n\tpersist_funcs!(init,add,add2);\r\n}\r\n\r\nmeta字段可以改为驱动方式，不必用户修改。\r\nMetaObject使得A具备获取当前版本的能力，用于实现对象内MVCC。	\N	\N	17	\N	3	\N	5	0	2021-04-10 16:08:25.666837	2021-04-10 16:08:25.666837	2021-04-10	0	\N	\N	843	1	2	f	\N
850	6	10	列存稀疏索引		\N	\N	17	\N	3	\N	5	0	2021-04-15 06:34:39.600595	2021-04-15 06:34:39.600595	2021-04-15	0	\N	\N	850	1	2	f	\N
1129	6	23	面试题：存储引擎中级开发者	基础知识：CPU，内存，网络，存储\r\n1，锁，atomic与volatile\r\n2，mmap\r\n3，cacheline\r\n4，DIRECT与SYNC ioflag的作用。\r\n5，TCP\r\n6，hashtable的冲突解决方法以及应用场景\r\n7，cache算法有哪些，区别是什么\r\n8，怎么理解ACID。\r\n9，MVCC是什么概念\r\n\r\n数据结构与算法：\r\n\r\n开放问题：编码技术与架构\r\n1，常见的内存管理手段，如何做并发控制\r\n2，里氏替换原则的理解。\r\n	\N	\N	17	\N	3	\N	5	4	2022-10-12 08:56:17.848116	2022-10-12 09:08:07.236816	2022-10-12	0	\N	\N	1129	1	2	f	\N
786	6	8	孙子兵法解决了我一个心理问题	有时候我有一个困惑，自己变强之后就会跟更容易跟别人冲突。\r\n然后想想就知道这是不符合客观实际的。\r\n1，只有更强才有和平，即强反而冲突少。\r\n2，强意味着更好的处理能力，战争是最后的处理方式。	\N	\N	17	\N	3	\N	5	0	2021-02-28 08:42:56.844151	2021-02-28 08:42:56.844151	2021-02-28	0	\N	\N	786	1	2	f	\N
752	6	9	谈立志	佛家空性可渡自己，或渡自己的门徒，渡不了以家庭为单位的社会，是小路。\r\n道家无为，容易进入避世，且当下人不具备避世能力，环境也缺乏支持，是岔路。\r\n儒家修身学习，构建家庭组织秩序，不断更新维持，建功立业，儒家是大路。\r\n\r\n但是大路也难走，其竞争激烈，内卷严重。因为生存压力或膨胀的欲望，人们已疲惫不堪，\r\n更何谈自强不息。但这样就陷入不良循环，没精力提升，不提升就继续面对非常多的竞争。\r\n不花功夫立志做点事就脱离不了这环境。也没能力脱离。\r\n\r\n\r\n孔子将人分类：\r\n1，庸人\r\n内心没有信念，做事随意，说话没有底线，随波逐流，迷恋于声色犬马。\r\n孔子对庸人的定义，就是为人处世，不能善始善终，不能掌控自己的人生命运。\r\n\r\n2，士人\r\n有原则，有信念。孔子说的，就是当时普通的读书人，学问未必深，\r\n但有自己的观点和主张；事业未必成功，但做事有条理。\r\n\r\n3，君子\r\n孔子评价君子，跟功业无关，看品性，君子但问耕耘，无论收获，知命敬业，排除妄念，\r\n实事求是，得之我幸，失之我命，不纠结。小人不是个小，而是面对现实，患得患失！\r\n君子固穷，说明君子要立志，自强不息，坚韧不拔。\r\n\r\n4，贤人\r\n有经世济用之才，同时能够身体力行，为社会人群建功立业！贤人的品行无可置疑，\r\n贤人的功业是可见，经得住时间考验的！\r\n\r\n5，圣人\r\n圣人的标准是思想可以影响一个国家甚至整个世界的大善之人。想成为圣人，先得成为文化之集大成者，\r\n在文化层面立得住，然后砥砺前行，教化世人，形成影响千年的文化流派。	\N	\N	17	\N	3	\N	5	12	2021-01-17 06:05:52.719932	2021-02-28 14:04:10.090371	2021-01-17	0	\N	\N	752	1	2	f	\N
860	6	27	做事的禁忌	1,看不到，想不透，只尝试不思考。\r\n2,如果真不行，就启动迭代，如同rust一样，没找到完美的方法，先往前走走看。\r\n3,不要做垃圾系统，\r\n  不要做没人使用的系统，\r\n  不要做服务于恶的系统，\r\n  认真的做事。	\N	\N	17	\N	3	\N	5	0	2021-04-25 08:59:27.115246	2021-04-25 08:59:27.115246	2021-04-25	0	\N	\N	860	1	2	f	\N
791	6	29	2021.2.8	1，整体之前的设计文档\r\n2，开始格式和objectstore接口设计\r\n\r\n首先奔着clickhouse的目标去，即实现历史数据的分析。\r\n支持大批量导入，支持不频繁的删除。支持读写分离和远端存储。	\N	\N	17	\N	3	\N	5	0	2021-03-02 06:41:43.846387	2021-03-02 06:41:43.846387	2021-03-02	0	\N	\N	791	1	2	f	\N
794	6	7	tmp	并发\r\n异步\r\n多动作的原子性\r\n 两种玩法：1是先执行，记录undo，redo。 2是推迟到提交时执行。\r\n多节点完成一致的动作序列。\r\n\r\n实时计算，MPP，大数据框架\r\n什么流批一体\r\nHANA的生态空间	\N	\N	17	\N	3	\N	5	1	2021-03-05 19:56:25.518915	2021-03-07 21:07:18.145002	2021-03-05	0	\N	\N	794	1	2	f	\N
221	6	9	面试方法总结	技术：\r\n1，对某个系统的掌握程度------时间，关键问题的总结与理解\r\n2，代码开发，工程能力------看输出\r\n3，创新能力-------看对系统的改进，想法等。\r\n4，思维方法----逻辑清晰，科学态度\r\n\r\n德：\r\n1，责任感，重承诺----推动事情完成\r\n2，积极态度----能主动发现问题，积极处理\r\n3，三观要正----正确认知自己的价值，对未来的规划可体现部分。邓主要问题，三观有问题，社交一般也有问题。要么冷漠，麻木。要么勾心斗角。\r\n\r\n要识别伪君子，这种人比较恐怖，说得一套套，做起来都不行。像冯有这种倾向。\r\n少言者这种人比较少。\r\n\r\n社交：\r\n1，能分清自己和别人界限，具备良好的互赖，既无太孤僻，也不太依赖。\r\n黎就是有点依赖过头。\r\n\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	8	2018-12-31 22:37:14.816381	2022-12-14 14:35:46.232209	2018-12-31	0	\N	\N	221	1	2	f	\N
796	6	10	行为实体关联的角度来理解行业	新的实体出现，新的行为，不同的动作方法，这就是机会。	\N	\N	17	\N	3	\N	5	0	2021-03-08 06:17:41.32049	2021-03-08 06:17:41.32049	2021-03-08	0	\N	\N	796	1	2	f	\N
798	6	7	动作的特征	动作复杂有三个方面：\r\n1，动作分非常多的工序\r\n2，动作涉及很多实体\r\n3，动作有一定的特性要求，比如原子性，一致性\r\n\r\n动作完备性是软件的bug之源，而对称性是解决完备性的方法之一。	\N	\N	17	\N	3	\N	5	3	2021-03-08 06:36:11.177641	2021-11-13 20:12:13.534893	2021-03-08	0	\N	\N	798	1	2	f	\N
802	6	7	IO模型	IO模型\r\nIO动作分为写入，等待完成二个阶段。IO模型的本质是第二阶段与第一阶段的关系，以及由谁来执行。\r\n即反应了IO动作与执行模型的关系。\r\n同步阻塞是用户线程内核态阻塞等待，内核唤醒等待的用户线程。每个阻塞IO任务一个线程，任务多时线程切换频繁。\r\n同步非阻塞是重试方式的，好处是用户线程不必傻等了。且不必每个IO一个线程，效率上大大提升。\r\n同步非阻塞，IO复用。是采用轮询方式，好处是不必每个任务重试了。可以使用一个用户态线程来轮询，对其他用户线程来说就成了异步。\r\n异步非阻塞。由内核来完成异步调用。\r\n但是异步编程不方便啊，进一步进化出协程。\r\n\r\n这下子将任务和执行模型分开了。任务定了了同步和异步子任务。\r\n后端的线程池来执行任务。并且自动在任务等待时进行切换。\r\n\r\n这样彻底解决了最初的问题：内核因IO中断而切换线程带来的开销。\r\n任务可中断，线程不中断。	\N	\N	17	\N	3	\N	5	0	2021-03-09 12:53:57.915718	2021-03-09 12:53:57.915718	2021-03-09	0	\N	\N	802	1	2	f	\N
804	6	29	3.12	1,抽象coral静态数据的执行框架。\r\n多个表单，静态的，仅支持删除操作，可增加单表，要支持事物特性。\r\n提供锁接口(内存实现)，写op的接口，以及commit接口，在提交之后释放锁。通过版本支持隔离级别。咋有点像ceph的objectstore了。\r\n\r\n2，上述带事务能力的执行框架与当前框架如何配合？\r\n\r\n3，arrow使用手册，源码示例等。	\N	\N	17	\N	3	\N	5	0	2021-03-13 05:01:07.578133	2021-03-13 05:01:07.578133	2021-03-13	0	\N	\N	804	1	2	f	\N
842	6	27	rust共享与可变规则	为什么可变不共享，共享不可变？为什么单线程下也只有一个可变引用？\r\n首先我们要理解共享，引用一个变量即意味着在某个语境下使用它。\r\n如果将变量使用的上下文描述为task，那么变量与其引用存在于不同的task中。\r\n上述规则即避免了2个task中语义相关干扰。\r\ntask的执行可以在单线程，也可以分别在不同线程。\r\n举个例子：\r\n\r\n<pre>\r\nfn main() {\r\n    let mut foo = vec![1, 2, 3];\r\n\r\n\tfor e in &foo {\r\n\t\tif e % 2 == 0 {\r\n\t\t\tfoo.push(e+1);\r\n\t\t}\r\n\t}\r\n}\r\n</pre>\r\n\r\n该例中就同时出现了可变与不可变，\r\n其中for e in &foo的task是遍历foo。\r\n而foo本身在下面执行了push。\r\n\r\n再举一个例子，比如task：判断链表是否有某个元素，如果没有则添加该元素。\r\n但是判断和添加分2个动作执行。\r\n执行顺序如下：\r\ntask1.check\r\ntask2.check\r\ntask1.add\r\ntask2.add\r\n最终增加了2个元素，也就是说在单线程下，不同语境下同时修改变量可能不满足语义要求。\r\n当然同时修改一个变量并非总有问题，比如add 1操作，此操作本身语义并不冲突。理论上可同时修改。\r\nrust加强了这种限制，以便于静态检查。代价是即便有些代码是安全的，仍然不能以安全rust写，必须使用非安全代码。\r\n比如计数器。即便单线程使用的Rc，必须使用非安全代码才能写出来。\r\n\r\n另外Cell和RefCell也没打破规则，Cell只能整体来set或replace其中的成员，取出只能拷贝方式。\r\n而RefCell是在运行时检查是否有违反上述规则，违反了就panic。好处是根据实际借用时间来判断冲突。\r\n比如：\r\n\r\n<pre>\r\nlet mut p = 4;\r\nlet x = &p;\r\np = 1;\r\nprintln!("{}", x);\r\n</pre>\r\n\r\n显然上述在语义上没冲突，x虽然引用了p，但是还没开始使用。但编译时只能根据作用域判断认定冲突。\r\n使用RefCell解决该问题：\r\n\r\n\r\n<pre>\r\nlet p = RefCell::new(4);\r\nlet x = &p;\r\nprintln!("{}", x.borrow());\r\n*p.borrow_mut() = 1;\r\nprintln!("{}", x.borrow());\r\n</pre>	\N	\N	17	\N	3	\N	5	1	2021-04-10 14:37:42.313998	2021-04-10 14:38:21.555842	2021-04-10	0	\N	\N	842	1	2	f	\N
1058	6	32	算法的真相	栈可以处理具备完全包含关系的问题，即问题A包含问题B。所以栈可以处理递归问题。\r\n数据代表了不可变性，链表代表了可变性。很多结构都是在这两者之间折中。\r\n队列代表了顺序关系，栈代表了包含关系。\r\n\r\n侠义的算法是处理大量实体的，所以通常可以用递归或动态规划的思路来处理。\r\n\r\n换酒问题的核心在于认识空瓶实体和满瓶实体。\r\n算法类问题都是要识别不同类型的实体群。然后研究实体的关系，以及行为约束。\r\n\r\n背包问题的核心在于对背包状态和当前物品进行分类。\r\n当前P，那么就对实体进行分类，然后递归。\r\n\r\n算法步骤：\r\n1，确定实体集合。就研究对象\r\n2，表达实体关系\r\n3，认知实体行为，注意行为可能改变实体关系，也可能重新划分实体集合。\r\n\r\n一种表达实体关系的方法是表格，这是一种非常有效的方法，比如最长子串问题。	\N	\N	17	\N	3	\N	5	0	2022-05-16 06:03:47.625477	2022-05-16 06:03:47.625477	2022-05-16	0	\N	\N	1058	1	2	f	\N
806	6	9	2021年年度目标	保底目标：在编程和羽毛球领域达到高手水平，有自己一套体系，能做出好东西，能辨别高手。能很好完成每个动作。\r\n         能有效的领导5人团队。\r\n工作上：把coral出色的做好。	\N	\N	17	\N	3	\N	5	0	2021-03-15 06:22:51.924052	2021-03-15 06:22:51.924052	2021-03-15	0	\N	\N	806	1	2	f	\N
813	6	7	创建类设计模式	工厂模式家族：\r\n说的是客户不必自己拿着材料去找具体师傅生产衣服和鞋子，以前还真是这种状态。\r\n而是由工厂这个抽象结构来接单，工人来生产。这样客户以简单接口与工厂打交道，工人随时可以变动。\r\n\r\n工人：你给我生产一个宝马汽车，懵逼？\r\n简单工厂: 你再给我生产一个奥迪汽车，懵逼？\r\n工厂： 你给我生产一个奥迪手机，懵逼?\r\n抽象工厂：都给你搞定，可以支持不同产品，不同工厂。\r\n\r\n工厂模式体现了可变性，即生产具备不同特征的不同产品。\r\n\r\n创建者模式(电脑城模式)：\r\n我们在电脑城并非自己买了各种零件，然后自己组装。\r\n而是买了零件交给电脑城组装店面，让他们完成组装。\r\n即他们提供了相对固定的组装模式，这样不用每个客户操心具体怎么组装了。\r\n\r\n原型模式：\r\n显然懂王这理解该模式，没人更懂我自己。\r\n创建相似实体的工作，理应交给实体本身完成。\r\n	\N	\N	17	\N	3	\N	5	0	2021-03-18 07:34:09.745714	2021-03-18 07:34:09.745714	2021-03-18	0	\N	\N	813	1	2	f	\N
805	6	9	将何往	回望历史，已有先人指路\r\n探寻风景，亦有文人骚客\r\n我将何往，八荒之极。\r\n这世间真知，就蕴含于万物之中，只是时机不成熟的人无法探知。\r\n真善美智乐强权色皆我所求也，中庸之极，随心所欲。\r\n心实而强。\r\n强大的目标，专注的意识，才有良好的行动方案和执行力。	\N	\N	17	\N	3	\N	5	2	2021-03-15 06:04:25.008233	2021-03-15 06:34:37.545753	2021-03-15	0	\N	\N	805	1	2	f	\N
844	6	29	version:0.0.1	mos提供的能力：\r\n1，支持批量操作原子性\r\n2，支持对象内的MVCC\r\n3，支持derive struct成meta object。\r\n\r\n待支持：\r\n1，rlog写入\r\n2，executor执行并清理pengding transaction\r\n3，writer写入\r\n4，cache淘汰\r\n5，savepoint\r\n6，rlog同步	\N	\N	17	\N	3	\N	5	0	2021-04-13 06:58:00.434815	2021-04-13 06:58:00.434815	2021-04-13	0	\N	\N	844	1	2	f	\N
846	6	29	关注指标	1，压缩率\r\n2，性能	\N	\N	17	\N	3	\N	5	0	2021-04-13 14:53:17.366569	2021-04-13 14:53:17.366569	2021-04-13	0	\N	\N	846	1	2	f	\N
849	6	10	列存压缩技术		\N	\N	17	\N	3	\N	5	0	2021-04-15 06:34:25.255062	2021-04-15 06:34:25.255062	2021-04-15	0	\N	\N	849	1	2	f	\N
854	6	27	rust对于option和result类型的简化写法	https://rustcc.gitbooks.io/rustprimer/content/error-handling/option-result.html	\N	\N	17	\N	3	\N	5	0	2021-04-18 17:28:52.103308	2021-04-18 17:28:52.103308	2021-04-18	0	\N	\N	854	1	2	f	\N
853	6	15	谈平抽挡	首先一个问题：平抽挡到底是否跟高远一样要侧身，腰腹发力。\r\n\r\n我认为是要的，但是因为不需借那么多力，因而幅度小且快。\r\n不要则有一个问题：没法做鞭打动作，鞭打一定是上一节带动的，如果没有这个，则是旋转运动，其速度不会很快。	\N	\N	17	\N	3	\N	5	1	2021-04-18 05:13:32.033852	2021-05-21 06:33:23.064416	2021-04-18	0	\N	\N	853	1	2	f	\N
848	6	9	边界的感知，解决注意力涣散的问题，要思考也要聚焦	当我最初开始编程时，我写着代码逻辑，但彷佛不像我写的。\r\n就如同我吃过东西，但彷佛不是我吃的，不知其味也不知其名。\r\n\r\n多年过去了，我重复且肤浅的思考着很多问题，然而在任何一个领域都未曾达到很好的水平。\r\n君子不器，然而如果一个人未曾深入一个领域到骨髓，很难对其他领域有深刻见解。\r\n\r\n这个世界需要博物学者，然而这并不容易。尤其在智识不够的时候。\r\n学会100门，并不比精通一门更优，这是一件可叹的事，然而也是必然。\r\n但这个问题可以通过分享来解决。这是这个社会的基本特征。\r\n\r\n所以聚焦于自己选择的那颗子树，不断探索，才能练就自己对人和事的探知能力，才能发展事物。	\N	\N	17	\N	3	\N	5	2	2021-04-15 06:32:45.421332	2021-04-15 07:29:11.922058	2021-04-15	0	\N	\N	848	1	2	f	\N
999	6	9	如何看待工作	工作在本质上是一堆人完成一个复杂的工程。\r\n这里面有几点：\r\n1，应该让个人工作聚焦于整体，这样可以整个公司机器才能更好运转。自己才有更好的报酬。\r\n   最好每个人都有一个自己的worklist，每个小组织有worklist，然后不断的调整优先级，以及根据外部进行调整。\r\n   而达成整个目标。\r\n2，工作不同于学习，在学校可能有人交你最根本的知识，但是工作中几乎不会。\r\n   所以同事与朋友有根本性区别，如果公司塑造竞争关系，那公司就是敌人更多。\r\n                               如果公司更多塑造合作，那么伙伴就更多。\r\n3，不要试图改变他人，强行别人改变观念认知本质上也非自由，告诉他们你需要什么，他们需要自己做调整。\r\n   把牛引到岸边，但水要它自己喝。这就是管理。\r\n\r\n   	\N	\N	17	\N	3	\N	5	0	2021-12-24 10:52:19.437594	2021-12-24 10:52:19.437594	2021-12-24	0	\N	\N	999	1	2	f	\N
807	6	7	探究设计模式	建造者模式是对行为的包装，即行为动作序列不变。但行为本身有差别。\r\n\r\n设计模式的作用：\r\n1，隔离变化\r\n2，约束关系\r\n   生成，一般与特殊，观察者，适配器，桥接器，迭代器\r\n   \r\n关系有强弱，对应于耦合，内聚\r\n关系有M:N\r\n\r\n设计的第一步是分解组合，得到基本的实体，第一层分解之后通常叫架构模式。\r\n第二层分解是一个模块之内，分解实体之后，一个任务就是明确他们之前的关系。这就是设计模式。\r\n分解的重点在于明确实体关系，未来可能增加的实体，或实体可能增加的行为并对这些可变性作出隔离。\r\n还有一个很重要的是增加虚拟实体，比如迭代器这种。虚拟实体可以辅助构建实体关系。\r\n当然这不是一蹴而就的，有些变化提前未知，因而在开发过程中涉及重构。   \r\n\r\n继承与多态是相辅相成的，没有继承则类型不能作为其他类型的替代而出现，就没有多态。\r\n封装+继承多态是实体关系的根基。即从整体而言系统是一个树状结构的。\r\n树状结构一个常见动作还有上提下拉。上提则共享，下拉则分化。\r\n\r\n还有一种并非描述实体关系的，而是行为关系的，或叫开发模式吧\r\n其作用是抽象相同行为，将关联行为进行约束，以避免代码出现bug。\r\n比如析构，生命周期，所有权这套。\r\n常见软件错误：\r\n数据类：1，错误的理解变量含义与范围。 2，不一致的状态。 3，离开作用域的数据。\r\n行为类：1，缺失或多出或乱序的动作。 2，动作的边际效应。 3，没有约定好的接口\r\n设计类：1，缺乏实体包装引起的复杂性 2，不合适的实体关系。 3，弥散的隐式依赖，包括行为的。\r\n\r\n	\N	\N	17	\N	3	\N	5	3	2021-03-15 19:08:34.73221	2021-03-17 06:39:24.479556	2021-03-15	0	\N	\N	807	1	2	f	\N
770	6	9	儒家的发展	朱程理学出于回答哲学问题，世界观问题。提出了物，理概念，这是对儒家的积极发展。\r\n但封建社会形态决定了，其应用只能出于国家礼教。因而非常机械化，逐步搞出了"吃人的礼教"。\r\n心学是对于理学的纠正，在哲学上是唯心的。并且传承了儒家性善理论。在人文领域比理学更进步。\r\n儒家其实出发点就是解决人，人与人关系，社会秩序问题，并没有明显哲学偏向。\r\n\r\n另外上述从哲学视野看，跟科学都没关系。有唯心哲学家也是科学家。\r\n这或许是孔子不去回答的问题，鬼神？本体论？这些并不影响生活。\r\n所以孔子是思想家、政治家、教育家，但不是哲学家。儒家也不算真正意义上的宗教。\r\n\r\n从现代社会看，人文主义+科学是标配。其实先秦儒家就很有人文主义味道。\r\n而王阳明继承发展了一些先秦儒家，因而仍然有人继续发扬。同时儒家仁，礼等思想仍然在深刻影响着中国。	\N	\N	17	\N	3	\N	5	1	2021-01-29 15:44:43.491916	2021-03-17 07:26:14.87645	2021-01-29	0	\N	\N	770	1	2	f	\N
814	6	7	库中的全局变量问题	一种处理方式是库初始化时传出一个句柄，将库范围内的变量挂在该句柄上。	\N	\N	17	\N	3	\N	5	0	2021-03-18 12:35:39.067933	2021-03-18 12:35:39.067933	2021-03-18	0	\N	\N	814	1	2	f	\N
815	6	7	配套的动作，生命周期，以及rust mutex实现	我们知道有分配就得有释放，有加锁就应该有解锁。否则存在动作遗漏。\r\n\r\nrust类型系统提供了在变量无效时的drop方法来完成动作的匹配。\r\n\r\n这是一个很好的办法。\r\n\r\nC语言里面很多问题都是因此产生的。在C语言中如果一个函数内尚可以通过宏来达到这个目的。\r\n\r\n比如 \r\n#define XXBegin \\\r\n  {\\\r\n     xx;\r\n\r\n#define XXEnd \\\r\n     xx;\\\r\n  }\r\n\r\n这样如果不配套使用，则编译会报错。	\N	\N	17	\N	3	\N	5	0	2021-03-18 14:45:23.763061	2021-03-18 14:45:23.763061	2021-03-18	0	\N	\N	815	1	2	f	\N
851	6	9	魔界的团队管理	极具挑战且艰巨的任务：战胜魔王\r\n领袖：阿拉贡\r\n神辅：甘道夫\r\n任务组：xxx\r\n\r\n每个人都有磨难，也都有成长。	\N	\N	17	\N	3	\N	5	1	2021-04-16 06:33:26.384666	2021-04-16 06:35:19.75966	2021-04-16	0	\N	\N	851	1	2	f	\N
861	6	27	原本我想写一本书	我想写一本书讲述如何编程，但是发现代码大全，重构，设计模式等把如何写出可以生长变化代码的技巧都提及了。\r\n当然这里生长变化是在程序员的手下。\r\n\r\n如果程序本身不是程序员写的，就不存在这个问题。\r\n程序员的根本性难题在于复杂度，要能理解，理清楚关系才能修改代码。\r\n\r\n程序员的上限就在于对于复杂度的管理能力，通过工具技术。\r\n未来肯定有不少代码是自动生成的，不需要人去理解为什么能工作。就像一个经验系统一样。\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2021-04-26 07:34:35.443825	2021-04-26 07:34:35.443825	2021-04-26	0	\N	\N	861	1	2	f	\N
811	6	6	修炼法门	以前看小说拿到啥武功秘籍，修炼之后功力大增。感觉不太靠谱。\r\n现在想想，也并非不可能。 \r\n修炼修的是啥，是思考方式，去观看一切的角度。\r\n如有经典系统阐述深刻的思想，就是经，就是武功秘籍。\r\n\r\n经者，径也。\r\n\r\n如从实体划分，实体关系，实体行为，行为关系，多行为关系，状态等等角度来看待程序，则能入木三分，进到程序之内。\r\n如果流于表面，没有使用内心去看，那只能隔岸观赏了。\r\n其区别在哪？我们内心有了运行的程序。在我们的脑中，程序不再是外部符号信息。\r\n\r\n我要写一本书，编程心法。从此心法去看当下的一切。\r\n心学是否也如此？即在心中运转事物，达到通达。便可进入高手境界。	\N	\N	17	\N	3	\N	5	3	2021-03-17 06:06:32.558412	2021-05-10 07:28:08.889055	2021-03-17	0	\N	\N	811	1	2	f	\N
892	6	24	Coral的设计调整(痛心)	原方案问题：\r\n1，死锁检查怎么做？与anchorBase的死锁检查系统如何一起工作？\r\n2，如何回滚？准确的说要求在提交阶段去做coral submit写redo这本身不合适。\r\n   这块既与事务在anchorbase中执行的部分相关关联，但是又用了另外一套机制。\r\n3，PN使用对象来执行逻辑同步倒还行，但也非必要。PN本地也可写入anchorBase系统表。\r\n   真需要对象执行的是外部系统，需要解析对象格式，这逻辑对于PN也需要。\r\n   PN的逻辑日志执行可以在anchorBase代码中完成。\r\n4，逻辑日志的同步可以使用Rust实现。这逻辑日志就是一个局部行为同步插件。\r\n   其变数在于是否可以使用AnchorBase的逻辑复制来实现，如此则这部分也被干掉了。\r\n   Mos也就完全没了。\r\n\r\n花了最多时间的Mos被干掉了。再造一个简单一致性系统的想法被扼杀了。\r\nwhy？ 为了保持与AnchorBase的一致性。\r\n\r\n这算设计上的政治失败吧。	\N	\N	17	\N	3	\N	5	3	2021-06-20 14:28:29.008748	2021-07-01 15:02:47.242058	2021-06-20	0	\N	\N	892	1	2	f	\N
1059	6	23	C数组初始化 -陷阱	注意只有用{0}才能批量初始化，其他值只能初始化一个。	\N	\N	17	\N	3	\N	5	0	2022-05-19 13:26:32.764337	2022-05-19 13:26:32.764337	2022-05-19	0	\N	\N	1059	1	2	f	\N
863	6	27	对象生成和销毁时可变，运行时不可变 - Arc	通常我们有这种对象，在创建之后其不可变，构建过程中是可变的。\r\n而且需要共享，这种对象就适合在构建之后使用Arc包装起来	\N	\N	17	\N	3	\N	5	0	2021-04-27 06:10:26.914008	2021-04-27 06:10:26.914008	2021-04-27	0	\N	\N	863	1	2	f	\N
862	6	29	version 0.0.3	\r\n把yashan/crab列式格式数据转存为parquet或其他格式。\r\n给yashan/crab列式格式数据生成索引信息。\r\n\r\n统一描述为统计信息。\r\ncalc接口，关联于结果类型。\r\n\r\n或者可以说为不同的类型，实现了不同的统计方法。\r\n分别对应于不同运算。\r\n\r\nsum\r\ncount\r\ncount(not null)\r\ncount(null)\r\nmin\r\nmax\r\n即如果对于该数据集已经有了此运算结果，就可以直接运用。\r\n这本质上是运算缓存。\r\n\r\n所以首先要明确，一种类型上支持的运算。\r\n\r\n本质上是为某种类型的vector存储一个运算结果。\r\ncolumnId，data type，op, result.\r\n\r\n输入是某列，类型\r\n中间是类型所支持的运算统计\r\n输出是每种计算的结果，该结果缓存于slice index元数据中。\r\n\r\nminCompute\r\nmaxCompute\r\nComputeResult\r\n\r\n结果怎么存：\r\nsparse_index {\r\n  columnId,\r\n  datatype,\r\n  op,\r\n  result,\r\n}\r\n\r\n可以使用通用表示。即没有类型。\r\n然后将该通用表示在实际用的地方再转换为具体类型。\r\n\r\n使用场景：文件过滤，结果的预计算\r\n将sparse index作为表达式输入，进行计算，以确定该slice是否可排除。\r\n比如条件 where a > 3 and a < 10.\r\n使用min(a) >= 10 或 max(a) <= 3可过滤。\r\n比如单一条件 where a = 5，\r\n使用min(a) > 5 或 max(a) < 5可过滤。\r\n\r\n比如 select count(b) where b is null;\r\n\r\n这里不考虑chunk层次的索引。\r\n\r\n对上层接口：是条件下推，还是统计信息上升？\r\n            应该是条件下推，文件内过滤也需要这个信息。\r\n\r\nSlice层接口：\r\nslice的数据格式，利用该格式，生成对应的trait object来完成具体类型的读写操作。\r\n文件的局部操作能力。如何暴漏出来。\r\n\r\n怎么映射数据类型？条件怎么传下去？\r\narrow实现的parquet是否满足要求，未来怎么扩展？这个就是官方的\r\n其他实现怎样？谓词下推\r\n目前仅Statistics support和谓词下推没支持\r\n\r\nparquet-rs\r\n理解下arrow如何跟parquet对接的。\r\nparquet库写入时要处理level。\r\n\r\nFAQ：\r\n1，parquet如何做到只读取部分chunk数据的？或者说parquet如何表示条件过滤的？   \r\n2，如何缓存parquet读取到部分数据？\r\n   缓存应该是透明的，比如以对象为单位，按其中读取的range进行缓存。\r\n3，上层是否要保留rowgroup的index？\r\n   没必要，parquet有。但目前parquet rust实现尚未支持。\r\n\r\ncoral的format层主要就是做parquet的reader/writer包装，一个格式和schema转换。\r\n\r\n	\N	\N	17	\N	3	\N	5	4	2021-04-26 17:39:39.616105	2021-04-27 13:48:27.456861	2021-04-26	0	\N	\N	862	1	2	f	\N
1062	6	23	shell脚本编写循环，gdb非交互式批量查看core文件堆栈	find /tmp/corefiles/ -name "core-*" | xargs -i gdb --batch --ex "set height 0" -ex "bt"  /tmp/ci_project_backup/master_L2_dst_lsc_SDV_p1_release_20220521024216/v22.1.B107/bin/yasdb {} >> core_stack.txt	\N	\N	17	\N	3	\N	5	0	2022-05-24 06:47:04.691809	2022-05-24 06:47:04.691809	2022-05-24	0	\N	\N	1062	1	2	f	\N
896	6	23	C++/C编译时找不到已包含库文件的函数问题	错误信息：\r\n<pre>\r\n/tmp/tmp.oW8oNPviMt/codcommon/src/number/cod_number.h: In function ‘CodBool codIsZeroFloat(CodFloat)’:\r\n/tmp/tmp.oW8oNPviMt/codcommon/src/number/cod_number.h:104:24: error: ‘fpclassify’ was not declared in this scope\r\n     return fpclassify(n) == FP_ZERO;\r\n                        ^\r\n/tmp/tmp.oW8oNPviMt/codcommon/src/number/cod_number.h:104:24: note: suggested alternative:\r\nIn file included from /usr/include/c++/4.8.2/random:38:0,\r\n                 from /usr/include/c++/4.8.2/bits/stl_algo.h:65,\r\n                 from /usr/include/c++/4.8.2/algorithm:62,\r\n                 from /tmp/tmp.oW8oNPviMt/test/concurrencytest/ctest_framework.cpp:1:\r\n/usr/include/c++/4.8.2/cmath:578:5: note:   ‘std::fpclassify’\r\n     fpclassify(_Tp __x)\r\n</pre>\r\n\r\n确认cmake使用的cxx版本：\r\ncmake ../ --trace > log.txt 2>&1\r\n/tmp/tmp.oW8oNPviMt/build/CMakeFiles/3.14.6/CMakeCXXCompiler.cmake(2):  set(CMAKE_CXX_COMPILER_ARG1  )\r\n/tmp/tmp.oW8oNPviMt/build/CMakeFiles/3.14.6/CMakeCXXCompiler.cmake(3):  set(CMAKE_CXX_COMPILER_ID GNU )\r\n/tmp/tmp.oW8oNPviMt/build/CMakeFiles/3.14.6/CMakeCXXCompiler.cmake(4):  set(CMAKE_CXX_COMPILER_VERSION 7.3.1 )\r\n\r\nClion在生成项目时也会输出：\r\n/usr/bin/cmake -DCMAKE_BUILD_TYPE=Debug -G "CodeBlocks - Unix Makefiles" /tmp/tmp.oW8oNPviMt\r\n-- Running cmake version 3.14.6\r\n-- The C compiler identification is GNU 4.8.5\r\n-- The CXX compiler identification is GNU 4.8.5\r\n\r\n经确认是因为机器上有多个gcc版本。Clion生成项目使用了老版本的g++导致。\r\n修改~/.bashrc可解决：\r\nsource /opt/rh/devtoolset-7/enable\r\n	\N	\N	17	\N	3	\N	5	1	2021-06-24 15:55:53.937393	2021-06-25 07:46:17.581065	2021-06-24	0	\N	\N	896	1	2	f	\N
898	6	9	婚姻是一种盟约	婚姻是盟约关系，而不是依存关系。\r\n结盟是为了为大家的成长和利益。\r\n\r\n婚姻并不意味着安全，看看历史便知道，结盟本身也有风险。\r\n独自面对世界很恐怖？兴衰存亡仍必然现象，就像人不能假设自己永不死亡一样。\r\n只是很多人忽略了事实。 问题并不在于天地不仁，在于我们是否敢接受。	\N	\N	17	\N	3	\N	5	0	2021-07-01 07:15:52.736956	2021-07-01 07:15:52.736956	2021-07-01	0	\N	\N	898	1	2	f	\N
899	6	7	我的编程指导思想	1，精益迭代\r\n  不断通过迭代精进\r\n2，系统化，方法论\r\n  首先将事务视为一个系统，理解并认知\r\n3，自顶而下的分化思想。设计与编码的路径\r\n  与之相应的有自下而上的组合思想\r\n4，互联思想\r\n5，实体行为的程序观	\N	\N	17	\N	3	\N	5	0	2021-07-02 08:27:22.24971	2021-07-02 08:27:22.24971	2021-07-02	0	\N	\N	899	1	2	f	\N
900	6	9	<你的缺陷>	最最重要的并非解决问题或做成事情，而是我们的精神和状态。这决定了我们有能力去适应变化，应对问题。\r\n难道不是吗？ 问题总是层出不穷。生机活泼的精神幸福是最重要的，也是人最强大的力量。\r\n这本书就是告诉我们达成该状态存在的一些坑。	\N	\N	17	\N	3	\N	5	0	2021-07-02 08:35:32.74705	2021-07-02 08:35:32.74705	2021-07-02	0	\N	\N	900	1	2	f	\N
902	6	23	莫名其妙的SSH无法登录	https://www.cnblogs.com/y593216/p/11232703.html，\r\n尝试关闭防火墙，修改sshd配置都无效。\r\n\r\n	\N	\N	17	\N	3	\N	5	1	2021-07-05 15:45:52.912846	2021-07-05 17:21:22.178241	2021-07-05	0	\N	\N	902	1	2	f	\N
864	6	9	再见了，我的童年	我一直很想回家，休息上个把月，甚至无限休息。\r\n我以前只是明白人得往前走去达到目标。\r\n\r\n而如今我觉得那只是自己未成满足的愿望，或许人一生都在追求最初那些没满足的东西。\r\n今年五一我又回了，家乡春天的气息令人心旷神怡。我记住了这种感觉，生机勃发。\r\n\r\n然后除此之外，家乡于我还有什么呢？乡亲于我感情并不深，那不是一个人情味很浓的地方。\r\n在贫穷的地方人因为利益斗争更加厉害。善良也有，但麻木更多。\r\n机场建设更是将人们赶离他们的土地，而只求更多一点的利益而已。\r\n但退过来问自己：如果给够点钱，或许我也愿意搬离。 所以家乡于我是什么呢？\r\n我想要的是安全感？是一个停靠的港湾？就算那里并非是我曾熟悉的地方？\r\n或许人老了记忆是最宝贵的东西，这记忆并非一张张图片，而是一种感觉，发生过的事，一些人。\r\n\r\n而这记忆随着变迁大概也只能留在我的脑海中了，那气息也留在我的脑海中。\r\n\r\n所以，今天我告别自己的童年，我不再迷恋过去。\r\n我也不在生活在某种设定中，没有人真的在乎你的身份财富地位。\r\n我要生活在真实的世界中，每天去改变一些东西，选择一些东西，自然的开始与结束。\r\n认真的过着自己的生活，也认真的对待身边的人和事。\r\n\r\n远离那个虚妄的世界，赚取自己需要的东西，而不是在恐惧而构建自己的虚拟世界。\r\n\r\n再见了我的童年，记忆我留着，安全感我知道不在那里，需要我们去构建，去行动，增强信心，慢慢的实现。\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	1	2021-05-06 06:32:36.627072	2021-05-07 11:46:55.378107	2021-05-06	0	\N	\N	864	1	2	f	\N
865	6	27	写代码的方法论	首先一定要抑制自己上来就写，以及CURD的冲动。\r\n搞开源的经验告诉我，没有什么是可以直接拿来就用的，除非你真的弄懂它。\r\n\r\n所以写代码的步骤一定是：\r\n1，设计(除非仅设计一个函数，一个很小能一天完成的特性)\r\n2，TDD（即便自从而上编程，也建议从测试和接口入手）\r\n3，功能实现与重构	\N	\N	17	\N	3	\N	5	0	2021-05-08 06:24:23.686254	2021-05-08 06:24:23.686254	2021-05-08	0	\N	\N	865	1	2	f	\N
866	7	16	docgen	需求：可以通过网络使用的文档生成器。\r\n功能要求：\r\n1，支持多用户\r\n2，支持管理员\r\n3，支持业务模板管理\r\n4，支持上传，下载\r\n5，支持审计日志\r\n6，支持浏览器访问\r\n7，支持最近的WPS版本	\N	\N	19	\N	3	\N	5	2	2021-05-08 11:36:47.367415	2021-05-14 21:00:18.614752	2021-05-08	0	\N	\N	866	1	2	f	\N
906	7	16	swf减少内存拷贝优化	1，要先计算是否可以使用attach方式，这代价比较大。\r\n   而且中间存在被修改可能性。\r\n2，批量减少的可能性。是否凡是可以减少拷贝就启用？\r\n   目前算法是以最长字段按2次幂取整，然后计算在页面内最多能访问多少batch。\r\n3，内存应该挂在accessor上，而不是在slice上。\r\n   结构与资源的分离，使得资源可以单独管理。\r\n4，DataBuf结构需调整，标记是否支持move	\N	\N	19	\N	3	\N	5	0	2021-07-07 19:00:20.656393	2021-07-07 19:00:20.656393	2021-07-07	0	\N	\N	906	1	2	f	\N
909	6	7	C++的教训-约束的重要性，复杂与简约	如果一个系统约束很少，当然它很强大，可以各种方式使用。但是使用成本，以及各种差异带来的理解成本也非常高。\r\nC++是集大成，但是C++也被很多专业人士吐槽。\r\n\r\n包括我们设计模块也是一样，是多个子模块都暴漏，还是封装统一接口？\r\n做一件事情是有多种方法，还是留一种方法？ 要去取舍。多种方法的意义在哪里？	\N	\N	17	\N	3	\N	5	0	2021-07-14 08:32:31.078019	2021-07-14 08:32:31.078019	2021-07-14	0	\N	\N	909	1	2	f	\N
904	6	23	centos7 安装clang高版本	clang-devel.x86_64 : Header files for clang\r\ncsmock-plugin-clang.noarch : csmock plug-in providing the support for Clang\r\nllvm-toolset-7-clang-devel.x86_64 : Development header files for clang.\r\nllvm-toolset-7-clang-libs.x86_64 : Runtime library for clang\r\nllvm-toolset-7-clang-tools-extra.x86_64 : Extra tools for clang\r\nllvm-toolset-7-git-clang-format.x86_64 : clang-format integration for git\r\nllvm-toolset-7.0-clang-devel.x86_64 : Development header files for clang.\r\nllvm-toolset-7.0-clang-libs.x86_64 : Runtime library for clang\r\nllvm-toolset-7.0-clang-tools-extra.x86_64 : Extra tools for clang\r\n\r\nllvm-toolset这里就是高版本，装完之后要source一下：\r\nsource /opt/rh/llvm-toolset-7/enable	\N	\N	17	\N	3	\N	5	2	2021-07-05 18:29:31.366922	2021-09-26 19:49:26.580208	2021-07-05	0	\N	\N	904	1	2	f	\N
905	6	23	玩转git submodule	https://zhuanlan.zhihu.com/p/87053283\r\n\r\n1，修改submoudle的仓库和分支\r\n\r\n可直接修改.gitmodules文件，然后执行git submodule sync。\r\n\r\n2，更新submodule版本\r\n首先得拉去sub module,git submodule update --init.\r\n然后在目录内，执行对于的pull命令更新。\r\n这时使用git status命令就能看到sub module版本刷新了。\r\n然后在外层提交即可。	\N	\N	17	\N	3	\N	5	1	2021-07-07 08:09:08.904105	2021-10-12 06:44:10.196871	2021-07-07	0	\N	\N	905	1	2	f	\N
1000	6	24	新coast理解	概念解释：\r\nextent：extent是一个数据片段，包含一个或多个block，其是压缩和IO的单位。\r\nblock：block是一个数据片段，对于列来说其是固定记录数量的，是编码的单位。\r\nzonemap：按页粒度的统计信息。因而数据过滤的单位也是页。\r\n\r\n数据布局(列数据布局，每列如此)：\r\n1，所有block元数据，extent元数据，zonemap作为列的元数据单独一个文件存放。\r\n2，数据的所有block单独存放。\r\n\r\n列元数据结构:\r\ncolumn metadata {\r\n\textent\r\n\tblock\r\n\t[min,max]\t\r\n\t[aux(dictionary)]\r\n\t[history.min, history.max],\r\n\tcolumn meta\r\n}\r\n\r\n列数据结构：\r\nblock\r\n+\r\nblock\r\n+\r\nblock\r\n+\r\n...\r\n\r\nblock对于不同列，可能包含的数据稍微有点差别。	\N	\N	17	\N	3	\N	5	1	2022-01-11 18:20:13.048401	2022-01-11 19:11:40.239975	2022-01-11	0	\N	\N	1000	1	2	f	\N
1002	6	3	栈变量的初始化	注意不同编译器的处理有点不一样。clang不会初始化，gcc会。\r\n\r\n因而为保通用还是要自己初始化。\r\n\r\n栈内存	\N	\N	17	\N	3	\N	5	0	2022-01-18 18:15:26.517327	2022-01-18 18:15:26.517327	2022-01-18	0	\N	\N	1002	1	2	f	\N
868	6	27	windows下删除文件	windows系统中当我们在删除某个文件或文件夹时有时会提示该文件有程序在使用不能被删除，这时相当惆怅。那么可以用这个方法来找到是哪个进程在占用该文件：  \r\n\r\n1：打开任务管理器选择“性能”  \r\n2：单击下部的“资源监视器”  \r\n3：选择“CPU”，在下部可以看到“关联的句柄”搜索框  \r\n4：在该搜索框中输入要删除的文件名回车  \r\n\r\n在下面就会列出来占用该文件的进程名，右键该进程单击“结束进程”，OK，可以删除了:\r\n\r\nhttps://www.cnblogs.com/liushui-sky/p/8135292.html	\N	\N	17	\N	3	\N	5	1	2021-05-08 20:33:00.014077	2021-05-08 20:33:16.305965	2021-05-08	0	\N	\N	868	1	2	f	\N
1021	6	23	Linux虚拟机网络配置	推荐的虚拟机网络配置：\r\n1，桥接模式\r\n如果公司允许分配ip，可以使用该模式。\r\n在该模式下虚拟机和主机一样是网络中一台机器\r\n\r\n2，双网卡：NAT + Host-only\r\nNAT下虚拟机可以访问网络。但是主机不能访问虚拟机\r\nHost-only主机可以访问虚拟机\r\n\r\n\r\nhttps://www.cnblogs.com/jpfss/p/8616613.html\r\nhttps://zhuanlan.zhihu.com/p/403513377	\N	\N	17	\N	3	\N	5	0	2022-02-27 15:49:15.758032	2022-02-27 15:49:15.758032	2022-02-27	0	\N	\N	1021	1	2	f	\N
646	6	15	再论高远球	看慢动作很容易发现专业球员都是拍子倒到很右边，为什么这样呢？\r\n\r\n因为这里藏着一个秘密，就是内旋发力，这是小臂和手腕公共完成的动作。\r\n不仅是小臂前端和手腕的内旋，而是整个小臂的内旋。\r\n\r\n这也是控制拍面为正的技术，因为旋转过来必然是手掌向前的。	\N	\N	17	\N	3	\N	5	17	2020-06-20 05:34:05.145658	2022-05-20 06:31:59.812215	2020-06-20	0	\N	\N	646	1	2	f	\N
869	6	9	Storage Programmer	任何软件都涉及数据以及数据存储。\r\n有数据就有数据如何组织，如何查找，如何存储等问题，不论在内存中，还是在磁盘上。\r\n如何修改等问题。\r\n\r\n工程师：如何编程\r\nstorage工程师：如何写存储软件。	\N	\N	17	\N	3	\N	5	0	2021-05-10 07:07:51.421573	2021-05-10 07:07:51.421573	2021-05-10	0	\N	\N	869	1	2	f	\N
871	6	27	存储高性能编程	1，并行/并发执行模型\r\n   线程池模型，异步框架，内核绑定\r\n2，数据结构的并发/并行能力\r\n   数据冲突，cache，内存池。\r\n   并行扫描\r\n3，单线程单点操作延时\r\n4，单线程批量操作吞吐量\r\n6，内存相关：零拷贝\r\n   内存性能优化的关键就是减少拷贝。\r\n   本质上程序就是在重组织数据，查找数据，以及转换数据(运算).\r\n   内存拷贝与并发是矛盾的，不拷贝则冲突范围扩大。除非是Arc的。\r\n\r\n7，存储优化\r\n   压缩，对齐读，顺序读，合并sync\r\n\r\n8，内联，静态等编程语言优化\r\n9，算法优化\r\n   最精简的动作和辅助结构\r\n\r\n总结下有如下性能优化手段：\r\n1，执行模型优化\r\n2，内存优化\r\n3，磁盘优化\r\n4，算法优化\r\n5，语言优化\r\n   JIT优化，编译优化\r\n6，计算机架构优化\r\n   绑定内核，内存，特殊指令等。	\N	\N	17	\N	3	\N	5	7	2021-05-11 07:02:52.776049	2022-03-02 17:20:41.132471	2021-05-11	0	\N	\N	871	1	2	f	\N
872	6	24	元数据组织	元数据组织：\r\n\r\n<pre>\r\n表\r\n  --分片\r\n      -- 分区\r\n\t     -- del\r\n\t     -- grouplist\r\n\t\t -- group0\r\n\t\t -- group1\r\n\t\t    -- slicelist\r\n\t\t\t-- slice0\r\n\t\t\t-- slice1\r\n</pre>\r\nslicelist中包含slice基本信息，以及统计信息等，以加速整个slice过滤。	\N	\N	17	\N	3	\N	5	1	2021-05-13 08:58:30.547983	2021-05-13 08:58:48.257461	2021-05-13	0	\N	\N	872	1	2	f	\N
873	6	27	llvm&clang了解		\N	\N	17	\N	3	\N	5	0	2021-05-14 15:41:29.218158	2021-05-14 15:41:29.218158	2021-05-14	0	\N	\N	873	1	2	f	\N
878	7	16	将strife融入DBx10000	1，即支持DBx10000以任务调度方式执行。\r\n2，支持YCSB，TPCC扩展DataNode，支持range冲突判断。	\N	\N	19	\N	3	\N	5	0	2021-05-24 15:00:57.600868	2021-05-24 15:00:57.600868	2021-05-24	0	\N	\N	878	1	2	f	\N
877	6	24	crab熟悉	需要了解crab的地方：\r\n1，表达式如何持久化以及运用？\r\n2，如何实现dataset与列格式转换/\r\n3, 错误码	\N	\N	17	\N	3	\N	5	1	2021-05-19 06:54:50.644461	2021-05-23 05:46:40.028421	2021-05-19	0	\N	\N	877	1	2	f	\N
875	7	16	列存简介	存储(涉及的基本问题，类型，编解码，压缩)\r\n数据库存储引擎\r\n  事务，并发控制，空间管理，索引\r\n行式存储与列式存储\r\n列式存储的基本问题\r\n如何定位一行？如何支持修改？\r\nswordfish	\N	\N	19	\N	3	\N	5	4	2021-05-18 12:57:37.168092	2021-05-25 04:42:55.188721	2021-05-18	0	\N	\N	875	1	2	f	\N
879	6	7	思考与行动之间	做事情一定要追求真懂，未真懂之前都是瞎摸。\r\n但真懂是一个过程，有时单纯思考不如实验来得快。\r\n\r\n但终究问题在那里，解决问题的根本在于真正弄明白。这就是知识的力量。	\N	\N	17	\N	3	\N	5	1	2021-05-27 07:52:46.71723	2021-05-27 07:53:14.988548	2021-05-27	0	\N	\N	879	1	2	f	\N
886	6	24	coral review意见	1，本地存储考虑使用anchorBase，直接使用上层接口\r\n   考虑单独使用一个表。\r\n2，group概念暴露，如暴露则其规则应该非常明确。\r\n   如果以目录展示，则说明该概念也暴露。\r\n3，cache缓存解码后的数据。\r\n   改造parquet-reader，读取后可以跳过编解码这步。	\N	\N	17	\N	3	\N	5	5	2021-06-11 14:32:25.355329	2021-06-16 14:04:21.846714	2021-06-11	0	\N	\N	886	1	2	f	\N
841	6	7	我的编程体系	基本概念：实体，行为，关系\r\n基本属性：结构，封装(可见性)，约束\r\n\r\n上述概念可以扩展延伸，形成更多的子概念体系，比如行为可以并发，可以重入，可以组合。\r\n关系可以有强弱，有依存，有共生，有特定范式下的关系。\t  \r\n拓展概念：状态(可变性)，共享实体，并发行为。\r\n系统的出现都是解决问题，适应环境而存在。因具备了某些特性而得以存在。\r\n\r\n语言是一个符号系统，用于描述概念的。所以真敢号称语言无所谓的人，得真实的理解编程。\r\n就像剑客说剑无所谓，那前提是剑术达到出神入化的境界。\r\n\t\t  \r\n不安全：未定义的系统行为\r\n类型系统：本质上是约束，或者说约束的表现形式就是类型系统。\r\n    动态类型，静态类型，强类型，弱类型。上述类型可换为约束。\r\n封装：可见性，本质上就是依赖关系\r\n引用或指针：表达的是共享，有些场景必须使用共享，比如计数。clone得到的是另一个实体，无法完成计数能力。\r\n            共享还有一个目的是为了性能。为了读拷贝一个实体代价很大。	\N	\N	17	\N	3	\N	5	11	2021-04-10 13:03:52.248314	2021-07-22 06:34:01.313762	2021-04-10	0	\N	\N	841	1	2	f	\N
884	6	7	编程只有一种方法就是自顶而下	即便先写底层模块，也是在该模块内自顶而下的编程。\r\n\r\n好处是思路清晰，分解合理。	\N	\N	17	\N	3	\N	5	3	2021-06-02 05:18:06.386302	2021-06-13 06:48:53.780624	2021-06-02	0	\N	\N	884	1	2	f	\N
870	6	7	todo	1，RPC原理\r\n2，bloomfilter原理及运用	\N	\N	17	\N	3	\N	5	0	2021-05-10 07:09:18.717661	2021-05-10 07:09:18.717661	2021-05-10	0	\N	\N	870	1	2	f	\N
1022	6	23	Linux磁盘命令	查看分区：fdisk \r\n查看硬盘信息：smartctl\r\n查看io：iostat, pt_diskstat，这个可能更好用。\r\n    wget "https://www.percona.com/downloads/percona-toolkit/3.0.3/binary/tarball/percona-toolkit-3.0.3_x86_64.tar.gz"\r\n    perl Makefile.PL\r\n    make\r\n    make install\r\n查看文件系统信息：xfs.info等 xfs_info /dev/sdb\r\n查看文件空间分布：xfs_bmap	\N	\N	17	\N	3	\N	5	0	2022-03-07 18:20:12.698486	2022-03-07 18:20:12.698486	2022-03-07	0	\N	\N	1022	1	2	f	\N
867	6	24	parquet	crab到parquet文件\r\n\r\n存储方式：\r\n一个文件一个rowgroup。\r\n大约1M记录。排序后写入parquet。\r\n为什么要排序？\r\n不需要parquet的过滤能力，parquet目前也不支持。\r\n在上层过滤。只需要parquet的存储能力。\r\n能否改变R/D含义使得parquet能表达null？\r\n或null单独存储。\r\n\r\n存储方式：\r\n1，一个文件一个rowgroup，大约1M记录\r\n2，尽量使用可以直接转换的类型，避免多次编解码。\r\n   典型的例子如bit->bool->bit，bool类型仅写了就做了2次转换。\r\n3，null使用def表示。\r\n\r\n缺陷：\r\n1，null值处理的效率\r\n2，因接口类型而导致的额外编解码。以及内存与持久化格式差异引起的编解码。\r\n   parquet physical类型的意义：决定编码方式，进行比较运算？\r\n   统计信息对于coral可以在上层做，本来有些类型parquet也不感知。\r\n   编码除了常见原生类型，其他类型都使用byte编码。\r\n\r\n1，元数据，类型映射\r\n2，数据格式转换\r\n3，null值处理\r\n\r\n逻辑类型只是用于和外部做类型映射，如果上层给出了类型就不需要。\r\n看来比较运算跟逻辑类型并无关系。\r\n\r\nWriter：\r\n拿到col writer，\r\n生成def\r\n将格式转换\r\n写入\r\n\r\nReader：\r\n拿到col reader，处理page。\r\n读取def，数据信息\r\n利用builder生成crab column。\r\n\r\ncrab如何build数据？bool类型是FixLen一个特例，是共享一个builder的。\r\nallocator用法\r\n\r\nwhy need page? page是压缩的单位。按chunk压缩不好么？page主要是为了支持分批写入。\r\n不然R/D如何组织？ 另外一个原因是为了过滤。\r\n横向划分是为了过滤，纵向划分是为了project。\r\n但page大小是否固定是不一定的，尤其是存在压缩的情况，parquet和clickhouse的页面大小都不固定。\r\n不固定的大小还是页面吗？当然是的。\r\n\r\n	\N	\N	17	\N	3	\N	5	5	2021-05-08 15:34:32.89351	2021-05-26 07:13:56.725862	2021-05-08	0	\N	\N	867	1	2	f	\N
876	6	24	关于stable slice的并发修改问题	slice生成是不存在并发的，slice合并也不存在并发。\r\n我们总是在最新的group生成slice。只会对老的slice合并，如果要并行合并。\r\n可以分别对不同的group执行。\r\n\r\n且我们不支持跨group合并。可支持group内没slice时删除group。	\N	\N	17	\N	3	\N	5	1	2021-05-18 13:01:34.823788	2021-05-18 13:04:03.298763	2021-05-18	0	\N	\N	876	1	2	f	\N
981	6	7	SSDR12 软件数据结构的学问(软件复杂度)	                  结构：一定组织下的数据以及行为的集合\r\n\t\t  实体：软件结构的实例\r\n\t\t  软件系统：实体集合，理想的软件系统应该是一颗实体树(森林也可以看成树)。\r\n\t\t  \r\n\t\t  自由实体：由系统的基本类型，及其集合组成的实体。或由其他自由实体组成的实体。\r\n                     这些实体理论上可以出现在系统的任何地方。如果把结构当成一棵树，这些实体就是树叶这类较为通用的结构，其在任意分支都可存在。\r\n\t\t  非自由实体：在软件实体树上的实体，其不可随意脱离实体树。\r\n\t\t  参数实体：作为参数而存在的实体，其是自由实体的一种使用场景。\r\n\t\t  单向依赖规则：结构只能由比自己更小的结构组成。\r\n\t\t                或者说结构依赖只能单向，不可有环。\r\n\t\t  独立规则：自由实体(指可以出现在系统结构树多处的对象)不应该依赖所有权实体。\r\n                    在系统中传递的实体应该是自由实体。\r\n\t\t\t\t\t举例：数据系统固定有很多handler，handler在系统结构树上。执行某个动作需要参数。\r\n\t\t\t\t\t但是在传递时应该将参数和handler分开。其实一个是执行上下文，一个是参数。\r\n\t\t  单一职责：任何结构或行为都应该尽可能内聚。有精简合适的名称。\t\t\t\r\n\t\t\t\t\t\r\n\t\t  可见规则：结构不应该看到比自身更大范围的结构。\r\n\t\t\t\t\t结构可以看到自身以及作为参数的自由实体。\r\n                    在rust等新语言中，结构的第一个参数都是self就是这个含义，其他参数都是自由实体，唯有self例外。\t\r\n          最小可见原则：最小接口原则，只依赖该依赖的部分，只暴露该暴露的部分。\t\t\t\t\t\r\n\t\t  \r\n\t\t  \r\n          开闭原则：应该扩展软件，如不是修改。\t\t  \r\n\t\t  约束原则：实体所受的约束应该尽可能在软件范围内表达，而不是通过文档或潜规则。                  	\N	\N	17	\N	3	\N	5	7	2021-11-05 09:22:22.096249	2022-12-12 21:19:53.873708	2021-11-05	0	\N	\N	981	1	2	f	\N
874	6	9	解惑:心智 最深处的秘密	我们生活在这世界上，充满了混乱无序，不确定性，我们也通常未准备好。\r\n因而通常遇到的都是挫折和失败，生活铺面而来。\r\n这时选择划地为园是我们觉得比较安全的做法，然而对于外面和改变我们心生恐惧。\r\n我们阅读别人介绍外面的文章，各种认知。但是仍然害怕在园外的黑暗森林之中。\r\n\r\nhttps://en.wikipedia.org/wiki/A_Guide_for_the_Perplexed\r\n	\N	\N	17	\N	3	\N	5	6	2021-05-18 05:43:36.124258	2021-05-19 05:24:54.485053	2021-05-18	0	\N	\N	874	1	2	f	\N
1025	6	7	SSDR 23：实体存储方式的研究，栈，堆，应用栈	实体的存储最关键的语义在于 其是定长还是变长。	\N	\N	17	\N	3	\N	5	0	2022-03-08 06:58:51.081005	2022-03-08 06:58:51.081005	2022-03-08	0	\N	\N	1025	1	2	f	\N
1020	6	23	Linux安装桌面以及Clion	安装图形化界面\r\n\r\n步骤一：Centos7安装图形化界面，安装gnome\r\n\r\n切换到root用户，或sudo\r\n\r\n\r\n# yum groupinstall "Server with GUI"\r\n# ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target\r\n# reboot\r\n\r\n步骤二：安装xrdp\r\n# yum install -y epel-release\r\n# yum install -y xrdp\r\n# systemctl enable xrdp\r\n# systemctl start xrdp\r\n# systemctl status xrdp\r\n\r\n步骤三：设置防火墙\r\n# firewall-cmd --permanent --zone=public --add-port=3389/tcp\r\n# firewall-cmd --reload\r\n# systemctl enable xrdp && systemctl restart xrdp\r\n\r\n步骤四：远程连接\r\n\r\nhttps://www.itzgeek.com/how-tos/linux/centos-how-tos/install-gnome-gui-on-centos-7-rhel-7.html	\N	\N	17	\N	3	\N	5	3	2022-02-27 15:48:57.278996	2023-03-01 11:51:50.953019	2022-02-27	0	\N	\N	1020	1	2	f	\N
1024	6	7	SSDR 22，实体使用方式的研究，参数传递	数据类型是最基础的数据结构。\r\n  \r\n任何数据的使用都只有三种语义：\r\n  1，拷贝，生成\r\n     这种是干净，没任何依赖的，但是性能差，代价大(占空间)\r\n  2，引用，可变引用，局部引用\r\n     这种是依赖的，共享的。\r\n\t 多个引用时会产生并发问题。\r\n  3，移动，转移所有权\r\n     这种也是无依赖且无拷贝的。\r\n\r\n参数是一种特殊的实体，其在栈上保存的，这决定了其必须为定长。\r\n	\N	\N	17	\N	3	\N	5	0	2022-03-08 06:56:49.029576	2022-03-08 06:56:49.029576	2022-03-08	0	\N	\N	1024	1	2	f	\N
1016	6	18	公司软件开发平台- keep fun，keep painful	有趣有目标，恐惧压迫有多深，娱乐就有多受欢迎。\r\n公司不应该以恐惧压迫来达成目标，应该有趣有成长的达成目标。\r\n\r\n保持对目标的热情，保持痛感来调整自己活得成长。\r\n应该建立一个有效痛感的系统，而不是一个压迫恐惧的系统。\r\n\r\n\r\n<pre>\r\n一开始把事情做对固然好，我想强调的是即便开始没做好，我们应该有能力纠正。\r\n我们需要一个纠偏系统，让我们发现偏差并做出调整。\r\n就像软件开发中的重构一样，但是这有个前提：\r\n1，要及时发现需要重构的代码\r\n2，系统要能支持重构\r\n\r\n这可能就像佛洛依德和阿德勒心理学一样，一个是描述因果，一个是描述改变。\r\n\r\n反向分析，通过个人提交的代码的情况来反向分析个人，并给出改进建议。\r\n\r\n个人接收任务数量，提交的MR数，增加代码数量，删除代码数量，测试用例数量，Review意见数量等等。\r\n让开发让玩游戏一样。王者后面还有数据分析呢。\r\n\r\n就像review意见一样，其实是非常宝贵的，痛感也是如此。\r\n但是这么重要的信息居然没什么人去收集，反馈。\r\n\r\n另外的共识像新代码ut测试少到某种程度，无法通过等。\r\n如果代码问题越早发现越好，那应该及早的运用高科技对代码进行检查。\r\n而且通过条条框框，最终能否找到设计上存在的问题。\r\n\r\n除此之外，还有自动测试生成系统。\r\n\r\n</pre>	\N	\N	17	\N	3	\N	5	1	2022-02-20 10:10:56.298249	2022-03-24 06:39:48.025187	2022-02-20	0	\N	\N	1016	1	2	f	\N
1030	6	18	研究兴趣-编译原理与代码生成，及管理革命		\N	\N	17	\N	3	\N	5	1	2022-03-24 06:45:50.386215	2022-03-24 06:54:20.975178	2022-03-24	0	\N	\N	1030	1	2	f	\N
880	6	24	coral问题集	1，parquet中上层定义类型与兼容性的矛盾。\r\n   arrow项目本质上就意图解决该问题，虽然parquet是通用格式，但是由于上层格式未统一，不同系统之间仍然需进行类型转换。\r\n\r\n   如arrow成为标准内存格式，则其他系统如格式不兼容只需与arrow做格式转换。但arrow的性能也是一个大问题。其不绑定底层格式，但这样性能很差劲。\r\n   这或许是一个选择，类型系统，兼容性，性能三者的权衡。算法也是在权衡，选择。\r\n\r\nstruct DataPageHeaderV2 {\r\n  /** Number of values, including NULLs, in this data page. **/\r\n  1: required i32 num_values\r\n  /** Number of NULL values, in this data page.\r\n      Number of non-null = num_values - num_nulls which is also the number of values in the data section **/\r\n  2: required i32 num_nulls\r\n  /** Number of rows in this data page. which means pages change on record boundaries (r = 0) **/\r\n  3: required i32 num_rows\r\n  /** Encoding used for data in this page **/\r\n  4: required Encoding encoding\r\n  明确了values的数量。	\N	\N	17	\N	3	\N	5	3	2021-05-27 08:03:46.369623	2021-06-01 14:53:21.046891	2021-05-27	0	\N	\N	880	1	2	f	\N
881	6	7	工程师进阶线路图	1，熟悉常见编程模式，以及编码规则，实体行为分解，接口封装的基本功。\r\n所有暴漏的接口都将被依赖。\r\n\r\n2，善于阅读论文，技术文档，快速理解掌握的能力\r\n 这是软件开发的第一性原理，如果这个做不到，很容易瞎摸。\r\n 就像打羽毛球时以维护身体稳定性作为第一原则一样，编程的第一原则就是逻辑正确性。\r\n 由此才是高手的入门。\r\n\r\n3，综合效率阶段\r\n 能够在团队中实现综合效率，在对对手的对战中运用大脑算法。\r\n\r\n4，开拓新篇章\r\n	\N	\N	17	\N	3	\N	5	7	2021-05-30 07:00:58.430321	2022-06-30 08:13:58.228464	2021-05-30	0	\N	\N	881	1	2	f	\N
883	6	24	coral开发	将接口都封装到coral struct中，不单独暴漏函数接口\r\n错误统一到coral crate并统一分配错误码。	\N	\N	17	\N	3	\N	5	0	2021-06-02 04:56:11.287999	2021-06-02 04:56:11.287999	2021-06-02	0	\N	\N	883	1	2	f	\N
889	6	9	真实世界游戏的特征	1，主动性\r\n这是生物第一次大进化。\r\n就是得有意图，得主动行为。\r\n躺平的人难以真正强大。\r\n\r\n2，智力\r\n使得人有了更高级的策略。\r\n比如制造，使用工具。\r\nhttps://www.zhihu.com/question/38628001\r\n主要是人的大脑结构变化，使得其有处理复杂场景，以及构想的能力。\r\n确实没必要呆板的去看待问题。具体到什么样的规模具备什么能力确实值得研究。\r\n\r\n或许看到自己的思考，即自我意思，思考自己的思考这是人与动物区别最大的地方。\r\n这也是自我修炼的地方。\r\n\r\n3，大规模连接\r\n语言表达与沟通绝对是无与伦比的一次进化\r\n而且人类的语言表达+智力产生了无限可能。\r\n其核心就是语言。\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2021-06-14 05:43:30.269033	2021-06-14 05:43:30.269033	2021-06-14	0	\N	\N	889	1	2	f	\N
887	7	16	docgen	1,下载python-3.8.2-amd64\r\n2,安装python，加入path环境变量\r\n3,下载pip-21.1.2-py3-none-any.whl\r\n  安装pip: easy_install ./pip-21.1.2-py3-none-any.whl\r\n4, 安装pandas\r\n pip3 install   pandas\r\n openpyxl不好用，即便完全一样的excel和py脚本，还是会报File is not a zip file的问题\r\n5，安装docx\r\n pip3 install python-docx \r\n 注意如果版本不够，会报No module named 'exceptions'\r\n\r\n6，算法\r\n将key按字典反序排列，只要包含key就替换 	\N	\N	19	\N	3	\N	5	3	2021-06-13 19:06:26.45855	2021-06-15 07:06:31.262359	2021-06-13	0	\N	\N	887	1	2	f	\N
885	6	7	意图驱动	意图很重要，\r\n一些人的意图，这个世界就是被这种意图所驱动。每个人都有，你可以说是需求。\r\n需求是相对被动的，意图是其主动的说法。\r\n我们需要制定的是实现意图的算法。因为达到意图有很多种方法。\r\n算法，物件最终都是为了意图。\r\n\r\n物件都是人造出来的，同样遵守上述原理。\r\n\r\n我有一个意图，希望自己可以在环境优美，宁静的地方工作生活。\r\n今天出去玩之后，这种想法就更加强烈。我想让每个人都在自己想要的地方办公。\r\n可以从生存压力，恐惧中解放出来，去正向生活。\r\n\r\n很多人工作是为了满足别人的意图，从中赚取收益。以达到自己的意图。\r\n没有意义，没有积极主动的意图，因为问题有时候在于他通过工作去改变了自己，也改变了自己的意图。\r\n弱者有需求，强者有意图。旅途不一样。\r\n\r\n编程方法论，或者说做事方法论。\r\n\r\n1，编程高手\r\n2，远程工作\r\n\r\nTDD方法，我主要想利用其聚焦于设计和需求变化。\r\n自顶而下的理解事物的方式。意图驱动，需求驱动，测试驱动。\r\n\r\n不断用代码和文档表达想法。\r\n即便是自底而上的开发方法，在单个模块也是自顶而下的。\r\nTDD的T是针对接口的。TDD的核心是需求，交流，接口设计。\r\n比如这篇文章的误解：https://coolshell.cn/articles/3649.html\r\n就在于对T的错误理解，\r\n\r\nTDD好处其实很简单：\r\n1、帮你整理需求\r\n2、帮你设计接口（空想的话很容易设计出屎）\r\n3、帮你做regression和给以后重构做准备\r\n4，小步快跑，迭代式，降低复杂度，增强行动力\r\n5，不留债务\r\n6，利于设计每层的可见性，抽象隔离。\r\n8，测试让我们思考约束.\r\n9，TDD让我们尽早交流\r\n10，便于想清楚再行动，程序员的大忌就是用尝试代替思考。\r\n用猜想代替交流。\r\n不去真正的弄清楚问题的本质，这一切都是人造的，都是有意图，有原因的。\r\n11，符合生产分化原则	\N	\N	17	\N	3	\N	5	3	2021-06-07 05:29:52.502071	2021-06-18 16:51:47.361101	2021-06-07	0	\N	\N	885	1	2	f	\N
882	7	16	列存新员工培训材料	没有deadline，时间资源将会一直被消耗。	\N	\N	19	\N	3	\N	5	8	2021-06-01 07:21:21.304529	2021-07-04 13:15:52.161054	2021-06-01	0	\N	\N	882	1	2	f	\N
888	6	9	关于内卷和躺平	其实根本不存在这个问题，当人注意力在与他人竞争上，当然容易卷。\r\n但如果注意力在提升自我上，就不是卷，这是一个意图驱动的修真游戏。\r\n没有等级上限。可以有各种不同的任务种类，刻苦练习就能有所提升，有比这更好玩的游戏吗？\r\n	\N	\N	17	\N	3	\N	5	2	2021-06-14 05:19:04.535831	2021-09-13 17:27:56.176054	2021-06-14	0	\N	\N	888	1	2	f	\N
890	6	24	框架以及计划调整	AnchorCoral {\r\n  Option<Checkpointer>；通过修改记录(此处可为逻辑日志)来在Metadata基础上执行写对象动作。\r\n  Am；\r\n  Metadata；\r\n}\r\n\r\nCoral {\r\n  format；\r\n  Obs；\r\n  Option<Rlog>；逻辑日志，在对象上执行，从而保持元数据一致。在正常逻辑日志后面加一条即可？\r\n                大量过滤。先不做这个，万一生变不划算。\r\n}\r\n\r\nPN怎么搞，读取对象？即如果是DN，metadata从本地读，而PN或外部节点。\r\n则metadata从对象读取。\r\n\r\n基于时间的分组。slice的metadata中记录其分组信息。\r\nslice是不断生成的，因而组一旦老化，其中slice就会不会增加。\r\n合并时优先同组合并，否则逐渐往后合并。合并的slice放在被合并的组中。\r\n这样做的目的是维护组的时间特性。\r\n\r\n9.30可以把parquet和S3搞定部分。把AnchorBase内的元数据部分搞定。\r\n池管理	\N	\N	17	\N	3	\N	5	1	2021-06-20 08:55:05.264487	2021-06-20 09:00:03.814989	2021-06-20	0	\N	\N	890	1	2	f	\N
893	6	7	设计大纲	1，意图\r\n   why制造一个系统？为了性能？生态？现有产品一致性(因为在不同分化路径上)？\r\n   意图需要我们理解问题，理解对方，没有理解就没有善，没有理解就在门外，谈何意图。\r\n\r\n2，战略  \r\n   第二步是战略，有意图，但是没有竞争优势就会失败，我们选择去做一个系统或分化它是因为我们看到了什么。\r\n   这就是战略。\r\n\r\n3，正确性\r\n   逻辑正确性论证，设计是否能满足意图需求？\r\n   一致性，这也是正确性相关的话题，设计尽量不要犯政治或平台选择上的错误。实现意图有很多种方法，实现一个系统也有很多种方法。\r\n\r\n4，扩展性\r\n   系统在那些地方是稳定的，基本不可变的，在那些地方可以扩展。\r\n   完全不稳定性的系统是不可用的。\r\n\r\n5，连接\r\n   系统在那些地方与外部连接，怎样连接。	\N	\N	17	\N	3	\N	5	1	2021-06-20 15:20:28.262285	2021-06-20 15:31:00.390676	2021-06-20	0	\N	\N	893	1	2	f	\N
1029	8	10	ClickHouse的缺陷	SQL8 CK慢有两个原因：类似于select count(*) from ads_upc_online_store_sales_detail WHERE district = '乳源瑶族自治县' and sls_amt < 9999\r\n数据量3亿：\r\n1， district = '乳源瑶族自治县' 条件CK没法过滤，Coast可以过滤掉3/7 block。\r\n2， 行式过滤及tightly优化，虽然扫描了接近1.8亿数据，但是满足的只有5万多条。不解码的数据拷贝功不可没。\r\n3， number类型计算慢，这个比1影响更大\r\n\r\n	\N	\N	17	\N	3	\N	5	3	2022-03-23 07:36:29.33223	2022-09-14 08:29:41.302884	\N	0	\N	\N	1029	1	2	f	\N
895	6	23	C结构体初始化的写法	    RecSwfVcsRowId rec = {\r\n        .rowId.value = rowId.value,\r\n        .offset = offset,\r\n    };	\N	\N	17	\N	3	\N	5	0	2021-06-23 19:04:45.539502	2021-06-23 19:04:45.539502	2021-06-23	0	\N	\N	895	1	2	f	\N
894	6	7	设计的正确性- 如何让思考可视化	首先设计是在不同层次上工作的。从最大的几个模块入手。\r\n在一次正确性论证时，应该仅考虑同一个层次的。\r\n\r\n如何做正确性论证？ 写伪代码。\r\n既然代码是行为与实体交织而成，用伪代码来验证行为和实体是否划分合理是一种方法。\r\n不过有一点伪代码是不可直接执行的，只能由人脑来验证了。\r\n\r\n不能漫无边际的思考，设计验证和编码都不是要灵感的工作，而是需要方法和不断细化的事情。\r\n\r\n	\N	\N	17	\N	3	\N	5	2	2021-06-20 15:27:44.536237	2021-07-02 08:21:50.576791	2021-06-20	0	\N	\N	894	1	2	f	\N
897	6	9	我觉得我好像理解了什么，原来是孤独，依赖与独立	5.1回家，看着老家周围的村庄被拆除，机场高速的破土而出。我内心有一种说不出的感觉。\r\n村子未来也可能拆除，再也回不到那个是家的地方，我有一种说不出的感觉。\r\n但也有一种如释重负的感觉，或许这里将不再有人认识我，而我也可以做自己。\r\n\r\n我想我是强烈依赖于环境的。否则我怎么会害怕失去家园，\r\n害怕亲人不和，害怕表达自己的看法，害怕发表不完善的成果即便接近deadline，害怕汇报工作？\r\n我知道自己内心是害怕的，直到我直面这种感觉。直到冬寅不在家，甚至一直不回我该如何面对。\r\n\r\n有时我也想如果自己一个人该如何生活。\r\n如果那些依存，依恋，依赖都不存在了。我一个人于这个世界该如何生活？\r\n\r\n20年前如果说突然的变故带来的是灾难，20年后的今天我无可逃避，我选择面对。\r\n每个人都当写下自己的独立宣言\r\n	\N	\N	17	\N	3	\N	5	2	2021-06-30 19:13:40.992025	2021-07-01 06:34:04.545919	2021-06-30	0	\N	\N	897	1	2	f	\N
1027	6	23	static & inline & extern & 前置声明	https://blog.csdn.net/fengbingchun/article/details/51234209	\N	\N	17	\N	3	\N	5	1	2022-03-22 07:36:01.475002	2022-03-23 05:41:28.325319	2022-03-22	0	\N	\N	1027	1	2	f	\N
1028	6	7	SSDR 24: 关于命名	函数命名：主语 + 谓语 + 宾语\r\n         主语通常是模块，rust里面的self主体\r\n         谓语是动作，函数当然是在执行动作。\r\n         宾语，动作对象，通常其也出现在参数中。\r\n\r\n结构体命名： 修饰 + 名词\r\n             一般是XX器如Filter，或者按资源 XXSession, XXobject, XXContext, XXHandler\r\n             多实体结构，可以看组织结构，比如Array, Vector, HashTable 等等。	\N	\N	17	\N	3	\N	5	0	2022-03-23 06:16:20.925918	2022-03-23 06:16:20.925918	2022-03-23	0	\N	\N	1028	1	2	f	\N
1026	6	7	SSDR 24：设计模式的理解	设计模式本质上是教我们一些常见场景的编程实践。当然是围绕如何处理可变性来的。\r\n\r\n完全不用拘泥于23种或依赖关系。\r\n常用的有：\r\n状态机（封装状态转换的原则），\r\n应用栈（简化N多对象分配和释放），\r\n工厂(支持可变的生产商)，\r\n代理（处理中间关系），\r\n构建器(处理复杂可变的构建过程)，\r\n克隆，\r\n单例，\r\n迭代器，\r\n适配器(From/to),\r\n事件监听器（处理有复杂多变的事件以及接收者）。\r\n	\N	\N	17	\N	3	\N	5	2	2022-03-13 20:33:07.170749	2022-10-16 20:12:24.21458	2022-03-13	0	\N	\N	1026	1	2	f	\N
1060	7	16	yasdb列存设计教训总结	关键数据类型：number, varchar。\r\n关键指标：存储空间，初次加载性能。 占用的缓存空间，二次查询性能，批量导入性能。\r\n\r\n1，vcs多列合并存方案不靠谱，主要是合并行后，会扩大事务冲突范围，引起死锁等问题。\r\n2，vrs实际也少用\r\n3，vds是较为成功的方案，尤其是inline存储\r\n4，cbu和批量插入，批量查询应该还算比较合适的。另外插入不写undo，删除时写undo等方案目前看也还行。\r\n  批量更新尚未得到验证。\r\n5，swf虽然具备良好更新性能，但是其空间膨胀比较大。丧失了列存极致列编码压缩的好处。\r\n  其使用场景限制于即时更新和分析场景。\r\n\r\ncoast：\r\n1，extent等io单位太大，太小都不好，对于本地文件系统，1M可能太大了。\r\n会出现即便命中10%，也需要全部读取的情况。\r\n	\N	\N	19	\N	3	\N	5	0	2022-05-20 07:49:31.426652	2022-05-20 07:49:31.426652	2022-05-20	0	\N	\N	1060	1	2	f	\N
901	7	16	Deterministic DB	1，减少复制代价，使得其高性能，可扩展并且更强一致性(相对nosql)。\r\n2，去除高昂的提交协议代价，提供了吞吐量和并发性。\r\n缺点：\r\n1，缺乏交互性事务\r\n2，事务执行前的预处理\r\n\r\nCalvin\r\n\r\n\r\n三种实现方案：\r\n1，partition\r\n   Hstore，支持Partition。\r\n2，locking \r\n   要求按input log顺序加锁。\r\n   OLLP\r\n3，depend graph\r\n\r\n逻辑复制如何保证结果是对的？使用SCN序？\r\nPost-write，结果在执行后确定，因而必须使用log等机制。\r\n\r\n重点介绍了第三种方案\r\n讨论了对于MVCC的影响。serializable MVCC。\r\ndeterministic MVCC\r\n\r\n由于不会abort，修改可能可以更早的可见？ \r\n\r\n疑问：\r\n并发能力？\r\n批次执行还是流式执行？ 	\N	\N	19	\N	3	\N	5	0	2021-07-05 07:47:33.59503	2021-07-05 07:47:33.59503	2021-07-05	0	\N	\N	901	1	2	f	\N
912	6	23	火焰图并非全能	在dataset优化，减少malloc/free之后，并行性能竟然提升了4倍。\r\n但是看到的火焰图还是一样的....	\N	\N	17	\N	3	\N	5	3	2021-07-26 16:31:07.566425	2022-03-24 07:47:14.628131	2021-07-26	0	\N	\N	912	1	2	f	\N
903	6	23	莫名其妙的Curl https失效	curl: (60) Peer's certificate issuer has been marked as not trusted by the。\r\n\r\n尝试更新CA也没解决，总不能只规避问题吧，换一台机器就好了。	\N	\N	17	\N	3	\N	5	0	2021-07-05 17:22:40.827847	2021-07-05 17:22:40.827847	2021-07-05	0	\N	\N	903	1	2	f	\N
907	6	23	git submodule update失败：  fatal: reference is not a tree	原因是子模块在其他仓库，需要到对应的目录下先把repository加进来，然后fetch到本地。\r\n再更新就可以了\r\n\r\ngit remote add xierui http://XX/xierui/XX.git\r\ngit fetch xierui	\N	\N	17	\N	3	\N	5	1	2021-07-08 07:34:56.305349	2021-07-08 07:35:15.315917	2021-07-08	0	\N	\N	907	1	2	f	\N
1061	6	7	SSDR 34：并行的本质	并行有两种方式：\r\n1，垂直平行，就是将行为分割，数据不变。\r\n2，水平分割，将数据分割，再不同数据上执行相同的行为。\r\n	\N	\N	17	\N	3	\N	5	1	2022-05-23 19:11:41.665879	2022-05-24 06:48:37.230797	2022-05-23	0	\N	\N	1061	1	2	f	\N
1065	7	16	列存论文	目标：Coast是为了解决海量稳态（归档）数据的存储成本、访问效率问题而自研的存储引擎。\r\n\r\n主要的技术思路：\r\n\r\n1.自适应的数据压缩技术和基于压缩数据的直接计算（存储主要是过滤方面），无需用户干预即可获取业界最优的数据压缩率和访问效率\r\n\r\nGood to the Last Bit: Data-Driven Encoding with CodecDB\r\n\r\n\r\n PDF\r\n\r\n1.通过training model来选择匹配数据特征的编码方式\r\n\r\n2.array aggregation和stripe hash aggregation提升agg的性能、phase concurrent hashmap(PCH)提升hash join性能（针对计算引擎，非存储引擎）\r\n\r\nLightweight Data Compression Algorithms:\r\nAn Experimental Survey\r\n\r\n\r\n PDF\r\n\r\n对LDC的一个survey，系统性参考编码\r\nRevisiting Data Compression in Column-Stores\r\n\r\n\r\n PDF\r\n\r\n可以看做另外一个survey，主要回答了3个问题：\r\n\r\nRQ1: Are heavy-weight compression schemes still inappropriate for disk based column-stores?\r\n– RQ2: Are new light-weight compression algorithms better than the old ones?\r\n– RQ3: Is there a need for SIMD-employing decompression algorithms in case\r\nof a disk-based system?\r\n\r\nMorphStore: Analytical Query Engine with a Holistic Compression-Enabled Processing Model\t\r\n\r\n PDF\r\n\r\n无解压处理框架，主要是计算引擎方面的，这里可以作为参考\r\n\r\nPIDS: Attribute Decomposition for Improved Compression and Query Performance in Columnar Storage\t\r\n\r\n PDF\r\n\r\n针对字符类型的编码，主要是提取字符串模式形成子串压缩\r\n\r\nMostly Order Preserving Dictionaries\t\r\n\r\n PDF\r\n\r\n部分保序的字典编码实现和应用\r\n数值压缩参考\thttps://github.com/powturbo/TurboPFor-Integer-Compression\t\r\n2.利用条件下推和内部轻量索引实现数据提前过滤，减少上层计算数据量\r\n\r\nData Blocks: Hybrid OLTP and OLAP on Compressed Storage using both Vectorization and Compilation\t\r\n\r\n PDF\r\n\r\nPSMA、向量化和行式编译执行的结合\r\n\r\nPredicate Pushdown in Parquet and\r\nApache Spark\r\n\r\n\r\n PDF\r\n\r\n\r\n3.并行指令集处理算法（SIMD），主要用于数据编解码和数据过滤\r\n\r\nSIMD-Scan: Ultra Fast in-Memory Table Scan using onChip Vector Processing Units\r\n\r\n\r\n PDF\r\n虽然不是最高效的，但是可以当做入门paper\r\nBoosting Data Filtering on Columnar Encoding with SIMD\t\r\n\r\n PDF\r\n\r\n目前看到针对数值类型编码数据和字典编码直接做过滤的最高效实现，存储过滤参考实现，SBOOST代码部分开源，可以参考\r\n\r\nEfficient Lightweight Compression Alongside Fast Scans\t\r\n\r\n PDF\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n4.透明多级缓存/存储技术，计算存储分离，物理存储可以采用低成本的解决方案，如OBS等\r\n\r\nSequentiality and prefetching in database systems\r\n\r\nSequentiality and prefetching in database systems.pdf\r\n\r\ncache管理经典文章\r\n\r\nGCLOCK算法\r\n\r\nNb-GCLOCK: A Non-blocking Buffer Management Based on the Generalized CLOCK\r\n\r\n\r\n PDF\r\n\r\n无锁的GClock算法实现\r\n2Q: A Low Overhead High Performance Buffer Management Replacement Algorithm\r\n\r\n\r\n PDF\r\n\r\n\r\n\r\n在LRU的基础上增加一条FIFO队列，解决只访问一次的页面问题\r\n\r\nLIRS: An Efficient Low Inter-reference Recency Set Replacement Policy to Improve Buffer Cache Performance\t\r\n\r\n PDF\r\n\r\nLRU-K，2Q，LIRS算法介绍与比较_PunC的专栏-CSDN博客_lirs算法\r\n\r\nLRU上增加访问概率：recency，最近被访问的时间;Inter-Reference Recency (IRR)，同一块连续两次访问期间中间访问过的不重复块数\r\nCLOCK-Pro: An Effective Improvement of the CLOCK Replacement\r\n\r\n\r\n PDF\r\n\r\n当前AB实现的单条LRU思路基本类似，但AB还没实现对已经淘汰出去的持续跟踪\r\nCrystal: A Unified Cache Storage System for Analytical Databases\t\r\n\r\n PDF\r\n\r\n\r\nSemantic Data Caching and Replacement\r\n\r\n\r\n PDF\r\n\r\n\r\nNetco: Cache and I/O Management for Analytics over Disaggregated Stores\t\r\n\r\n PDF\r\n\r\n\r\nDelta cache\thttps://docs.databricks.com/delta/optimizations/delta-cache.html\t\r\n1.Parquets format,\r\n\r\n2.本地文件作为远程对象的缓存\r\n\r\n3.透明，自动触发，对于修改的文件自动失效\r\n\r\n\r\n\r\nManaging Non-Volatile Memory in Database Systems\t\r\nhttps://cloud.tencent.com/developer/article/1666817\r\n\r\nhttps://blog.csdn.net/u013129143/article/details/83829600\r\n\r\n1.增加NVM作为支持\r\n\r\n2.mini page的管理思路可以借鉴到二级缓存extent中页的加载\r\n\r\n3.Clock算法来管理页面淘汰\r\n\r\nSpitfire: A Three-Tier Buffer Manager for Volatile and Non-Volatile Memory\r\n\r\n\r\n PDF\r\n\r\n1.adaptive data migration：通过机器学习来决策页面在不同存储介质上的迁移\r\n\r\n2.迁移策略模型量化：Bypass DRAM during Reads (Dr )/Bypass DRAM during Writes (Dw )/Bypass NVM During Reads (Nr )/Bypass NVM During Writes (Nw )	\N	\N	19	\N	3	\N	5	0	2022-05-31 19:17:38.316292	2022-05-31 19:17:38.316292	2022-05-31	0	\N	\N	1065	1	2	f	\N
916	6	15	羽毛球技术之--只能这么打	想想我们的击球点，无外乎就几个方位，一是身前球，二是反手位球，三是身边球，四是正手头顶球，五是头顶球，六是反手头顶球，7，正手边位球。\r\n应对方法：\r\n1，跨步身前击球法，扑，挑，搓\r\n2，反手，切，抽，档\r\n3，让开身位击球，反手正打。\r\n4，马来步\r\n5，杀球，pidiao，滑板\r\n6，反手吊球，反手高远\r\n7，中国跳\r\n\r\n不要惧怕打网前，因为人跨步有限，赶到前面扑没那么容易。网前只要弧度在，对方没啥好机会。\r\n反而起球后对方机会很多。\r\n\r\n羽毛球的核心在于快，快除了基本功外(执行指令的速度)，主要是预判	\N	\N	17	\N	3	\N	5	0	2021-07-27 06:36:21.061753	2021-07-27 06:36:21.061753	2021-07-27	0	\N	\N	916	1	2	f	\N
917	6	9	从羽毛球领悟做事技巧-预判---我不喜欢被动（积极主动）	很多人做事打球都喜欢被动，因为降低了风险，同时降低了自己的能耗。\r\n然而被动通常受益不怎么好。	\N	\N	17	\N	3	\N	5	0	2021-07-27 06:37:58.413958	2021-07-27 06:37:58.413958	2021-07-27	0	\N	\N	917	1	2	f	\N
914	6	9	从打羽毛球领悟做事技巧-从别人的角度来评估选择策略（统合综效，要事优先）	显然打羽毛球新手都有一个问题：不敢打前场，为啥，因为怕对方杀。而自己又怕别人打自己的前场。\r\n这不是矛盾么？\r\n\r\n实际做事的时候我们也要做选择，要事优先\r\n带领团队时更如此，要综合效率就得打通阻塞大家的关节，这样效率才能高。所以领导者除了引领，还得有通盘考虑的问题。	\N	\N	17	\N	3	\N	5	2	2021-07-27 06:22:59.777502	2021-07-27 06:38:39.979611	2021-07-27	0	\N	\N	914	1	2	f	\N
918	6	9	羽毛球领悟做事技巧--本质上就是计算执行（孙子兵法） ---- 以终为始	打羽毛球我们经常说贯彻的好，就是达成结果得计算，计算好执行好结果自然就会好。\r\n当然有意外因素，但这是优化因素。	\N	\N	17	\N	3	\N	5	0	2021-07-27 06:49:03.832944	2021-07-27 06:49:03.832944	2021-07-27	0	\N	\N	918	1	2	f	\N
908	6	9	什么时候成人？	当我们能否解除对于各种组织(包括家庭)的依赖，转而已互利合作的方式。\r\n当我们能独立面对纷繁复杂的世界，社会时\r\n当我们接收死亡时，思考在死亡来临时我们该如何面对时\r\n\r\n当思考独立面对时，我们才会看到我们对于他人和组织的依赖，眷念。	\N	\N	17	\N	3	\N	5	2	2021-07-13 08:42:15.351823	2021-08-07 14:41:21.414507	2021-07-13	0	\N	\N	908	1	2	f	\N
1031	6	7	SSDR 25：高质量编程的技巧 (deprecated)	软件bug的根源在于：隐含的约束未被满足。\r\n\r\nrust牛逼在哪？ 通过类型系统，零成本抽象等表达了隐含约束。使得系统的行为符合预期。\r\n\r\n主要有如下几点：\r\n1，动作对称性，资源泄漏基本都是此类问题引起。\r\n2，不安全的函数，不安全的并发访问。其实实例的定义就决定了其是否是线程安全的。\r\n3，数组越界，数值越界。 严格的类型系统。\r\n\r\nC语言怎么写可以达到上述效果？\r\n1，通过命名更显示的表达，比如对称性，open/close， create/destroy\r\n2，通过运行时检查，比如进出次数必须相等，堆栈必须还原。\r\n3，通过对关联动作的封装，简化外部使用。\r\n4，通过用例来表达约束。这一招rust里面也可以用。\r\n5，通过代码分析工具。	\N	\N	17	\N	3	\N	5	1	2022-03-28 19:23:58.666358	2023-01-29 18:03:42.034448	2022-03-28	0	\N	\N	1031	1	2	f	\N
1135	7	33	待整理，编译引发的思考	1，抽象程度不够\r\n   实体概念不清晰，行为描述不准确。\r\n2，实体所在的位置搞不清晰，因而关系混乱。依赖模糊。\r\n3，有些基础工作没做到位，比如对已有实体的调研。\r\n4，我的问题在于纠结，不清楚做到什么程度算ok了，在深度上不知道何时停止，\r\n在广度上也不知道何时停止，因而效率非常低。陷自己于汪洋而无力自救。\r\n首先要搞清楚问题的规模，问题的难度，这个需要有清醒的认知。\r\n5，调研研究的基本功不够，论文与已有实践的了解不够。\r\n6，防错编程，方便问题定界。\r\n7，逃避在更大范围解决问题，而引入复杂方案\r\n   spf的vgd可见性判断以及锁定是例子，为了避免加slice锁。\r\n8，怎么把事物和问题(矛盾)讲清楚\r\n   1.从大到小的讲。\r\n   2.把复杂事务简化\r\n   3.把多个步骤进行分解\r\n   实体与外部关系非常多，内部层次也非常多。\r\n   外部关系与内部构造。\r\n   外部要求与内部行为。\r\n9，问题解决的方式\r\n   重构，在时间与空间下重构，增加什么，减少什么，改变什么关系等等。\r\n   庖丁解牛，利用实体行为的方法来解决问题。\r\n10，解决复杂问题，需多人协作问题。   \r\n\r\n实体关系论搞定技术\r\n矛盾实践论搞定业务\r\n\r\n设计展示的是思考结果而非思考过程。\r\n\r\nLSM才是HTAP的正确线路？\r\n局部数据，不可更新才好做格式变换。\r\n4K对齐，可变长页面，解决格式变换后buffer长度变化问题。\r\n\r\nLSM一致性更新问题怎么解决？数据从一个part转移到了另一个part。后面的更新可能会错过。\r\n基于LSM的TP如何解决一致性更新问题。\r\n\r\n\r\n------------------------------------------------\r\n\r\n【2022.2】tac表支持merge into功能\r\n【2022.2】TAC支持跨分区更新\r\n【2022.2】自定义LSC表冷热数据转换规则\r\n【2022.2】【分布式】分布式下merge into语法功能\r\n\r\n\r\n性能分析方法的研究\r\n1，auto trace能否用于整体性能分析？\r\n2，深圳通性能分析\r\n3，缓存性能测试：读写带宽测试。跟fio对比\r\n  可以对比损耗多少。\r\n4，缓存效果\r\n  这个就不好对比了，此问题很难解。\r\n  \r\n5，寻找云数仓的标准，以及标准测试方法，其中的性能测试部分。有没啥规范？  \r\n\r\n今天：\r\n3，s3库编译\r\n4，提交压缩代码(搞定)\r\n\r\nroot/123456 192.168.31.10\r\n\r\n1，通过环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH 修改cmake的优选路径。\r\n注意有时候没生效是因为cmake结果缓存了。\r\n\r\n1，使用动态加载理论上只能是函数指针，而不是一个定义的函数，否则会找不到定义。\r\n    编译时动态库必须有？\r\n\r\n2，如何确定正在连接的是哪个库？\r\n   cmake调试\r\n   CMakeCache.txt：可以看到不少cmake生成的信息，辅助定位。比如某个外部库使用的版本。\r\n   \r\n   FIND_PACKAGE_MESSAGE_DETAILS_CURL:INTERNAL=[/usr/lib64/libcurl.so][/mnt/squid/s3/curl_install/include][c ][v7.29.0()]\r\n//Details about finding OpenSSL\r\nFIND_PACKAGE_MESSAGE_DETAILS_OpenSSL:INTERNAL=[/mnt/squid/s3/openssl_install/lib/libcrypto.so][/mnt/squid/s3/openssl_install/include][c ][v1.1.1q()]\r\n\r\n   看上面curl选择的版本仍然不对。头文件和库对不上\r\n   注意动态库存在冲突问题，如果curl的版本与openssl对不上就可能有问题。\r\n\r\n3，curl在power pc下编译不过\r\neasy_lock.h: In function 'curl_simple_lock_lock':\r\neasy_lock.h:56:7: error: implicit declaration of function 'sched_yield' [-Werror=implicit-function-declaration]\r\n       sched_yield();\r\n       ^~~~~~~~~~~\r\n\t通过在easy_lock.h头文件中增加#include <sched.h>解决。   \r\n\t   \r\n4，查看cmake文件有哪些配置项\r\n  cmake .. -LH\r\n  \r\n  5, cmake如何确定使用的openssl版本\r\n    为啥看到CMakeCache.txt中使用的是1.0.2k。\r\n\t此外居然还会出现编译后同时使用crypto两个版本的现象。\r\n\t\r\n  5.1 这个版本的确定与头文件有没关系？\r\n    当然有关系，这个不对，可能检查出来的版本就对不上。\r\n\t\r\n6，curl编译，直接参考子目录winbuild下的readme。\r\n   nmake /f Makefile.vc mode=dll SSL_PATH=D:\\tmp\\openssl\\libcrypto-1.1.1L-win\\\t\r\n   \r\n   7，HAVE_XX 可指定吗\r\n   \r\n windows编译：\r\nhttps://docs.aws.amazon.com/sdk-for-cpp/v1/developer-guide/setup-windows.html \r\n\r\n error LNK2019: 无法解析的外部符号 __imp_curl_easy_init\r\n   \r\n   "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe" ALL_BUILD.vcxproj  -p:Configuration=Release\r\n   \r\n8，cmake在必须满足的条件没达到时，一定要拦截住。软件各种乱七八糟的问题都是考虑不全面。\r\n9，配置具备相关性，但是缺乏约束。\r\n10， makefile如何确定configure完成后的选项，以及变量   \r\n    config.log\r\n\r\n\r\n逻辑正确性问题求解。\r\n1， error LNK2019: 无法解析的外部符号 __imp_curl_easy_perform\r\n      到底是ws找不到库，还是找到的版本不对？\r\n\t  是cmake时给的库路径没有精确到文件。\r\n2，Targets may link only to libraries.  CMake is dropping the item\r\n     cmake找不到库的错误提示\r\n3，D:\\tmp\\curl-7.84.0\\curl-7.84.0\\builds\\libcurl-7.84.0-win\\bin\\libcurl.dll : fatal error LNK1107: 文件无效或损坏: 无法在 0x2F8 处读取\r\n\r\n   有说法是32与64位的问题，\r\n   使用cmake编译的时候，有一个选项，选择编译器，如果你编译的是一个32位的库，就不能选择默认的编译器，就会导致这种错误。c++/c 的编译器都是cl。在vs的vc目录下。\r\n   指定静态库搞定，但是奇怪的是动态库仍然依赖curl\r\n\r\n4，CMake Error: Error required internal CMake variable not set, cmake may not be built correctly.\r\n   Missing variable is:\r\n   CMAKE_CXX_FLAGS_DEBUGOPT\r\n\r\nwindows下实际编译命令：\r\ncmake ../  -DCMAKE_BUILD_TYPE=Release -DFORCE_CURL=ON -DCURL_INCLUDE_DIR='D:/tmp/curl-7.84.0/curl-7.84.0/builds/libcurl-7.84.0-win/include/' -DCURL_LIBRARY='D:/tmp/curl-7.84.0/curl-7.84.0/builds/libcurl-7.84.0-win/lib/libcurl.lib' -DBUILD_ONLY="s3"\r\n"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe" ALL_BUILD.vcxproj  -p:Configuration=Release\r\n\r\n\r\n打包命令：\r\ntar -zcvf libcurl-7.84.0-arm.tar.gz include/ lib/libcurl.a lib/libcurl.so*\r\ntar -zcvf aws_s3_sdk-1.9.319-arm.tar.gz include/ lib/libaws-cpp-sdk-core.so lib/libaws-cpp-sdk-s3.so\r\n\r\n	\N	\N	19	\N	3	\N	5	0	2022-11-01 17:49:37.139398	2022-11-01 17:49:37.139398	2022-11-01	0	\N	\N	1135	1	2	f	\N
925	10	30	2021-8-01	\N	\N	\N	4	\N	3	\N	5	1	2021-08-01 19:49:15.483086	2021-08-01 19:49:54.916119	\N	100	\N	\N	925	1	2	f	\N
852	6	9	谢锐6.0	使用大版本是因为目标变了。\r\n我不再以成为最好的程序员为目标，也不再以达到多强为目标。\r\n\r\n真善美：可以无限追求，那是心灵的天空。\r\n权，强，财，色：取自己那份，够了就好。多了也没啥用，老的时候也享受不了，身外之物。美女3千太过了，几个就好。资产上亿，财富自由？ 够用就行。\r\n                但不够的时候还是要调整自己去获取的。\r\n人生最重要的就是这个旅途，我们想以什么样的方式去渡过。\r\n如果我喜欢写程序并且还能获取物质等，当然非常好。\r\n如果长期做自己不喜欢的事去获取超过实际需要的物质，无疑是在对自己作恶。其实内心是不接收的。\r\n\r\n善良：就是接收改进的意思。顺从本心，且着手改变，这就是生机勃发。\r\n\r\n被恶遮蔽就看不到光明，听不见悦耳真实的声音，看不到美丽纯粹的颜色。\r\n\r\n所以我们去做一件事，从根本上是我们喜欢它，接受它。这是一段美妙的旅程不是吗？\r\n\r\n人生观：人生本就是一个体验事和物的过程，生生不息，生机畅达。\r\n\r\n我的定位：programmer，speaker\r\n作为programmer，我喜欢去理解人和事物，并用程序表达他们。\r\n作为speaker，我会努力去用自己的善去影响别人，用自己学到的知识帮助别人去体验。\r\n             作为一个自我管理者，一个教育者，帮助其他人，分享自己。\r\n\r\n\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	17	2021-04-18 04:53:37.38302	2021-08-01 19:53:16.591511	2021-04-18	0	\N	\N	852	1	2	f	\N
927	6	27	软件开发技巧之用对称性解决动作闭关问题	对称性可解决资源泄漏，可解决动作缺失。\r\n如果语言本身提供对称性检查，那么就能避免这类bug，rust做到了。	\N	\N	17	\N	3	\N	5	0	2021-08-01 19:55:00.101013	2021-08-01 19:55:00.101013	2021-08-01	0	\N	\N	927	1	2	f	\N
928	6	27	软件开发箴言	接口优先，尤其是作为接口的数据结构，应该提前稳定。\r\n\r\n不要自我重复\r\n\r\n重构而不是重写，重写意味着更换，而不是进化。其实做很多事情都有此原则，不进化则难进步，人只能在进化的路上增强，就像更换工作一样，频繁换方向肯定是不利的，每个方向都得走别人的老路。\r\n\r\n事件机器，小步快跑\r\n显式约束，约束必然存在，约束让事物成为他自己\r\n最小知识，可见性是软件可变性的灵魂，这也是自然法则，自然也没有把所有复杂性直接展现给人。\r\n依赖和独裁是一对，依赖意味着变化就带来极大痛苦，减少依赖控制，明确互赖是更合适的道路。\r\n\r\n组合通常胜过继承，公司制胜过家族制，本质还是在于更好的可变性。\r\n稳定性是高手之间的差距，也是难做的	\N	\N	17	\N	3	\N	5	1	2021-08-01 19:58:26.278645	2021-08-01 20:00:12.520035	2021-08-01	0	\N	\N	928	1	2	f	\N
1033	6	23	static inline函数与coredump	<pre>\r\n内联函数的coredump堆栈异常问题\r\n\r\n代码函数如下：\r\n\r\nxx.h\r\nstatic inline function doxx()\r\n{\r\n\r\n  COD_ASSERT(xx)\r\n}\r\n\r\n注:.c中的inline同样有此问题,单纯static无此问题\r\n\r\nyy.c\r\nfunction example() \r\n{\r\n   COD_ASSERT(xx);\r\n   doxx();  \r\n}\r\n\r\n代码core掉，coredump堆栈显示core在doxx的COD_ASSERT.\r\n然而定位下来发现实际core是在example中的COD_ASSERT。\r\n\r\n这样导致误判问题出现的现场，怎么分析都发现不了问题。\r\n切记存在该情况，如果带inline函数，实际core的地方可能并非如coredump所示。\r\n</pre>	\N	\N	17	\N	3	\N	5	1	2022-03-31 18:12:27.245003	2022-03-31 18:44:04.638959	2022-03-31	0	\N	\N	1033	1	2	f	\N
930	6	27	软件的正确性	当然可能几乎没有软件工程师敢声称自己的软件是正确的。\r\n正确在这里是指在各种输入，各种并发，任何时刻的故障下软件的行为是可预期的。\r\n这件事情为何难以做到？\r\n因为在一个复杂系统中，存在很多隐式约束和没有处理的漏洞。\r\n尤其是一个系统在不断发展演进的过程中。\r\n\r\n后续的修改可能又在不断增加债务。增加不合理的依赖或隐式约束，或漏洞。\r\n\r\n最终软件的进化变得缓慢，经常查缺补漏，又不断重构或重写部分逻辑。	\N	\N	17	\N	3	\N	5	2	2021-08-07 14:49:31.344371	2021-08-07 15:06:58.915154	2021-08-07	0	\N	\N	930	1	2	f	\N
931	6	9	计算与思考 - 孙子兵法，原则	其实就是计算机器，程序的力量。\r\n使用模型进行运算。计算是精确的，可量化，可重复的。\r\n\r\n思考通常是发散式的，综合归纳式的，创新式的，需要灵感。\r\n得到的结果通常是概括性，抽象性的。\r\n\r\n对于确定性问题，使用计算效果更好。\r\n对于非确定性问题，需要想象力，灵感，思考。	\N	\N	17	\N	3	\N	5	2	2021-08-07 19:27:54.189151	2021-08-12 05:49:33.882778	2021-08-07	0	\N	\N	931	1	2	f	\N
1034	6	23	静态库的重复定义：rust downcase类型失败	一个静态库在程序中出现多次，且出现\r\n\r\n1，libAInstance1\r\n2，libAInstance2\r\n\r\nlibAInstance1.Type1 downcast_to libAInstance2.Type1 失败。	\N	\N	17	\N	3	\N	5	0	2022-04-01 13:00:35.643043	2022-04-01 13:00:35.643043	2022-04-01	0	\N	\N	1034	1	2	f	\N
933	6	9	生活的寄托-谈信仰	即便经过3年多的开悟思考，在独自一人时偶尔仍然不知干啥。\r\n翻翻视频，找找游戏，最终还是徒劳。\r\n回老家去远方又能解决什么问题呢？ \r\n\r\n在老家研究吃，搞搞玩的？时间长了呢？\r\n\r\n我们寻找精神力量，这代人缺乏的正是这些。\r\n生活了然无趣，工作亦如此。\r\n\r\n很多人忽略了生活本身就很难得事实，不是难在生存和内卷。\r\n而是难在生机活泼，这需要人去探索发现，去维持一颗新鲜的心。\r\n\r\n有的人每天都是一张白纸，有的人每天起来都感觉纸上无去可写。\r\n信仰本质上就是精神依赖，还是中国古人高明。儒家，佛家都不谈信仰。\r\n生生不息，生机畅达，生活就是生活，其本质也只能来自于生活本身。\r\n如果其本身了然无趣，在其他地方也找不到。	\N	\N	17	\N	3	\N	5	0	2021-08-13 06:31:21.696898	2021-08-13 06:31:21.696898	2021-08-13	0	\N	\N	933	1	2	f	\N
1032	6	23	动态链接与静态链接	静态链接是要生成可执行内容的，因而必须是有定义的。\r\n而动态链接只需要声明，在最终执行时能找到符号即可。\r\n\r\n同理，如果共享库想被静态链接，最好其中不要包含全局变量，否则就涉及重定义。\r\n\r\n当然作为自由实体的公共库，本来也不应该有全局变量这种非自由实体。	\N	\N	17	\N	3	\N	5	0	2022-03-30 17:49:08.38993	2022-03-30 17:49:08.38993	2022-03-30	0	\N	\N	1032	1	2	f	\N
951	6	7	SSDR6: 计算机的基本问题理解	1，计算机的发明\r\n  这是数学理论（二进制，布尔代数，数理逻辑）等学科发展，以及物理（电磁，晶体管）等发展的背景下产生的。\r\n  也是计算需求激增下的必然，为什么计算激增？这又跟航海和军事等有关系。\r\n2，指针是什么\r\n  指针是可变的间接地址。不是直接地址(变量名)，也不是间接地址（引用）。\r\n3，C语言引入了什么？\r\n  确定了高级语言的雏形，作用域？类型系统？结构体？编译跨平台？\r\n4，动作，增删改查 4个基本动作，执行流程，顺序，选择，循环执行的理解\r\n4.1 动作对称性\r\n5，实体，数据结构，组合与关系的理解\r\n6，接口与抽象，接口的本质是等价性，等价性有个特征是可替换，即实现了内部可变性。\r\n6，可见性，不同层次\r\n6，模块化，空间隔离性，空间的本质就是隔离性，在有限时间内不可达到。\r\n7，可变性\r\n8，原子性\r\n9，一致性，顺序，因果\r\n10，时间，时间是顺序，也是因果，时间具备全局性。\r\n11，持久性\r\n12，复杂性\r\n12，并发性\r\n13，约束	\N	\N	17	\N	3	\N	5	4	2021-09-24 07:04:33.81109	2021-09-24 07:32:18.74124	2021-09-24	0	\N	\N	951	1	2	f	\N
966	6	9	论自由	真相是我们做自由抉择的基础，如果没有真相，那就没有自由。\r\n为什么理解很重要。选择我们所关注的事情很重要，没人应该做乌合之众。没人应该把自己的大脑交给别人。	\N	\N	17	\N	3	\N	5	4	2021-10-04 13:11:26.483455	2022-08-08 06:55:02.680194	2021-10-04	0	\N	\N	966	1	2	f	\N
956	6	9	思维的4种境界	1，无知，从外部看待事物\r\n2，有知，从内部认知事物\r\n3，无物，将物融入自己的认知体系，在体系内用概念映射\r\n4，无我，思维中已忘记了自己的体系，将自己的系统融入自然体系\r\n\r\n众生如佛说的就是这个意思，每个人都可以将思维修炼到第四种境界。	\N	\N	17	\N	3	\N	5	1	2021-09-26 07:17:37.444066	2021-10-24 07:02:39.827359	2021-09-26	0	\N	\N	956	1	2	f	\N
954	6	23	ca证书问题，self signed certificate in certificate chain	self signed certificate in certificate chain	\N	\N	17	\N	3	\N	5	4	2021-09-24 16:51:21.535046	2021-09-26 15:06:13.461506	2021-09-24	0	\N	\N	954	1	2	f	\N
1063	6	27	如何review代码	1，正确性，抓住关键分析逻辑正确性\r\n  第一轮看代码正确性。主要是核心逻辑，避免实现上的根本风险，导致完全重写。\r\n  哪些是核心逻辑? 比如vgd，其状态切换就是核心。\r\n  实体关系，以及重要的行为，主路径。\r\n  并发下的正确性。\r\n\r\n2，效率，理清结构，减少bug和代码反复重构。\r\n   \r\n3，友好性\r\n\r\n其实开发也是上述过程\r\n   	\N	\N	17	\N	3	\N	5	0	2022-05-24 12:03:49.944168	2022-05-24 12:03:49.944168	2022-05-24	0	\N	\N	1063	1	2	f	\N
961	6	1	coral todo	IR7-SR7 LSC Table性能优化之支持分区剪枝(待自验证)    10.11\r\nIR7-SR6 LSC Table性能优化之支持并行查询(待自验证)    10.11\r\n表slice元数据管理\r\nLSC表空间管理\r\nIR7-SR2 LSC 存储数据压缩 (加配置项，指定字段压缩方式，需求来源) \r\nIR7-SR1 支持LSC Table的DDL (表 create,drop, alter暂不支持)   10.13\r\nIR7-SR3 分布式下LSC Table支持批量插入(分布式，写入转换)      已支持\r\nIR7-SR4 LSC Table的查询                                      已支持            \r\nIR7-SR8 LSC Table性能优化之支持字典压缩                      3天\r\nIR7-SR10 单机下LSC Table支持批量插入                         10.12\r\nIR12-SR3 备份/恢复工具	\N	\N	17	\N	3	\N	5	0	2021-09-29 07:50:49.757859	2021-09-29 07:50:49.757859	2021-09-29	0	\N	\N	961	1	2	f	\N
962	6	7	SSDR8：再论性能优化的方法及其本质	1，减少不必要的工作，算法优化\r\n  比如数据库中的filter以及project，都是去掉实际不参与运算的数据。\r\n  减少数据拷贝，copyOnWrite，减少io，减少网络交互。\r\n2，并行化，分布式，无锁化\r\n  多个人干活\r\n3，批量化\r\n  一次处理更多，吞吐量优化\r\n4，cache以及预计算\r\n  cache本质上是将动作缓存，即用空间换时间，用状态缓存代替运算动作。\r\n\r\n基本原理：\r\n1，木桶原理\r\n	\N	\N	17	\N	3	\N	5	11	2021-09-29 14:50:25.014407	2023-04-24 07:15:01.592502	2021-09-29	0	\N	\N	962	1	2	f	\N
967	3	24	coral重构	表id(64位)和slice id(32位)\r\n作为唯一标识。\r\n\r\n如果是外部slice，则视为link slice。\r\n\r\ncoral目前是一个格式管理和文件存放的接口库。不是一个独立的存储引擎。\r\n等元数据同步也具备后，其可以暴漏表接口，就成了table format或者叫table engine。\r\n现在还是format + obs。大脑在metadata\r\n但仍然coral不是独立数据库引擎，其dml的ACID仍然不在coral中保证。\r\nmetadata仅同步，即没有所谓的PN，都是DN。要么就是把任务打包发给PN执行，而不实际同步元数据。\r\nDN要支持某些tablespace不进行同步。\r\n\r\n或者说存在PN并不意味着我们需要实时同步元数据。\r\n\r\n1，id和字符串有本质区别吗？没有，问题的核心在于如果id或名字是外部产生的，那么\r\n应该由产生它的系统来解释它。这样就没有矛盾。\r\n   即OBS不知道ID的确切含义，ID是抽象的，同样OBS也不知道路径的含义，OBS仅将其作为一个标识。\r\n	\N	\N	17	\N	3	\N	5	1	2021-10-07 05:56:59.136586	2021-10-07 07:42:19.10062	2021-10-07	0	\N	\N	967	1	2	f	\N
935	7	16	pg统计信息	记录方法：\r\nhttp://mysql.taobao.org/monthly/2016/05/09/\r\n代码：compute_scalar_stats\r\n对于pg_statistic的5组属性，会根据需要进行填充。这是由列的属性决定的。\r\n而每组内填多少组值也是变化的。\r\n5是pg支持的统计类型决定的。\r\n\r\n\r\n如何使用：\r\n遍历stakind1~5，找出我们支持的类型，MCV/HISTOGRAM\r\n对于满足的类型i，获取stavalues{i} 和 stanumbers{i}。\r\n去除其中的数组，每个作为一个bucket来填充。\r\n\r\n使用的关键数据结构：\r\n/* Result struct for get_attstatsslot */\r\ntypedef struct AttStatsSlot\r\n{\r\n\t/* Always filled: */\r\n\tOid\t\t\tstaop;\t\t\t/* Actual staop for the found slot */\r\n\tOid\t\t\tstacoll;\t\t/* Actual collation for the found slot */\r\n\t/* Filled if ATTSTATSSLOT_VALUES is specified: */\r\n\tOid\t\t\tvaluetype;\t\t/* Actual datatype of the values */\r\n\tDatum\t   *values;\t\t\t/* slot's "values" array, or NULL if none */\r\n\tint\t\t\tnvalues;\t\t/* length of values[], or 0 */\r\n\t/* Filled if ATTSTATSSLOT_NUMBERS is specified: */\r\n\tfloat4\t   *numbers;\t\t/* slot's "numbers" array, or NULL if none */\r\n\tint\t\t\tnnumbers;\t\t/* length of numbers[], or 0 */\r\n\r\n\t/* Remaining fields are private to get_attstatsslot/free_attstatsslot */\r\n\tvoid\t   *values_arr;\t\t/* palloc'd values array, if any */\r\n\tvoid\t   *numbers_arr;\t/* palloc'd numbers array, if any */\r\n} AttStatsSlot;\r\n\r\n\r\n具体填充方法，对于MCV：\r\n1，stavalues{x} => bucket{x} endpoint value\r\n2，freq{x} => bucket{x} endpoint number\r\n3，distinct为常量1\r\n\r\n对于HISTOGRAM(等高直方图)\r\n1，stavalues{x} => bucket{x} endpoint value\r\n2，freq{x} =>  1/num histogram\r\n3，？？\r\n\r\n注意：stadistinct可能是负值。\r\n\r\npg中的使用方法，参考函数calc_hist_selectivity\r\n	\N	\N	19	\N	3	\N	5	0	2021-08-14 18:51:23.822298	2021-08-14 18:51:23.822298	2021-08-14	0	\N	\N	935	1	2	f	\N
938	6	23	vargrind内存检查	valgrind --leak-check=yes --error-limit=no	\N	\N	17	\N	3	\N	5	0	2021-08-19 19:10:35.381724	2021-08-19 19:10:35.381724	2021-08-19	0	\N	\N	938	1	2	f	\N
939	6	7	软件的性质	对称性---解决动作遗漏\r\n可见性---控制复杂度\r\n稳定性---函数，变量，事物都该有名字\r\n可变性---变量可变性\r\n         结构可变性---架构的关键，变化的成本。\r\n关联性(依赖性) --- bug之源，隐藏依赖。\r\n共享性(重复性) --- 效率的根本\r\n并发性 ----- 真实世界的模样\r\n计算------软件的根本\r\n结构与分化------- 系统的根本	\N	\N	17	\N	3	\N	5	1	2021-08-23 06:29:04.003657	2022-09-13 09:25:43.322452	2021-08-23	0	\N	\N	939	1	2	f	\N
945	6	7	SSRD2:软件开发的真相	1，定义实体\r\n2，定义实体行为接口\r\n3，处理实体与其他实体的关系\r\n4，处理实体在其他行为中的动作关系。\r\n\r\n最终构成一个更大的实体，能否提供更加复杂与丰富的行为。\r\n这与自然进化何其相似。\r\n\r\n软件变革在于发现新的系统特性，比如互联，比如智能\r\n软件的高度自主是否符合当下社会？	\N	\N	17	\N	3	\N	5	19	2021-08-31 06:33:21.079802	2022-09-13 09:37:38.619161	2021-08-31	0	\N	\N	945	1	2	f	\N
941	6	15	展肩的重要性	我思前想后，看自己的动作总不对劲。\r\n终于看出了点门道， 不对劲在于没有展肩。含肩打球容易受伤，而且不好看，切记切记！！！	\N	\N	17	\N	3	\N	5	0	2021-08-23 06:33:41.184143	2021-08-23 06:33:41.184143	2021-08-23	0	\N	\N	941	1	2	f	\N
920	6	23	centos 升级gcc版本问题，找不到各种头文件问题	升级：\r\n$ sudo yum install centos-release-scl\r\n$ sudo yum install devtoolset-7\r\n\r\n生效：\r\n$ source /opt/rh/devtoolset-7/enable\r\nor\r\n$ source scl_source enable devtoolset-7\r\n\r\nsource /opt/rh/llvm-toolset-7/enable\r\nsource /opt/rh/devtoolset-7/enable\r\n\r\n注意有时候加到bashrc也没生效，可能是有些脚本启动后环境变化引起。\r\n可以在当前session中再次执行上述命令，再执行脚本试试	\N	\N	17	\N	3	\N	5	1	2021-07-28 08:29:18.253448	2021-08-23 12:21:00.159987	2021-07-28	0	\N	\N	920	1	2	f	\N
942	6	7	SSRD1：软件架构是什么		\N	\N	17	\N	3	\N	5	9	2021-08-23 06:34:35.988241	2023-04-04 11:47:59.147667	2021-08-23	0	\N	\N	942	1	2	f	\N
943	7	16	20210-8-23	1，验证dataset问题\r\n   完成，已通知jingdong\r\n2，投入rowid和index一致性问题。\r\n   深水区\r\n3，实验项目\r\n   改为在执行期间sleep看效果，MVCC咋办？\r\n      \r\n   YCSB，key冲突才会abort，找出冲突key进行调度\r\n   MVCC如何放大冲突域，可能不太好控制，锁时间太长或有问题。\r\n   \r\n   row上的抢占锁或许是影响性能的一大因素。\r\n4, 内存拷贝优化的sdv验证。\r\n   修复了core问题，link accessor的数据来源不一样了。\r\n   封装的意义体现出来了。不直接访问，也是一种让关联显式化的方法。	\N	\N	19	\N	3	\N	5	0	2021-08-23 18:02:54.68589	2021-08-23 18:02:54.68589	2021-08-23	0	\N	\N	943	1	2	f	\N
944	7	16	swf列存的字典方案	对外规格\r\n1，哪些列使用字典\r\n2，用户指定还是自动识别，如何指定？如何识别？\r\n   是否可见\r\n\r\n接口\r\n1，如何读取字典列？\r\n   存储计算打通，如何在内存中表示字典\r\n\r\n存储格式\r\n1，字典怎么存\r\n   字典序与数值序一致，字典是否存在删除，顺序如何维护。\r\n2，字段值如何与字段关联\r\n3，字段是否同时存在字典值与实际值形态\r\n\r\n并发更新： 	\N	\N	19	\N	3	\N	5	0	2021-08-27 08:01:32.007136	2021-08-27 08:01:32.007136	2021-08-27	0	\N	\N	944	1	2	f	\N
948	6	9	秦时明月，抉择：如果你在看对错，好坏，那么你将受制于他们	如果你在于别人的眼光，如果你在比较，那么也难以跳出其限制。\r\n你觉得要买房，要稳定工作，要学习，这不是抉择。\r\n抉择是事物内在规律在怎么变化，我们想要它怎么变化，处于什么状态。\r\n	\N	\N	17	\N	3	\N	5	1	2021-09-08 07:35:45.263559	2021-09-11 14:58:07.444179	2021-09-08	0	\N	\N	948	1	2	f	\N
946	6	7	SSDR3：Tidb分布式的缺陷	采用主键分区，执行优化不感知数据分布，很多请求全部打散到各个节点。\r\n导致了TiDB的每条命令代价都很大。	\N	\N	17	\N	3	\N	5	1	2021-09-08 06:32:59.264865	2021-09-08 06:41:11.181162	2021-09-08	0	\N	\N	946	1	2	f	\N
947	6	7	SSDR4：字典与可变性	世界上每个人都有一部字典，但是字典刷新了每个人都得换一份，这是巨大的资源浪费。\r\n想想一个字典占100M，发布一个新版本得浪费多少存储空间。	\N	\N	17	\N	3	\N	5	1	2021-09-08 06:53:36.79377	2021-09-08 17:33:27.217395	2021-09-08	0	\N	\N	947	1	2	f	\N
955	6	7	SSDR7 空间，时间，物质与计算机	空间是容器，具备隔离性，分割性，不可立即达到。\r\n空间内容纳物，物是基本粒子在不同组织下的产物，即结构。\r\n\r\n计算机中内存，磁盘等充当空间，而其上的信息就是物。\r\n物质是特定的结构，没有空间物质就没有承载。\r\n\r\n物质在运动，运动让物质结构发生变化，计算单元就是一个变换器。\r\n物质在其中发生反应产生新的物质。\r\n\r\n我不清楚是自然系统在指导我学习计算机还是计算机在指导我学习自然系统，\r\n但我知道人脑的灵感和思考源自于 将事物相关联起来，组合反应得到新的事物和认知。\r\n而割裂的看待事物，将物与心分离让人丧失灵感	\N	\N	17	\N	3	\N	5	0	2021-09-26 07:11:40.515819	2021-09-26 07:11:40.515819	2021-09-26	0	\N	\N	955	1	2	f	\N
953	6	9	落到实处就有效果	做事不可浮于表面，靠投机取巧，要做到实处，掌握根本才能快速进步。\r\n投机取巧不得根本，其代价是始终无法得到知识。\r\n	\N	\N	17	\N	3	\N	5	0	2021-09-24 07:39:40.033844	2021-09-24 07:39:40.033844	2021-09-24	0	\N	\N	953	1	2	f	\N
963	6	18	做一个形式系统，可以模拟个体的形式系统	如果将人作为一个形式系统，那么人的逻辑可以保留下来。\r\n那么就有一个虚拟的我，这个我拥有我的思维。	\N	\N	17	\N	3	\N	5	0	2021-09-30 07:11:59.030853	2021-09-30 07:11:59.030853	2021-09-30	0	\N	\N	963	1	2	f	\N
959	6	23	linux软件源管理之epel	https://blog.csdn.net/weixin_41831919/article/details/109035936\r\n\r\n\r\nEPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux.\r\n\r\n我们在Centos下使用yum安装时往往找不到rpm的情况，官方的rpm repository提供的rpm包也不够丰富，很多时候需要自己编译很痛苦，而EPEL恰恰可以解决这两方面的问题。EPEL的全称叫 Extra Packages for Enterprise Linux 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。\r\n————————————————\r\n版权声明：本文为CSDN博主「不忘初心fight」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\r\n原文链接：https://blog.csdn.net/weixin_41831919/article/details/109035936	\N	\N	17	\N	3	\N	5	0	2021-09-27 07:12:08.86617	2021-09-27 07:12:08.86617	2021-09-27	0	\N	\N	959	1	2	f	\N
960	6	9	说到底都是唯物辩证法	https://zhuanlan.zhihu.com/p/256353125\r\nhttps://www.zhihu.com/question/404556789	\N	\N	17	\N	3	\N	5	2	2021-09-28 06:16:49.209723	2021-09-28 06:25:23.226375	2021-09-28	0	\N	\N	960	1	2	f	\N
957	6	9	唯物与唯心，理论与实践，科学与宗教	需要将其结合起来，心灵意识让我们有了认知，客观与实践让我们修正认识。\r\n\r\n科学的一个重要特征是可证伪，即判断的统一标准。\r\n而宗教，基督教最初对于统一认知的追求促进了科学的发展。\r\n宗教显然比追求利益的政治团体更能促进科学的进步。\r\n我觉得这是很多团队无法孕育出科学的根本原因。\r\n\r\n各路大神，牛人都在搞什么，就是在看自己能认知世界万物到什么层次。以及能做出什么样的行为。	\N	\N	17	\N	3	\N	5	3	2021-09-26 10:38:55.195004	2021-09-30 06:54:39.257721	2021-09-26	0	\N	\N	957	1	2	f	\N
964	6	9	学习与思考的关系，知和行的关系	学而不思则罔，思而不学则殆。\r\n\r\n学习的时候有一点很尴尬，就是作者的背后是有一套可以解释世界的系统，然而写成书却通常成为了知识点的堆砌。\r\n然而问题也在于此，作者即便用一句话把核心要领说出来，却仍然需要我们的系统能领悟并融入其中，这是思考和学习的区别。\r\n\r\n学和思考应该是同时进行的，否则学成了死记硬背，而思考成了天马行空。\r\n其实知和行的关系也是如此，行动的时候不思考，没有抉择，纯粹习惯性肯定是不行的。\r\n光认知，不行动也是不行的。就像没有运动的物体一样。	\N	\N	17	\N	3	\N	5	0	2021-10-04 12:33:06.969616	2021-10-04 12:33:06.969616	2021-10-04	0	\N	\N	964	1	2	f	\N
965	6	9	如何看待努力	消极的努力的人就是奴隶。\r\n努力显然并非人的自然状态，没有人说做自己喜欢的事情是在努力。\r\n\r\n努力是无所适事的人的避难所。人需要的不是努力，是热爱和激情，是回到灵魂所在的地方。\r\n\r\n就像人需要的并非是控制或压迫，而是自由，是源自对于对世界真相理解下的自由抉择。\r\n致良知之所以有效在于人们忘记了常识这种最重要的认知，而回观内心我们就能找回这种常识。	\N	\N	17	\N	3	\N	5	0	2021-10-04 13:09:48.574297	2021-10-04 13:09:48.574297	2021-10-04	0	\N	\N	965	1	2	f	\N
958	6	9	哲学基础	1，物质由基本粒子组成\r\n2，物质有波粒2象性\r\n3，质量和能量是物质的不同属性，或者说物质在不同形态下所展现的属性。\r\n4，运动与结构化是物质的基本属性\r\n   	\N	\N	17	\N	3	\N	5	3	2021-09-27 06:58:05.103788	2021-10-26 07:17:21.86289	2021-09-27	0	\N	\N	958	1	2	f	\N
984	6	9	谢锐 7.0	目的：生存与生机畅达。获得人生的大成。\r\n手段：通过学习与实践，变得更加强大，能处理各种问题，包括人的问题。\r\n态度：绝不自我压制，不恐惧，不依赖，走独立自由之路，探索规律和秘密，\r\n      通过生活获得生机。\r\n      不恐惧则不追求名声，面子这些表面之物。\r\n      不依赖则不追求成就，一怕一时得失，始终持之以恒。\r\n  	\N	\N	17	\N	3	\N	5	34	2021-11-12 07:01:43.522953	2023-03-25 06:55:35.993724	2021-11-12	0	\N	\N	984	1	2	f	\N
1040	6	20	2022.4.8 做一款开源，稳定可靠，高性能的存储引擎	这当然是我的目标，然后根据机会进行调整，支持数字实体崛起。\r\n从而极大提高人的资源和效率，适应人越来越宅，，生存环境恶劣，体能弱化等方面的问题。	\N	\N	17	\N	3	\N	5	0	2022-04-08 05:56:29.923262	2022-04-08 05:56:29.923262	2022-04-08	0	\N	\N	1040	1	2	f	\N
1035	6	9	 头号玩家观后感	\r\n头号玩家观后感：\r\n或许虚拟世界真的是未来的发展方向。\r\n另外从某个层度讲，我们这世界跟虚拟世界又何其相似。\r\n知识如同魔法一样，把那些没有掌握知识的人变成社会的弱者，排除在外。\r\n同样暴力武器都被统治者掌控。\r\n对这世界最深刻的认知才是解开游戏的密码。\r\n\r\n商业的本质是在为社会寻找答案，去解决那些困扰着人们的问题。\r\n去引导人们以怎样的方式去生产，生活。如果这样我们便是企业家而不是奴隶。\r\n\r\n我不想改变世界，但我想改变我的生活方式，我想让人回归生活，每个人都应该有基本的物质保障。\r\n即便不工作，这是自然赋予人的，也是技术赋予人的。而它却被有些人拿走了。\r\n\r\n虚拟世界和现实世界是相辅相成的，我们通过在虚拟世界中技术+现实世界其他辅助技术。\r\n最终可能造成现实世界的全面进步。就像电脑和手机给人类带来的。它们需要软件。\r\n我们构建虚拟世界当然是因为我们知道它们能帮助我们改进现实世界。\r\n\r\n让软件给人派活，而不是人来管理，我们需要的是规则。有规则才有自由。\r\n不是实现让人改变，而是人让现实发生改变。软件及工具来适应人。\r\n而规则能够达成的前提就是契约精神。否则软件与工具只会成为压迫手段。\r\n为什么工作并非如此？\r\n\r\n\r\n在虚拟世界中识别物体，展示物体跟虚拟世界一样。\r\n虚拟实物一样具备价值，具备独一性的结构。\r\n问题的根本在于如何构建出具备足够复杂度虚拟实体。\r\n并且让实体具备不可复制性？无穷多的神经网络？输入的干扰性？\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2022-04-03 22:54:17.906865	2022-04-03 22:54:17.906865	2022-04-03	0	\N	\N	1035	1	2	f	\N
969	6	9	逻辑，真相，抉择, 死亡	冰与火：只有一个神，就是死神。\r\n不必恐惧，每个人都有自己当下的状态，不能说我们没达到某个状态就心生恐惧。\r\n\r\n强大得有强大的世界观和方法论。按逻辑而行。\r\n经济只是世界的一个维度，有人以为它超越了灵魂的重要性。	\N	\N	17	\N	3	\N	5	3	2021-10-07 06:00:23.183138	2021-10-07 07:57:41.390921	2021-10-07	0	\N	\N	969	1	2	f	\N
1039	6	7	SSDR 26：CPU技术	确定CPU是否是虚拟化的：\r\nlscpu命令可查看CPU虚拟化类型。物理机貌似不存在Hypervisor vendor。\r\n\r\nHypervisor vendor:     KVM\r\nVirtualization type:   full\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2022-04-07 14:15:28.096553	2022-04-07 14:15:28.096553	2022-04-07	0	\N	\N	1039	1	2	f	\N
977	6	6	论共识的重要性	没有共识人类无法建立大规模社会团体。\r\n没有共识就没法建立科学体系，经济体系。\r\n\r\n可以说古代中国没法前进的原因也是因为没法建立普遍共识。\r\n没有苏格拉底的三段论，没有亚里士多德的第一性原理。\r\n当然人们有道德上的一些共识，并且这些共识是无法革新的，它更多的是约束，而无太多创造性。\r\n统治者让人始终处于贫穷状态，无知状态，知识无法很好积累传播。顶多有人思考如何适应社会的问题，如何解脱痛苦的问题。\r\n少有人问及这世界究竟是怎样的问题。\r\n\r\n统治者的共识可能最终无法推动社会进步。因为社会绝大多数人是贫民。\r\n或者说从根本上统治者的共识与变革是相违背的。因为变革必然意味着一部分人将崛起，那统治者的一部分人得让位。\r\n	\N	\N	17	\N	3	\N	5	0	2021-10-24 08:03:53.284901	2021-10-24 08:03:53.284901	2021-10-24	0	\N	\N	977	1	2	f	\N
979	6	7	SSDR10：事务的本质	事务的本质在于探寻两个动作序列之间的关系，动作包含操作和操作数。\r\nACID阐述了这些关系中最为重要的几个特性。\r\n1，原子操作：事务内局部动作要求一同完成，否则后续逻辑会异常。\r\n2，事务内操作分为不可回滚部分与可回滚部分，通常元数据修改不可撤销。\r\n3，自治事务：事务内局部动作要求在其完成后，立即对其他事务可见。\r\n   这或许是因为其某些修改没有被隔离，影响会被其他事务看到，导致这些动作不可撤销。\r\n4，提交：动作序列要保持一同完成或一同失败。\r\n5，隔离级别：探讨当2个动作序列操作相同数据时的特征。\r\n             如果动作是修改，涉及冲突判断。如果动作是读，涉及可见性判断。\r\n6，持久化性：动作在系统重启后其影响应该仍然存在。	\N	\N	17	\N	3	\N	5	1	2021-10-26 07:05:18.828553	2022-04-08 11:55:54.357515	2021-10-26	0	\N	\N	979	1	2	f	\N
980	6	7	SSDR11：存储引擎之结构	存储引擎除了事务之外，还有部分就是存储结构。\r\n存储结构的本质在于描述如何组织数据之间的关系。\r\n这里关系有2层含义，一是逻辑关系，二是物理关系。\r\n逻辑关系最终也通过物理关系来表达。\r\n\r\n其目的通常在于使得基于此的操作尽可能的快。\r\n快有很多含义：\r\n1，哪些动作快？ 插入还是查询，点查询还是范围查询？\r\n2，怎样才能快？cache，预计算，预判提前加载？	\N	\N	17	\N	3	\N	5	0	2021-10-26 07:10:10.67415	2021-10-26 07:10:10.67415	2021-10-26	0	\N	\N	980	1	2	f	\N
983	6	9	我以为我要学习政治	在一个集体中，人和人存在利益关系，存在权利斗争，存在善恶斗争。\r\n所以很多人会走入政治道路，但是这是歧路。\r\n\r\n学习政治得目的不在于赢得斗争，挣回面子，这种人一开始就输了。\r\n其目的在于构建更合理的系统组员关系，这会让系统迸发下强大的力量。\r\n\r\n人真正要学的是如何解决问题，因为这是妨碍人的生存与生机畅达的矛盾。\r\n一旦矛盾无法解决，问题就会接踵而至。这才是根本啊	\N	\N	17	\N	3	\N	5	0	2021-11-12 06:55:58.527205	2021-11-12 06:55:58.527205	2021-11-12	0	\N	\N	983	1	2	f	\N
1037	6	27	高度复杂化的软件结构（人力之殇）	软件公司的成果是一行行代码，这些代码可能是在压迫追赶下生产的。\r\n也可能在探索与追求中生产。\r\n软件工程师也是人，并且跟随社会在发生变化，体能，身体素质等等。\r\n适应其规律，提供合适其生产的环境才是最终出路。\r\n\r\n架构的目的难道不应该是让人的工作最小化，相关度最低化么。为何让人疲于交互？\r\n构建一个高度耦合，信息需要全流通的产品是多么难：\r\n1，相关代码有文档吗?\r\n2, 知识和隐藏的依赖能达成共识吗？\r\n\r\n加一个数据类型或一种结构变得异常复杂，到处都得适配且没人知道是否绝对全面了。\r\n最终软件投入的成本变得不可接受。只有有一定产出的公司才能维持慢慢的迭代。\r\n\r\n最终极大的限制了软件的创新和发展。\r\n	\N	\N	17	\N	3	\N	5	0	2022-04-06 06:55:13.028099	2022-04-06 06:55:13.028099	2022-04-06	0	\N	\N	1037	1	2	f	\N
972	6	18	做一个软件像clippy，但是更强大	1，一个可以检查其他软件是否写得合适的软件\r\n  或许这就是编译器要干的活？\r\n2，这个软件可以不断的添加规则，不断的扩展\r\n  可以运行得很慢，但是其执行是自动化的。\r\n3，可以自动生成用例，并且执行\r\n  这样就有人在夜间帮我工作了。	\N	\N	17	\N	3	\N	5	3	2021-10-12 08:31:32.04301	2022-02-18 07:19:01.124735	2021-10-12	0	\N	\N	972	1	2	f	\N
974	6	24	coral字典	字典设计\r\n\r\nDictionaryColumn -> Column\r\n\r\n1，dataset支持字典列\r\n   同一批读取数据仅支持一个字典，即字典的作用域和扫描的边界需对其。\r\n   字典向量的数据类型与列原生类型一致，增加了position向量。\r\n   \r\n1.1 字典列的接口\r\n1.1.1 分割\r\n      对position和null分割，对字典共享\r\n1.1.2 合并\r\n      底层不会对不同字典的dataset进行合并\r\n1.1.3 还原\r\n      从字典列读取原数据   \r\n\t  \r\n2，含字典列的写入\r\n   \t将字典数据进行还原，使用存储的字典来写入。\r\n\r\n3，含字典列的更新，删除\r\n    上层条件运算支持对字典的支持，列转行进行还原。\r\n    更新值本身不支持字典。\r\n\r\n4，存储对于多字典的支持\r\n   目前仅LSC支持字典，slice内rowgroup共享字典。\r\n   后面扩展成slice内共享字典。\r\n\r\n5，字典列的读取\r\n    读取时将rowgroup的字典读取，按批次返回value。\r\n    但是字典只需一份，是否支持字典压缩？\r\n    \r\n    parquet改造：支持吐出字典列。然后在wrapper中与crab的DictionaryColumn对接。\t\r\n   	\N	\N	17	\N	3	\N	5	0	2021-10-14 15:11:04.090321	2021-10-14 15:11:04.090321	2021-10-14	0	\N	\N	974	1	2	f	\N
976	6	18	开发平台的发展方向（用语言来包裹平台）	1，开发平台会提供硬件，操作系统，语言的抽象\r\n2，开发平台提供解决日志，运维，分布式，复制，网络，线程运行主体等通用功能。\r\n3，软件开发人员只需做逻辑部分即可。\r\n4，开发平台应该能自动化测试程序，并且检查程序的各种环节，命名统一性等等。\r\n\r\n能否利用rust语言提供的这种能力去做到呢？\r\n开发人员拿到平台，只写逻辑代码即可。\r\n	\N	\N	17	\N	3	\N	5	2	2021-10-24 07:43:50.636725	2021-10-24 08:04:36.403796	2021-10-24	0	\N	\N	976	1	2	f	\N
1036	6	5	读《中国是部金融史》教育，文明，制度，科技，财富	政治权利有其运行规律，权力的运行可以带来统治力，但随之带来的还有运行权力的开销。\r\n经济有其内在规律，任何君主都没法对经济规律发号施令。\r\n\r\n每个人都有其约束，倒行逆施最终必然走向灭亡。\r\n而维持平衡又何其之难。看历史太平日子又有多少。\r\n\r\n企业同样如此，可以像大秦或吴王一样大权独揽，并将人们绑在战争机器上。利用压迫和恐惧来前进。\r\n也可以尝试建立相对平衡的制度，让每个机构正常运转，并且效率在一段时间内的折扣。	\N	\N	17	\N	3	\N	5	1	2022-04-06 06:42:50.532019	2022-04-06 06:52:04.153094	2022-04-06	0	\N	\N	1036	1	2	f	\N
1038	6	27	软件开发：制度，规则，约束	如果将软件开发视为团队构建虚拟实体过程，那么可以从制度，规则，约束等维度来看其管理过程。\r\n\r\n指定实体目标，通过运转制度，规则，约束最终达成目标。\r\n\r\n另外实体构建的自动化必然会发展出来，否则极大的限制了创造力。\r\n\r\n而我想要的样子也是如此。	\N	\N	17	\N	3	\N	5	0	2022-04-06 07:45:03.954797	2022-04-06 07:45:03.954797	2022-04-06	0	\N	\N	1038	1	2	f	\N
1041	6	31	知识储备：事务1	在控制文件，系统表，结构元数据，页面数据等各种数据，redo/undo下如何配合实现事务的ACID	\N	\N	17	\N	3	\N	5	2	2022-04-08 07:37:11.524979	2022-04-10 08:42:17.906398	2022-04-08	0	\N	\N	1041	1	2	f	\N
973	6	24	coral库预读性能测试	total row count 119994608 cost :14762 ms(不预读，文件系统预读调整为256kb)\r\n file read use 2035 ms\r\n\r\n谢锐 10-13 19:57:16\r\ntotal row count 119994608 cost :12988 ms(预读，文件系统预读调整为256kb)\r\n file read use 185 ms\r\n\r\n谢锐 10-13 19:57:47\r\n上面非预读 时间占比确实小了点\r\n\r\n谢锐 10-13 20:01:53\r\ntotal row count 119994608 cost :16022 ms(预读，文件系统预读调整为32kb)\r\n file read use 2440 ms\r\ntotal row count 119994608 cost :17416 ms（不预读，文件系统预读调整为32kb）\r\n file read use 4432 ms\r\n稍微有点效果 不明显\r\n\r\ntotal row count 119994608 cost :13136 ms（不清文件系统cache，不预读）\r\n file read use 760 ms\r\n\r\n发现的潜在问题:\r\n1，积累到最后写占用的内存非常大。	\N	\N	17	\N	3	\N	5	3	2021-10-13 18:13:10.210465	2021-10-14 09:05:30.500627	2021-10-13	0	\N	\N	973	1	2	f	\N
970	6	9	终究之问：我是谁？世界是怎样的？	这两问题都没有终极答案，但是我们可以在自己的认知内给出自己的答案。\r\n\r\n我把世界等有复杂结构的事物称为系统。系统的逻辑维度观察称为形式系统。\r\n不同形式系统之间能否相容取决于公理(即共识，所以为什么共识如此重要，信用如此重要)。\r\n大家公认的建立共识的方法是辩证法，科学，是要求符合大家所观察的客观系统，即世界或宇宙系统。\r\n当然部分信徒之间可能是信仰神学。\r\n因此人是一个形式系统，动物是一个形式系统，计算机是一个形式系统。\r\n形式系统主要研究主体是概念定义，公理，定理，规则逻辑，行为，变化，关系等等。\r\n\r\n以计算机举例，计算机系统就是通过数学方法表达事物的某些维度特征(编码)，\r\n然后进行计算，和转换得到我们想要的行为或软件实体的过程。从某种角度看状态和行为是统一的，就像变量和函数在形式上也可以统一。\r\n\r\n另外人还有一个系统是情感系统，人的恐惧，悲伤，爱恨情仇属于这个系统，这个系统并非形式化的。\r\n而且通常人是被这个系统所支配的。这个系统人类有非常多的研究思考，道家，儒家，佛家，以及心理学等等。\r\n\r\n如同通篇来看一个人，形式系统如同高山，情感系统如同大海。高山虽高，但只要不失足不走死胡同，总可以达到更高境界。\r\n大海则没有绝对的方向，心安风平浪静，焦躁则暴风骤雨。魔怪就在自己心中。\r\n\r\n以上是一点点感悟的总结，当然尤其我这个形式系统的认知所限，特地限定了自己的思维范围。\r\n广阔的宇宙，微观的粒子，恶魔的炼狱，荣耀的圣殿，没思考或未能身临其境不做设想。\r\n\r\n另外知识也不应该是霸凌的理由，任何人不应该因为缺乏知识(即自己形式系统完善度低)而让自己的情感系统被别人压制。\r\n也就是赛德克巴莱中原始部落反抗的意义，科技，文明低等并不代表情感也低等，灵魂也低等，虽然落后会挨打。\r\n这就是自由平等。失去财富人不一定会反抗，但失去灵魂也不反抗就真的死亡了。\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	3	2021-10-10 18:43:28.430463	2021-10-10 18:50:42.393334	2021-10-10	0	\N	\N	970	1	2	f	\N
975	3	24	coral一次写入很多数据的问题	如果一个slice 10GB，那写入过程中会占10GB的内存，消耗非常大。\r\n需要支持写部分数据的能力。可限制在一个范围内，在一个page内会跳转不同地方写入，但是page间是连续的。\r\n要支持一种机制可以刷page从而不占用太多内存。\r\n对于s3 pool而言，就是得支持分片上传了。	\N	\N	17	\N	3	\N	5	0	2021-10-15 13:37:25.714244	2021-10-15 13:37:25.714244	2021-10-15	0	\N	\N	975	1	2	f	\N
910	6	23	一次软件重构的教训	重构的原因：dataset的内存管理，构建，以及dataset本身没有很好的分离，导致接口耦合，无法扩展不同的资源管理模式。\r\n重构的过程：在方案上我多次徘徊，有时候想彻底重构，但是又觉得工作量太大，搞了部分放弃了。\r\n            然后又想往dataset塞入内存分配器，仍然有不灵活的问题，需要给dataset中的列更好内存分配器。而且这样代码复杂度将继续上涨。\r\n            最后又折回，还是把构建与内存管理扣出来了。\r\n为啥反复： 因为想不清楚啊，看不出利弊，想不清楚到底是否要增加子结构，不同结构是否需进一步拆分。\r\n教训： 除了方案上的反复外，\r\n       做事情真是拼实力啊，什么是循环渐进，为啥要拆分很多小步骤。步骤一多，涉及的实体一多，就会乱。\r\n       做软件就得循序渐进，无法渐变很可能会失败。\r\n       没测试就没有重构，没接口就没有代码。\r\n\r\n改接口代价大，这也是架构师的作用。\r\n\r\n软件的核心矛盾就是：复杂度+可变性+功能/性能。\r\n                    复杂度要求我们认知事物，在不同的层次，不同的广度上。\r\n                    可变性要求我们以生长的方式来对待软件，过于复杂的系统必然无法可变。\r\n                    \r\n	\N	\N	17	\N	3	\N	5	2	2021-07-25 19:32:25.275751	2022-04-13 13:01:00.122591	2021-07-25	0	\N	\N	910	1	2	f	\N
971	6	9	终极恐惧的消除	有的人的终极恐惧可能是死亡，但实际并非如此。\r\n更多的人恐惧的是为什么我会这样，而别人不会。\r\n\r\n如果我因为失业而无法生活，那我应该恐惧吗？\r\n我认为不应该，如果失业找不到对应收入的工作说明我知识不够。\r\n知识不够=>道德也不够。那既然道德也不够，那失业的是我不是应该的吗？\r\n\r\n只有一种人会愤愤不平，就是不愿意调整自己的人，也不愿面对被淘汰的人。\r\n如果坚持自己且坚定不移到即便被淘汰也无所畏惧，那还有什么好恐惧呢？	\N	\N	17	\N	3	\N	5	1	2021-10-10 20:18:06.414685	2021-11-12 06:42:03.208595	2021-10-10	0	\N	\N	971	1	2	f	\N
1051	6	7	SSDR 33:分布式事务	两阶段提交协议的最大缺陷在于它是一种阻塞协议。如果协调者永远死亡，则事务将永远阻塞。另外两阶段提交协议的性能也不理想，YashanDB会从两个方面有所优化：\r\n\r\ncommit phase2通过异步提交来提升性能，在yascn实现TM详细设计中介绍\r\n协调者故障，会通过协调者多活进行高可用切换，在选定的协调者收集参与者事务信息进行异常恢复\r\n5.1.1.3 lamport SCN\r\n实现：CN与DN进行事务操作时，相互同步SCN的行为称为lamport SCN。本地实例上缓存的SCN = max(lamport SCN，本地时间生成的SCN）+ 1。注意只是推进缓存的SCN，lamport SCN相关的操作还是使用带过来的SCN。\r\n\r\n作用：用于实例间同步SCN，推进对方实例的本地SCN，确保实例上后来的操作一定能获取到比先来的操作更大的SCN，避免后来者读到前者部分数据的情况。\r\n\r\n5.1.1.4 读一致性的典型场景分析\r\n分布式事务的读一致性有两个要点：\r\n\r\n已提交的数据，针对RC级别，原则上需要立即读到\r\n对于同一CN下发的消息，我们是能保证的\r\n对于不同CN下发的查询与修改，由于网络时延的存在，如果CN间时间存在较大偏差，会存在无法立即可读的情况（存在系统的时间与现实时间的偏差）\r\n未提交的数据，查询不能读到\r\n读一致性最容易出问题的场景就是多CN下的多DN读写并发，保证此场景下读一致性的关键技术点：\r\n\r\n为了性能，我们尽量取CN本地的GTS时间戳缓存生成SCN（取本地SCN带来了多CN下无法立即提交读的可能性，详见yasmn实现GTS的设计的《时延问题》一节）\r\n多DN写操作commit phase2时，需要取远程时间生成SCN\r\n涉及多节点的操作必须使用CN的SCN\r\n单机事务阻塞查询机制\r\n下面具体分析多CN多DN读写并发的场景下，这些技术点如何发挥作用保证了读一致性。\r\n\r\n设CN1上涉及多DN的查询操作代号为M5，设计流程如下图：\r\n\r\n\r\n\r\n设CN2上涉及多DN的修改操作代号为M6，设计流程如下图：\r\n\r\n\r\n\r\n设M5 query SCN的时间为tq（即M5场景图的第1步SCN生成时间），M6 commit phase1 SCN的时间为t1（即M6场景图的第4步SCN生成时间），M6 commit phase2 SCN的时间为t2（即M6场景图的第7步取到的时间、第8步SCN生成时间）。\r\n\r\n首先证明如果多DN写操作commit phase2时，不取远程时间生成SCN，可能会出现问题。若M6第7步不使用远程时间，而使用CN2本地时间（未被后台同步时间线程推进）生成SCN用来提交。若CN1已经开始M5操作，且M5的query SCN>M6的commit phase2 SCN（因为都是取本地时间，所以t2有可能比已经开始的tq小）。若在DN1上，M6准备消息先到，M5查询消息后到；在DN2上，M5查询消息先到，M6准备消息后到。此时DN1上M5查询可见M6提交，而DN2上M5查询不可见M6提交，不满足读一致性。该问题也叫做“未来时间先到问题”，如下图：\r\n\r\n\r\n\r\n接着证明“多DN写操作commit phase2时，需要取远程时间生成SCN”和“涉及多节点的操作必须使用CN的SCN”这两点保证了该问题不会出现。若M6第7步使用远程时间，首先正常情况下，取到的时间t2会比CN2正在进行的M5操作之前取到的时间tq大，这就确保了M5操作不可见M6提交。但是由于网络延迟、业务压力等原因，依然可能会出现取到的时间t2比CN2正在进行的M5操作之前取到的时间tq小的情况（见yasmn实现GTS设计文档的《多cn时的后取到时间更小问题》一节）。但是，根据如下2点：\r\n\r\n涉及多节点的操作都使用cn时间，且cn时间都是从GTS取的\r\nt2是在t1提交后才去GTS取的\r\n可以推出，只要在GTS上有tq>t2的关系，就保证了CN2拿到tq时t1已经提交，故不会出现M5 tq时发送的查询消息比M6 t1时发送的准备消息（已经提交）先到的情景。还可以推出，若tq>t1，在DN1上t1比tq先到，DN2上tq比t1先到，那必然有tq<t2（已证tq>t2时tq不可能比t1先到），因此DN1上M5查询会阻塞最后不可见，和DN2上查询不可见一致。\r\n\r\n下面反证“单机事务阻塞查询机制”的必要性。单机事务阻塞查询机制是指若一个查询发现有事务正在修改相关数据，则会阻塞直到事务提交，才决定是否可见该事务的修改。设没有该机制，在DN1上准备消息先到，查询消息后到，不做阻塞，M5对M6提交的部分数据可见；在DN2上查询消息先到，准备消息后到，M5对M6提交的数据不可见，如下图所示，不满足读一致性。\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2022-04-25 08:32:38.736361	2022-04-25 08:32:38.736361	2022-04-25	0	\N	\N	1051	1	2	f	\N
1052	6	23	工作任务跟踪与推进	1，跟踪当前的大粒度任务\r\n可以搞一个excel表格\r\n\r\n2，跟踪单个任务内的每个事项\r\n再加一个文档表格，\r\n每个事项刷新进度，直到任务完成。\r\n\r\n最怕缺漏。\r\n	\N	\N	17	\N	3	\N	5	0	2022-04-27 10:15:41.365707	2022-04-27 10:15:41.365707	2022-04-27	0	\N	\N	1052	1	2	f	\N
1042	6	7	SSDR 27：关于volatile	最近在讨论多线程编程中的一个可能的 false sharing 问题时，有人提出加 volatile 可能可以解决问题。这种错误的认识荼毒多年，促使我写下这篇文章。\r\n\r\n约定\r\nVolatile 这个话题，涉及到计算机科学多个领域多个层次的诸多细节。仅靠一篇博客，很难穷尽这些细节。因此，若不对讨论范围做一些约定，很容易就有诸多漏洞。到时误人子弟，就不好了。以下是一些基本的约定：\r\n\r\n这篇博文讨论的 volatile 关键字，是 C 和 C++ 语言中的关键字。Java 等语言中，也有 volatile 关键字。但它们和 C/C++ 里的 volatile 不完全相同，不在这篇博文的讨论范围内。\r\n这篇博文讨论的 volatile 关键字，是限定在 C/C++ 标准之下的。这也就是说，我们讨论的内容应该是与平台无关的，同时也是与编译器扩展无关的。\r\n相应的，这篇文章讨论的「标准」指的是 C/C++ 的标准，而不是其他什么东西。\r\n我们希望编写的代码是 (1) 符合标准的，(2) 性能良好的，(3) 可移植的。这里 (1) 保证了代码执行结果的正确性，(2) 保证了高效性，(3) 体现了平台无关性（以及编译器扩展等的无关性）。\r\n含义\r\n单词 volatile 的含义\r\n在谈及 C/C++ 中的 volatile 关键字时，总有人会拿 volatile 这个英文单词的中文解释说事。他们把 volatile 翻译作「易变的」。但事实上，对于翻译来说，很多时候目标语言很难找到一个词能够反映源语言中单词的全部含义和细节。此处「易变的」就无法做到这一点。\r\n\r\nVolatile 的意思，若要详细理解，还是应该查阅权威的英英字典。在柯林斯高阶学习词典中，volatile 是这样解释的：\r\n\r\nA situation that is volatile is likely to change suddenly and unexpectedly.\r\n这里对 volatile 的解释有三个精髓的形容词和副词，体现了 volatile 的含义。\r\n\r\nlikely：可能的。这意味着被 volatile 形容的对象「有可能也有可能不」发生改变，因此我们不能对这样的对象的状态做出任何假设。\r\nsuddenly：突然地。这意味着被 volatile 形容的对象可能发生瞬时改变。\r\nunexpectedly：不可预期地。这与 likely 相互呼应，意味着被 volatile 形容的对象可能以各种不可预期的方式和时间发生更改。\r\n因此，volatile 其实就是告诉我们，被它修饰的对象出现任何情况都不要奇怪，我们不能对它们做任何假设。\r\n\r\n程序中 volatile 的含义\r\n对于程序员来说，程序本身的任何行为都必须是可预期的。那么，在程序当中，什么才叫 volatile 呢？这个问题的答案也很简单：程序可能受到程序之外的因素影响。\r\n\r\n考虑以下 C/C++ 代码。\r\n\r\nvolatile int *p = /* ... */;\r\nint a, b;\r\na = *p;\r\nb = *p;\r\n若忽略 volatile，那么 p 就只是一个「指向 int 类型的指针」。这样一来，a = *p; 和 b = *p; 两句，就只需要从内存中读取一次就够了。因为从内存中读取一次之后，CPU 的寄存器中就已经有了这个值；把这个值直接复用就可以了。这样一来，编译器就会做优化，把两次访存的操作优化成一次。这样做是基于一个假设：我们在代码里没有改变 p 指向内存地址的值，那么这个值就一定不会发生改变。\r\n\r\n此处说的「读取内存」，包括了读取 CPU 缓存和读取计算机主存。\r\n然而，由于 MMIP（Memory mapped I/O）的存在，这个假设不一定是真的。例如说，假设 p 指向的内存是一个硬件设备。这样一来，从 p 指向的内存读取数据可能伴随着可观测的副作用：硬件状态的修改。此时，代码的原意可能是将硬件设备返回的连续两个 int 分别保存在 a 和 b 当中。这种情况下，编译器的优化就会导致程序行为不符合预期了。\r\n\r\n总结来说，被 volatile 修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。而这些可观测的副作用，是由程序之外的因素决定的。\r\n\r\n关键字 volatile 的含义\r\nCPP reference 网站是对 C 和 C++ 语言标准的整理。因此，绝大多数时候，我们可以通过这个网站对语言标准进行查询。关于 volatile 关键字，有 C 语言标准和 C++ 语言标准可查。这里摘录两份标准对 volatile 访问的描述。\r\n\r\nC 语言：Every access (both read and write) made through an lvalue expression of volatile-qualified type is considered an observable side effect for the purpose of optimization and is evaluated strictly according to the rules of the abstract machine (that is, all writes are completed at some time before the next sequence point). This means that within a single thread of execution, a volatile access cannot be optimized out or reordered relative to another visible side effect that is separated by a sequence point from the volatile access.\r\nC++ 语言：Every access (read or write operation, member function call, etc.) made through a glvalue expression of volatile-qualified type is treated as a visible side-effect for the purposes of optimization (that is, within a single thread of execution, volatile accesses cannot be optimized out or reordered with another visible side effect that is sequenced-before or sequenced-after the volatile access. This makes volatile objects suitable for communication with a signal handler, but not with another thread of execution, see std::memory_order). Any attempt to refer to a volatile object through a non-volatile glvalue (e.g. through a reference or pointer to non-volatile type) results in undefined behavior.\r\n这里首先解释两组概念：值类型和序列点（执行序列）。\r\n\r\n值类型指的是左值（lvalue）右值（rvalue）这些概念。关于左值和右值，前作有过介绍。简单的理解，左值可以出现在赋值等号的左边，使用时取的是作为对象的身份；右值不可以出现在赋值等号的左边，使用时取的是对象的值。除了 lvalue 和 rvalue，C++ 还定义了其他的值类型。其中，xvalue 大体可以理解为返回右值引用的函数调用或表达式，而 glvalue 则是 lvalue 和 xvalue 之和。\r\n\r\n序列点则是 C/C++ 中讨论执行顺序时会提到的概念。对于 C/C++ 的表达式来说，执行表达式有两种类型的动作：(1) 计算某个值、(2) 副作用（例如访问 volatile 对象，原子同步，修改文件等）。因此，如果在两个表达式 E1 和 E2 中间有一个序列点，或者在 C++ 中 E1 于序列中在 E2 之前，则 E1 的求值动作和副作用都会在 E2的求值动作和副作用之前。关于序列点和序列顺序规则，可以参考：这里和这里。\r\n\r\n因此我们讲，在 C/C++ 中，对 volatile 对象的访问，有编译器优化上的副作用：\r\n\r\n不允许被优化消失（optimized out）；\r\n于序列上在另一个对 volatile 对象的访问之前。\r\n这里提及的「不允许被优化」表示对 volatile 变量的访问，编译器不能做任何假设和推理，都必须按部就班地与「内存」进行交互。因此，上述例中「复用寄存器中的值」就是不允许的。\r\n\r\n需要注意的是，无论是 C 还是 C++ 的标准，对于 volatile 访问的序列性，都有单线程执行的前提。其中 C++ 标准特别提及，这个顺序性在多线程环境里不一定成立。\r\n\r\nvolatile 与多线程\r\nvolatile 可以解决多线程中的某些问题，这一错误认识荼毒多年。例如，在知乎「volatile」话题下的介绍就是「多线程开发中保持可见性的关键字」。为了拨乱反正，这里先给出结论（注意这些结论都基于本文第一节提出的约定之上）：\r\n\r\nvolatile 不能解决多线程中的问题。\r\n按照 Hans Boehm & Nick Maclaren 的总结，volatile 只在三种场合下是合适的。\r\n和信号处理（signal handler）相关的场合；\r\n和内存映射硬件（memory mapped hardware）相关的场合；\r\n和非本地跳转（setjmp 和 longjmp）相关的场合。\r\n\r\n\r\n以下我们尝试来用 volatile 关键字解决多线程同步的一个基本问题：happens-before。\r\n\r\nnaïve case\r\n首先我们考虑这样一段（伪）代码。\r\n\r\n// global shared data\r\nbool flag = false;\r\n\r\nthread1() {\r\n    flag = false;\r\n    Type* value = new Type(/* parameters */);\r\n    thread2(value);\r\n    while (true) {\r\n        if (flag == true) {\r\n            apply(value);\r\n            break;\r\n        }\r\n    }\r\n    thread2.join();\r\n    if (nullptr != value) { delete value; }\r\n    return;\r\n}\r\n\r\nthread2(Type* value) {\r\n    // do some evaluations\r\n    value->update(/* parameters */);\r\n    flag = true;\r\n    return;\r\n}\r\n这段代码将 thread1 作为主线程，等待 thread2 准备好 value。因此，thread2 在更新 value 之后将 flag 置为真，而 thread1 死循环地检测 flag。简单来说，这段代码的意图希望实现 thread2 在 thread1 使用 value 之前执行完毕这样的语义。\r\n\r\n对多线程编程稍有了解的人应该知道，这段代码是有问题的。问题主要出在两个方面。其一，在 thread1 中，flag = false 到 while 死循环里，没有任何机会对 flag 的值做修改，因此编译器可能会将 if (flag == true) 的内容全部优化掉。其二，在 thread2 中，尽管逻辑上 update 需要发生在 flag = true 之前，但编译器和 CPU 并不知道；因此 flag = true 可能发生在 update 完成之前，因此 thread1 执行 apply(value) 时可能 value 还未准备好。\r\n\r\n加一个 volatile 试试？\r\n在错误的理解中，此时就到了 volatile 登场的时候了。\r\n\r\n首先我们考虑这样一段（伪）代码。\r\n\r\n// global shared data\r\nvolatile bool flag = false;  // 1.\r\n\r\nthread1() {\r\n    flag = false;\r\n    Type* value = new Type(/* parameters */);\r\n    thread2(value);\r\n    while (true) {\r\n        if (flag == true) {  // 2.\r\n            apply(value);\r\n            break;\r\n        }\r\n    }\r\n    thread2.join();\r\n    if (nullptr != value) { delete value; }\r\n    return;\r\n}\r\n\r\nthread2(Type* value) {\r\n    // do some evaluations\r\n    value->update(/* parameters */);\r\n    flag = true;\r\n    return;\r\n}\r\n这里，在 (1) 处，我们将 flag 声明为 volatile-qualified。因此，在 (2) 处，由于 flag == true 是对 volatile 变量的访问，故而 if-block 不会被优化消失。然而，尽管 flag 是 volatile-qualified，但 value并不是。因此，编译器仍有可能在优化时将 thread2 中的 update 和对 flag 的赋值交换顺序。此外，由于 volatile 禁止了编译器对 flag 的优化，这样使用 volatile 不仅无法达成目的，反而会导致性能下降。\r\n\r\n再加一个 volatile 呢？\r\n在错误的理解中，可能会对 value 也加以 volatile 关键字修饰；颇有些「没有什么是一个 volatile 解决不了的；如果不行，那就两个」的意思。\r\n\r\n// global shared data\r\nvolatile bool flag = false;\r\n\r\nthread1() {\r\n    flag = false;\r\n    volatile Type* value = new Type(/* parameters */);   // 1.\r\n    thread2(value);\r\n    while (true) {\r\n        if (flag == true) {\r\n            apply(value);\r\n            break;\r\n        }\r\n    }\r\n    thread2.join();\r\n    if (nullptr != value) { delete value; }\r\n    return;\r\n}\r\n\r\nthread2(volatile Type* value) {\r\n    // do some evaluations\r\n    value->update(/* parameters */);                    // 2.\r\n    flag = true;\r\n    return;\r\n}\r\n在上一节代码的基础上，(1) 将 value 声明为 volatile-qualified。因此 (2) 处对两个 volatile-qualified 变量进行访问时，编译器不会交换他们的顺序。看起来就万事大吉了。\r\n\r\n然而，volatile 只作用在编译器上，但我们的代码最终是要运行在 CPU 上的。尽管编译器不会将 (2) 处换序，但 CPU 的乱序执行（out-of-order execution）已是几十年的老技术了；在 CPU 执行时，value 和 flag 的赋值仍有可能是被换序了的（store-store）。此外，(2) 处的 value = new Type() 一行代码并不如想象中那么简单。它实际上大概做了三件事情\r\n\r\n分配一块 sizeof(Type) 大小的内存；\r\n在这块内存上，执行 Type 类型的初始化；\r\n将这块内存的首地址赋值给 value。\r\n对于编译器来说，这些工作都是改表达式语句的求值和副作用，因此不会与 flag 赋值语句换序。但是，在 CPU 乱序执行之下，甚至有可能发生 value 和 flag 已赋值完毕，但内存里尚未完成 Type 初始化的情况。此时若 thread1 中使用 value，则程序可能崩溃。\r\n\r\n也许有人会说，x86 和 AMD64 架构的 CPU（大多数个人机器和服务器使用这两种架构的 CPU）只允许 sotre-load 乱序，而不会发生 store-store 乱序；或者在诸如 IA64 架构的处理器上，对 volatile-qualified 变量的访问采用了专门的指令。因而，在这些条件下，这段代码是安全的。尽管如此，使用 volatile 会禁止编译器优化相关变量，从而降低性能，所以也不建议依赖 volatile 在这种情况下做线程同步。另一方面，这严重依赖具体的硬件规范，超出了本文的约定讨论范围。\r\n到底应该怎样做？\r\n回顾一下，我们最初遇到的问题其实需要解决两件事情。一是 flag 相关的代码块不能被轻易优化消失，二是要保证线程同步的 happens-before 语义。但本质上，设计使用 flag 本身也就是为了构建 happens-before 语义。这也就是说，两个问题，后者才是核心；如有其他不用 flag 的办法解决问题，那么 flag 就不重要。\r\n\r\n对于当前问题，最简单的办法是使用原子操作。\r\n\r\n// global shared data\r\nstd::atomic<bool> flag = false;  // #include <atomic>\r\n\r\nthread1() {\r\n    flag = false;\r\n    Type* value = new Type(/* parameters */);\r\n    thread2(value);\r\n    while (true) {\r\n        if (flag == true) {\r\n            apply(value);\r\n            break;\r\n        }\r\n    }\r\n    thread2.join();\r\n    if (nullptr != value) { delete value; }\r\n    return;\r\n}\r\n\r\nthread2(Type* value) {\r\n    // do some evaluations\r\n    value->update(/* parameters */);\r\n    flag = true;\r\n    return;\r\n}\r\n由于对 std::atomic<bool> 的操作是原子的，同时构建了良好的内存屏障，因此整个代码的行为在标准下是良定义的。\r\n\r\n除此之外，还可以结合使用互斥量和条件变量。\r\n\r\n// global shared data\r\nstd::mutex m;                   // #include <mutex>\r\nstd::condition_variable cv;     // #include <condition_variable>\r\nbool flag = false;\r\n\r\nthread1() {\r\n    flag = false;\r\n    Type* value = new Type(/* parameters */);\r\n    thread2(value);\r\n    std::unique_lock<std::mutex> lk(m);\r\n    cv.wait(lk, [](){ return flag; });\r\n    apply(value);\r\n    lk.unlock();\r\n    thread2.join();\r\n    if (nullptr != value) { delete value; }\r\n    return;\r\n}\r\n\r\nthread2(Type* value) {\r\n    std::lock_guard<std::mutex> lk(m);\r\n    // do some evaluations\r\n    value->update(/* parameters */);\r\n    flag = true;\r\n    cv.notify_one();\r\n    return;\r\n}\r\n这样一来，由线程之间的同步由互斥量和条件变量来保证，同时也避免了 while (true) 死循环空耗 CPU 的情况。	\N	\N	17	\N	3	\N	5	2	2022-04-12 17:50:39.423851	2022-09-20 17:46:28.880192	2022-04-12	0	\N	\N	1042	1	2	f	\N
1050	6	7	SSDR 32：编程需要考虑的维度  CheckList	编程的维度：\r\n逻辑编程：\r\n1，正确性\r\n   分布性，协议与网络编程\r\n   持久性，事务\r\n   并发性，原子性，隔离，并发编程\r\n2，可行性\r\n3，可维护\r\n\r\n效率编程：\r\n1，扩展性：接口与泛型编程\r\n2，高性能，硬件指令与算法优化\r\n3，兼容性\r\n4，资源消耗优化\r\n\r\n友好编程：\r\n1，人体工学，色彩，行为等\r\n2，可探测性\r\n3，引导性\r\n4，智能性	\N	\N	17	\N	3	\N	5	3	2022-04-24 07:00:41.843238	2022-05-16 18:17:14.415887	2022-04-24	0	\N	\N	1050	1	2	f	\N
950	6	7	SSDR5: 行为的特性： 原子性，顺序性，可见性，一致性	内存屏障与order的关系？\r\n内存屏障一定是关于某个内存的吗？为啥写法只有一个mfence？\r\n\r\nhttps://doc.rust-lang.org/nomicon/atomics.html\r\n如果程序逻辑要求数据访问在不同线程间有因果关系，那么就涉及order。\r\n计数器是只要求原子性的。\r\n如果每个线程都要看别人是否修改变量来决定自己的行为，那就存在因果关系了。\r\n什么时候需要严格顺序？彼此都要看到对方的任何操作？\r\n\r\n锁实现原子性？AtomicBool里面有锁吗？\r\n顺序实现一致性？\r\n\r\nMESI协议，内存屏障都是处理一致性问题的。\r\nvolatile不使用内存和cpu cache值。\r\n锁是比内存屏障更强的操作\r\n\r\n读写同一个地方是因果，读写不含因果就是平行世界。\r\n顺序也是因果\r\n共享性	\N	\N	17	\N	3	\N	5	17	2021-09-20 07:30:15.095054	2023-03-23 17:46:10.741562	2021-09-20	0	\N	\N	950	1	2	f	\N
1048	6	15	最新提升方向	1，体能，几个肌肉的训练。羽毛球的根基在于全身肌肉协调发力。\r\n \r\n2，攻克不连贯的地方，前场弓箭步做好能回，后场击球能回位。\r\n\r\n3，球路，常见技战术。吊球，平高，杀球都能运用。\r\n         斜线，中路都能运用。	\N	\N	17	\N	3	\N	5	2	2022-04-17 15:10:13.122361	2022-09-25 17:38:41.775588	2022-04-17	0	\N	\N	1048	1	2	f	\N
996	6	24	ClickHouse	编码：\r\nck列的类型可指定。压缩类型也可指定\r\n\r\nhttps://clickhouse.com/docs/en/\r\nCH存在的原因，OLAP业务特征。\r\n\r\nhttps://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/custom-partitioning-key/\r\nhttps://www.modb.pro/db/55689\r\n这篇文章介绍了CH是写入就形成片段，然后在后台做合并的写入模式。适合导入但不适合写入。\r\n新版本增加WAL提升写入性能。\r\n\r\n配置项：\r\nhttps://clickhouse.com/docs/en/operations/settings/settings/?version=2.5.50000.157&platform=win\r\n\r\n压缩算法：None、LZ4、ZSTD，默认使用的lz4.\r\nuse_uncompressed_cache\r\nWhether to use a cache of uncompressed blocks. Accepts 0 or 1. By default, 0 (disabled). 优化小查询\r\n相关配置merge_tree_max_rows_to_use_cache，merge_tree_max_bytes_to_use_cache\r\n\r\n预读\r\n从目前资料看没支持预读，利用的文件系统的预读能力。\r\n\r\ncache\r\nhttps://clickhouse.com/docs/en/operations/caches/\r\nuncompressed_cache机制：针对短小的请求进行数据缓存。\r\nhttps://clickhouse.com/docs/en/operations/settings/settings/#setting-use_uncompressed_cache\r\n\r\nDictionaries data cache：这个可支持使用SSD_CACHE\r\n\r\nCH的基本介绍，以及使用\r\nhttps://toutiao.io/posts/ugmca67/preview	\N	\N	17	\N	3	\N	5	4	2021-12-20 14:33:28.589928	2022-04-28 12:35:40.919715	2021-12-20	0	\N	\N	996	1	2	f	\N
1087	6	24	dml语法扩展：upsert	pg的insert on conflict(比mysql更好用，可指定具体哪个唯一约束冲突了才执行update)\r\nmysql insert on duplicate key。\r\noracle的merge into\r\n 等价用法的一个例子：https://www.cnblogs.com/csmountains/p/13526408.html\r\n	\N	\N	17	\N	3	\N	5	0	2022-07-19 08:04:54.038068	2022-07-19 08:04:54.038068	2022-07-19	0	\N	\N	1087	1	2	f	\N
985	6	7	事务并发问题(存储开发的基本功，高价值)	问题：有一批顺序操作op1...opn, 其中opn要求事务成功后执行，因为其执行后立即对其他事务可见了。\r\n      如果设计事务确保op1..opn具备原子性，同时又满足可见性?\r\n解决办法：\r\n1，op1..opn-1 包在事务中，mark opn。opn实际通过事务结束后的清理 与 check + opn来完成。\t  \r\n   删除的实现就是如此，删除的空间不能立即被其他事务使用，否则无法回滚。\r\n   还有drop segment，segment真drop的操作是其他事务立即可见，因而不能放在事务成功前。\r\n   \r\n2，锁，opn影响的操作全部加锁等待。\r\n\r\nmark：锁当然只能存在于内存中，持久化状态+内存锁达到持久化锁。\r\n      要知道锁的目的是防止多个线程或进程并发操作，线程与进程只会存在于内存中。\r\n动作的因果性是其根本属性。\r\n      包含动作的顺序，动作的原子性，隔离性，持久性等都描述相互关联动作的因果保证。\r\n      原子性描述对于某些步骤出错的处理，隔离性是指并发因果性，持久性指掉电故障等场景下的因果性。\r\n      这一切终究是为了符合语义逻辑，因果要求。\t  \r\n\t  \r\n\r\n初始化动作分析\r\n\r\n1，检查状态invalid\r\n2，创建segment\r\n3，将segment入口记录下来\r\n4，将状态置为active\r\n5，将水位线上移\r\n\r\n其中4，5两步操作会具备立即可见性，因为缺乏锁与读写并发。\r\n去掉高水位	\N	\N	17	\N	3	\N	5	6	2021-11-14 21:51:16.568703	2022-05-06 20:39:32.888784	2021-11-14	0	\N	\N	985	1	2	f	\N
989	7	16	2021-12-6	1，测试最佳slice大小，rowgroup大小，以及bulk size。\r\n2，修复并发读问题。	\N	\N	19	\N	3	\N	5	0	2021-12-06 06:26:42.501453	2021-12-06 06:26:42.501453	2021-12-06	0	\N	\N	989	1	2	f	\N
990	6	7	SSDR13：软件的实体结构从何而来	最初软件是一句话，然后扩展写成一篇文章，一本书。\r\n软件就是这样不断分解分化而来的，可以说是生长而成。\r\n现实情况是复杂的，通常我们面对的并非全新事物，了解事物本来的面貌至关重要。\r\n\r\nDDD？	\N	\N	17	\N	3	\N	5	0	2021-12-08 07:55:17.505044	2021-12-08 07:55:17.505044	2021-12-08	0	\N	\N	990	1	2	f	\N
1092	7	33	设计存储计算分离方案		\N	\N	19	\N	3	\N	5	1	2022-07-20 07:22:27.552824	2022-07-20 07:22:44.820704	2022-07-20	0	\N	\N	1092	1	2	f	\N
1137	6	23	CMake&Makefile的痛苦反思	CMake痛苦反思：\r\nCMake，makefile是正确性的反面教材。\r\n1，一个事情很多种做法\r\n2，给的指导流程，但总是有意外。\r\n  这点跟文字描述有点像，即没有逻辑化。存在着缺失的步骤或预置条件。\r\n3，出错了，提示信息极其不好好。\r\n  比如找不到符号，说不清楚到底是库版本问题，还是没找到。\r\n4，过程不好跟踪\r\n  configure完了，到底做了什么，决定了哪些东西也不清楚。\r\n5，没有封装好，暴漏的各种乱七八槽的变量。\r\n6，设置了变量，但是不可查其实际是否生效。  	\N	\N	17	\N	3	\N	5	0	2022-11-02 04:50:54.189091	2022-11-02 04:50:54.189091	2022-11-02	0	\N	\N	1137	1	2	f	\N
992	7	16	2021-12-9	1，讨论dc膨胀问题如何解决\r\n2，确定lsc与ck的差距\r\n3，支持读时cache\r\n4，解决索引一致性问题。\r\n5，确定内存问题修改方案	\N	\N	19	\N	3	\N	5	1	2021-12-09 09:32:11.666639	2021-12-13 06:40:15.612729	2021-12-09	0	\N	\N	992	1	2	f	\N
573	6	6	学习方法	学会一个东西其本质就是在大脑中构建其知识体系的过程。\r\n但是这个构建过程应该是自顶而下的，这是人脑的理解事务的方式决定的。\r\n况且知识体系的发展本身就是树状的。\r\n\r\n好，有了这样的体系认知之后，关键就是搞其中每个关键点，这样的点不多，可能就几百上千个。\r\n就像王垠说的学习语言不是去研究记住每个printf使用细节，而应该从语言特性入手，以上帝模式理解它。\r\n\r\n这里我学羽毛球或编码来看，方法就是每天投入大量精力去思考它，调研它，无时无刻。\r\n但不是那种强迫性的，而是自愿的。自愿是因为自己真的想要。\r\n真的想要心智成熟，因而每天修炼\r\n真的想身体健康，因而经常活动关节\r\n真的热爱羽毛球，因而脑中经常浮现动作，琢磨它。\r\n真的想去创造一些东西，真的对其他人的爱，真的想拥有上帝一般的能力，因而疯狂的学习编程。\r\n真的想在世界各地挖矿，去与有真知的灵魂交流，而不是在吃垃圾信息，因而去掌握英语。\r\n真的热爱生活就不会醒了还假装在睡觉。	\N	\N	17	\N	3	\N	5	5	2020-02-18 06:13:59.251696	2021-12-22 19:42:49.755006	2020-02-18	0	\N	\N	573	1	2	f	\N
1054	6	24	tiflash 删除更新实现，stble合并算法		\N	\N	17	\N	3	\N	5	0	2022-05-02 14:40:30.059065	2022-05-02 14:40:30.059065	2022-05-02	0	\N	\N	1054	1	2	f	\N
1053	6	24	coast优化记录	<pre>\r\n1\t等值比较优化，之前没有专门的等值函数\t谢锐\t\r\n3-11\t3-11\t合入\t有效果\r\n2\t字典使用dictId做等值比较\t谢锐\t\r\n3-12\t3-12\t合入\t有效果\r\n3\tdict编码 in优化\t谢锐\t1\t3-14\t3-16\t合入\t部分语句效果明显\r\n4\t\r\nbit操作优化，\r\n\r\n验证tightly block效果\r\n\r\n验证dict和dict plan对比效果\r\n\r\n谢锐\t1\t3-17\t3-18\t合入\t\r\nbit优化有效果\r\n\r\n\r\n\r\ndict plan效果挺明显\r\n\r\n5\t在in优化过程中如果发现有条件不在字典中，可在mask中标记为无效。\t谢锐\t1\t\r\n\r\n合入\t有效果\r\n6\t验证布隆过滤器\t谢锐\t\r\n\r\n\r\n\r\n\r\n7\t从投影列中去掉完全下推的过滤列\t徐晓锋\t\r\n\r\n\r\n\r\n方案待讨论，拉上晓锋，靖东\r\n8\t\r\n利用排序键\r\n\r\n< min或>max跳过页面\r\n\r\n实现特殊比较函数跳过不必要计算\r\n\r\n谢锐\t2\t\r\n\r\n\r\nblock内单范围\r\nblock内多范围(in)\r\n9\t跳过完全不满足的block\t谢锐\t1\t\r\n\r\n合入\t结合5，有明显效果\r\n10\t验证启用simd\t黄文早\t1\t\r\n\r\n\r\n\r\n11\tdict编码下使用bitEqXX函数进行比较并优化其中bit操作\t谢锐\t\r\n\r\n\r\n\r\n\r\n12\t基于已有数据用单机来测试YashanDB\t易文亮\t1\t\r\n\r\n\r\n\r\n13\t并行度线性度问题\t谢锐\t2\t\r\n\r\n\r\n并行线性问题分析\r\n14\tSQL8的CK结果比YashanDB差很多，重测CK数据\t刘晓旋\t\r\n3-21\t3-21\t\r\n已重测 CK 的 SQL8，测试数据 与3月11号测试结果（排序键：city, time_period、分区键：store_brand_name）一致\r\n15\t分批排序写入slice\t叶子\t1\t\r\n\r\n\r\n\r\n16\t\r\nnumber优化：\r\n\r\n1，按block统计p最高位数，全正，全负。方便计算层支持短路经优化。\r\n\r\n2，支持number类型的批量编解码，避免计算层单条编解码开销。在内存中使用Plain格式。\r\n\r\n3，存储规整化，并提供对应的比较函数，实现number的快速过滤\r\n\r\n黄文早\t\r\n\r\n\r\n\r\n\r\n17\t\r\ncount(*)优化，比单字段慢非常多，CK两者接近\r\n\r\nselect count(*) from ads_upc_online_store_sales_detail WHERE district = '乳源瑶族自治县';\r\n\r\nselect count(district) from ads_upc_online_store_sales_detail WHERE district = '乳源瑶族自治县';\r\n\r\n\r\n\r\n\r\n\r\n\r\ncount(*) 与 count\r\n18\t精确过滤支持跳过前面已经过滤的列\r\n</pre>	\N	\N	17	\N	3	\N	5	2	2022-04-28 12:38:51.442271	2023-04-10 06:49:27.626774	2022-04-28	0	\N	\N	1053	1	2	f	\N
1055	7	16	5.5	1，定位vgd问题.\r\n2，数说性能分析\r\n3，处理问题单\r\n4，晚上面试\r\n5，合入之前的cover优化\r\n6，	\N	\N	19	\N	3	\N	5	0	2022-05-05 20:44:54.758422	2022-05-05 20:44:54.758422	2022-05-05	0	\N	\N	1055	1	2	f	\N
1056	6	8	解决双重焦虑，再见光明(或是我的墓志铭)	你还终日惶恐不安，担心他人或未来的风险？\r\n我没有光明，不能点亮自己，也没法照亮他人。\r\n\r\n我见识过黑夜和梦魇，但我选择了光明。我知道黑夜和梦魇中的恐惧，焦虑，以及人的暴戾或者卑微。\r\n我想用心火成就人的阳光，信任与温和。\r\n\r\n心火如信仰，它重要是因为我们觉得它重要，并非因为他人或外物，这才是真的无价之宝，是人脱离奴役的根本所在，火息则人亡。\r\n\r\n有些信仰我坚定不移：\r\n那就是个人的独立自由，可变与强大。我相信人的力量，伙伴信任的力量。\r\n人的标志是他是目的是什么，将成为什么样的人，他的信仰和信念。\r\n没有信仰信念我们会被压力和焦虑粉碎。\r\n\r\n\r\n他人和前途都未可知，\r\n	\N	\N	17	\N	3	\N	5	4	2022-05-10 07:42:44.122521	2022-10-16 20:03:16.870215	2022-05-10	0	\N	\N	1056	1	2	f	\N
1064	7	16	预读与cache	预读改进思路：\r\n\r\n1，在perload队列空或低于一定比例时，由perload线程主动生成任务。\r\n\r\n      需看到整个扫描任务，其scanRange以及filter。\r\n\r\n1.1 perload跟不上scan线程的情况\r\n\r\n      这时读请求可能由scan发起，并且设置Scan进度，以便于预读跳过。\r\n\r\n2，根据内存空闲度来评估生成的任务数量。(preload queue深度调大)\r\n\r\n      可定义单个查询任务最大可消耗的内存比例。\r\n\r\n      new task count = max(preload_queue_empty_size, free_object_ctrl)  / scan_task_count\r\n\r\n2.1 评估预读内存空闲量\r\n\r\n      free = old queue threshold - old queue size\r\n\r\n\r\n\r\ncache调整：\r\n\r\n1，old queue是预读队列，cold queue是缓存队列，hot queue是热点队列。\r\n\r\n     old queue中的数据在访问结束后，要快速转出来。(增加flag)\r\n\r\n     meta和频繁访问的小表，以及大表频繁访问的元数据要入hot队列。 hot队列优先得以保障。（调整元数据的weight，slice meta→ column meta→column data）\r\n\r\n     cold可以加速短期内的重复请求，其很容易被短期访问冲掉。\r\n\r\n     建议：首先配置old，确保发挥系统的预读能力。 其次评估热点数据大小，配置hot比例。 剩余的配置cold，提升缓存命中率。（支持调整比例）\r\n\r\n      \r\n\r\n2，避免大表扫描冲掉cold queue\r\n\r\n      评估查询将会使用的空间大小，如果接近cold queue大小，可设置hint只预读不缓存，支持从old queue直接到free queue。\r\n\r\n2.1 大表利用cold queue缓存部分数据进行加速	\N	\N	19	\N	3	\N	5	0	2022-05-31 18:51:09.350446	2022-05-31 18:51:09.350446	2022-05-31	0	\N	\N	1064	1	2	f	\N
1069	6	32	数学是程序的灵魂	当我们决定去做一件事情或处理一个问题时。\r\n首先我们得定义问题，描述清楚问题，阐述解决方案。然后才是设计以及实现。\r\n\r\n而阐述问题，描述解决方案主要用到的就是数学知识。\r\n这涉及如何表述问题，如何抽象找到问题本质，如何对方案步骤进行说明，以及方案的证明。\r\n\r\n这才是根本	\N	\N	17	\N	3	\N	5	0	2022-06-13 13:02:06.645349	2022-06-13 13:02:06.645349	2022-06-13	0	\N	\N	1069	1	2	f	\N
1071	7	16	fio 测试配置	[global]\r\nname=iotest\r\nioengine=sync\r\niodepth=64\r\ngroup_reporting=1\r\nbs=512K\r\nsize=1G\r\nrw=read\r\n\r\n[obj1]\r\nfilename=./testfile1\r\n[obj2]\r\nfilename=./testfile2\r\n[obj3]\r\nfilename=./testfile3\r\n[obj4]\r\nfilename=./testfile4\r\n[obj5]\r\nfilename=./testfile5\r\n[obj6]\r\nfilename=./testfile6\r\n[obj7]\r\nfilename=./testfile7\r\n[obj8]\r\nfilename=./testfile8	\N	\N	19	\N	3	\N	5	0	2022-06-15 11:41:14.411648	2022-06-15 11:41:14.411648	2022-06-15	0	\N	\N	1071	1	2	f	\N
1072	7	16	strace分析文件io	strace -f -e trace=file -p 8437	\N	\N	19	\N	3	\N	5	0	2022-06-16 08:16:05.280639	2022-06-16 08:16:05.280639	2022-06-16	0	\N	\N	1072	1	2	f	\N
1073	7	16	io的理解	很奇怪的是fio的随机io不加direct时，avgrq-sz上不去。这样看到的请求很多，但是吞吐量上不去。\r\nsda               0.00     0.00  281.00    0.00    35.12     0.00   256.00     7.97   28.11   28.11    0.00   3.56 100.00\r\n\r\n加了direct之后：\r\nsda               0.00     0.00  128.00    0.00    64.00     0.00  1024.00     7.99   65.21   65.21    0.00   7.81 100.00\r\n\r\n这说明随机大块IO加direct性能更好。但是为什么呢？为什么io分割成更小的了？\r\n经过测试超过128K之后，使用direct io效果就超过了buffer io。\r\n在希捷7200盘测试。	\N	\N	19	\N	3	\N	5	1	2022-06-16 09:15:47.450884	2022-06-16 15:19:40.379694	2022-06-16	0	\N	\N	1073	1	2	f	\N
1078	6	9	无为与无不为，实事求是与随性而为，严肃与活泼	实事求是真魄力，随性而为是傻逼！\r\n\r\n蓦然回首发现自己很多事情都是随性而为，没有章法，没有逻辑与科学。导致做事反反复复，没有效果。\r\n举个例子：带小孩去看病，如果认真把这当个事。那么就应该按客观规律来，提前做好规划与准备。确保结果。\r\n比如优化性能：你总得对问题要准确的描述，对解决方法进行论证，然后再去实施吧，不然不是瞎搞一通。\r\n\r\n有为与对生命的抑制是两回事，做事与活泼并不矛盾。\r\n是低质量的做事与活泼矛盾。因为那样会在反复挫败自己。\r\n\r\n无为而无不为就是强大而不随性。	\N	\N	17	\N	3	\N	5	1	2022-07-01 07:24:39.218203	2022-07-01 07:37:30.351936	2022-07-01	0	\N	\N	1078	1	2	f	\N
1066	6	15	我的步伐-寻找适合业余选手的步伐	原则：在保持连贯的前提下尽可能少费力的快速移动。\r\n\r\n要少费力必须减少起跳和并步。\r\n那问题就在于如何发挥交叉步的威力。\r\n\r\n交叉步与散步区别在于驱动力不一样。散步时是大腿上抬发力。交叉步是大腿小腿蹬地发力。\r\n显然蹬地更快，也稍微费力点，但是比起跳和并步对小腿力量要求好很多。\r\n\r\n1，保持持续移动，利用惯性，不要停下来。\r\n2，把握节奏，改变步伐对上节奏。\r\n	\N	\N	17	\N	3	\N	5	1	2022-06-02 06:51:10.656343	2022-06-19 20:19:19.966611	2022-06-02	0	\N	\N	1066	1	2	f	\N
1079	6	23	踩内存问题分析	1，要么资源没初始化好就用了。\r\n2，要么使用了释放的资源\r\n3，要么越界\r\n4，要么并发没控制住\r\n\r\nc语言可使用clang的asan功能来分析，\r\nvs貌似有其他工具可以分析。\r\n\r\n但科学的方式我觉得还是得用rust,go等语言来解决。\r\n\r\n但是封装高了性能优化，gdb都很难。不过话说回来需要用gdb的时候效率应该不行了。\r\n	\N	\N	17	\N	3	\N	5	0	2022-07-03 06:43:39.168862	2022-07-03 06:43:39.168862	2022-07-03	0	\N	\N	1079	1	2	f	\N
1084	6	9	存在主义，行先于知	世界与人生当然毫无意义，但存在确实客观的。\r\n但寻找不到意义后，人们很容易陷于神秘，虚无。\r\n自由是非常令人恐惧和不安的，道德习俗构建的秩序又显得非常的荒谬。\r\n\r\n行先于知是非常有意义的。\r\n这跟唯物主义有点相通，没有物质没有意识，没有行为也没有意识。\r\n试想下一个什么都没做都没看到的人会有什么样的意识？\r\n\r\n有物质必然就有存在，就有行为，存在就是物质与行为。存在先于意识。	\N	\N	17	\N	3	\N	5	0	2022-07-13 19:18:31.412861	2022-07-13 19:18:31.412861	2022-07-13	0	\N	\N	1084	1	2	f	\N
1085	6	23	强大的Vtune	vtune除了pref那种汇总图外，最重要的是有时间线。\r\n可以看出：\r\n1，每个线程在什么阶段做什么\r\n2，每个线程的堆栈，而不是汇总的	\N	\N	17	\N	3	\N	5	0	2022-07-14 09:32:59.264933	2022-07-14 09:32:59.264933	2022-07-14	0	\N	\N	1085	1	2	f	\N
1080	6	23	编译问题之-----报库中没有某个函数，但是代码明明有	很可能是链接错了库	\N	\N	17	\N	3	\N	5	1	2022-07-03 06:45:56.850507	2022-09-15 13:32:13.788643	2022-07-03	0	\N	\N	1080	1	2	f	\N
705	6	15	羽毛球运动理解1.0	整个击球过程的分解：\r\n1，启动\r\n2，调整位置(腿，身体)\r\n3，调重心(包括高低，方向)\r\n3，蹬地(腿)\r\n4，刚体传动（身体）\r\n5，枝节传动(大臂，手肘，手腕)\r\n这里根据前中场球打法变化很多。\r\n6，方向控制(主要是手肘，小臂)\r\n7，握紧击球\r\n8，回位\r\n\r\n这8步身体的大部位全部参与了。\r\n在某个部位发力时，其他部位通常是放松的。\r\n\r\n定律：\r\n1，击球角度必然与手肘手指展开在一个平面，因而其角度选择并不大，一般在10到12点方位。\r\n此外继续发力就是浪费，且影响连贯性。这也决定了大臂要展开。\r\n2，方向控制由手肘和小臂来完成。\r\n\r\n\r\n除了个人技术之外羽毛球还有2个方向：\r\n1，战术\r\n2，配合	\N	\N	17	\N	3	\N	5	12	2020-10-28 05:56:18.228661	2022-10-29 15:34:31.824343	2020-10-28	0	\N	\N	705	1	2	f	\N
1070	7	16	一种变长buffer设计，同时解决malloc碎片化导致的内存膨胀问题	http://db.in.tum.de/~freitag/papers/p29-neumann-cidr20.pdf\r\n\r\n碎片化引起的膨胀：\r\n由于虚拟地址的高地址部分	\N	\N	19	\N	3	\N	5	0	2022-06-15 08:11:41.207808	2022-06-15 08:11:41.207808	2022-06-14	0	\N	\N	1070	1	2	f	\N
1023	6	23	Linux io性能分析	工具：iostat,pt_diskstat\r\n1，首先要确定压力是否到了硬盘。\r\n   看响应时间，看队列等待，再综合吞吐量，大概能分析下的io的特征\r\n\r\n2，探测硬盘的能力上限\r\n   如果是裸盘，直接有规格，但是中间加了raid等就不好说了。\r\n\r\n     寻址时间\r\n　　从接到读写命令到能够开始读写第一个数据所需要的时间称为磁盘存储器的寻址时间。\r\n　　寻址时间由两部分组成：定位时间和等待时间。定位时间也称为寻道时间，是磁头移到指定磁道所需要的时间。\r\n    磁盘存储器的定位时间与所采用的定位方法有关，硬盘存储器一般采用音圈电机定位，定位时间为10ms左右，软盘存储器采用步进电机定位，定位时间与要访问的磁道有关。\r\n　　等待时间是指磁头移动到需要访问的磁道之后，等待被访问的扇区转动到磁头下方所需要的时间。\r\n    等待时间与磁盘的转速和磁头定位完成时所处的物理位置有关，理想情况是：当磁头刚刚移动道要访问的磁道时，\r\n    被访问的扇区也正好转动到磁头下方，这时，等待时间为0；最坏情况是：当磁头移动到要访问的磁道时，被访问的扇区刚刚转过磁头下方，\r\n    这时，要等待磁盘再旋转一圈，被访问的扇区才能转到磁头下方，因此，等待时间为磁盘转动一圈所需要的时间。\r\n    通常，采用平均等待时间来表示，平均等待时间为磁盘旋转半圈所需要的时间。\r\n　　在有些磁盘存储器的参数表中，并不直接给出寻址时间、等待时间等，而是给出磁盘的转速和寻道时间（或平均寻道时间）。\r\n    实际上，通过磁盘的转速很容易就能换算成平均等待时间，把平均等待时间与寻道时间相加就得到磁盘存储器的寻址时间。\r\n\t\r\n   为什么2个线程一个顺序io，一个随机io，在队列深度为1且direct时，但是速度并不相等？\r\n      按理说每个发一个请求，最终一起结束？磁盘回来寻道旋转？\r\n      实测并非如此，可能实际情况是磁盘相应了请求后，马上后面来了一个连续的请求，并优先得到调度。\r\n\r\n   这也说明不论在什么情况下，单线程内尽量顺序IO也是有意义的。\t\r\n\r\n   一般机械盘，随机250M+， 顺序1GB(要超过这个速度，基本上要靠内存cache命中了)。\r\n\r\n3，io特征，是随机io，还是顺序io	\N	\N	17	\N	3	\N	5	2	2022-03-07 19:52:36.510587	2022-06-15 12:59:35.815182	2022-03-07	0	\N	\N	1023	1	2	f	\N
1067	6	24	StarRock存储引擎	<pre>\r\n1，存储结构\r\n目录结构：storage_root_path -> bucket -> tablet -> schemaHash(table)-> segments\r\nhttps://xie.infoq.cn/article/4f7d09d6185fb3055d4e7e51c\r\n\r\n\r\n2，模块结构\r\n\r\n3，物理结构\r\n\r\n4，插入实现\r\nhttps://xie.infoq.cn/article/4cc8416c0054bf6f2cdb8b16c\r\n\r\n5，UniqueKey的更新/删除实现\r\nhttps://xie.infoq.cn/article/4cc8416c0054bf6f2cdb8b16c\r\nunique key的实现：\r\n\r\n使用rowset记录删除/更新。但是需要进行逻辑合并。\r\n\r\n更新：利用多版本，由于key是unique的，因而同一个key只要最新版本即可。\r\n\r\n删除：记录谓词条件。\r\n\r\n6，UniqueKey查询实现\r\n读时合并技术，基于UniqueKey。必须要unique，因为合并是根据key来的，而非rowid。\r\n\r\n参考源码：TabletReader::_init_collector\r\n\r\nhttps://www.slidestalk.com/doris.apache/15457\r\n\r\n7，PrimaryKey下的更新/删除\r\nhttps://docs.starrocks.com/zh-cn/main/table_design/Data_model\r\nhttps://zhuanlan.zhihu.com/p/513426455\r\n\r\n使用rocksdb存储del vector，采用roaring bitmap编码。\r\n\r\n\r\n\r\n8，预读\r\n\r\n没预读，使用文件系统预读能力。多线程直接读。\r\n\r\n\r\n\r\n9，缓存\r\n\r\nindex page 元数据与数据分离。都使用page cache，但是元数据会占一定比例。\r\n\r\n另外像PrimaryIndex这类数据支持缓存到内存，并未使用page cache。\r\n</pre>	\N	\N	17	\N	3	\N	5	2	2022-06-06 18:58:15.116726	2022-06-15 14:32:25.570065	2022-06-06	0	\N	\N	1067	1	2	f	\N
1075	6	18	个人世界与极大丰富的软件实体	不论是否承认，个人的意义在于构建自己的世界。而不是作为无聊的参与者。\r\n并且个人参与创作的世界，一个极大丰富了软件实体的世界。\r\n\r\n需要哪些技术支撑：\r\n1，要有坚实的构建软件的方法\r\n2，要有产权保护与利益分配\r\n3，个人参与	\N	\N	17	\N	3	\N	5	0	2022-06-19 15:20:15.683534	2022-06-19 15:20:15.683534	2022-06-19	0	\N	\N	1075	1	2	f	\N
1076	7	16	磁盘饱和度分析，磁盘并行能力	https://www.percona.com/blog/2017/08/28/looking-disk-utilization-and-saturation/\r\nhttps://blog.csdn.net/cling60/article/details/80758095\r\n\r\n目前看没啥好办法，只能通过fio测试了，压到：\r\n吞吐量无法增加为止，这时增加io只会加排队时间。\r\n或者\r\n压到wait服务时间与线程数等比增长。这时说明吞吐量也没法提升了。\r\n\r\n一个磁盘只有一个机械头，但是raid的有并行能力\r\nhttps://www.zhihu.com/question/270092008	\N	\N	19	\N	3	\N	5	0	2022-06-21 08:55:39.03712	2022-06-21 08:55:39.03712	2022-06-21	0	\N	\N	1076	1	2	f	\N
1068	6	27	我的软件开发流程，套路(以创业之心来做事)	1，需求调研 -- 系统与哲学，经济学等等\r\n2，设计   -- 数学，从问题抽象，以及原理上阐述。\r\n3，执行  --管理学， 执行表单算法，可以随时补缺，跟踪进度。\r\n4，开发与自验证  -- 语义，逻辑，语言以及工程\r\n5，review  -- checklist，沟通交流\r\n6，publish - 沟通	\N	\N	17	\N	3	\N	5	4	2022-06-09 07:28:08.234697	2022-08-16 08:50:00.997615	2022-06-09	0	\N	\N	1068	1	2	f	\N
1132	7	33	数据库存储引擎(业务)	接口层：DML访问接口，事务接口(分布式事务)，复制接口，DDL，启停\r\n对象层：字典，系统表(DDL)，视图，表，索引，IOT. 分区\r\n结构层：heap，btree, swf\r\n缓存层：buffer，cache(只读页面缓存)\r\n事务层：事务，undo，锁，空间管理(表空间，segment)\r\n持久层：控制文件，双写，redo, checkpoint，归档，物理和逻辑复制\r\n资源层: device文件，线程，内存池	\N	\N	19	\N	3	\N	5	2	2022-10-25 07:58:12.149567	2022-11-08 18:57:07.380932	2022-10-25	0	\N	\N	1132	1	2	f	\N
1077	6	7	SSDR 36：实体的位置及关系	实体之间有属于，引用，间接引用等关系。\r\n所有权与实体关系是另外一回事。\r\n比如实体A拥有C的所有权，但是C与B实体关系更加紧密。\r\n举个例子：\r\n操作slice的hander，大家共享的memCache，其中有很多object。\r\n现在我想把handler访问到的object跟踪起来。那这个跟踪器跟handler，memCache是什么关系？\r\n1，首先queryTracker管理的是object，那么肯定在object之上。\r\n2，queryTracker是在memCache模块内使用，分配或释放内存对象时使用。\r\n3，queryTracker是属于某个handler的。\r\n\r\n所以queryTacker怎么放？\r\n1，放入memCache用hashTable记录然后handler间接引用，比如queryId。\r\n2，定义在memCache，但是分配释放的所有权归handler。handler直接拥有queryTacker。\r\n3，定义在handler层，反向注入。\r\n\r\n显然方案2更合适。\r\n\r\n注意拥有不一定非要用结构体表达，也可以用指针。\r\n    直接引用则只能是指针了\r\n    间接引用是用另外一套地址，加上查表来表示。	\N	\N	17	\N	3	\N	5	0	2022-06-22 07:02:06.129001	2022-06-22 07:02:06.129001	2022-06-22	0	\N	\N	1077	1	2	f	\N
1082	6	7	SSDR 37: 多线程框架	1，不同任务如何划分给执行单元？\r\n   任务的特征如何？\r\n   从中断的地方切，比如计算线程，io线程，网络线程等。\r\n   再加上一些后台线程，定时器等。\r\n\r\n2，相同的任务并发执行如何调度？\r\n3，线程池还是按会话创建线程？\r\n4，请求进来经过多少级线程合适？\r\n5，哪些任务适合线程池，哪些任务需要专用线程。\r\n\r\n线程是对CPU能力的封装，内存池是对内存的封装。	\N	\N	17	\N	3	\N	5	1	2022-07-09 15:12:58.257368	2022-07-09 21:39:39.055762	2022-07-09	0	\N	\N	1082	1	2	f	\N
1083	6	23	Linux iostat详解	那么怎么判断IO是在调度队列排队等待，还是在设备上处理呢？iostat有两项数据可以给出一个大致的判断。svctime，这项数据的指的是IO在设备处理中耗费的时间。另外一项数据await，指的是IO从排队到完成的时间，包括了svctime和排队等待的时间。那么通过对比这两项数据，如果两项数据差不多，则说明IO基本没有排队等待，耗费的时间都是设备处理。如果await远大于svctime，则说明有大量的IO在排队，并没有发送给设备处理。\r\n\r\n存储原理\r\nhttps://plantegg.github.io/2020/01/25/SSD%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/\r\n\r\n容易误读的iostat\r\nhttp://linuxperf.com/?p=156	\N	\N	17	\N	3	\N	5	0	2022-07-09 21:49:41.581866	2022-07-09 21:49:41.581866	2022-07-09	0	\N	\N	1083	1	2	f	\N
1086	6	9	朴素辩证法-自然的归纳-太极，松弛，矛盾	其本质都在描述事物内部不仅有矛盾，而且内部力量必然引起转化。\r\n而且这种转化不仅是必然的，而且是需要的。\r\n\r\n而我们就应该专注于当下，才能让毛和盾都完满。犹如太极。\r\n又犹如打羽毛球，必须很松，然后才能很紧。\r\n这是因为事物都有内部矛盾，即有变化。	\N	\N	17	\N	3	\N	5	1	2022-07-19 06:45:11.477762	2022-07-19 06:46:52.064901	2022-07-19	0	\N	\N	1086	1	2	f	\N
1089	7	33	TPCH优化合入dev	1，cache优化\r\n7.20： 目前还没验证，导入10GB数据进行验证。\r\n另外写文档跟踪\r\n\r\n2，减少访问block数量的优化。	\N	\N	19	\N	3	\N	5	0	2022-07-20 07:13:21.920982	2022-07-20 07:13:21.920982	2022-07-20	0	\N	\N	1089	1	2	f	\N
1093	7	33	调研其他产品的冷热存储方案		\N	\N	19	\N	3	\N	5	0	2022-07-20 13:38:48.747978	2022-07-20 13:38:48.747978	2022-07-20	0	\N	\N	1093	1	2	f	\N
1088	7	33	深圳通dev版本性能跟踪	目前发现的问题：\r\n1，allLink优化有用\r\n2，swfVdsFetchDataFromLinks的性能优化，else分支因为pLink->len随机值而加上，但是对性能有影响。\r\n3，TAC统计信息不准确\r\n4，并行没用上。\r\n5，TAC可以增加一些debug日志，在扫描或插入结束的时候。\r\n	\N	\N	19	\N	3	\N	5	1	2022-07-20 07:11:56.612455	2022-07-21 16:41:28.991916	2022-07-20	0	\N	\N	1088	1	2	f	\N
821	6	8	谈色和欲	通过钱财权利获取交配权是现代社会最大的不平等。\r\n而把交配权卖给金钱还能大行其道或许在商业社会也无可避免。\r\n这也是出于生存需要吧，把自己降低到一个卑微的身份，承认人和人的不平等。\r\n通过交易，富人就没了道德谴责。\r\n\r\n色是每个人的需求，应该以适当的渠道满足。而欲是心魔需要人去修炼。\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	1	2021-03-21 09:18:18.881853	2022-07-24 21:21:57.627632	2021-03-21	0	\N	\N	821	1	2	f	\N
1096	6	8	我心理的4个问题	1，焦虑问题\r\n2，情欲问题\r\n3，时空问题\r\n   活在当下还是诗和远方\r\n   其实不论当下，还是诗和远方，人都活在现象，意识，心灵三个世界中。\r\n当我们说诗和远方时，我们其实在寻找心灵世界中迷失的东西。\r\n4，意义问题\r\n   发现，构建，与分享我的世界。	\N	\N	17	\N	3	\N	5	0	2022-07-24 21:39:46.033689	2022-07-24 21:39:46.033689	2022-07-24	0	\N	\N	1096	1	2	f	\N
1100	6	23	数据库客户端	DataGrid， 收费\r\nDBeaver， 免费好用	\N	\N	17	\N	3	\N	5	0	2022-07-28 11:54:21.53925	2022-07-28 11:54:21.53925	2022-07-28	0	\N	\N	1100	1	2	f	\N
1102	6	23	开发工具系列： git	git为啥经典，它提供了多人协作的多版本管理工具。\r\n强大的分支管理能力，使得代码可以快速迭代发展。	\N	\N	17	\N	3	\N	5	0	2022-07-28 12:05:55.40145	2022-07-28 12:05:55.40145	2022-07-28	0	\N	\N	1102	1	2	f	\N
1104	6	23	开发工具系列：doc	通过markdown直接生成产品文档。\r\n软件开发必须让文档维持常新，否则文档就会失去意义。\r\n\r\n文档是用另一种语言描述的代码。\r\n即文档应该利用工具从代码仓库生成。\r\n\r\nrust采取了该方式。	\N	\N	17	\N	3	\N	5	0	2022-07-28 12:10:08.231504	2022-07-28 12:10:08.231504	2022-07-28	0	\N	\N	1104	1	2	f	\N
1107	6	23	定位工具系列： iostat,vmstat	结合排队理论分析磁盘或网络瓶颈。\r\n\r\n施压 + 观察，直到无法提升为止。	\N	\N	17	\N	3	\N	5	0	2022-07-28 12:12:58.008772	2022-07-28 12:12:58.008772	2022-07-28	0	\N	\N	1107	1	2	f	\N
1094	7	33	release版本panic改造		\N	\N	19	\N	3	\N	5	1	2022-07-20 14:14:22.856517	2022-08-01 06:36:55.722796	2022-07-20	100	\N	\N	1094	1	2	f	\N
1091	7	33	迭代二特性设计风险排查		\N	\N	19	\N	3	\N	5	2	2022-07-20 07:21:56.206542	2022-08-01 06:40:25.99189	2022-07-20	0	\N	\N	1091	1	2	f	\N
1090	7	33	推动-韩峰哲完成技术材料		\N	\N	19	\N	3	\N	5	1	2022-07-20 07:21:13.410068	2022-08-01 06:41:07.40689	2022-07-20	0	\N	\N	1090	1	2	f	\N
1108	6	24	列存更新方法(HTAP技术线路)	hologres：delete + insert memtable\r\nhttp://119.23.14.122:10083/\r\n\r\n\r\nstarrock: delete + insert \r\nhttps://zhuanlan.zhihu.com/p/513426455\r\n同时介绍了其他更新手段。\r\n\r\nstarrock没有支持行级事务的结构，可能产生很多rowset。\r\n\r\n方案三：\r\nbase + delta (delta只有一个)\r\nhttps://blog.csdn.net/TiDBer/article/details/126103052\r\n\r\n这个方案有starrock描述的问题，没有delete bitmap，即必须先合并数据再过滤。	\N	\N	17	\N	3	\N	5	7	2022-08-03 18:57:52.989693	2022-12-14 14:10:56.089302	2022-08-03	0	\N	\N	1108	1	2	f	\N
1081	6	27	兼容性设计	1，预留式，要初始化为0\r\n2，末尾扩展式\r\n3，多版本式，或编解码式	\N	\N	17	\N	3	\N	5	1	2022-07-03 12:14:52.934797	2023-02-01 18:10:06.630148	2022-07-03	0	\N	\N	1081	1	2	f	\N
1109	6	7	SSDR 38：软件的4个要求(我所期望的软件开发(辩证法在软件开发中的运用))	软件开发的水平主要体现在：\r\n1，软件是创新的，具备先进性\r\n   软件是用于解决新矛盾新问题的，应该有其先进性。\r\n2，软件不仅要是正确的，而且是要防错的。\r\n   软件想出错都难，这需要测试平台，以及软件开发方法支撑。\r\n   实现不应该随便打乱设计\r\n3，软件是有效率的，不仅是运行效率，还有沟通效率，以及适应变化。\r\n   软件可以持续快速的增加新功能\r\n   这需要得益于清晰良好的架构\r\n   软件可以快速发布\r\n   这要求很高的软件管理水平，组织内文档资料，测试套，概念体系，发布等等都能及时跟上。\r\n4，软件是可维护的\r\n	\N	\N	17	\N	3	\N	5	12	2022-08-06 07:33:39.669391	2022-12-27 09:15:30.009498	2022-08-06	0	\N	\N	1109	1	2	f	\N
1116	6	24	CacheLib方案	1，使用共享内存\r\n  共享内存要考虑升级问题，处理比较麻烦。\r\n  比如扩容SSD咋搞。	\N	\N	17	\N	3	\N	5	0	2022-08-26 08:27:47.059207	2022-08-26 08:27:47.059207	2022-08-26	0	\N	\N	1116	1	2	f	\N
1117	6	24	LSM的本质，clickhouse	diskcache也用到了lsm的思想。\r\nlsm不一定要跟kv绑定，https://zhuanlan.zhihu.com/p/521350452。\r\n	\N	\N	17	\N	3	\N	5	0	2022-08-29 08:18:39.653336	2022-08-29 08:18:39.653336	2022-08-29	0	\N	\N	1117	1	2	f	\N
1123	6	9	没有银弹，从具体到一般，不要沉迷宏大设计	我做了一个梦：一个题目图中有非常多的点，让我们描述如何画出来。即找出这些点的规律。\r\n\r\n我从这里看，从哪里看都没法得出一个统一的规律，然后就梦醒了。\r\n\r\n这里我看出了自己思维的问题：即总想找到一个全局的解。\r\n实际上大问题，大系统可能都是局部解然后在申华。\r\n\r\n即要从具体到一般，而非上来就宏观设计，这样很容易犯教条主义或经验主义错误。\r\n世界是复杂的，没有一种统一规律可以概况所有情况，不必在此浪费太大功夫。	\N	\N	17	\N	3	\N	5	0	2022-09-07 09:42:08.534466	2022-09-07 09:42:08.534466	2022-09-07	0	\N	\N	1123	1	2	f	\N
1018	6	7	SSDR21: 什么是他妈的好代码	目标\r\n算法与架构\r\n设计与计划\r\n编码\r\n测试\r\n\r\n如果从5个层次给程序员划分效能。\r\n那么掌握越高层次的人，效率越高，可能是*3关系。\r\n这样最优秀的执行任务的人跟普通人差距可能有243倍。\r\n如果普通打工人收入是10万，那么顶级人员按效能算，可以是2430万。\r\n\r\n注意我们在做事的效率取决于：\r\n1，从顶层我们能设计考虑到什么程度，如何纠偏，如何正确高效的做事。\r\n   从程序来说从顶层，我们可以将结构细化到何种程度？认知到哪些事物之间的关系？\r\n2，从底层如何落实，如何发现问题反馈给顶层，以做出调整。\r\n   对于认知不到的，再继续挖还不如干来得快，那我们先做一部分，然后再反推顶层。\r\n\r\n切记越高层越牛逼，不要为了短期完成任务蛮干而不掌握顶层能力。\r\n\r\n目标----痛感----效能 可以是一个三角。\r\n目标：应该是可以执行的，不然不称为事，即不可执行。\r\n痛感：保持痛感是生存的必须，但是并非恐惧，焦虑与狂躁。\r\n效能：人的做人做事能力，积极作为，这个是改变的力量。没有此力量，人在自然规律，社会规则下就会到处受制，自由就是要不断的自我抉择，调整自己更好使得适应环境，改变环境。这是生命该有的样子。也是少有人走的路，也是目的论的出发点。\r\n	\N	\N	17	\N	3	\N	5	4	2022-02-23 05:57:39.369834	2022-09-09 05:35:33.949272	2022-02-23	0	\N	\N	1018	1	2	f	\N
1115	6	9	何为修道		\N	\N	17	\N	3	\N	5	2	2022-08-17 07:58:58.911172	2022-08-31 19:40:21.156144	2022-08-17	0	\N	\N	1115	1	2	f	\N
1118	7	33	8.30	1，review 陈宜顺交底书\r\n2，将S3提交到拉出的分支\r\n3，阿港数据湖测试用例	\N	\N	19	\N	3	\N	5	3	2022-08-30 12:11:06.329839	2022-09-01 12:26:39.489185	2022-08-30	0	\N	\N	1118	1	2	f	\N
618	7	16	堡垒机	欧伟杰 4-22 12:00:02\r\n【通知】我们的堡垒机调整了外网接入的安全性，后面请用https://fortress.sics.ac.cn/接入\r\n\r\n李伟超 3-27 19:51:26\r\n新的堡垒机上没有我的主机了[流泪]\r\n\r\n欧伟杰 3-27 10:38:01\r\n【通知】新堡垒机账号 ID是大家姓名的全拼，初始密码是CoD@123456，可以试下能否登录自己的机器，如果找不到IP地址和我说下 	\N	\N	19	\N	3	\N	5	2	2020-05-08 14:51:29.259481	2022-09-19 08:36:58.539129	2020-05-08	0	\N	\N	618	1	2	f	\N
1142	6	4	学习思路2	1，词根法不靠谱\r\n   组多多变，全靠猜\r\n2，场景记忆也不靠谱\r\n   后来会发现连场景都记不住\r\n\r\n计划：\r\n1，搞定阅读理解\r\n\r\n1.1 词汇量\r\n还是用传统分类整理法来学吧。\r\n1，单词分类整理\r\n   40*100，搞定4000单词\r\n2，单词生成原理\r\n   单词从何而来，在概念体系中的层次。\r\n3，英文原书阅读，每周一本。\r\n\r\n1.2 句法理解\r\n\r\n2，听\r\n\r\n3，说\r\n\r\n4，写	\N	\N	17	\N	3	\N	5	0	2022-11-10 07:26:45.449197	2022-11-10 07:26:45.449197	2022-11-10	0	\N	\N	1142	1	2	f	\N
1119	7	33	对象存储技术项目调研	立项，得证明我们所做的事情：\r\n1，方向正确，目标清晰\r\n2，具有生存空间，有竞争优势。\r\n\r\n\r\n1，云数仓最牛逼的几家。\r\n2，跟它有哪些技术差距。\r\n3，这个小技术项目要搞定哪几个点。\r\n4，这几个点如何算达成目标，确定验收规格。	\N	\N	19	\N	3	\N	5	3	2022-08-30 15:18:01.216566	2023-03-14 18:33:10.559004	2022-08-30	0	\N	\N	1119	1	2	f	\N
1145	6	7	SSDR 46:流处理与批处理	流处理对实时性有要求，中间某些错误可以忽略，数据源源不断的进来。\r\n\r\n这可以理解成从输入的特征来区分计算的类型。\r\nOLTP和OLAP是从计算的特征来区分	\N	\N	17	\N	3	\N	5	0	2022-11-16 21:06:05.945573	2022-11-16 21:06:05.945573	2022-11-16	0	\N	\N	1145	1	2	f	\N
1143	7	33	继续往前走，解决计算弹性扩展问题	首先尝试解决计算组内的弹性扩展问题。\r\n对于新一代云数仓和我们的架构。 其实我们只是多了一层而已。\r\n我们一个计算组就相当于别人的整体架构。\r\n\r\n拉起全量同步。	\N	\N	19	\N	3	\N	5	2	2022-11-11 04:31:49.105049	2022-11-11 04:38:50.334515	2022-11-11	0	\N	\N	1143	1	2	f	\N
1148	6	4	阅读列存论文		\N	\N	17	\N	3	\N	5	0	2022-11-17 18:27:00.280944	2022-11-17 18:27:00.280944	2022-11-17	0	\N	\N	1148	1	2	f	\N
1133	3	33	列锁与行锁的争论	列锁面临的2个问题：\r\n\r\n1，列锁分为多个锁之后，冲突可能性变大。这样check row的代价放大，check row需重新生成CR页。\r\n\r\n   必须全部加锁成功后，再修改。锁数量增加，存储代价大，加锁代价大。\r\n\r\n2，会出现不期望的行。比如事务1执行update A=2 where M=‘x’， 事务2执行update M=‘y’ where A=1；\r\n\r\n原记录是1，'x', 执行完之后既不是2,'x'， 也不是 1,'y'。\r\n\r\n    锁定所有相关列(包括查询列)，否则就会出现不一致。\r\n\r\n\r\n行锁面临的问题：\r\n\r\n1，undo不再跟页面关联，即undo链有点逻辑化，undo可能与原页面对不上。	\N	\N	17	\N	3	\N	5	0	2022-10-25 18:19:08.090185	2022-10-25 18:19:08.090185	2022-10-25	0	\N	\N	1133	1	2	f	\N
1134	6	23	debug info无法使用的问题	clickhouse调试包无法使用的问题\r\ngdb: 7.6\r\nDwarf Error: wrong version in compilation unit header (is 0, should be 2, 3, or 4) [in module /usr/lib/debug/.build-id/5f/3d9e4f48d4cc47.debug]\r\n\r\ngdb: 8\r\nBFD: /usr/lib/debug/.build-id/5f/3d9e4f48d4cc47.debug: unable to initialize decompress status for section .debug_line\r\nBFD: /usr/lib/debug/.build-id/5f/3d9e4f48d4cc47.debug: unable to initialize decompress status for section .debug_line\r\n\r\nwarning: File "/usr/lib/debug/.build-id/5f/3d9e4f48d4cc47.debug" has no build-id, file skipped\r\n[Thread debugging using libthread_db enabled]\r\nUsing host libthread_db library "/lib64/libthread_db.so.1".\r\n	\N	\N	17	\N	3	\N	5	0	2022-10-26 18:22:39.86521	2022-10-26 18:22:39.86521	2022-10-26	0	\N	\N	1134	1	2	f	\N
1136	6	24	云数仓是什么？	1，技术标准，行业标准。\r\n2，规范测试\r\n3，用户场景\r\n   到底解决了啥问题\r\n\r\n从这些维度去了解云数仓。	\N	\N	17	\N	3	\N	5	3	2022-11-02 04:07:36.026721	2022-11-12 15:33:52.240565	2022-11-02	0	\N	\N	1136	1	2	f	\N
1138	6	23	ABI是啥	ABI是一种规范，要解决的是二进制跨平台执行的问题。\r\n1，跨不同的硬件版本\r\n2，跨不同的操作系统版本\r\n3，跨不同的编译器版本\r\n\r\n\r\n语言，编译器(操作系统kernel, glibc,ELF)，硬件架构都有自己的ABI规范。\r\n\r\nc语言本身是跨平台的，汇编语言是平台相关的。\r\nc编译器可以做到不同版本兼容，即不同版本的编译器出来的二进制是可以互通的。\r\nc++编译器做不到。c++不同编译器编出来的代码可能带前缀不一样，动态库都找不到。\r\n\r\njava等语言的编译器由于有中间码，可以跨平台。\r\n\r\n\r\n参考资料：\r\nhttps://blog.csdn.net/linyt/article/details/46841845\r\nhttps://www.zhihu.com/question/39148567\r\nhttps://zhuanlan.zhihu.com/p/556726543	\N	\N	17	\N	3	\N	5	0	2022-11-02 19:31:26.283696	2022-11-02 19:31:26.283696	2022-11-02	0	\N	\N	1138	1	2	f	\N
1097	6	24	swf性能优化	1、计划选择行计划\r\n2、查询投影列下推，忽略无关列\r\n3、allocator并发冲突及性能\r\n4、热页cache\r\n5、减少内存申请、尽量使用栈内存或已有内存\r\n6、插入空闲空间寻址逻辑\r\n7、部分执行函数逻辑优化\r\n8，notnull使用多页存储，降低页面冲突	\N	\N	17	\N	3	\N	5	2	2022-07-26 14:03:38.985326	2022-12-27 14:08:28.125407	2022-07-26	0	\N	\N	1097	1	2	f	\N
1160	3	33	存储引擎需提供哪些能力才能保证ACID	底层提供存在基本元数据的页面封装，事务页，空间管理，空闲空间管理，数据页的封装。\r\n\r\n元数据页面需支持多版本，事务能力。\r\n空间管理是只追加申请，整体回收的，因而不必提供回滚能力。\r\n空闲空间在事务期间主要是申请，回收是延迟的。其通过页面锁的并发来实现，也不必实现多版本。\r\n数据页是需要多版本的。\r\n其实还需原子操作接口，因为有些情况不会提供undo，只要这些操作一起成功一致性就得以保证。\r\n\r\nundo/redo,redo group 锁页的redo/原子操作/checkpoint\r\n\r\n空间管理坑很多，要考虑到各种页面复用场景，某列的页面被自己复用，某列页面被同表其他页面复用。还有undo与页面对不上的场景。\r\n这些情况都需要报snapshot too old。	\N	\N	17	\N	3	\N	5	4	2022-12-27 13:33:34.166798	2023-02-09 12:34:39.934007	2022-12-27	0	\N	\N	1160	1	2	f	\N
1153	7	33	表，全局临时表，临时表	表的基本信息：\r\n1，TAB$,COL$等元数据\r\n2，SEG相关元数据，其中总入口在TAB$, COL_SEG$\r\n3, TableDict，SwfDict关系，swfDict挂在tableDict上，tableDict挂在DictEntry。\r\n4, dataOid来源\r\n5，数据\r\n\r\nPTT：\r\n1，元数据在handler上\r\n2，swfDict内存自己分配，与tableDict独立\r\n3，handler->pttDcCtx\r\n4，handler上临时\r\n\r\nDictEntry是独立的\r\n\r\n\r\nGTT：\r\n1，TAB$,COL$等元数据\r\n2，记录在tempSegCache上\r\n3，从stack上临时分配 （这里其实不太适合swf）\r\n4，\r\n\r\nDictEntry是共享的，因而不能将tableDict挂到DictEntry上。	\N	\N	19	\N	3	\N	5	2	2022-12-07 13:28:55.929485	2022-12-28 08:17:14.60011	2022-12-07	0	\N	\N	1153	1	2	f	\N
1112	6	24	HTAP专利	专利保护的是方法或装置，是别人不好绕过去的实现路径。\r\n\r\n专利意见：\r\n1，一点要写明白active/stable与main/delta差异在哪?\r\n  如果别人使用内存的列存呢，merge有优势？\r\n2，实施例可以展开点写\r\n  一种实施例直接在active slice之上做编码压缩(可更新的编码压缩)，稀疏索引。同时维持几乎不变的更新能力。\r\n  第二种在第一种基础上将active slice 基本不更新的列抽取出来，做编码压缩。但不重排序。其他列维持几乎不变的更新能力。\r\n  //第三种在第一种基础上，把指定列抽取出来，并且进行重排序，剔除无效行，但是需要维护到之前的行映射。\r\n  第四种将active slice完成转换成stable slice，并且重排序，剔除无效行，编码，压缩。但stable slice不支持本地更新。\r\n\r\n  二是active中扣出部分列做编码压缩，排序，然后合并。\r\n  三是将active中数据扣出来。重新组织，但是事务信息仍然一体化。\r\n\r\n仍然体现冷热，但是冷之后进行转换处理，转换的重点是将数据扣出来。\r\n而不是将新数据合入。即将热转出。\r\n好处是可以维持更新删除能力。\r\n	\N	\N	17	\N	3	\N	5	5	2022-08-10 15:06:37.435626	2022-11-05 05:47:33.243473	2022-08-10	0	\N	\N	1112	1	2	f	\N
1147	6	24	SSB测试总结	SSB测试识别的问题：\r\n1，不支持带函数的时间条件下推。因而部分语句yashandb扫描的行数多出N倍。\r\n\r\n    如extract(year from LO_ORDERDATE)= 1993，to_char(LO_ORDERDATE, 'YYYYMM') = '199401' \r\n\r\n2，扫描数据量接近时\r\n\r\n     非首次yashandb性能跟ck接近。如语句4~9,11等。\r\n\r\n     首次性能经过调整slice大小以及编码方式后差距大幅缩小，部分已接近。\r\n\r\n3，yashandb slice文件太小，离散IO。要支持更大的slice，但是可能不利于并行查询(跟slice总数有关系).\r\n\r\n4，CK date类型使用2 bytes，yashandb使用8字节，且没有对应的短类型。\r\n\r\n5,  dictionary(rle) 比 dictionary(plain)能节省大量空间，可优选dictionary(rle)。\r\n\r\n6，varchar类型的长度部分需要编码。\r\n\r\n7，带order key过滤的语句即便改写性能也与ck差距非常大。\r\n\r\n     可能是排序粒度影响了，2M粒度下虽然过滤效果也不差，但是IO比较离散(这里还有io放大问题)。\r\n\r\n     order key作为最明显的过滤条件，应该在有此条件时最优化。order粒度要支持更大。\r\n8，充分利用order key，做二分或快速查找	\N	\N	17	\N	3	\N	5	1	2022-11-17 14:54:30.629566	2022-11-18 08:42:55.872644	2022-11-17	0	\N	\N	1147	1	2	f	\N
1139	6	7	SSDR 44: 一致性的思考	一致性问题主要有两种情况：\r\n1，关联数据的一致性。比如元数据与数据一致性。\r\n2，多份数据的一致性，比如cache一致性，副本一致性。\r\n\r\n一致性问题是伴随着并发出现的。\r\n这问题通常有两种解法：\r\n1，原子性。\r\n实用两阶段锁把数据x和数据y给锁起来，保证读写一致性。\r\n2，多版本。\r\n读取的人可读到对应的老版本。写总是基于最新版本。\r\n2.1 通常老版本维护的时间有限，这时又出现了新的一致性问题。\r\n比如：1，block被同segment复用问题。 2，undo链上的页面被复用问题。\r\n\r\n3，校验\r\n通过机制发现不一致的情况，然后报错或重试。\r\n3.1 重试的前提是可重入的。\r\n比如upsert，如果更新失败，必须先回滚再重新执行整个语句。\r\n\r\n数据库一致性场景分析：\r\n1，元数据与数据一致性\r\n典型场景就是存储结构中的元数据。\r\n如果元数据不支持多版本，数据支持多版本。那显然就有问题，\r\n代码从元数据入口找不到对应的老数据了。\r\n\r\n2，cache一致性\r\n比如数据库字典，字典不支持多版本，如果不失效，以及通过引用机制来使用。\r\n那么老的查询可能没法拿到对应版本的字典，而dml也没法使用最新的字典。\r\n为了不搞字典多版本，闪回查询不支持跨越ddl，而cache中也只支持放与ddl相关的内容。\r\n\r\n3，副本一致性问题\r\n比如原子操作包装的相关页面，在备机读取时如果没有对应的措施，就很容易出现一致性问题。\r\n通过页面锁保证。所以页面锁也得记录redo。\r\n\r\n4，数据block与undo一致性\r\nundo写入需在页面加锁期间，否则可能出现block数据与undo不一致问题。\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	2	2022-11-05 06:36:20.965315	2022-11-09 17:31:10.187562	2022-11-05	0	\N	\N	1139	1	2	f	\N
1124	6	7	SSDR 40：实体与行为封装原则 --- 依赖 - 软件可变性问题	1，相关度原则\r\n   实体内成员之所以在一起，是因为其存在某种内在关系。\r\n   比如物体，其具有公共移动的特点。\r\n   而对于软件实体，其通常具备 *公共存在，同时改变* 的特点。\r\n   \r\n \r\n2，稳定依赖\r\n   依赖时间更长，结构更加稳定，行为更加稳定的。\r\n   将对数据的依赖尽量转换为对接口的依赖，保持结构独立性\r\n\r\n3，替换原则\r\n\r\n4，可见性-内部可变原则\r\n\r\n5，最小沟通原则\r\n   实现实体或行为，需要参与的人越少越好。\r\n   减少人之间的依赖。\r\n\r\n   	\N	\N	17	\N	3	\N	5	7	2022-09-12 20:44:35.96001	2022-11-21 19:17:00.482749	2022-09-12	0	\N	\N	1124	1	2	f	\N
934	6	9	生活的真相	没有人能完全从别人视角看待问题，没有人能让其他人成长，人必须独立而自由。\r\n利用动物的能动性，人的沟通能力和智力去开启自己的奇幻旅程。\r\n\r\n生机畅达只能来源于生活本身，没有一个外在纯然存在的精神力量或地方能让人保持愉悦。\r\n想想打羽毛球，什么动力让人去羽毛球馆，是纯粹打羽毛球过程中的快乐，\r\n挥汗如雨给身体带来的体验，进步带来的信心，领悟带来的兴奋感，杀球带来的快感。\r\n\r\n生活中很多事情都是熵增过程，人在生活中要不断面对这些，比如疾病，比如感情变淡，\r\n取得一些成长也难，所有我们体验过的感觉可能都会慢慢变淡。\r\n吃喝玩乐显然是有难度的，原先吃的，吃多了就不喜欢了。\r\n没有一种躺平就有的快乐，也没有一种不变状态能让人一直快乐。\r\n人也没法像机器一样，纯然理性下一直快乐。\r\n\r\n我曾以为是人生理想让人能坚持不断完善，但是即便如此谁会每时每刻提醒自己？\r\n现在我不这么认为了，是刺激和快乐让人不断的去做一些事情。\r\n人和人的不同在于不同的事情给人的快乐并不一样，有些人能发现一些事情的快乐，\r\n而另外的人则不能。\r\n\r\n基于真善美，在自然与社会的规律下，过得最快乐。\r\n很多人并不懂怎么快乐，不是吗？ 快乐有方法有技巧。\r\n在一个人没发现一件事情的纯然快乐时，要靠坚持和耐心渡过一些时期。\r\n或许还要一些技巧。	\N	\N	17	\N	3	\N	5	11	2021-08-14 14:56:57.969047	2022-11-07 06:50:14.543336	2021-08-14	0	\N	\N	934	1	2	f	\N
1141	6	7	SSDR 45：上亿用户的软件与几十人的软件	区别在哪里？\r\n规模不一样，兼容性，可靠性，安全性，鲁棒性要求都不一样。\r\n	\N	\N	17	\N	3	\N	5	1	2022-11-07 07:47:28.83732	2022-11-08 16:54:54.079823	2022-11-07	0	\N	\N	1141	1	2	f	\N
1146	6	10	我的方向	产品涉及的人的架构，与产品本身的架构具备一致性。\r\n底层软件为啥开源，因为其客户是开发者。因而需要很好的技术文档，需要开放性。\r\n\r\n而作为研发人员创业方向也最好是：\r\n1，直面客户\r\n比如手机app，或云上服务，或开源软件。\r\n企业软件那套需要相应的摸爬滚打才行，时间周期都较长。\r\n\r\n只有两个方向：\r\n1，开源软件共建平台\r\n2，服务模式\r\n   走在线模式。\r\n\r\n佛道的本质都是反秩序，即建立自己的秩序。\r\n世间以多，快为好，没人愿意处在下层结构，斗争反复而不安。\r\n佛道并非避世，而是开创自己的秩序。\r\n不论什么学说必然走斗争独立自由道路，否则就是一条死路。\r\n\r\n即不论何时人都要独立发展自己的秩序，可以在前人或平台基础上，但这个秩序必须从自己内心生长出来。\r\n\r\n从这个角度出发，现代基于互联网提供服务不失为一种新秩序。\r\n\r\n我想建立一个小秩序，这是我的软件。等小弟长大了，他们也需要构建自己的秩序。\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	2	2022-11-16 21:45:51.745177	2022-11-21 06:42:29.38377	2022-11-16	0	\N	\N	1146	1	2	f	\N
1151	6	23	C安全编程	## 一、前言\r\n\r\n### 目的\r\n\r\n本规范旨在加强编程人员在编程过程中的安全意识，建立编程人员的攻击者思维，养成安全编码的习惯，编写出安全可靠的代码。\r\n\r\n### 攻击者思维\r\n\r\n编程过程中应该时刻保持以下的假设：\r\n\r\n1. 程序所处理的所有外部数据都是不可信的攻击数据\r\n2. 攻击者时刻试图监听、篡改、破坏程序运行环境、外部数据\r\n\r\n### 安全编码基本思想\r\n\r\n基于以上的假设，得出安全编码基本思想：\r\n\r\n1. 程序在处理外部数据时必须经过严格的合法性校验 编程人员在处理外部数据过程中必须时刻保持这种思维意识，不能做出任何外部数据符合预期的假设，外部数据必须经过严格判断后才能使用。编码人员必须在这种严酷的攻击环境下通过遵守这一原则保证程序的执行过程符合预期结果。\r\n   \r\n2. 尽量减少代码的攻击面 代码的实现应该尽量简单，避免与外部环境做多余的数据交互，过多的攻击面增加了被攻击的概率，尽量避免将程序内部的数据处理过程暴露到外部环境。\r\n   \r\n3. 通过防御性的编码策略来弥补潜在的编码人员的疏忽 粗心是人类的天性。由于外部环境的不确定性，以及编码人员的经验、习惯的差异，代码的执行过程很难达到完全符合预期设想的情况。因此在编码过程中必须采防御性的策略，尽量缓解由于编码人员疏忽导致的缺陷。这些措施包括：\r\n\r\n   * 变量声明应该赋予初值\r\n   * 谨慎使用全局变量\r\n   * 禁用功能复杂、易用错的函数\r\n   * 禁用易用错的编译器/操作系统的机制\r\n   * 小心处理资源访问过程\r\n   * 不要改变操作系统的运行环境（创建临时文件、修改环境变量、创建进程等）\r\n   * 严格的错误处理\r\n   * 合理使用调试断言（COD_ASSERT）  \r\n\r\n### 外部数据定义\r\n\r\n* 文件（包括程序的配置文件）\r\n* 注册表\r\n* 网络\r\n* 环境变量\r\n* 命令行\r\n* 用户输入（包括命令行、界面）\r\n* 用户态数据（对于内核程序）\r\n* 进程间通信（包括管道、消息、共享内存、socket、RPC等）\r\n* 函数参数（对于API）\r\n* 全局变量（在本函数内，其他线程会修改全局变量）\r\n\r\n## 二、基础要求\r\n\r\n### 2.1 变量\r\n\r\n### 2.1.1 指向资源句柄或描述符的变量，在资源释放后立即赋予新值\r\n\r\n资源释放后，对应的变量应该立即赋予新值，防止后续又被重新引用。如果释放语句刚好在变量作用域的最后一句，可以不进行赋值。\r\n\r\n### 2.1.2 严禁对指针变量进行sizeof操作\r\n\r\n编码人员往往由于粗心，将指针当做数组进行sizeof操作，导致实际的执行结果与预期不符。\r\n\r\n### 2.2 断言（ASSERT）\r\n\r\n断言是一种除错机制，用于验证代码是否符合编码人员的预期。编码人员在开发期间应该对函数的参数、代码中间执行结果合理地使用断言机制，确保程序的缺陷尽量在测试阶段被发现。 断言被触发后，说明程序出现了不应该出现的严重错误，程序会立即提示错误，并终止执行。 断言必须用宏进行定义，只在调试版本有效，最终发布版本不允许出现assert函数。\r\n\r\n#### 2.2.1 断言必须使用宏定义COD_ASSERT，禁止直接调用系统提供的assert()\r\n\r\n#### 2.2.2 运行时可能会导致的错误，严禁使用断言\r\n\r\n```C++\r\nchar *str = (char *)malloc(STR_SIZE); \r\nCOD_ASSERT(str!=NULL); // 错误用法，内存可能分配失败，应有异常判断处理机制\r\n```\r\n\r\n#### 2.2.3 严禁在断言内改变运行环境\r\n\r\n在程序正式发布阶段，断言不会被编译进去，为了确保调试版和正式版的功能一致性，严禁在断言中使用任何赋值、修改变量、资源操作、内存申请等操作。例如，以下的断言方式是错误的：\r\n\r\n```C++\r\nCOD_ASSERT(p1 = p2);        // p1被修改\r\nCOD_ASSERT(i++ > 1000);     // i被修改\r\nCOD_ASSERT(close(fd) == 0); // fd被关闭\r\n```\r\n\r\n### 2.3 函数\r\n\r\n#### 2.3.1  严禁对公共接口API函数的参数进行ASSERT操作\r\n\r\n对于设计成API的函数，必须对参数进行合法性判断，严禁在API实现过程中产生CRASH。对API函数的参数进行ASSERT操作是没有意义的。应加上错误判断和处理模块。\r\n\r\n#### 2.3.2 不对内容进行修改的指针型参数，定义为const\r\n\r\n### 2.4 循环\r\n\r\n#### 2.4.1 循环必须要有退出条件\r\n\r\n循环如果没有退出条件，那么程序无法安全退出。 以下代码，在一个大循环内接收外部数据并进行处理，但没有退出条件，会导致该程序无法正常退出。\r\n\r\n#### 2.4.2 循环次数如果受外部数据控制，需要校验其合法性\r\n\r\n### 2.5  安全退出\r\n\r\n#### 2.5.1 禁用atexit函数\r\n\r\natexit函数注册若干个有限的函数，当exit被调用后，自动调用由atexit事先注册的函数。 当资源不再使用后，编码人员应该立即主动地进行清理，而不应该在最终程序退出后通过事先注册的例程被动地清理。例外： 作为服务维测监控功能，为定位程序异常退出原因的模块，可以作为例外使用atexit()函数。\r\n\r\n#### 2.5.2 严禁调用kill、TerminateProcess函数终止其他进程\r\n\r\n调用kill、TerminateProcess等函数强行终止其他进程(如kill -9)，会导致其他进程的资源得不到清理。 对于进程间通信，应该主动发送一个停止命令，通知对方进程安全退出。 当发送给对方进程退出信号后，在等待一定时间内如果对方进程仍然未退出，可以调用kill、TerminateProcess函数。\r\n\r\n#### 2.5.3 禁用pthread_exit、ExitThread函数\r\n\r\n## 三、 字符串/数组操作\r\n\r\n#### 3.1 确保有足够的存储空间\r\n\r\n部分字符串处理函数由于设计时安全考虑不足，或者存在一些隐含的目的缓冲区长度要求，容易被误用，导致缓冲区写溢出。典型函数如itoa，realpath。 以下的代码，试图将数字转为字符串，但是目标存储空间的长度不足。\r\n\r\n#### 3.2 外部数据作为数组索引时必须确保在数组大小范围内\r\n\r\n外部数据作为数组索引对内存进行访问时，必须对数据的大小进行严格的校验，否则为导致严重的错误。\r\n\r\n#### 3.3 外部输入作为内存操作相关函数的复制长度时，需要校验其合法性\r\n\r\n在调用内存操作相关的函数时（例如memcpy、memmove、memcpy_s、memmove_s等），如果复制长度外部可控，则必须校验其合法性，否则容易导致内存溢出。\r\n\r\n#### 3.4 调用格式化函数时，禁止format参数由外部可控\r\n\r\n调用格式化函数时，如果format参数由外部可控，会造成字符串格式化漏洞。 这些格式化函数有：\r\n\r\n* 格式化输出函数：xxxprintf \r\n* 格式化输入函数：xxxscanf\r\n* 格式化错误消息函数：err()，verr()，errx()，verrx()，warn()，vwarn()，warnx()，vwarnx()，error()，error_at_line()\r\n* 格式化日志函数：syslog()，vsyslog()\r\n\r\n## 四、 安全函数\r\n\r\n安全函数是指codSafeStrLen、codSafeStrCpy等套件函数，可有效防止缓冲区溢出、越界访问等问题。\r\n\r\n#### 4.1 必须检查安全函数返回值，并进行正确的处理\r\n\r\n## 五、 整数\r\n\r\n#### 5.1 整数之间运算时必须严格检查，确保不会出现溢出、反转、除0\r\n\r\n在计算机中，整数存储的长度是固定的（例如32位或64位），当整数之间进行运算时，可能会超过这个最大固定长度，导致整数溢出或反转，使得实际计算结果与预期结果不符。 如果涉及到除法或者求余操作，必须确保除数不为0。\r\n\r\n#### 5.2 整型表达式比较或赋值为一种更大类型之前必须用这种更大类型对它进行求值\r\n\r\n由于整数在运算过程中可能溢出，当运算结果赋值给比他更大类型，或者和比他更大类型进行比较时，会导致实际结果与预期结果不符。\r\n\r\n#### 5.3 禁止对有符号整数进行位操作符运算\r\n\r\n位操作符（～、>>、<<、&、^、|)应该只用于无符号整型操作数。\r\n\r\n#### 5.4 禁止整数与指针间的互相转化\r\n\r\n指针的大小随着平台的不同而不同，强行进行整数与指针间的互相转化，降低了程序的兼容性，在转换过程中可能引起指针高位信息的丢失。\r\n\r\n#### 5.5 禁止对指针进行逻辑或位运算（&&、||、!、～、>>、<<、&、^、|）\r\n\r\n对指针进行逻辑运算，会导致指针的性质改变，可能产生内存非法访问的问题。\r\n\r\n## 六、 不安全函数\r\n\r\n#### 6.1 禁止外部可控数据作为system、popen、WinExec、ShellExecute、execl, execlp, execle, execv, execvp、CreateProcess等进程启动函数的参数\r\n\r\n这些函数会创建一个新的进程，如果外部可控数据作为这些函数的参数，会导致注入漏洞。 即使参数经过拼接，也可能由于命令分隔符（请参考"附录B 命令注入相关的特殊字符"）机制，导致注入漏洞。 如果需要使用system()、popen()、WinExec()、ShellExecute()，请使用白名单机制校验其参数，确保这些函数的参数不受任何外来数据的命令注入影响。\r\n\r\n#### 6.2 禁止外部可控数据作为dlopen/LoadLibrary等模块加载函数的参数\r\n\r\n#### 6.3 禁止在信号处理例程中调用非异步安全函数\r\n\r\n信号处理例程应尽可能简化。在信号处理例程中如果调用非异步安全函数，可能会导致函数的执行不符合预期的结果。\r\n\r\n#### 6.4 禁用setjmp/longjmp\r\n\r\nsetjmp/longjmp函数允许C语言跨函数跳转。调用setjmp函数保存当前的执行环境，后续调用longjmp跳转到之前setjmp位置处。 使用setjmp/longjmp函数使程序变得特别复杂，不易理解，资源不能得到有效清理，并且无法在多线程环境下使用。\r\n\r\n#### 6.5 禁止使用内存操作类危险函数\r\n\r\nC标准的许多函数，没有将目标缓冲区的大小作为参数，并且未考虑到内存重叠、非法指针的情况，在使用中很容易引入缓冲区溢出等安全漏洞。 基于历史缓冲区溢出漏洞触发的情况统计，有很大一部分是因为调用了这些内存操作类函数但未考虑目标缓冲区大小而导致。 以下列出了内存操作类危险函数： \r\n\r\n* 内存拷贝函数：memcpy()，wmemcpy()，memmove()，wmemmove() \r\n* 内存初始化函数：memset() \r\n* 字符串拷贝函数：strcpy()，wcscpy()，strncpy()，wcsncpy() \r\n* 字符串拼接函数：strcat()，wcscat()，strncat()，wcsncat() \r\n* 字符串格式化输出函数：sprintf()，swprintf()，vsprintf()，vswprintf()，snprintf()，vsnprintf()\r\n* 字符串格式化输入函数：scanf()，wscanf()，vscanf()，vwscanf()，fscanf()，fwscanf()，vfscanf()，vfwscanf()，sscanf()，swscanf()，vsscanf()，vswscanf()  \r\n* stdin流输入函数：gets()\r\n\r\n## 七、 文件输入/输出\r\n\r\n#### 7.1 创建文件时必须显式指定合适的文件访问权限\r\n\r\n创建文件时，如果不显式指定合适访问权限，可能会让未经授权的用户访问该文件。\r\n\r\n#### 7.2 必须对文件路径进行规范化后再使用\r\n\r\n当文件路径来自外部数据时，需要先将文件路径规范化，如果没有作规范化处理，攻击者就有机会通过恶意构造文件路径进行文件的越权访问： 例如，攻击者可以构造“../../../etc/passwd”的方式进行任意文件访问。 在linux下，使用realpath函数，在windows下，使用PathCanonicalize函数进行文件路径的规范化。\r\n\r\n#### 7.3 不要在共享目录中创建临时文件\r\n\r\n## 八、 敏感信息处理\r\n\r\n#### 8.1 禁用rand函数产生用于安全用途的伪随机数\r\n\r\nC标准库rand()函数生成的是伪随机数，请使用/dev/random生成随机数。\r\n\r\n#### 8.2 内存中的敏感信息使用完毕后立即清0\r\n\r\n口令、密钥等敏感信息使用完毕后立即清0，避免被攻击者获取。 以下代码获取到密码后，将密码保存到password中，进行密码验证，使用完毕后，通过memset_s对password清0。\r\n	\N	\N	17	\N	3	\N	5	0	2022-11-24 06:36:41.344536	2022-11-24 06:36:41.344536	2022-11-24	0	\N	\N	1151	1	2	f	\N
18	7	1	PR特性合入jewel	jewel版本watch/notify机制变化了，这块需要研究清楚，然后调整下\r\n\r\npr需要提供接口给RBD，rbd通过命令操作。\r\n\r\n保留测试用例。\r\n\r\n\r\n这是一件蛋疼的事，监控系统尽量保持独立比较好。监控系统不应该因为存储故障收到影响。\r\n监控系统最好是一个多活的系统，其可靠性应该跟mon类似，非常适合使用paxos类协议构建。	\N	2	4	\N	3	\N	5	7	2017-10-16 09:17:47.571554	2022-12-05 17:11:17.865269	2017-10-16	0	\N	\N	18	1	2	f	\N
1149	6	10	金融业数据仓库发展白皮书		\N	\N	17	\N	3	\N	5	1	2022-11-22 18:39:03.786594	2022-12-13 14:32:07.004026	2022-11-22	0	\N	\N	1149	1	2	f	\N
1140	6	24	TAC设计总结	1，列锁方案或许行得通。\r\n  行锁方案虽然与行表一致，但是undo没有与页面对应。\r\n  需要处理各种undo一致性问题。\r\n2，每列segment，要考虑drop列之后被其他列或同列再次使用的情况。\r\n  即如果并发每个segment有唯一标识，则需要其他标识识别这种情况。避免读操作误读页面。\r\n3，逻辑页面是一个不错的设计，再加上缓存对于AP基本够用。\r\n  但是TP场景下，操作离散，查找物理页面成了高冲突高代价操作。\r\n4，并发插入错开xbu页面很有必要，对TPCC性能。\r\n  列表的页面冲突是性能杀手。\r\n5，swf元数据一开始没有多版本就是错误设计，没考虑一致性。\r\n   swf其实可以没有元数据，作为其他结构的子结构，其元数据可由其他模块提供。\r\n   主要问题在于dc应该要轻量级，dc离散加载页面是非常耗性能的，元数据应该尽量简化。\r\n6，vds link对变长列性能很有帮助。\r\n7，一开始就应该支持条件下推\r\n8，通过在cursor上提供函数获取查询某行中某列的数据是一个不错的设计，统一了行表和列表获取数据的方式。\r\n9，行列数据格式不一样是个隐形炸弹。保不准哪里需要做转换。\r\n10，针对批量插入走特殊路径是有意义的。\r\n	\N	\N	17	\N	3	\N	5	4	2022-11-05 12:45:16.749762	2023-01-10 07:07:25.823882	2022-11-05	0	\N	\N	1140	1	2	f	\N
1144	6	15	发力篇(刘辉)	找到带动发力的感觉。\r\n节奏必须是慢再快，打得急肯定不是鞭打发力。\r\n这样就要求前面的慢动作要提前点做，步伐到位就是主动球，不到位就是被动球。\r\n	\N	\N	17	\N	3	\N	5	2	2022-11-13 13:59:13.501037	2023-04-24 06:34:40.421972	2022-11-13	0	\N	\N	1144	1	2	f	\N
1150	6	10	电信领域数据库使用特征	Trump：\r\n电信软件领域使用oracle还是相对克制的，尽可能考虑不绑定特定数据库，能比较容易切换其他数据库，一般使用主流数据库都支持的通用特性或者有替代办法的特性：\r\n1、存储过程和高级包，循环，if else，exception，游标（包括更新游标）\r\n2、分区表，在线动态创建分区（一般按时间），分区本地索引\r\n3、查看SQL执行计划，通过hint调优SQL执行计划（主要是多表关联场景）\r\n4、job任务，调用存储过程定时汇总时结、日结数据，作报表统计\r\n5、create/rebuild index online，新增维护索引不阻塞业务\r\n6、大表在线加字段，业务升级场景不阻塞业务\r\n7、动态视图，查看锁阻塞信息，查看连接信息，终止某些阻塞别人的连接，查看数据库、表空间、表和索引的空间和剩余空间情况\r\n8、awr报告以及统计信息，查看top等待事件分析系统瓶颈，查看top SQL(可按执行时长、disk read、buffer get、执行次数等排序)\r\n9、flashback查询\r\n10、备份恢复\r\n11、RAC集群，应用分割使用不同节点，单点故障时透明切换（客户端TAF能力）\r\n12、dataguard容灾\r\n13、审计\r\n14、安全加固，强口令，口令策略等	\N	\N	17	\N	3	\N	5	0	2022-11-23 06:23:21.447351	2022-11-23 06:23:21.447351	2022-11-23	0	\N	\N	1150	1	2	f	\N
1152	6	23	定位工具系列 Strace	Strace可指定事件跟踪。\r\nstrace -f -e trace=open,read ./minio --json server ./data\r\n\r\ntrace可以是file	\N	\N	17	\N	3	\N	5	0	2022-11-25 08:32:35.822553	2022-11-25 08:32:35.822553	2022-11-25	0	\N	\N	1152	1	2	f	\N
1074	6	7	SSDR 35:如何描述问题或目标(软件开发困难之二)	首先我们得有实体结构，然后我们需要回答：\r\n1，谁的问题\r\n  如果搞不清楚这个，通常解决方案是混乱的。\r\n  甚至我们不能把问题分开，问题a和问题b是什么关系？\r\n\r\n2，什么问题，这个要用数学，逻辑语言来描述。\r\n  要证明为什么能解决问题，方案的优劣等。\r\n  不要用应该是，可能，大概率等。这样得不出什么，也构建不了知识的大厦。\r\n\r\n3，不同的目标或问题分别对待，以降低复杂度。如无必要尽量分离。（低耦合）	\N	\N	17	\N	3	\N	5	3	2022-06-19 15:16:19.848848	2022-12-02 06:51:07.50586	2022-06-19	0	\N	\N	1074	1	2	f	\N
1154	6	7	SSDR 47：限定词与Trait，接口	限定词的含义。\r\n全局临时的表，局部临时的表。\r\n全局临时是一个修饰符，修饰本身意味着特征，能力，同时还有约束。\r\n\r\n限定词应该用接口或trait来表示。\r\n这样我们才能很清楚的明确当一种结构的表，要实现临时或全局临时的时候该做什么。\r\n并且有效的将这些属性相关的实现，与其他属性相互隔离。\r\n\r\n\r\n那些差异被某些实体作为flag或其他形式携带，然后在代码的各个分支都得进行处理。\r\n一旦漏掉就可能产生未定义的行为。\r\n尤其是我们有一些大的类型，一切都能塞入其中，就更容易出现这种情况，加一个标记，然后加分支是显而易见的处理方案。	\N	\N	17	\N	3	\N	5	1	2022-12-07 13:54:57.872133	2022-12-07 14:47:35.226023	2022-12-07	0	\N	\N	1154	1	2	f	\N
1156	6	9	论生活与工作的方法	为了成为真正的人，独立自由的人，有自己体系(三观)的人。\r\n人生没有真正的失败者，只有达到和未达到。不往前走和拼命追赶的人生本质是一样的。\r\n都看不到沿途的风景。我偶尔专注的做事情，也偶尔停下脚步欣赏沿途的风景。\r\n就像打球一样，太快或者太慢都是不合适的，合适的是按照一定的节奏来运转。\r\n\r\n当我心神专注时，我的思维运行于物体之内，物与我合成一体。我忘记了自己的存在。\r\n\r\n也是禅宗：应无所住，而生其心。\r\n心学：将我们的心神运行于事物之上，然后用“良知”去体会事物本身的矛盾，善恶。\r\n然后尝试去解决矛盾，为善去恶。\r\n但这有个前提，即我们的心念可以运行事物，即意识可以分辨事物，了解事物。\r\n同时我们拥有无善无恶的良知，这或许是庄子众生无别，也可能是等级森林。总之得有一个明确的尺度。	\N	\N	17	\N	3	\N	5	1	2022-12-12 20:36:03.096497	2022-12-12 20:36:59.110001	2022-12-12	0	\N	\N	1156	1	2	f	\N
1163	6	7	SSDR50：《关于软件》大纲	道：\r\n有道无术,术尚可求,有术无道,止于术.神即道,道法自然,如来!\r\n吾生也有涯，而知也无涯。以有涯随无涯，殆已\r\n为学日益，为道日损\r\n\r\n\r\n1，软件是什么\r\n1.1 软件思维\r\n\r\n2，软件实体\r\n2.1 行为的理解\r\n2.2 模块化编程\r\n \r\n\r\n3，软件结构\r\n3.1，软件的性质\r\n3.1.1 复杂度\r\n3.2, 分化与泛化\r\n3.3，设计原则\r\n\r\n术\r\n4，怎么做软件\r\n    其实就同怎么做事一样。\r\n4.1 政治\r\n4.1.1 引入矛盾斗争\r\n4.1.2 获取与运用资源\r\n4.1.3 开明的政治 \r\n\r\n4.2 怎么分析需求\r\n4.3 怎么交流讨论\r\n4.4 怎么设计\r\n4.4.1 逻辑设计，设计模式\r\n4.4.2 可靠性，高可用，兼容性.... \r\n\r\n4.5 怎么编码\r\n4.6 设计的完备性与技术债务\r\n4.7 软件正确性\r\n\r\n5，数据结构\r\n\r\n6，算法\r\n\r\n7，编程语言	\N	\N	17	\N	3	\N	5	4	2023-01-29 17:59:43.205285	2023-01-29 18:31:26.009634	2023-01-29	0	\N	\N	1163	1	2	f	\N
1168	6	7	SSDR54: 兼容性设计	1，预留式，要初始化为0\r\n2，末尾扩展式\r\n3，多版本式，或编解码式	\N	\N	17	\N	3	\N	5	3	2023-02-01 18:10:39.992818	2023-02-01 18:15:57.575477	2022-07-03	0	\N	\N	1168	1	2	f	\N
1169	6	23	软件开发流程工具	1，需求\r\n2，设计\r\n这些都可以通过MarkDown文档形式保存在GitLab。\r\n3，代码\r\nGitLab\r\n4，任务与问题跟踪\r\nGitLab\r\n任务分解与对应关系怎么描述？\r\n5，软件文档\r\nGitLab\r\n6，CI\r\nJenkins\r\n\r\n完全可以高度工具化。	\N	\N	17	\N	3	\N	5	1	2023-02-03 08:27:11.423861	2023-02-03 08:29:37.702801	2023-02-03	0	\N	\N	1169	1	2	f	\N
1173	6	23	vtune与malloc性能问题	火焰图呈现波浪形态说明存在并发等待，导致CPU无法用满。\r\n通过vtune观察到malloc占比较高，很可能不是内存分配本身开销，而是malloc中的锁冲突严重。\r\n这时可考虑使用本地化内存管理来优化。\r\n	\N	\N	17	\N	3	\N	5	2	2023-02-14 12:44:05.453365	2023-02-14 12:46:24.238481	2023-02-14	0	\N	\N	1173	1	2	f	\N
1175	6	23	arm跨平台问题	比如原子命令要求按8字节对齐	\N	\N	17	\N	3	\N	5	0	2023-02-20 14:40:30.762791	2023-02-20 14:40:30.762791	2023-02-20	0	\N	\N	1175	1	2	f	\N
1157	6	23	看护架构的方法	一种看护软件架构的方法\r\n\r\n随着软件开发的进行，软件架构会不断生长。\r\n除了枝干的变化，还有关节核心的调整。如何看护软件的架构呢？\r\n\r\n首先我们要用一种语法来描述架构，即描述核心模块之间的关系。\r\n其次需要使用工具对代码生成架构描述。\r\n再对比架构描述文档，进行架构变更核查。\r\n\r\n这里还涉及一个层次问题，即架构看护需要到哪个层次的实体？\r\n一般而言到模块层次可能就够了\r\n\r\n其实其他想看护的目标同样如此，比如性能，兼容性等。\r\n每个人都不必需要记住太多东西，只要代码提交过，就可以睡大觉。	\N	\N	17	\N	3	\N	5	1	2022-12-13 11:55:05.159002	2023-04-23 12:07:47.312564	2022-12-13	0	\N	\N	1157	1	2	f	\N
1159	3	33	yashandb架构恶化记	存储结构感知到其使用者，这显然是依赖反转了。\r\n这样结构本身的独立性就完全丧失了。\r\n作为结构本身的dc是结构可以依赖的，其实就是上层元数据的代表结构。\r\n\r\n即上层结构记录了子结构的基本信息。然后通过加载到DC缓存，再传给子结构的方式来使用。\r\n为什么这样呢？\r\n1，元数据与数据分离存储。\r\n2，元数据高频使用。\r\n\r\n但是这个一定不能扩大，否则子结构的复用就会出现问题。\r\n比如在yashandb中heap依赖table Dict这样就废了。\r\n\r\n之前产生对TableDict依赖的原因：\r\n结构需要从上层传入的其实不是columnAttr，而是ankColumn.\r\n其除了列的类型之外，还需要列的默认值之类的。\r\n\r\n另外一个很大问题是决不可出现所有模块都依赖的类，一旦这种情况出现。\r\n即意味着依赖关系丢失，也意味着架构将无法看护。终将变长一团乱麻。\r\n比如yashandb中的ankHandler，内核看似有各种结构，实则无法守住。	\N	\N	17	\N	3	\N	5	4	2022-12-27 09:11:07.213773	2023-02-16 07:02:38.461922	2022-12-27	0	\N	\N	1159	1	2	f	\N
968	6	7	SSDR9 设计方法论	设计的基本原理\r\n实体和行为是事物的2种属性，可以认为其是同时存在的。\r\n我们很难说软件本身的目的是得到某个状态下的实体，或是优化某种行为。\r\n或者2者兼而有之。\r\n\r\n或者单纯从二进制的角度来看，实体和行为也是同在的。\r\n就像转换生成语法一样，通过转换动作，生成了新的句子，这个过程中实体和行为是同在的。\r\n或说道生一，一生二，二生三，三生万物一样。\r\n实体是变化的，变化发生在实体上。\r\n\r\n从转换生成的角度理解设计。\r\n\r\n文法与设计的关系\r\n4种文法：\r\nhttps://www.cnblogs.com/qjkobe/p/5332612.html\r\n语言学的研究方向是语言能力，先天语言能力论。\r\n转换生成语法理论。\r\n\r\n语言的本质：\r\n语言是思维的形式,思维是语言的内容。\r\n\r\n动作的本质就是把从一个状态到另一个状态，而cache的本质就是把执行动作替换为存储状态。\r\n互联网就是更大范围内的机器\r\n\r\n我们通常不知道系统的边界，模块的边界，把一些不相干的东西放在一起。\r\n把实现暴漏给外面，泛型编程是一种更抽象更符号化的编程思路。\r\n把边界搞清楚，把约束和要求搞清楚，	\N	\N	17	\N	3	\N	5	26	2021-10-07 05:57:47.939827	2022-12-28 07:37:10.49578	2021-10-07	0	\N	\N	968	1	2	f	\N
1177	6	7	SSDR55：多核下的软件架构	软件如何利用多核。有哪些形态，分别适用于哪些场景？	\N	\N	17	\N	3	\N	5	0	2023-03-02 07:47:21.700678	2023-03-02 07:47:21.700678	2023-03-02	0	\N	\N	1177	1	2	f	\N
1162	4	33	S3 c sdk	\N	\N	\N	17	\N	3	\N	5	1	2023-01-27 17:28:05.152849	2023-01-27 17:29:46.507811	2023-01-27	0	\N	\N	1162	1	2	f	\N
106	6	5	关于买房	房地产目前有两个大作用：\r\n1，解决相关人员就业问题，这个作用是非常巨大的，如果相关人员失业，波及面将非常广。\r\n2，作为人名币的蓄水池，完成剪羊毛功能。\r\n\r\n但是房地产这种模式能否永久持续下去呢？显然不会，大咖也不会认为会持续下去。\r\n主要条件：\r\n1，中国的城镇化程度\r\n2，长期人口增长情况\r\n3，继续放水的程度\r\n\r\n在1，2，3 条件均满足的情况下，房价必然上涨。\r\n目前农村限制建房，可以逼出一些需求，但是这个空间也不会太大了，但是改善性需求是存在的。\r\n但改善性需求能否维持房价基本面是一个问题。\r\n\r\n长期人口增长从目前看必然是下降的。\r\n如果控制放水速度与房产开发速度相当，则水可以灌入房产。但房产最终会出现相对过剩。\r\n\r\n这时放水可以维持房价，而且房价是合理的，但是问题在于财富分配会进一步不均衡。这才是问题的关键。\r\n我们对此的容忍度非常高。但并非没有极限。\r\n\r\n所以未来房价是上涨还是下跌取决于政府意志，下跌会巨痛，会经历失去的N多年。但上涨会更加的危险。\r\n目前看想控制住缓慢增长。但要做到这点非常难。\r\n\r\nh1. 刚需买房\r\n从个人角度看，如果不考虑各种政策，应该是看租售比。如果过高就买房，否则就租房。\r\n通过教育强制割羊毛是需考虑的一个因素，宁愿为了教育被割多少需看家庭经济情况。\r\n显然为了孩子教育赌几年的时间是值得的，但是如果超过了9年，我个人觉得并不划算。按年纯收入25万(刨除医疗等各种可能支出)。\r\n那么最多可牺牲200来万，这还是不考虑失业风险的情况下。\r\n\r\nh1. 投资买房\r\n投资则必须转手，得有人接手，这点风险是非常高的。\r\n在经济的整体上升期，资产价格会被高估，这时风险小，可大胆投入，在经济收缩时则相反。\r\n\r\n	\N	\N	17	\N	3	\N	5	1	2018-10-07 21:42:37.759575	2023-01-27 20:43:59.558849	2018-10-07	0	\N	\N	106	1	2	f	\N
1181	6	27	软件效率	1，复用组件\r\n1.1 实际上底层组件都设计成复用的，那么软件的工作量和复杂度将急剧下降\r\n    想想世界上多少复用的结构。在软件世界里可以得以统一。\r\n    \r\n2，使用代码生成技术\r\n2.1 泛型，泛型有类型安全的好处，同时不同类型不同实现，提升了软件的效率。\r\n2.2 宏\r\n\r\n3，针对性设计\r\n比如对运行环境做要求，snowflake的TShirt思路。\r\n尽可能少的配置。什么内存大小控制，CPU资源控制等等由外部完成。\r\ndocker这类技术不是都很流行了么。\r\n\r\n4，工程自动化\r\n4.1 自动格式化\r\n4.2 CI技术\r\n4.3 自动生成测试用例。\r\n\r\n	\N	\N	17	\N	3	\N	5	0	2023-03-15 07:25:15.333868	2023-03-15 07:25:15.333868	2023-03-15	0	\N	\N	1181	1	2	f	\N
1161	6	7	SSDR49：一个干净的模块（你真的懂模块化编程吗）	一个干净的模块：\r\n1，其接口的输入是明确的，不会放大，不产生额外依赖，方向依赖。\r\n2，接口参数的构造方式是明确的。\r\n3，输出是明确的，或者有明确的接口获取输出结果。\r\n4，其不存在反向依赖，即不应该依赖其使用场景。\r\n5，其不应该存在分离的部分，使用外部使用者需同时与两部分打交道。\r\n   元数据分离的系统应该将元数据包在模块内。\r\n6，其子模块也是干净的。   	\N	\N	17	\N	3	\N	5	4	2022-12-28 09:24:30.67291	2023-03-16 13:29:04.184408	2022-12-28	0	\N	\N	1161	1	2	f	\N
1183	3	33	jdbc与其方言	JDBC协议调研：\r\njdbc是run/oracle公司指定的java语言使用数据库的规范。\r\n其他数据库提供driver对接。\r\n\r\njdbc接口规范：https://docs.oracle.com/javase/8/docs/api/java/sql/Blob.html\r\n规范文档： jdbc-specification/jdbc4.2-fr-spec.pdf \r\n\r\njdbc方言，用户可以绕过jdbc使用厂家提供的特有接口。\r\n像oracle driver就提供了不少lob接口	\N	\N	17	\N	3	\N	5	1	2023-03-22 10:15:25.581256	2023-03-22 17:56:41.087118	2023-03-22	0	\N	\N	1183	1	2	f	\N
1165	6	7	SSDR52：软件实体是什么	软件实体是包含特定行为的抽象结构。\r\n抽象可以是针对人物或辅助结构。\r\n\r\n其核心在于行为，这是其本质特征，结构是为行为服务的。\r\n结构是多变的，通常服务于主要行为。如果其主要行为发生变化，那么实体也就不是原来的实体了。\r\n比如锅铲，木的，铁的都可以，但是筷子不是锅铲。\r\n\r\n推论：\r\n实体应该很好的封装，就像自然界的物一样。其具备可见性，整体性等特征。\r\n实体不应该随便被修改，程序员经常做出用锄头炒菜，用脚盆洗脸的事。\r\n因为这并不像社会上的事物那样显而易见。\r\n\r\n从诞生之初，实体就应该具有明确的含义，行为。且具备一定的稳定性。\r\n\r\n例如内存分配，Stack和MemoryContext都有分配内存的能力，但其主要行为其实有差异。\r\nStack有push和pop，save，restore。 Context的主要行为则是多次分配，一次性回收，整体复用。\r\n我们不能以为某个实体能做这个事就直接用，或随意给stack加功能使其同时具备MemoryContext的能力。\r\n而在某些场景下，其主要行为不被使用，或不同行为之间不可同时使用等。\r\n\r\n实体的内部结构应该对外不可见。\r\n\r\n实体对外应该尽量泛化，不应该于外部环境，这样才可以在各种环境下复用。	\N	\N	17	\N	3	\N	5	2	2023-01-29 19:32:33.292845	2023-02-03 15:38:59.590413	2023-01-29	0	\N	\N	1165	1	2	f	\N
1164	6	7	SSDR51： 软件是什么	百科定义：软体（英语：software）是一系列按照特定顺序组织的电脑数据和指令，是电脑中的非有形部分。\r\n这是从计算机的角度来看，但人不是这样看问题的，这样看无法与我们生活的世界联系起来。\r\n也无法回答为什么不同的软件差异如此之大。\r\n\r\n软件是对人和物部分特征以及行为的抽象，使得人和物的行为可以经过计算机处理来代替，最终又作用于人和物。\r\n由上述定义我们可以知道软件与我们生活环境的关系，从而可以将其与软件联系起来。\r\n\r\n有没有不与人或物产生任何关系的程序。这就像问有没有看不见的人，可能有，但是不可观察，这里我们也不进行讨论。\r\n\r\n有了此定义我们就可以讨论软件是产生与发展的。\r\n既然软件是人和物及其行为抽象的集合。\r\n人和物本身的抽象是软件的一部分。比如软件中的用户，物品清单等。\r\n人和物的行为，比如人购买行为，摄像头的拍照行为等。\r\n乍一看软件好像很简单，但从规模，时间，人物的个体差异以及不同环境下的行为变化等角度看，软件可以非常复杂。\r\n\r\n比如以数据库举例，数据库存储了大量人和物的信息，支持查询字段，过滤条件，连接等等。\r\n根据其存储数据以及用法等，分化出各种不同的数据库，如TP,AP，时序，时空地理等等。\r\n\r\n软件涉及的人除了其描述的人外，还有各种不同使用者，开发者，测试人员，运维等等。\r\n\r\n软件思维\r\n\r\n软件思维是通过类似软件抽象的方法来处理问题。\r\n这里指各种问题，除了软件中的需求分析，设计开发外，日常生活问题也可以采用这种思想进行优化。\r\n\r\n下面我们尝试以软件描述一个生活场景，比如一家人回家过年。\r\n我们要考虑的有：\r\n1，哪些人\r\n2，在哪里过年\r\n3，过年期间这些人各自有那些行为\r\n4，这些人会有哪些公共行为，如何进行同步。\r\n5，人的这些行为涉及哪些物。\r\n6，具体行为怎样，行为完整发生后，这些物会发生哪些变化\r\n7，行为有哪些变种，哪些可能顺序\r\n\r\n当有了上述描述之后，我们就解决如下问题：\r\n1，如何更好的同步。\r\n2，相互之间如何提供便利，以提高整体效率。\r\n3，如何批量购买。\r\n4，如何保证行为的完整性。减少每个人的抱怨。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n	\N	\N	17	\N	3	\N	5	2	2023-01-29 19:13:36.987166	2023-03-02 07:46:03.409279	2023-01-29	0	\N	\N	1164	1	2	f	\N
1178	6	7	SSDR56：多节点下的架构	软件的物理结构与逻辑结构的关联关系。\r\nSMP，NUMA，MPP还有其他的吗？\r\n把MPP的存储拉到远端就能成为SMP吗？显然不是的。	\N	\N	17	\N	3	\N	5	0	2023-03-02 07:51:41.626336	2023-03-02 07:51:41.626336	2023-03-02	0	\N	\N	1178	1	2	f	\N
1179	4	33	TP与AP	\N	\N	\N	17	\N	3	\N	5	1	2023-03-07 13:43:17.365919	2023-03-07 13:43:53.068742	2023-03-07	0	\N	\N	1179	1	2	f	\N
1180	6	23	ubuntu下VS+rust	1,下载vs code\r\n2,安装rust,https://blog.csdn.net/inthat/article/details/106742193\r\n  注意使用国内源\r\n3,vs插件， analyzer\r\n4,安装c编译器, sudo apt install build-essential\r\n5,cargo new 工程.\r\n\r\nubuntu系统现在确实是非常好用的了。	\N	\N	17	\N	3	\N	5	0	2023-03-11 05:14:21.823296	2023-03-11 05:14:21.823296	2023-03-11	0	\N	\N	1180	1	2	f	\N
1182	3	33	存储过程简单例子	\r\n\r\n#DBMS_OUTPUT可输出结果\r\nSET SERVEROUTPUT ON\r\n\r\nDECLARE\r\nlob1 CLOB;\r\nloblen1 integer;\r\nBEGIN\r\nselect c2 into lob1 from t1 where c1=1;\r\nupdate t1 set c2 =lpad('a', 31000,'a') where c1=1;\r\ncommit;\r\nloblen1 := DBMS_LOB.GET_LENGTH(lob1);\r\nDBMS_OUTPUT.PUT_LINE('length : ' || loblen1);\r\nEND;\r\n/\r\n\r\n\r\nDECLARE\r\nlob1 CLOB;\r\nloblen1 integer;\r\nBEGIN\r\nselect c2 into lob1 from t1 where c1=1;\r\nloblen1 := DBMS_LOB.GET_LENGTH(lob1);\r\nDBMS_OUTPUT.PUT_LINE('length : ' || loblen1);\r\nEND;\r\n/\r\n	\N	\N	17	\N	3	\N	5	0	2023-03-22 07:50:02.925357	2023-03-22 07:50:02.925357	2023-03-22	0	\N	\N	1182	1	2	f	\N
1184	3	33	update/delete冲突下的语义正确性	update/delete的语义：\r\n在页级MVCC下，读取通常是按页的，对于列表也是如此。\r\n因为读取一定是基于快照，这样通过批读提升其性能。\r\n但是更新和删除必需基于最新版本，即更新和删除冲突时的重读必须基于某个行的版本，而不是一批数据的版本。\r\n此时冲突读得额外记录scn，通过revert机制读取准确的记录scn。\r\n然后lock记录时，再利用该scn判断记录是否在冲突读之后发生变更。\r\n\r\n这样意味着：\r\n1，必需使用两块buffer，一个存批读，一个存冲突读\r\n2，scn必需单独管理，冲突记录的scn单独记录。\r\n\r\n除非更新操作本身也是批量的，锁也是批量的，那可以考虑使用批scn。\r\n否则冲突批量读没有意义反而可能引入bug，因为到下一条记录时，冲突批读的结果可能引起误判。	\N	\N	17	\N	3	\N	5	0	2023-03-27 09:39:05.015462	2023-03-27 09:39:05.015462	2023-03-27	0	\N	\N	1184	1	2	f	\N
1185	4	33	数据类型	\N	\N	\N	17	\N	3	\N	5	1	2023-03-27 18:52:02.081567	2023-03-27 18:53:58.076818	2023-03-27	0	\N	\N	1185	1	2	f	\N
1186	6	24	有了parquet，为什么要做coast	1，实现block级别过滤\r\n2，实现条件下推（常量下推），不解码过滤\r\n3，避免类型转换开销\r\n4，自己可控，快速开发其他编码，特化	\N	\N	17	\N	3	\N	5	0	2023-03-31 13:11:39.204762	2023-03-31 13:11:39.204762	2023-03-31	0	\N	\N	1186	1	2	f	\N
1158	6	7	SSDR 48：什么是软件需求	从实体行为体系来说需求分为：\r\n1，增加行为。由此该体系内的很多实体都需要扩展行为，甚至引入约束。\r\n             甚至为了该行为引入新的实体。\r\n2，增加修饰。即对某个实体增加一种特性。比如表-》支持临时表。\r\n3，增加实体的其他变种实现。\r\n4，优化行为。优化某个行为，这可能需要在其上下文中增加对应的参数来作为优化的输入。\r\n\r\n\r\n要注意：\r\n1，分清主次。哪些行为是最重要的。我们没法同时考虑非常多的行为和实体关系，设计时先抓住当前最核心的行为。\r\n2，要自顶而下。 因为没有宏观设计，微观很容易需要调整。\r\n3，要逐个击破。 不要把不同的需求一起考虑，而是先拿出重要的，考虑好。然后再论证其他的。\r\n	\N	\N	17	\N	3	\N	5	1	2022-12-14 18:26:34.573816	2023-04-02 05:22:20.484651	2022-12-14	0	\N	\N	1158	1	2	f	\N
1187	6	7	SSDR57：什么是技术调研？	就是调研别人已有的结构，业务已形成的结构，已有系统的架构。\r\n不仅了解是怎样的？ 还应该理解为什么如此。\r\n或者换句话说重要的不是how，重要的是why？	\N	\N	17	\N	3	\N	5	0	2023-04-03 07:09:15.720594	2023-04-03 07:09:15.720594	2023-04-03	0	\N	\N	1187	1	2	f	\N
1171	7	33	DB1：控制文件	控制文件：\r\n存放整个系统的元数据，比如空间信息，redo文件路径，系统版本，checkpoint点等等。\r\n\r\n1，控制文件的主要问题在于如何保证其修改的原子性？\r\n因为此时系统中还没有redo,undo等机制。\r\nYashandb采用一次性准备好一批的修改点，每次写多个文件，写失败则abort，重启后校验的方式。\r\nPostgresql只有一个扇区，因而可以保证原子性。\r\n\r\n2，要避免对控制文件同一个位置的频繁写，可以搞多个位置轮流写。\r\n\r\n3，控制文件修改没有回滚机制，必须先在临时区改。正式修改内存与持久化一样不可逆。\r\n\r\n4，并发控制。	\N	\N	19	\N	3	\N	5	0	2023-02-11 22:18:39.497787	2023-02-11 22:18:39.497787	2023-02-11	0	\N	\N	1171	1	2	f	\N
1167	6	23	glibc ptmalloc内存暴涨问题	ptmalloc算法引起内存暴涨\r\nrule：\r\n只有当栈顶内存释放时，且栈顶空闲超过一定大小时，通过brk分配的小内存才能释放回系统。\r\n即ptmalloc是后申请先释放的机制。否则free时，内存会交给ptmalloc管理，并通过其内部机制复用。\r\n\r\n\r\n下述程序可以验证：\r\n1，mmap分配的内存不会影响brk分配的内存释放给系统。\r\n2，brk 后申请内存未释放，则先申请内存无法释放\r\n\r\n<pre><code class="c">\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <unistd.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n//mallopt(M_TRIM_THRESHOLD, 64*1024);\r\n//MemoryLeak\r\nchar * Array2064;\r\nfor (int j=0; j<2063; j++) {\r\nchar *Buff = (char *)malloc(3*1024);\r\nfor (int i=0; i<3*1024; i++)\r\nBuff[i] = i;\r\nArray[j] = Buff;\r\n}\r\nchar *Buff1 = (char *)malloc(256*1024);\r\nArray2063 = (char *)malloc(3*1024);\r\n\r\nsleep(25);\r\n    printf("Delete start\\n");\r\n\r\n//for (int j=0; j&lt;2064; j++) //check mmap and brk together.\r\n    for (int j=0; j&lt;2063; j++) \r\n        free(Array[j]);\r\n\r\nprintf("Delete All\\n");\r\n\r\n//sleep(10);\r\n    //malloc_trim(0);\r\n    //cout << "strim" << endl;\r\n\r\nwhile(1) sleep(10);\r\n}\r\n</code></pre>\r\n\r\n那么为什么会导致内存耗尽呢？即为什么free给ptmalloc的内存不能复用呢？\r\n这跟内存片的生命周期和内存碎片化有关系。\r\n\r\n1，如果一个小内存不回收，则其之前分配的内存永远不可回收，如果因为碎片化等因素导致其不可复用，则系统的内存会持续暴涨。\r\n直到ptmalloc合并减少碎片化，使得其管理的内存能符合进程的需要，但这本身就具备不确定性。\r\n2，如果该小内存在很久后才回收，即分配的内存部分生命周期很长，部分短。那么短生命周期的内存也可能长期无法回收。\r\n系统内存仍然可能暴涨。\r\n   比如申请了内存m1,m2,m3。但是m3一直不释放，m1,m2释放无法归还系统。\r\n则后分配m4,m5,m6。同样m6存在更久，m4,m5不归还。\r\n当然这前提是m4,m5,m6无法复用m1,m2。即小内存碎片无法复用。\r\n如果系统中大小内存交叉分配就比较容易出现。\r\n\r\n解决办法：\r\n1，长生命周期内存尽量使用mmap，减少对短期内存的影响。\r\n2，尽量减少碎片化内存。	\N	\N	17	\N	3	\N	5	2	2023-02-01 09:06:43.218308	2023-02-01 09:17:45.857266	2023-02-01	0	\N	\N	1167	1	2	f	\N
660	6	7	一个面试题	某系统生产期间会持续产生产品相关的记录，格式如下：\r\n{\r\n\t"编号": 10,\r\n\t"批次": 1001,\r\n\t"型号": 100,\r\n\t"责任人": "张三",\r\n}\r\n其中产品编号是单调增加(非严格)的。\r\n现要求实现一个存储子模块，记录上述产品生产信息，\r\n支持基于编号的查询(单个编号或编号范围)，以及删除过老产品记录以释放存储空间。\r\n(注:不明部分可使用伪代码表示)\r\n\r\n考察点：\r\n1，C基础\r\n2，抽象能力，适当的考虑变化，概念的运用，分块，迭代器\r\n3，设计能力，接口设计，封装\r\n4，工程，比如日志，错误处理，停机的考虑，测试，监控\r\n5，并发，三种操作之间的并发\r\n6，cache运用，flush再应答\r\n7，算法，索引的运用，二分查找	\N	\N	17	\N	3	\N	5	4	2020-07-17 07:52:08.32432	2023-02-08 18:13:26.054623	2020-07-17	0	\N	\N	660	1	2	f	\N
1170	7	33	2023年主要工作目标及要求	职责：\r\n1，看护设计质量，设计的正确性，全面性，性能等等。\r\n   要善于借助组织的力量。\r\n2，守住研发质量。\r\n   严格要求，据理以证\r\n3，产出高质量设计和代码。\r\n4，提升自身以及团队研发水平。\r\n4.1 技术分享\r\n5，抬头看路，输出思考。\r\n5.1 内核设计系列文章\r\n5.2 专利	\N	\N	19	\N	3	\N	5	0	2023-02-11 21:36:10.233938	2023-02-11 21:36:10.233938	2023-02-11	0	\N	\N	1170	1	2	f	\N
1172	7	33	DB2：redo	Redo：redo为系统提供原子性保证，故障恢复，复制，归档能力。\r\nRedo设计重点：性能\r\n1，每个session私有缓存\r\n2，公有缓存先分配空间和lsn，然后再拷贝，拷贝不阻塞其他线程。\r\n3，刷公有缓存，需切换当前公有缓存，不阻塞业务。\r\n4，批量提交，尤其是小事务，通过延迟机制达到batch提交效果。\r\n\r\n这些很多数据库的设计是类似的。\r\nredo中的lsn需回填页面，因而占好全局缓存的内存片后，需分配对应的lsn号，\r\n然后写入页面，再拷贝数据。	\N	\N	19	\N	3	\N	5	1	2023-02-11 22:34:04.909631	2023-02-11 22:48:07.860729	2023-02-11	0	\N	\N	1172	1	2	f	\N
1176	6	23	域名问题定位	ping: git.yasdb.com: Name or service not known\r\nCould not resolve host: git.yasdb.com; Unknown error\r\n\r\n[root@AchorBase ~]# nslookup git.yasdb.com\r\nServer:\t\t192.168.200.250\r\nAddress:\t192.168.200.250#53\r\n\r\nName:\tgit.yasdb.com\r\nAddress: 192.168.30.206\r\n\r\n/etc/resolv.conf nameserver顺序有关。	\N	\N	17	\N	3	\N	5	0	2023-03-01 08:12:10.081689	2023-03-01 08:12:10.081689	2023-03-01	0	\N	\N	1176	1	2	f	\N
1174	6	9	关于卖房的决定	关于房子的决定。\r\n2024年满5后卖房，考虑到巨大的风险以及后面的生活质量。\r\n\r\n安身立命的根本：凭本事解决客户的问题\r\n\r\n之后的生活安排：\r\n1，继续留深，但把贷款控制在小范围内。如50万。\r\n   留深圳的好处：\r\n   1，工作机会多\r\n   2，社会环境更好\r\n       (不考虑加班加点工作，未来还是得依赖高新技术，这点武汉或许更恶劣)\r\n   留深的坏处：\r\n   1，回老家不方便。\r\n   这边只能通过牺牲工作时间来弥补了，需降低对工作的预期。\r\n   \r\n2，回武汉，但前提是找到合适的工作。\r\n   回武汉的坏处：\r\n   1，工作机会少\r\n   2，社会环境没深圳优\r\n   \r\n   回武汉的好处：\r\n   1，可以有更多时间陪伴孩子。（其实深圳经济压力小点找个合适工作这点可以做得更好）\r\n   2，陪伴两边的母亲。（这点其实很残酷，但是社会如此，只能尽量多回老家了）	\N	\N	17	\N	3	\N	5	1	2023-02-19 17:05:05.820785	2023-03-12 16:13:40.236164	2023-02-19	0	\N	\N	1174	1	2	f	\N
1166	6	7	SSDR53：软件的结构	软件结构通常是有顶层结构，来自于最外层实体，以及其行为。\r\n\r\n然后内部结构如同人体系统一样，是一个森林。\r\n上层结构是不断分化而成，不存在反向依赖。\r\n\r\n软件通常有的系统有：内存资源，线程资源，日志系统，监控业务，业务系统等。\r\n\r\n软件结构对外泛化，对内分化。\r\n这样有更精细的行为，同时有更广的使用场景，降低软件复杂度。\r\n软件系统内有很多结构是单实例的，也有不少结构是多实例，即复用的。\r\n通常底层架构是单实例的，高层是多实例的。这两部分设计上都有难度。\r\n底层要考虑各种不同场景，各种功能，涉及架构伤筋动骨。\r\n高层复用性高，要考虑用法的各种变化，要极好的封装，否则改动成本大。\r\n所以新手最好在中间层工作。\r\n\r\n由软件结构可以指导软件的完备性设计。\r\n\r\n软件的表示法：\r\n用实体和行为来表达。\r\n我们为了实现行为增加子结构，但子结构通常会影响父结构的其他行为。\r\n结构有行为，行为催生结构。\r\n按照上述软件结构思想，可以用目录树一样的结构来表达软件。\r\n然后系统的需求，设计均可以通过该方式来描述。\r\n\r\n软件的发展：\r\n先用最不可或缺的场景，以及基本功能来设计软件。\r\n然后扩展其功能以及使用场景	\N	\N	17	\N	3	\N	5	4	2023-01-29 19:38:54.987621	2023-04-14 14:40:24.815253	2023-01-29	0	\N	\N	1166	1	2	f	\N
1196	6	24	热order key开发过程记录	LSC表点查性能验证，走列执行。直接开干。\r\n\r\n1，完成OK创建，删除\r\n2，完成OK dc加载\r\n3，vgd OK维护，dml\r\n   vgd slice\r\n   \r\ninsert/delete/update.\r\nTableSortDesc     sortDesc;\r\n   dcLoadVgdOrderKey,然后去创建segment，这跟一般路径是反的。\r\n   btreeCreateSegment，okDict内存与vgdSliceDict一同管理，同步加载。\r\n   entry记录在哪里？记在元数据。\r\n   VgdDict上保留一份cmpInfo？VgdDict\r\n   \r\n1，入口记在meta中. 如何记录入口。\r\n方式1：延迟创建回调\r\n   延迟创建时降信息写入meta。dc怎么刷新？\r\n     缺乏sliceId信息。\r\n方式2：不延迟创建，直接在后续写入到指定位置。\r\n\r\n方式2更加灵活。\r\n\r\nIndexKeyAssist结构：\r\nIoT概念：\r\n调用接口将列与rowid按顺序放入key中，即可。\r\nbtreePutNonKeyData\r\n从dataset生成key\r\n\r\n更新生成一个老的key，生成一个update key。\r\n困难在于不是一个index，能否构造一个呢？\r\n内部伪造一个indexDict，然后调用都走这个接口。\r\n\r\nbuildIndexFromSortKey.\r\n然后再改造index接口\r\n\r\n\r\n4，完成条件判断，以及vgd查询路径变更\r\n   vgd层次，将filter提取为公共的，\r\n   将filter转换为btree的range，启动扫描。可参看lob索引。lobInitScanCursor\r\n   然先表扫描的cursor，用于索引扫描。\r\n   \r\n   支持indexOnlyScan，先用crab调试\r\n   rowFormat只是需要填充rowid之类的，并且适配行取值接口\r\n   cursor->attr.getColumnValue = colGetSwfColumnValue;\r\n   cursor->attr.getTabColValue = cursor->attr.getColumnValue;\r\n\tCOLUMN_FORMAT走\tbtreeBatchFetch\r\n\tOrderKey也需支持回表，所以必须公用一个cursor。\r\n\t\r\n\tfetchByRowId呢，也用一个cursor吗？\r\n\tmakeIndexScanKey。\r\n\t\r\n\t\r\n4.1 填充range\r\nAnkIndexScanRange* range = &cursor->attr.indexRange;\r\n    ankInitIndexScan(cursor, range, COD_FALSE);\r\n\r\n    CodNumber     num = {.unused = 0};\r\n    CodBytes      bytes;\r\n    CodNumberData nd;\r\n    bytes.data = (CodUint8*)&nd;\r\n    num.value.item64[0] = locator->lobId;\r\n    codEncodeNumber(&num, &bytes);\r\n\r\n    CodUint32 blockPosStart = posInfo->blockStart -  posInfo->blockStart % LOB_MAX_BLOCKS_PER_KEY;\r\n    ankSetIndexScanKey(&range->leftKey, (CodChar*)bytes.data, bytes.size, COD_TRUE);\r\n    ankSetIndexScanKey(&range->leftKey, (CodChar*)&blockPosStart, sizeof(CodUint32), COD_TRUE);\r\n    ankSetIndexScanKey(&range->rightKey, (CodChar*)bytes.data, bytes.size, COD_TRUE);\r\n    ankSetIndexScanKey(&range->rightKey, (CodChar*)&posInfo->blockEnd, sizeof(CodUint32), COD_TRUE);\t\r\n4.2 多个range的表示\r\n    比如a=1 or a=2是分2个range，多次cursor扫描来完成的。参考fetchIndexRangeScan。\r\n\tvgd先支持单一range\r\n4.3 暂不做pushOnly优化\t\r\n4.4 索引扫描与表扫描的关系\r\n    索引扫描存在回表的情况，目前cursor使用的是同一个，内部去处理变量使用问题。\r\n\tauxCursor也存在给索引使用的情况。\r\n4.5 btree数据结构。btreeDecodeKeyColumns\r\n    出现undo insert找不到对应key的现象。页面中数据只有0和1。\r\n4.6 调试回表场景。\t\r\n    同样也是cursor问题，对于一个扫描而言，需要先init表扫描。\r\n\tprepare时可以prepare table scan，也可以是index scan。这样才具备回表能力。\r\n4.7 性能测试\r\n4.8 sysstat观察\r\n4.9 双索引验证\r\n    create table t1(c1 int, c2 varchar(30), c3 int) organization lsc mcol ttl '1' day  order by (c1,c2);\r\n4.9.1 index only\r\n    select c1 from t1 where c1 = 1;\r\n\tselect c1 from t1 where c1 > 5;\r\n\tselect c1 from t1 where c1 < 3;\r\n\tselect c1 from t1 where c1 > 3 and c1 < 5;\r\n\t\r\n\tselect c1,c3 from t1 where c1 = 1;\r\n\tselect c1,c3 from t1 where c1 > 5;\r\n\tselect c1,c3 from t1 where c1 < 3;\r\n\tselect c1,c3 from t1 where c1 > 3 and c1 < 5;\r\n\t\r\n4.9.2 accurate\r\n\tselect c1 from t1 where c1 = 1;\r\n\tselect c1,c2 from t1 where c1 = 1 and c2='abc';\r\n\tselect c1,c2 from t1 where c1 > 3 and c1 < 7 and c2='mo';\r\n\tselect c1,c2,c3 from t1 where c1 > 3 and c1 < 7 and c2='mo' and c3 < 650; 有问题，过滤无效\r\n\tselect c1,c2,c3 from t1 where c1 > 3 and c2='mo' and c3 < 650;\r\n\t\r\n4.9.3 组合条件\r\n    select c1 from t1 where c1 = 1 or c1 = 3;\r\n\tselect c1 from t1 where c1 in (1,3,4,7);\r\n\tselect c1 from t1 where (c1 < 3 or c1 > 5) and (c2 = 'mo' or c2='abc'); 有问题，结果变多\r\n\tselect c1 from t1 where c1 in (1,3,4,6,7) and c2 in ('mo','abcd','bo');\r\n   \r\n5，支持索引扫描\r\n   vgd slice   \r\n6, 兼容性，元数据默认为空，即为空时不使用OK  \r\n7, 可观察性，通过sysstat观察扫描的slice数量或记录数量\r\n   \r\n\r\n   \r\n   \r\n2，dict共享内存  \r\n3，compare info怎么存 \r\n   与order key保持同步。\r\n   TableSortDesc记录在tableDict，compare info字段值：\r\n   \r\n4，增加类型BTREE_FOR_VGD_SLICE\r\n5，写入直接调用btreeInsert\r\n   要拦截，如果没有初始化segment，则不插入\r\n   dcInitBtreeCmpInfo，cmpInfo等放在sortDesc上管理。\r\n   \r\n6，ok的可选择性问题。 \r\n\r\n周一评审，16列\r\n\r\nisFastFullScan\r\n\r\n默认LSC表的MCOL也会使用排序键，如MCOL不需要点查加速，在创建时可指定仅针对SCOL使用排序键。\r\n也可以使用alter命令开启或关闭MCOL的排序键。\r\n\r\n8，动态创建，使能order key功能。并且校验vgd order key。\r\n8.1 create table语法调整  搞定\r\n8.2 系统表调整以升级  搞定\r\n8.3 enable/disable order key\r\n    构建btree必须锁表，因而enable order key必然长久锁表。\r\n\t所以干脆全过程锁表，简化实现。\r\n\r\n    利用index构建过程，其好处是先排序，写入btree速度更快。\r\n    列排序没必要，btree本身就是行式的。\r\n    \r\n    并行加速这块后面可考虑下。\t\r\n\t\r\n8.4 校验\r\n8.5 动态创建\r\n    \r\n9，trace\r\ntrace到底是statistic还是trace本身，为啥非得设置statistic level才能看到。\r\n	\N	\N	17	\N	3	\N	5	0	2023-04-24 08:54:22.590564	2023-04-24 08:54:22.590564	2023-04-24	0	\N	\N	1196	1	2	f	\N
1195	7	33	列存引擎亮点以及技术点	1，列存组织\r\n2，编码压缩\r\n3，索引技术\r\n3.1 排序\r\n3.2 稀疏索引\r\n4，过滤\r\n4.1 条件下推\r\n4.2 不解码过滤\r\n4.3 过滤执行优化\r\n    如in比较优化，向量化执行\r\n5，缓存\r\n5.1 缓存算法\r\n5.2 内存缓存与磁盘缓存\r\n6，预读\r\n7，批写\r\n8，实时dml\r\n9，存储介质\r\n9.1 云存储\r\n9.2 元数据分离\t	\N	\N	19	\N	3	\N	5	1	2023-04-23 14:38:04.296938	2023-04-25 09:05:06.347579	2023-04-23	0	\N	\N	1195	1	2	f	\N
991	6	7	SSDR14：软件约束与正确性	软件错误的来源：\r\n1，不对称的动作\r\n  隐含的约束动作是很多bug的根源，直接造成实体的损害。\r\n  此问题rust无法杜绝(因而rust仍然有资源泄漏等问题)\r\n2，错误的变量值\r\n  计算表达式不对（当然rust也没法杜绝这种错误）\r\n  边界异常等(通过边界检查，rust可杜绝此类错误)\r\n3，因果错误，并发下的因果错误，持久化重启后的因果错误。\r\n  读写变量的因果无法得以保证等引起的问题。\r\n  不可并发也是一种常见的因果错误。（通过唯一可变的约束，以及锁等保护）\r\n4，间接因果，条件因果\r\n  比如if a {\r\n       do b;\r\n       do c;\r\n       do d; \r\n     }\r\n  b,c,d能修改的间接原因是a，如果a在其他地方变化，就会影响这里的果。\r\n  \r\n  \r\n\r\n 	\N	\N	17	\N	3	\N	5	10	2021-12-08 08:48:33.544963	2023-04-03 07:52:04.790867	2021-12-08	0	\N	\N	991	1	2	f	\N
1188	3	24	数据库思考	实例管理：\r\n空间管理：\r\n内存管理：\r\n网络管理：\r\nCPU管理：\r\nmeta操作，ddl, parquet,schema evolution。\r\n          挑战增删列，列的可选性。列的不确定性。\r\n\t\t数据湖与数据血缘。\r\nmeta缓存： 也涉及多版本问题\t\t\r\n\t\t\r\n传统处理方式上表的列可通过默认值如null来处理列的可选性问题。\t\t\r\nhttps://developer.aliyun.com/article/753783\r\nParquet通过元数据标识，支持在每条记录的维度支持列的可选性。\r\nSchemaEvolation通过Schema校验，以及merge来支持schema变化，如增删列。\r\n\t\t\r\ndata操作: 点查点修改点写(实时流式)，批写，批查。\r\ndata中是否一定要存储schema？\r\n从某种程度来说data都是编码的。\r\n\r\n数据索引技术：加点点查，批查，核心是降低冲突\r\n操作需要满足的约束：ACID。\r\n\r\n架构设计：\r\n1，不容易出错\r\n2，容易扩展\r\n3，容易调测，跟踪\r\n4，性能好\r\n5，兼容性好\r\n6，资源消耗低，能耗低\r\n\r\n分布式事务：\r\nXA事务，GXID，GTS即全局SCN。\r\n存储结构本身不关心事务。只需提供锁，冲突判断，可见性判断，一致性提交等逻辑即可。\r\nattach页面锁，避免备机读一致性问题。\r\n多dn xa事务等待，避免一致性问题。\r\n\r\nredo的持久化技术。成组提交。\r\nundo写法：针对删除写记录，而非插入。\r\n\r\n\r\n事务的辩证性：\r\n1，引用的代价是需要做生命周期管理。	\N	\N	17	\N	3	\N	5	0	2023-04-04 15:23:42.539894	2023-04-04 15:23:42.539894	2023-04-04	0	\N	\N	1188	1	2	f	\N
1193	6	24	云数仓方向的思考	1，首次存算分离架构的技术优势是非常明显的。\r\n   相对mpp架构。\r\n   成本下降，同时性能打折并不多。这得益于存储带宽的能力。\r\n2，VM资源隔离架构相比MPP计算组内扩容有更好的隔离优势。\r\n3，计算完全无状态，在计算弹性扩缩上还是有一定优势。\r\n\r\n2,3这两点或许是yashandb以后的架构劣势。\r\n主要区别在于元数据管理上，计算无状态了，因而不存在计算组的概念。\r\n\r\n当然我们也可以搞vm，但是需要考虑将当前DN上元数据同步给新的vm中的DN，这样代价是比较大的。\r\n优势是流式，实时性更强。\r\n	\N	\N	17	\N	3	\N	5	2	2023-04-11 18:45:45.087458	2023-04-12 11:56:55.243319	2023-04-11	0	\N	\N	1193	1	2	f	\N
1190	6	7	SSDR58：数据库是什么？	数据就是实体，也是类型，也是结构的实例。\r\n现实世界中各种不同特性的数据，以各种不同的结构组织来实现业务需要。\r\n\r\n数据库就是把这些存储起来，而存储起来的数据需要满足ACID的约束。\r\n除此之外，数据库提供了通用的数据处理能力，包括查找，计算等。	\N	\N	17	\N	3	\N	5	0	2023-04-05 22:29:36.370794	2023-04-05 22:29:36.370794	2023-04-05	0	\N	\N	1190	1	2	f	\N
1191	7	33	分布式事物	其实也不复杂，在单机事物基础上增加全局事物id，死锁，以及全局scn，然后实现xa协议。\r\n分布式事务xid会映射到本地事务。\r\n另外要考虑一些异常场景：\r\n1,多cn查询时scn的不同步问题\r\n 因为GTS本地缓存引起的一致性问题\r\n2,多dn查询时一致性问题，可能一个dn看到事务提交，另外一个看到未提交。\r\n 要处理这种中间态。如已开始第二阶段，要相应的等待。\r\n\r\n事务说白了主要就3个问题：\r\n1,一致提交与回滚\r\n2,冲突判断\r\n3,可见性判断\r\n即AI问题，C约束和持久化比较显然。\r\n\r\n但这里面有很多细化场景需要考虑，比如记录移动引起的miss update。\r\n所有数据包括元数据都得支持快照读能力。不支持的情况得额外处理。\r\n\r\nhttps://zhuanlan.zhihu.com/p/573680047	\N	\N	19	\N	3	\N	5	1	2023-04-05 22:38:02.85754	2023-04-05 22:40:08.652168	2023-04-05	0	\N	\N	1191	1	2	f	\N
1192	6	21	老家毛坯的相关问题	1,拆房的成本\r\n2,地基的厚度与宽度。\r\n3,框架结构还是砖混结构\r\n4,毛坯包含些什么\r\n5,门窗怎么搞\r\n6,屋顶怎么处理\r\n7,车库\r\n8,600如何保证质量？	\N	\N	17	\N	3	\N	5	0	2023-04-05 22:42:58.536776	2023-04-05 22:42:58.536776	2023-04-05	0	\N	\N	1192	1	2	f	\N
1189	6	9	写给孩子的	1, 事物是在辨证中发展的。\r\n   并非在原地踏步，事物在不断的发展，虽然这种发展通常是利弊都有，但通过其他代价消除弊端，\r\n   然后继续往前发展，所有事物莫不如此。所以不要真躺平，人还是要学会认知和改造世界，矛盾不会自然消散。\r\n 何况这社会本身就容易制造各种新矛盾。\r\n   \r\n2, 该怎么做：人应该以良性的方式去发展。\r\n  脱离世俗标准，拒绝恐惧，贪婪，愚昧化。回归本质并建立自己的体系才可能强大。\r\n  非良性就会引起反嗜。拒绝超身心负荷运转，以人为本。\r\n  人活着就是在做一件事：不断丰富自己的结构，身体和思想，同时保持结构的良性发展。\r\n\r\n3, 与他人关系：以合作与斗争的心态去对待身边的人，就像我们改造其他事物一样。\r\n  不要害怕合作与斗争，这些都是客观存在的。当然这需要我们有一颗强大的内心，而强大的内心来自于个人独立的世界观，价值观，人生观。\r\n  因为客观规律无法违背，人性也如此，将其考虑在内。\r\n  老实的本质是处事不够机智变通，考虑问题不够全面。即不够聪明智慧。\r\n\r\n4, 如何看待负面情绪：有时是应急需要，有时是非安全环境，以及非良性生活的指示灯。\r\n  所以拿出寻根问底的精神去解决问题。\r\n\r\n5, 与自我的关系：不要自我否定，人都会被淘汰\r\n他们需要安全和稳定，对他们来说，认为“自己出了问题”，比认为“他不能依赖那些他赖以为生的人”要好得多。\r\n“自我PUA”是一个比“自我厌恶”更加复杂、更加隐秘的心理状态。它还可能与我们的创伤体验有关，与羞耻感有关，与对完美的不合理期待有关。最重要的是，它所提供的“掌控感”，是我们内心非常渴望的体验。 \r\n\r\n我们之所以一直难以摆脱自我的操控，正是因为这些操控是有效的、是有好处的、是能达成目的的。因此，我们更需要借助外界的力量，去打破它们。参考https://zhuanlan.zhihu.com/p/377250858\r\n\r\n所有人都有被淘汰的一天，所有结构最终都会消亡。所以不要害怕斗争失败，环境恶化。\r\n即便我们依赖的环境再好，我们也得坚持走自己的路，这就是独立自由。\r\n认知自我，并构建出有生命力的自我，强大的内心，我们就能生发出一切，而前提就是我们的自信与独立。	\N	\N	17	\N	3	\N	5	2	2023-04-05 22:06:00.188045	2023-04-06 06:57:58.454391	2023-04-05	0	\N	\N	1189	1	2	f	\N
1194	6	18	AI辅助软件构建	有没可能一种AI，能自动学习结构知识，并且以此来认知事物。\r\n就像个人用自己的认知来了解世界一样。并且给出评判与诊断？\r\n有没有办法辅助构建程序等结构，\r\n其实主要难点在于纷繁复杂的约束。以及结构分化过程中维持其结构合理性。	\N	\N	17	\N	3	\N	5	2	2023-04-19 11:40:04.741426	2023-04-19 13:24:52.422477	2023-04-19	0	\N	\N	1194	1	2	f	\N
1197	6	9	结构，成长，失衡	万物皆因结构差异。结构是成长发展的。\r\n就像软件系统中的结构一样，刚开始简单，然后慢慢复杂化，最后就成了类似AI这种超复杂结构。\r\n而高级的行为便来自于复杂结构。理解是什么？\r\n成长与增长是有区别的，很多人会预设一个目标，然后让一个结构达成这类指标，这是增长。\r\n就像知识积累，资本增值一样。\r\n但成长不一样，成长是自发的，是不可期而至，是跳跃式的。\r\n核心区别在于是否失衡。\r\n群体化的组织，其中的成员是很容易失衡的，即其无法将时间投入到使其进行平衡的事务中。\r\n他知道什么对他很重要，哪些问题他最感兴趣，但是他无法投入其中。\r\n失衡需要相应的补救措施，比如快速的汽车需要跑道。失衡的个人需要自由恣意的空间。\r\n这也是佛家说的堕入魔道。\r\n但弥补失衡仅是让系统可以继续存续。\r\n这绝非净土，就像猪圈的猪一样，被人限制了自由，同时喂养，过着低质量生活，以及被屠宰的最终命运。	\N	\N	17	\N	3	\N	5	0	2023-04-24 17:43:07.7494	2023-04-24 17:43:07.7494	2023-04-24	0	\N	\N	1197	1	2	f	\N
\.


--
-- Name: issues_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.issues_id_seq', 1197, true);


--
-- Data for Name: journal_details; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.journal_details (id, journal_id, property, prop_key, old_value, value) FROM stdin;
9	5	attr	status_id	18	4
11	9	attr	status_id	18	8
12	11	attr	status_id	4	8
13	12	attr	status_id	8	11
14	13	attr	status_id	11	10
15	16	attr	status_id	8	11
16	17	attr	status_id	11	10
17	22	attr	status_id	17	18
18	23	attr	status_id	18	8
19	36	attr	status_id	18	8
20	42	attr	status_id	18	4
21	43	attr	status_id	4	11
22	44	attr	status_id	18	8
23	46	attr	status_id	17	4
24	48	attr	category_id	\N	2
25	49	attr	status_id	17	4
26	56	attr	status_id	17	4
27	57	attr	status_id	4	8
28	58	attr	status_id	8	11
29	62	attr	status_id	17	4
30	63	attr	status_id	4	12
31	64	attr	status_id	17	4
32	68	relation	copied_to	\N	27
33	69	relation	copied_from	\N	26
34	70	attr	fixed_version_id	\N	3
35	74	attr	status_id	17	4
36	75	attr	category_id	\N	4
37	75	attr	fixed_version_id	\N	3
38	76	attr	category_id	1	4
39	82	attr	status_id	8	11
40	84	attr	status_id	17	4
41	87	attr	status_id	4	8
42	95	attr	status_id	17	14
43	96	attr	status_id	17	4
44	99	attr	status_id	4	8
45	104	attr	status_id	17	16
46	105	attr	fixed_version_id	\N	1
47	106	attr	status_id	17	4
48	107	attr	fixed_version_id	4	5
49	108	attr	status_id	17	18
50	109	attr	status_id	17	4
51	114	attr	status_id	18	4
52	115	attr	fixed_version_id	\N	4
53	117	attr	category_id	\N	5
54	117	attr	fixed_version_id	\N	3
55	120	attr	status_id	17	4
56	144	attr	status_id	17	14
57	146	attr	status_id	17	18
58	152	attr	status_id	18	4
59	160	attr	tracker_id	7	4
60	160	attr	description	能够查询一个对象的变更历史，知道何时何人对对象做了变更。	\N
61	161	attr	tracker_id	7	4
62	161	attr	description	1，摸清楚license原理以及用法	\N
63	162	attr	status_id	19	24
64	163	attr	status_id	19	24
65	167	attr	done_ratio	0	100
66	221	attr	subject	2018.6.19	2018.6.19 （BI改造）
67	256	attr	subject	2018.7.23	2018.7.23(V5.2.0需求分析，存储策略，异构集群)
68	268	attachment	4	\N	pg分裂问题的严重性.png
69	286	attr	subject	基于bluestore的海量小文件处理方案	海量小文件问题
70	330	attr	category_id	\N	13
71	331	attr	category_id	\N	12
74	401	attachment	9	\N	rgw架构.png
75	405	attr	subject	游戏力实操训练营	游戏力实操训练营（第一课 妈妈，你走开-如何与孩子重新建立联结）
76	406	attr	subject	游戏力实操训练营（第3课 妈妈，我害怕- 如何让孩子勇敢）	游戏力实操训练营（第三课 妈妈，我害怕- 如何让孩子勇敢）
77	423	attr	subject	游戏力实操训练营（第四课 -妈妈，不要走-如何应对孩子的分离焦虑）	游戏力实操训练营（第四课 妈妈，不要走-如何应对孩子的分离焦虑）
78	455	attachment	12	\N	第四课复习卡.jpg
79	456	attachment	13	\N	第五课复习卡.jpg
80	457	attachment	14	\N	第一课复习卡.jpg
81	458	attachment	15	\N	第二课复习卡.jpg
82	459	attachment	16	\N	第三课复习卡.jpg
83	491	attr	subject	抽球练习心得1	打墙练习心得1
84	502	attachment	17	\N	499_tcpdump.png
85	504	attachment	18	\N	tcpdump_not_accept.png
86	511	attr	description	当一个帝国崛起之后，其会稳固其领导地位。\r\n而其他国家则试图在技术，以及其他方面创新从而实现自己的崛起。\r\n\r\n封建时代，中国无疑算是非常成功的，虽然中间几次沦落，但是那时辱民政策的恶果。\r\n如今的机会可能在于打开新的潘多拉魔盒，就像信息革命和工业革命一样。\r\n\r\n但人是否过得更好并非一定是选择方向。尤其是专制政府下。\r\n\r\n中国很可能有机会开启下一个魔盒，但释放的可能是新的魔鬼。	当一个帝国崛起之后，其会稳固其领导地位。\r\n而其他国家则试图在技术，以及其他方面创新从而实现自己的崛起。\r\n\r\n封建时代，中国无疑算是非常成功的，虽然中间几次沦落，但是那时辱民政策的恶果。\r\n如今的机会可能在于打开新的潘多拉魔盒，就像信息革命和工业革命一样。\r\n\r\n但人是否过得更好并非一定是选择方向。尤其是专制政府下。\r\n\r\n中国很可能有机会开启下一个魔盒，释放出新的魔鬼。
87	514	attachment	19	\N	tcpdump_not_accept.png
88	515	attachment	19	tcpdump_not_accept.png	\N
89	516	attachment	20	\N	tcp_netstat_error.png
90	518	attachment	21	\N	tcp_netstat_2.png
91	521	attachment	22	\N	hang_tcpdump.png
92	521	attachment	23	\N	normal_tcpdump.png
94	535	attr	subject	linux 进程通信与同步学习	linux 信号
108	682	attr	description	道不同，以光大本道。破除邪道。当人类走在分岔口。意识形态碰撞强烈时，战争就开始了。\r\n\r\n利益是小规模战争的原因。小规模是指局部战争，或实力悬殊的战胜。	道不同，以光大本道。破除邪道。当人类走在分岔口。意识形态碰撞强烈时，战争就开始了。\r\n\r\n战争还有一种单纯的原因就是利益。在物质并非最贵资源的今天，以争夺资源为目标的战争缺乏存在的基础。\r\n但是利益之战仍然存在，其形态发生了改变。
119	758	attr	description	所谓忧虑，就是存在风险\r\n所谓风险，就是能力不足，无法cover住各种情况。\r\n所谓创业，就是做一份自己热爱的事	所谓忧虑，就是存在风险\r\n所谓风险，就是能力不足，无法cover住各种情况\r\n所谓创业，就是做一份自己热爱的事\r\n所谓懒惰，就是没有能力掌控自己的精力
93	525	attr	description	1，realm配置变更时，rgw reload，一方面可能中断业务，另外可能因为资源依赖导致reload时rgw挂掉或可能hang住。\r\n2，多站点特性，多边同时执行put和删除操作，可能导致一边对象未删除，多出对象。\r\n3，老版本删除，和多出版本删除等gc操作在前端实现，在并发时可能引起本该删除的老对象没及时删除。\r\n4，osd在压力大时，可能出现slow request， peering卡住等问题\r\n5，osd恢复qos控制效果不好\r\n6，在某些场景下，掉电会出现db损坏问题。	1，realm配置变更时，rgw reload，一方面可能中断业务，另外可能因为资源依赖导致reload时rgw挂掉或可能hang住。\r\n2，多站点特性，多边同时执行put和删除操作，可能导致一边对象未删除，多出对象。\r\n3，老版本删除，和多出版本删除等gc操作在前端实现，在并发时可能引起本该删除的老对象没及时删除。\r\n4，rgw使用libfcgi存在风险，libfcgi在accept循环中读取头部数据\r\n5，osd在压力大时，可能出现slow request， peering卡住等问题\r\n6，osd恢复qos控制效果不好\r\n7，在某些场景下，掉电会出现db损坏问题。\r\n8，用户Qos，低tps用户发送大量请求可能阻塞高优先级用户。
95	546	attr	subject	个人工作职责的剥离	个人工作职责的剥离，用身边的人让自己变得成倍的强大。
96	555	attr	description	方案1：\r\n1，在对象删除后，并非立即将bi删除，而是增加删除标记。并且将对象实例丢入待清理列表\r\n2，在获取对象mtime时，获取含删除标记的对象的mtime。\r\n3，后台任务，在一段时间后清理删除标记。这里可启动新的后台任务，而非gc。\r\n\r\n问题：如何确定对象已经被同步？多久之后清理？\r\n注意：需考虑bucket删除等交叉场景。\r\n\r\n方案2：\r\n1，所有删除操作都不直接清除对象实例，而是将实例rename或打标记\r\n2，修改gc实现，gc扫描bi获取已删除对象进行删除。\r\n\r\n方案2的问题在于对于大量对象的bucket，这种遍历代价有点高。\r\n采用rename的方式以目前cls的方式实现问题不大，但是后续架构调整的目标是慢慢弱化cls。\r\n\r\n方案3：\r\n1，bucket都启用多版本	方案1：\r\n1，在对象删除后，并非立即将bi删除，而是增加删除标记。并且将对象实例丢入待清理列表\r\n2，在获取对象mtime时，获取含删除标记的对象的mtime。\r\n3，后台任务，在一段时间后清理删除标记。这里可启动新的后台任务，而非gc。\r\n\r\n问题：如何确定对象已经被同步？多久之后清理？\r\n注意：需考虑bucket删除等交叉场景。\r\n\r\n方案2：\r\n1，所有删除操作都不直接清除对象实例，而是将实例rename或打标记\r\n2，修改gc实现，gc扫描bi获取已删除对象进行删除。\r\n\r\n方案2的问题在于对于大量对象的bucket，这种遍历代价有点高。\r\n采用rename的方式以目前cls的方式实现问题不大，但是逻辑上稍微复杂些，\r\n除了按instance名字查询对象实例mtime，还得额外查询rename之后的key，后续架构调整的目标是慢慢弱化cls。\r\n\r\n方案3：\r\n1，bucket都启用多版本
97	560	attr	description	意外不意味着无法控制，反而你不加以控制，意外会越来越多。\r\n\r\n你得不断优化调试自己的机器，不断升级版本。而不是处于混沌状态。\r\n不论是学习，管理，还是干其他事都是如此。\r\n\r\n宏观可以看到方向，目标。 但微观才是决定成败的。	意外不意味着无法控制，反而你不加以控制，意外会越来越多。\r\n\r\n你得不断优化调试自己的机器，不断升级版本。而不是处于混沌状态。这样才能用“笨方法”把事做成。\r\n不论是学习，管理，还是干其他事都是如此。\r\n\r\n将机器执行逻辑不断分割为更小模块，理解这些模块，以及其关联关系，知道如何牵一发而动全身。\r\n\r\n宏观可以看到方向，目标。 但微观才是决定成败的。
98	561	attr	description	意外不意味着无法控制，反而你不加以控制，意外会越来越多。\r\n\r\n你得不断优化调试自己的机器，不断升级版本。而不是处于混沌状态。这样才能用“笨方法”把事做成。\r\n不论是学习，管理，还是干其他事都是如此。\r\n\r\n将机器执行逻辑不断分割为更小模块，理解这些模块，以及其关联关系，知道如何牵一发而动全身。\r\n\r\n宏观可以看到方向，目标。 但微观才是决定成败的。	意外不意味着无法控制，反而你不加以控制，意外会越来越多。\r\n\r\n你得不断优化调试自己的机器，不断升级版本。而不是处于混沌状态。这样才能用“笨方法”把事做成。\r\n不论是学习，管理，还是干其他事都是如此。\r\n\r\n将机器执行逻辑不断分割为更小模块，理解这些模块，以及其关联关系，知道如何牵一发而动全身。\r\n\r\n宏观可以看到方向，目标。 但计划与执行同样重要，微观决定成败。
99	574	attr	subject	xfs 碎片整理，内存占用等问题	海量小文件问题，xfs 碎片整理，内存占用等问题
100	586	attr	description	1，分治方法，合时扼要\r\n其重点在于识人用人，以及事的架构设计\r\n\r\n2，抓住本质，深入理解问题\r\n其实一些事情看似复杂，但是问题规模可能也就十几个。\r\n有些人一年就搞定了，而有些人10年都搞不定。\r\n\r\n3，学会放松\r\n\r\n	1，分治方法，合时扼要\r\n其重点在于识人用人，以及事的架构设计\r\n\r\n2，抓住本质，深入理解问题\r\n其实一些事情看似复杂，但是问题规模可能也就十几个。\r\n有些人一年就搞定了，而有些人10年都搞不定。\r\n\r\n3，善用工具，机器模型\r\n\r\n4，学会放松，调整精力。\r\n人在任何领域的差距都有百倍之上。精力强的人表现也会百倍于精力差的人。\r\n\r\n这就是人的综合差距有上万倍的原因。\r\n\r\n
101	598	attr	subject	关于去掉cls-rgw的思考	V6的思考(解耦)
102	611	attr	subject	提供中广核V3升级到V5方案	提供广发V3升级到V5方案
103	612	attr	done_ratio	0	100
104	641	attr	description	没有一无是处的人，如果感觉有，可能出现了如下情况：\r\n1，他放错了地方\r\n2，他做了不适合自己当下的事，聪明有经验的人不提出自己的建议，新手笨拙的人不提出自己的疑问。\r\n张小龙还想一秒变傻瓜呢，有些人不用变，因为心中没有魔障。\r\n\r\n说起来就是空间与时间，位置领域与趋势时机。	没有一无是处的人，如果感觉有，可能出现了如下情况：\r\n1，他放错了地方，做着不适合自己的事。\r\n2，他做了不适合自己当下的事，聪明有经验的人不提出自己的建议，新手笨拙的人不提出自己的疑问。\r\n张小龙还想一秒变傻瓜呢，有些人不用变，因为心中没有魔障。\r\n\r\n说起来就是空间与时间，位置领域与趋势时机。
105	643	attr	subject	当下流行的软件架构，以及常用组件	关于软件架构
106	646	attr	subject	一个大缺点 --- 缺乏责任心	优缺点分析
107	672	attr	subject	职业生涯规划-小章鱼之咨询篇	职业生涯规划-小章鱼之咨询篇20190228-0336
122	770	attr	done_ratio	0	30
124	790	attr	project_id	7	23
109	704	attr	description	1，缺乏充分调研，错用社区不稳定模块。闭门造车。\r\n2，有时候重写比重用更好，多版本就是典型例子，如果没搞懂，未经验证，最好别用。\r\n3，有时候以为需求明确了，但对于需求的紧急程度，需要的价值缺乏深入理解。\r\n做了很多流产的对接与小功能。\r\n4，没完全搞清楚现有系统就开始设计？你可能一开始就掉入陷阱。从开始到废弃。\r\n5，除了做对，还得考虑如何做得更好，V5重构就是一个天大的机会。然后错失了优化元数据的一次机会。\r\n6，临时测试验证的东西直接做成方案？小文件优化把这个坑演绎到极致。\r\n7，自动化测试用例应该由开发人员来写，且必须能快速有效的运行。\r\n8，设计review和开发review不仅应该做，而且应该做得很细。	1，缺乏充分调研，错用社区不稳定模块。闭门造车。\r\n2，有时候重写比重用更好，多版本就是典型例子，如果没搞懂，未经验证，最好别用。\r\n3，有时候以为需求明确了，但对于需求的紧急程度，需求的价值缺乏深入理解。\r\n做了很多流产的对接与小功能。\r\n4，没完全搞清楚现有系统就开始设计？你可能一开始就掉入陷阱。桶快照从开始到废弃。\r\n5，除了做对，还得考虑如何做得更好，V5重构就是一个天大的机会。然后错失了优化元数据的一次机会。\r\n6，临时测试验证的东西直接做成方案？小文件优化把这个坑演绎到极致。\r\n7，自动化测试用例应该由开发人员来写，且必须能快速有效的运行。\r\n8，设计review和开发review不仅应该做，而且应该做得很细。
110	705	attr	description	1，缺乏充分调研，错用社区不稳定模块。闭门造车。\r\n2，有时候重写比重用更好，多版本就是典型例子，如果没搞懂，未经验证，最好别用。\r\n3，有时候以为需求明确了，但对于需求的紧急程度，需求的价值缺乏深入理解。\r\n做了很多流产的对接与小功能。\r\n4，没完全搞清楚现有系统就开始设计？你可能一开始就掉入陷阱。桶快照从开始到废弃。\r\n5，除了做对，还得考虑如何做得更好，V5重构就是一个天大的机会。然后错失了优化元数据的一次机会。\r\n6，临时测试验证的东西直接做成方案？小文件优化把这个坑演绎到极致。\r\n7，自动化测试用例应该由开发人员来写，且必须能快速有效的运行。\r\n8，设计review和开发review不仅应该做，而且应该做得很细。	1，缺乏充分调研，错用社区不稳定模块。闭门造车。\r\n2，有时候重写比重用更好，多版本，多站点就是典型例子，如果没搞懂，未经验证，最好别用。\r\n3，有时候以为需求明确了，但对于需求的紧急程度，需求的价值缺乏深入理解。\r\n做了很多流产的对接与小功能。\r\n4，没完全搞清楚现有系统就开始设计？你可能一开始就掉入陷阱。桶快照从开始到废弃。\r\n5，除了做对，还得考虑如何做得更好，V5重构就是一个天大的机会。然后错失了优化元数据的一次机会。\r\n6，临时测试验证的东西直接做成方案？小文件优化把这个坑演绎到极致。\r\n7，自动化测试用例应该由开发人员来写，且必须能快速有效的运行。\r\n8，设计review和开发review不仅应该做，而且应该做得很细。
111	721	attr	description	命题是逻辑的基本构件，是一个陈述语句，它或真或假，不能既真又假。\r\n谓词：谓词本质就是命题函数，存在变元。\r\n量词：量词就是对于变元的情况做出规范，分为全称量词和存在量词。	命题是逻辑的基本构件，是一个陈述语句，它或真或假，不能既真又假。\r\n谓词：谓词本质就是命题函数，存在变元。含谓词的命题也叫谓词命题\r\n量词：量词就是对于变元的情况做出规范，分为全称量词和存在量词。含量词的命题也叫量化命题
112	722	attr	description	1，命题转换\r\n2，借助其他命题\r\n\r\n前提条件，蕴含的意思是如果前提为真，那么整体是否为真取决于结论是否为真。\r\np->q为真，则p是q的充分条件。\r\n\r\n推理规则就是采用等值变换将命题转换为其他形式。或根据前提来得出结论。\r\n\r\n直接证明：利用定义，以及其他公理，定理。通过推理来得出结论。\r\n反证法原理：p->q 等价于 非p V q 等价于 qV非p 等于于非q->非p。\r\n归谬法原理：证明p为真 等价于 非p->false为真。 false的一种形式为r且非r。 \r\n	1，命题转换\r\n2，借助其他命题\r\n\r\n前提条件，蕴含的意思是如果前提为真，那么整体是否为真取决于结论是否为真。\r\np->q为真，则p是q的充分条件。\r\n\r\n推理规则就是采用等值变换将命题转换为其他形式。或根据前提来得出结论。\r\n\r\n直接证明：利用定义，以及其他公理，定理。通过推理来得出结论。\r\n反证法原理：p->q 等价于 非p V q 等价于 qV非p 等于于非q->非p。\r\n归谬法原理：证明p为真 等价于 非p->false为真。 false的一种形式为r且非r。 \r\n\r\nso看到没，数理逻辑是数学证明的基础。证明的本质在于运用定义，公理来推理。
113	725	attr	description	分解：\r\n1，创建access schema分为哪几步？有哪些操作？\r\n  当作元数据，用户管理schema属于元数据操作。\r\n\r\n2，access schema在哪些阶段使用？怎样使用？\r\n  beas逻辑优化阶段\r\n\r\n3，access schema在什么情况下会被修改或删除？是否需关联删除constraint index？\r\n  当一个表的字段发生修改时\r\n  当一个表被删除时\r\n  \r\n  用户直接修改\r\n\r\n4，显然access schema在内存和外存中分别以什么形态存储？\r\n  hash查找快，但不好扩展。hash用来做均衡分布挺好的\r\n  红黑树可能更适合。\r\n\r\n5，对于access schema的使用做监控管理，比如用户使用怎样的查询语句来使用schema\r\n\r\n6，对于常量到表字段的映射，也需要加入到schema中管理？ \r\n比如select b2，a4 from A，B where a3 = 1. schema有null->a1, a1->b2.\r\nA的fetch sequence：a3=1\r\nB的fetch sequence：a3=1, a3->a1 , a1->a2\r\n\r\n7，关系提前生成？\r\n如a3->c4, c4->b3。从而生成a3->b3.\r\n	分解：\r\n1，创建access schema分为哪几步？有哪些操作？\r\n  当作元数据，用户管理schema属于元数据操作。\r\n  比如关联创建constraint index，关联创建衍生的acess schema? 是否需修改beas中保存的元数据？\r\n\r\n2，access schema在哪些阶段使用？怎样使用？\r\n  beas逻辑优化阶段\r\n\r\n3，access schema在什么情况下会被修改或删除？是否需关联删除constraint index？\r\n  当一个表的字段发生修改时\r\n  当一个表被删除时\r\n  \r\n  用户直接修改\r\n\r\n4，显然access schema在内存和外存中分别以什么形态存储？\r\n  hash查找快，但不好扩展。hash用来做均衡分布挺好的\r\n  红黑树可能更适合。\r\n\r\n5，对于access schema的使用做监控管理，比如用户使用怎样的查询语句来使用schema\r\n\r\n6，对于常量到表字段的映射，也需要加入到schema中管理？ \r\n比如select b2，a4 from A，B where a3 = 1. schema有null->a1, a1->b2.\r\nA的fetch sequence：a3=1\r\nB的fetch sequence：a3=1, a3->a1 , a1->a2\r\n\r\n7，关系提前生成？\r\n如a3->c4, c4->b3。从而生成a3->b3.\r\n
114	739	attr	subject	PG内存数据的结构算法	PG SysCache与RelCache
115	743	attr	description	beas的实现除了将beas功能内置为pg的子模块内，还有一种可能是将beas作为外部，内部把pg包住。	BEAS架构思考：\r\nbeas的实现除了将beas功能内置为pg的子模块内，还有一种可能是将beas作为外部，内部把pg包住。
116	747	attr	description	1，抬起脚根，抬起拍子，准备接球\r\n2，追高点\r\n3，放松(必须自信)展开击球，打到对方难受的地方 （需知彼）\r\n4，有节奏的回动到逻辑中心	V1.0：\r\n1，抬起脚根，抬起拍子，准备接球\r\n2，追高点\r\n3，放松(必须自信)展开击球，打到对方难受的地方 （需知彼）\r\n4，有节奏的回动到逻辑中心
117	756	attr	description	所谓风险，就是能力不足，无法cover住各种情况。	所谓忧虑，就是存在风险\r\n所谓风险，就是能力不足，无法cover住各种情况。
118	757	attr	description	所谓忧虑，就是存在风险\r\n所谓风险，就是能力不足，无法cover住各种情况。	所谓忧虑，就是存在风险\r\n所谓风险，就是能力不足，无法cover住各种情况。\r\n所谓创业，就是做一份自己热爱的事
121	769	attr	tracker_id	6	7
120	763	attr	description	Cygwin：是poxis模拟环境，提供了一套模拟运行环境\r\nMINGW:是GNU的工具链，用于在windows上像linux一样编译程序。	Cygwin：是poxis模拟环境，提供了一套模拟运行环境\r\nMINGW:是GNU的工具链，用于在windows上像linux一样编译程序。\r\nQt:基于Qt的桌面软件,Qt是一个桌面程序开发框架，就像windows上的MFC等
123	772	attr	done_ratio	0	100
126	792	attr	description	我们都知道一个缺乏原动力的人是多么的无趣，做事情没有认真严谨态度，对结果无所谓。我们在自己热爱的事情上难以容忍这样的搭档存在。\r\n我们可以有很多美好的目标，并且知道这些目标可以达到。只要我们行动起来，不断逼近。\r\n我们不因别人的好恶影响自己的选择，我们选择是因为我们的目标如此，我们不愿错过美好。\r\n\r\n成功方法论\r\n激励自己的目标 + 逻辑机器构建项目 + 彻底解决项目运转的各个细节问题(一个领域常见疑难问题可能就上千规模)。\r\n\r\n成熟检验方法：\r\n一个人只有当自己完全自由时，直面压力，掌控自己达成目标。才算真正成长起来，成为那个可以在前面遮风挡雨，独当一面的人。\r\n\r\n病痛分析：\r\n每个人因成长环境，原生家庭，可能形成恐惧，麻木，软弱不自信，无力，懒散，安全感缺失，依赖，放纵等等毛病。\r\n焦虑是因为有风险，有风险是因为能力不够或预期不实际。\r\n不去制定目标通常是因为缺乏自信，或者没有痛感，对自己的成长对世界的探索丧失了兴趣。	我们都知道一个缺乏原动力的人是多么的无趣，做事情没有认真严谨态度，对结果无所谓。我们在自己热爱的事情上难以容忍这样的搭档存在。\r\n我们可以有很多美好的目标，并且知道这些目标可以达到。只要我们行动起来，不断逼近。\r\n我们不因别人的好恶影响自己的选择，我们选择是因为我们的目标如此，我们不愿错过美好。\r\n我们不去假设自己成为那个最优秀的人，也许天生环境我们无法达到。但我们可以在自己热爱的方向上不断前进，这就足够美好了。\r\n\r\n成功方法论\r\n激励自己的目标 + 逻辑机器构建项目 + 彻底解决项目运转的各个细节问题(一个领域常见疑难问题可能就上千规模)。\r\n\r\n成熟检验方法：\r\n一个人只有当自己完全自由时，直面压力，掌控自己达成目标。才算真正成长起来，成为那个可以在前面遮风挡雨，独当一面的人。\r\n\r\n病痛分析：\r\n每个人因成长环境，原生家庭，可能形成恐惧，麻木，软弱不自信，无力，懒散，安全感缺失，依赖，放纵等等毛病。\r\n焦虑是因为有风险，有风险是因为能力不够或预期不实际。\r\n不去制定目标通常是因为缺乏自信，或者没有痛感，对自己的成长对世界的探索丧失了兴趣。
130	799	attr	due_date	\N	2019-05-16
135	805	attr	description	static语义是静态的，描述变量的存储特性。\r\n\r\n但是static在c语言中还有另一个作用（有点奇葩，一个关键字2个语义）： 限制作用域在本文件内。对于头文件而言就是包含该头文件的C文件内。	static语义是静态的，描述变量的静态存储特性，静态存储变量会自动初始化\r\n\r\n但是static在c语言中还有另一个作用（有点奇葩，一个关键字2个语义）： 限制作用域在本文件内。对于头文件而言就是包含该头文件的C文件内。
142	869	attr	description		MVCC的解决的问题是事务的隔离性。PG这块搞起来很复杂，一方面是因为事务本身复杂，pg的实现复杂。二是结合事务的各种状态，多版本的管理以及可见性判断复杂。\r\n隔离一种实现方式是加锁，但性能上没法接受。另一种方式就是MVCC。undo也是其中一种实现方案。
145	896	attr	subject	PG ScanDesc	PG Scan执行
147	898	attr	description	IOT使用场景：1，查询基本使用key。 2，表比较短小。\r\n从BEAS理论来说这两点都是满足的。\r\n\r\n如果将index最底层的page换成heap会怎样？\r\n或者说index不变，只是其指向的不再是tuple，而是page。逻辑上会发生什么变化。\r\n\r\n或者说成稀疏index，whatever？ 这样heap里面的tuple格式就与目标一致了，且insert不必总是更新两个页面。\r\n而版本清理后续还能通过undo机制优化。\r\n\r\nIOT的玩法对于scan也是一样，总是index scan。或者说这并非传统意义上的indexscan，这就是ac scan。\r\n如果能用索引，就直接定位到具体的heap page，如果不能，就从最左边的heap page开始。\r\n\r\nheap page仅支持单向扫描，干掉左边的指针。也可不支持指向parent，使得btree代码可以完全重用。\r\n\r\n优点：\r\n1，通常只需更新heap，可加快更新速度。\r\n2，砍掉了index头部，节省部分空间\r\n3，查询时不必额外拼装tuple。写入时也不必拆分。\r\n	IOT使用场景：1，查询基本使用key。 2，除了index key之外表比较短小。 3，尽量少的second index。\r\n从BEAS理论来说这两点都是满足的。\r\n\r\npostgresql不支持IOT可能有两方面原因：\r\n1，通常IOT实现在index上增加可见信息，这与pg目前框架区别太大，代价非常高。\r\n2，IOT适用场景比较有限。\r\n\r\n\r\n如果将index最底层的page换成heap会怎样？\r\n或者说index不变，只是其指向的不再是tuple，而是page。逻辑上会发生什么变化。\r\n\r\n或者说成稀疏index，whatever？ 这样heap里面的tuple格式就与目标一致了，且insert不必总是更新两个页面。\r\n而版本清理后续还能通过undo机制优化。\r\n\r\nIOT的玩法对于scan也是一样，总是index scan。或者说这并非传统意义上的indexscan，这就是ac scan。\r\n如果能用索引，就直接定位到具体的heap page，如果不能，就从最左边的heap page开始。\r\n\r\nheap page仅支持单向扫描，干掉左边的指针。也可不支持指向parent，使得btree代码可以完全重用。\r\n\r\n优点：\r\n1，通常只需更新heap，可加快更新速度。\r\n2，砍掉了index头部，节省部分空间\r\n3，查询时不必额外拼装tuple。写入时也不必拆分。\r\n
149	901	attr	subject	PG wal格式	PG wal
151	910	attr	description	索引记录的存储结构为\r\nX|Y|Z\r\nZ = heap header | count | pkid, Z是定长结构。\r\n\r\n该方案只需在中间层做些手脚就可以了，不改btree，也不改heap。\r\n\r\n\r\n	索引记录的存储结构为\r\nX|Y|Z\r\nZ = heap header | count | pkid, Z是定长结构。\r\n\r\n该方案只需在中间层做些手脚就可以了，不改btree，也不改heap。\r\n\r\n记录格式调整为:\r\nIndexTupleData + [ | IndexAttributeBitMapData] + [ | HeapHeaderData] + fields\r\n使用info长度为0的方式表达。或\r\n\r\n
152	911	attr	description	索引记录的存储结构为\r\nX|Y|Z\r\nZ = heap header | count | pkid, Z是定长结构。\r\n\r\n该方案只需在中间层做些手脚就可以了，不改btree，也不改heap。\r\n\r\n记录格式调整为:\r\nIndexTupleData + [ | IndexAttributeBitMapData] + [ | HeapHeaderData] + fields\r\n使用info长度为0的方式表达。或\r\n\r\n	索引记录的存储结构为\r\nX|Y|Z\r\nZ = heap header | count | pkid, Z是定长结构。\r\n\r\n该方案只需在中间层做些手脚就可以了，不改btree，也不改heap。\r\n\r\n记录格式调整为:\r\nIndexTupleData + [ | IndexAttributeBitMapData] + [ | HeapHeaderData] + fields\r\n\r\n使用ItemPointerData的offset最高位表示是否为AC，对于该offset的使用一定要小心。\r\n
154	913	attr	description	索引记录的存储结构为\r\nX|Y|Z\r\nZ = heap header | count | pkid, Z是定长结构。\r\n\r\n该方案只需在中间层做些手脚就可以了，不改btree，也不改heap。\r\n\r\n记录格式调整为:\r\nIndexTupleData + [ | IndexAttributeBitMapData] + [ | HeapHeaderData] + fields\r\n\r\n使用ItemPointerData的offset最高位表示是否为AC，对于该offset的使用一定要小心。\r\n这样可直接返回heapTuple。\r\n\r\n\r\n	索引记录的存储结构为\r\nX|Y|Z\r\nZ = heap header | count | pkid, Z是定长结构。\r\n\r\n该方案只需在中间层做些手脚就可以了，不改btree，也不改heap。\r\n\r\n记录格式调整为:\r\nIndexTupleData + [ | IndexAttributeBitMapData] + [ | HeapHeaderData] + fields\r\n\r\n使用ItemPointerData的offset最高位表示是否为AC，对于该offset的使用一定要小心。\r\n这样可直接返回heapTuple。 HeapHeaderData中null部分是变长的。\r\n\r\n\r\n
164	947	attr	status_id	4	12
165	952	attr	description	log_destination 语义并不准确，实际上是log格式。配置了stderr，但是下面配置collector，以及文件就能输出到指定文件。\r\n\r\n#log_destination = 'csvlog'\t\t# Valid values are combinations of\r\n\t\t\t\t\t# stderr, csvlog, syslog, and eventlog,\r\n\t\t\t\t\t# depending on platform.  csvlog\r\n\t\t\t\t\t# requires logging_collector to be on.\r\n\r\n# This is used when logging to stderr:\r\nlogging_collector = on\t\t# Enable capturing of stderr and csvlog\r\n\t\t\t\t\t# into log files. Required to be on for\r\n\t\t\t\t\t# csvlogs.\r\n\t\t\t\t\t# (change requires restart)\r\n\r\n# These are only used if logging_collector is on:\r\nlog_directory = 'pg_log'\t\t\t# directory where log files are written,\r\n\t\t\t\t\t# can be absolute or relative to PGDATA\r\nlog_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'\t# log file name pattern,\r\n\t\t\t\t\t# can include strftime() escapes\r\nlog_file_mode = 0640\t\t\t# creation mode for log files,\r\n\t\t\t\t\t# begin with 0 to use octal notation\r\n#log_truncate_on_rotation = off\t\t# If on, an existing log file with the\r\n\t\t\t\t\t# same name as the new log file will be\r\n\t\t\t\t\t# truncated rather than appended to.\r\n\t\t\t\t\t# But such truncation only occurs on\r\n\t\t\t\t\t# time-driven rotation, not on restarts\r\n\t\t\t\t\t# or size-driven rotation.  Default is\r\n\t\t\t\t\t# off, meaning append to existing files\r\n\t\t\t\t\t# in all cases.\r\nlog_rotation_age = 2d\t\t\t# Automatic rotation of logfiles will\r\n\t\t\t\t\t# happen after that time.  0 disables.\r\nlog_rotation_size = 100MB\t\t# Automatic rotation of logfiles will\r\n\t\t\t\t\t# happen after that much log output.\r\n\t\t\t\t\t# 0 disables.	log_destination 语义并不准确，实际上是log格式。配置了stderr，但是下面配置collector，以及文件就能输出到指定文件。\r\n\r\n<pre><code class="text">\r\n#log_destination = 'csvlog'\t\t# Valid values are combinations of\r\n\t\t\t\t\t# stderr, csvlog, syslog, and eventlog,\r\n\t\t\t\t\t# depending on platform.  csvlog\r\n\t\t\t\t\t# requires logging_collector to be on.\r\n\r\n# This is used when logging to stderr:\r\nlogging_collector = on\t\t# Enable capturing of stderr and csvlog\r\n\t\t\t\t\t# into log files. Required to be on for\r\n\t\t\t\t\t# csvlogs.\r\n\t\t\t\t\t# (change requires restart)\r\n\r\n# These are only used if logging_collector is on:\r\nlog_directory = 'pg_log'\t\t\t# directory where log files are written,\r\n\t\t\t\t\t# can be absolute or relative to PGDATA\r\nlog_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'\t# log file name pattern,\r\n\t\t\t\t\t# can include strftime() escapes\r\nlog_file_mode = 0640\t\t\t# creation mode for log files,\r\n\t\t\t\t\t# begin with 0 to use octal notation\r\n#log_truncate_on_rotation = off\t\t# If on, an existing log file with the\r\n\t\t\t\t\t# same name as the new log file will be\r\n\t\t\t\t\t# truncated rather than appended to.\r\n\t\t\t\t\t# But such truncation only occurs on\r\n\t\t\t\t\t# time-driven rotation, not on restarts\r\n\t\t\t\t\t# or size-driven rotation.  Default is\r\n\t\t\t\t\t# off, meaning append to existing files\r\n\t\t\t\t\t# in all cases.\r\nlog_rotation_age = 2d\t\t\t# Automatic rotation of logfiles will\r\n\t\t\t\t\t# happen after that time.  0 disables.\r\nlog_rotation_size = 100MB\t\t# Automatic rotation of logfiles will\r\n\t\t\t\t\t# happen after that much log output.\r\n\t\t\t\t\t# 0 disables.\r\n</code></pre>\r\n
166	956	attr	subject	PG CI_v3	PG CI_v2 vacuum&analyze
169	960	attr	status_id	4	12
125	791	attr	description	我们都知道一个缺乏原动力的人是多么的无趣，做事情没有认真严谨态度，对结果无所谓。我们在自己热爱的事情上难以容忍这样的搭档存在。\r\n我们可以有很多美好的目标，并且知道这些目标可以达到。只要我们行动起来，不断逼近。\r\n我们不因别人的好恶影响自己的选择，我们选择是因为我们的目标如此，我们不愿错过美好。\r\n\r\n成功方法论\r\n激励自己的目标 + 逻辑机器构建项目 + 彻底解决项目运转的各个细节问题(一个领域常见疑难问题可能就上千规模)。\r\n\r\n成熟检验方法：\r\n一个人只有当自己完全自由时，直面压力，掌控自己达成目标。才算真正成长起来，成为那个可以在前面遮风挡雨，独当一面的人。\r\n\r\n病痛分析：\r\n每个人因成长环境，原生家庭，可能形成恐惧，麻木，软弱不自信，无力，懒散，安全感缺失，依赖，放纵等等毛病。\r\n焦虑是因为有风险，有风险是因为能力不够或预期不实际。\r\n	我们都知道一个缺乏原动力的人是多么的无趣，做事情没有认真严谨态度，对结果无所谓。我们在自己热爱的事情上难以容忍这样的搭档存在。\r\n我们可以有很多美好的目标，并且知道这些目标可以达到。只要我们行动起来，不断逼近。\r\n我们不因别人的好恶影响自己的选择，我们选择是因为我们的目标如此，我们不愿错过美好。\r\n\r\n成功方法论\r\n激励自己的目标 + 逻辑机器构建项目 + 彻底解决项目运转的各个细节问题(一个领域常见疑难问题可能就上千规模)。\r\n\r\n成熟检验方法：\r\n一个人只有当自己完全自由时，直面压力，掌控自己达成目标。才算真正成长起来，成为那个可以在前面遮风挡雨，独当一面的人。\r\n\r\n病痛分析：\r\n每个人因成长环境，原生家庭，可能形成恐惧，麻木，软弱不自信，无力，懒散，安全感缺失，依赖，放纵等等毛病。\r\n焦虑是因为有风险，有风险是因为能力不够或预期不实际。\r\n不去制定目标通常是因为缺乏自信，或者没有痛感，对自己的成长对世界的探索丧失了兴趣。
127	793	attr	description	我们都知道一个缺乏原动力的人是多么的无趣，做事情没有认真严谨态度，对结果无所谓。我们在自己热爱的事情上难以容忍这样的搭档存在。\r\n我们可以有很多美好的目标，并且知道这些目标可以达到。只要我们行动起来，不断逼近。\r\n我们不因别人的好恶影响自己的选择，我们选择是因为我们的目标如此，我们不愿错过美好。\r\n我们不去假设自己成为那个最优秀的人，也许天生环境我们无法达到。但我们可以在自己热爱的方向上不断前进，这就足够美好了。\r\n\r\n成功方法论\r\n激励自己的目标 + 逻辑机器构建项目 + 彻底解决项目运转的各个细节问题(一个领域常见疑难问题可能就上千规模)。\r\n\r\n成熟检验方法：\r\n一个人只有当自己完全自由时，直面压力，掌控自己达成目标。才算真正成长起来，成为那个可以在前面遮风挡雨，独当一面的人。\r\n\r\n病痛分析：\r\n每个人因成长环境，原生家庭，可能形成恐惧，麻木，软弱不自信，无力，懒散，安全感缺失，依赖，放纵等等毛病。\r\n焦虑是因为有风险，有风险是因为能力不够或预期不实际。\r\n不去制定目标通常是因为缺乏自信，或者没有痛感，对自己的成长对世界的探索丧失了兴趣。	我们都知道一个缺乏原动力的人是多么的无趣，做事情没有认真严谨态度，对结果无所谓。我们在自己热爱的事情上难以容忍这样的搭档存在。\r\n我们可以有很多美好的目标，并且知道这些目标可以达到。有了激动人心的目标，我们就可以发挥自己的智慧提升自己的效率，自动思考相关问题，我们可以行动起来，不断逼近。\r\n我们不因别人的好恶影响自己的选择，我们选择是因为我们的目标如此，我们不愿错过美好。\r\n我们不去假设自己成为那个最优秀的人，也许天生环境我们无法达到。但我们可以在自己热爱的方向上不断前进，这就足够美好了。\r\n\r\n成功方法论\r\n激励自己的目标 + 逻辑机器构建项目 + 彻底解决项目运转的各个细节问题(一个领域常见疑难问题可能就上千规模)。\r\n\r\n成熟检验方法：\r\n一个人只有当自己完全自由时，直面压力，掌控自己达成目标。才算真正成长起来，成为那个可以在前面遮风挡雨，独当一面的人。\r\n\r\n病痛分析：\r\n每个人因成长环境，原生家庭，可能形成恐惧，麻木，软弱不自信，无力，懒散，安全感缺失，依赖，放纵等等毛病。\r\n焦虑是因为有风险，有风险是因为能力不够或预期不实际。\r\n不去制定目标通常是因为缺乏自信，或者没有痛感，对自己的成长对世界的探索丧失了兴趣。
128	795	attachment	31	\N	2019年5月12日母亲节感恩会.jpg
129	798	attr	subject	2019/5/12日母亲节活动总结	2019年5月12日母亲节活动总结
131	800	attr	tracker_id	8	6
132	800	attr	done_ratio	\N	0
133	801	attr	tracker_id	8	6
134	801	attr	done_ratio	\N	0
136	811	attr	project_id	17	23
137	818	attr	description	IO模型\r\n内存数据组织\r\n{\r\n   数据变更的通知\r\n   淘汰机制\r\n}\r\n磁盘数据组织\r\n数据的编解码\r\n事务机制\r\n{\r\n  并发控制\r\n  {\r\n    锁在内存的实现\r\n    锁的层次\r\n\t锁的类型\r\n  }\r\n  一致性保证\r\n  {\r\n    redo机制：提交则数据必然成功修改\r\n  }\r\n  隔离级别\r\n}\r\n数据保护\r\n{\r\n    多版本\r\n    快照\r\n    备份\r\n    容灾\r\n    防篡改\r\n}\r\n副本数据同步\r\n数据分布\r\nGC	IO模型\r\n内存数据组织\r\n{\r\n   数据变更的通知\r\n   淘汰机制\r\n   数据加载，数据加载需要锁保护，数据访问也需要锁保护。\r\n}\r\n磁盘数据组织\r\n数据的编解码\r\n事务机制\r\n{\r\n  并发控制\r\n  {\r\n    锁在内存的实现\r\n    锁的层次\r\n\t锁的类型\r\n  }\r\n  一致性保证\r\n  {\r\n    redo机制：提交则数据必然成功修改\r\n  }\r\n  隔离级别\r\n}\r\n数据保护\r\n{\r\n    多版本\r\n    快照\r\n    备份\r\n    容灾\r\n    防篡改\r\n}\r\n副本数据同步\r\n数据分布\r\nGC
138	823	attr	description	聚簇索引，其数据根据索引顺序组织，因而其btree的中间节点可指向页面，叶子节点就是实际数据。\r\n非聚簇索引，叶子节点存的是tid。\r\n\r\n\r\n<pre><code class="text">\r\n1、大多数表都应该有聚簇索引或使用分区来降低对表尾页的竞争，在一个高事务的环境中，对最后一页的封锁严重影响系统的吞吐量。\r\n2、在聚簇索引下，数据在物理上按顺序排在数据页上，重复值也排在一起，因而在那些包含范围检查(between、<、<=、>、>=)或使用group by或orderby的查询时，一旦找到具有范围中第一个键值的行，具有后续索引值的行保证物理上毗连在一起而不必进一步搜索，避免了大范围扫描，可以大大提高查询速度。\r\n3、在一个频繁发生插入操作的表上建立聚簇索引时，不要建在具有单调上升值的列(如IDENTITY)上，否则会经常引起封锁冲突。\r\n4、在聚簇索引中不要包含经常修改的列，因为码值修改后，数据行必须移动到新的位置。\r\n5、选择聚簇索引应基于where子句和连接操作的类型。\r\n</code></pre>\r\n	聚簇索引，其数据根据索引顺序组织，因而其btree的中间节点可指向页面，叶子节点就是实际数据。\r\n非聚簇索引，叶子节点存的是tid。\r\n\r\n\r\n<pre><code class="text">\r\n1、大多数表都应该有聚簇索引或使用分区来降低对表尾页的竞争，在一个高事务的环境中，对最后一页的封锁严重影响系统的吞吐量。\r\n\r\n2、在聚簇索引下，数据在物理上按顺序排在数据页上，重复值也排在一起，\r\n因而在那些包含范围检查(between、<、<=、>、>=)或使用group by或orderby的查询时，\r\n一旦找到具有范围中第一个键值的行，具有后续索引值的行保证物理上毗连在一起而不必进一步搜索，\r\n避免了大范围扫描，可以大大提高查询速度。\r\n\r\n3、在一个频繁发生插入操作的表上建立聚簇索引时，不要建在具有单调上升值的列(如IDENTITY)上，否则会经常引起封锁冲突。\r\n\r\n4、在聚簇索引中不要包含经常修改的列，因为码值修改后，数据行必须移动到新的位置。\r\n\r\n5、选择聚簇索引应基于where子句和连接操作的类型。\r\n</code></pre>\r\n
139	829	attr	description	Mysql编译：\r\n1，下载源代码\r\nhttps://github.com/mysql/mysql-server/tree/5.7\r\n2，下载boost 1.59\r\nhttps://www.boost.org/users/history/version_1_59_0.html\r\n\r\n3，安装ncurses\r\nyum install ncurses-devel\r\n\r\n4，mkdir build;cd build; cmake ../ -DWITH_BOOST=/root/boost_1_59_0/	Mysql编译：\r\n1，下载源代码\r\nhttps://github.com/mysql/mysql-server/tree/5.7\r\n2，下载boost 1.59\r\nhttps://www.boost.org/users/history/version_1_59_0.html\r\n\r\n3，安装ncurses\r\nyum install ncurses-devel\r\n\r\n4，mkdir build;cd build; cmake ../ -DWITH_BOOST=/root/boost_1_59_0/\r\n\r\n5，mysqld --initialize 初始化（5.7以后）\r\n\r\n6，在/var/log/mysql/error.log日志里面可以看到随机生成的root密码\r\n\r\n7，登录：mysql -uroot -p'GCIq<iXoo82j'\r\n\r\n8，修改用户\r\nhttps://blog.51cto.com/arthur376/1840353
140	857	attr	description	我将生生不息的参与2个游戏，一个是增强智慧与知识。另一个增强体魄与精气神。	我将生生不息的参与2个游戏，一个是增强智慧与知识。另一个增强体魄与精气神。\r\n再个就是强化沟通与交流，编织精彩网络。
141	864	attr	description	TID：tuple id\r\nXID：事务id\r\n	TID：tuple id\r\nXID：事务id\r\nLSN：log sequence number，记录在page上，用于确保wal机制.
143	871	attr	description	1，一个文件多大，如何切换文件	1，一个文件多大，如何切换文件\r\n这个实现在md中，_mdfd_segpath。pg对于relfilenode抽象：\r\ntypedef struct buftag\r\n{\r\n    RelFileNode rnode;            /* physical relation identifier */\r\n    ForkNumber    forkNum;\r\n    BlockNumber blockNum;        /* blknum relative to begin of reln */\r\n} BufferTag;\r\n\r\nforkNum：\r\n/*\r\n * The physical storage of a relation consists of one or more forks. The\r\n * main fork is always created, but in addition to that there can be\r\n * additional forks for storing various metadata. ForkNumber is used when\r\n * we need to refer to a specific fork in a relation.\r\n */\r\n因此我们可以定义自己的forkNum实现特殊的存储目的。\r\n\r\n对pg而言页的逻辑number是不断增加的，但是一个文件的大小受限于RELSEG_SIZE。默认是128k，这样一个segment不会超过1GB。
167	958	attr	subject	PG why need command ID	PG why need command ID 以及 Combo CommandID
168	959	attr	status_id	17	4
170	966	attr	subject	软件开发与打羽毛球	软件开发，羽毛球，江湖
171	974	attr	parent_id	\N	439
144	892	attr	description	如果将index最底层的page换成heap会怎样？\r\n或者说index不变，只是其指向的不再是tuple，而是page。逻辑上会发生什么变化。\r\n\r\n或者说成稀疏index，whatever？ 这样heap里面的tuple格式就与目标一致了，且insert不必总是更新两个页面。\r\n而版本清理后续还能通过undo机制优化。\r\n\r\nIOT的玩法对于scan也是一样，总是index scan。或者说这并非传统意义上的indexscan，这就是ac scan。\r\n如果能用索引，就直接定位到具体的heap page，如果不能，就从最左边的heap page开始。\r\n\r\nheap page仅支持单向扫描，干掉左边的指针。也可不支持指向parent，使得btree代码可以完全重用。\r\n	如果将index最底层的page换成heap会怎样？\r\n或者说index不变，只是其指向的不再是tuple，而是page。逻辑上会发生什么变化。\r\n\r\n或者说成稀疏index，whatever？ 这样heap里面的tuple格式就与目标一致了，且insert不必总是更新两个页面。\r\n而版本清理后续还能通过undo机制优化。\r\n\r\nIOT的玩法对于scan也是一样，总是index scan。或者说这并非传统意义上的indexscan，这就是ac scan。\r\n如果能用索引，就直接定位到具体的heap page，如果不能，就从最左边的heap page开始。\r\n\r\nheap page仅支持单向扫描，干掉左边的指针。也可不支持指向parent，使得btree代码可以完全重用。\r\n\r\n优点：\r\n1，通常只需更新heap，可加快更新速度。\r\n2，砍掉了index头部，节省部分空间\r\n3，查询时不必额外拼装tuple。写入时也不必拆分。\r\n
146	897	attr	description	如果将index最底层的page换成heap会怎样？\r\n或者说index不变，只是其指向的不再是tuple，而是page。逻辑上会发生什么变化。\r\n\r\n或者说成稀疏index，whatever？ 这样heap里面的tuple格式就与目标一致了，且insert不必总是更新两个页面。\r\n而版本清理后续还能通过undo机制优化。\r\n\r\nIOT的玩法对于scan也是一样，总是index scan。或者说这并非传统意义上的indexscan，这就是ac scan。\r\n如果能用索引，就直接定位到具体的heap page，如果不能，就从最左边的heap page开始。\r\n\r\nheap page仅支持单向扫描，干掉左边的指针。也可不支持指向parent，使得btree代码可以完全重用。\r\n\r\n优点：\r\n1，通常只需更新heap，可加快更新速度。\r\n2，砍掉了index头部，节省部分空间\r\n3，查询时不必额外拼装tuple。写入时也不必拆分。\r\n	IOT使用场景：1，查询基本使用key。 2，表比较短小。\r\n从BEAS理论来说这两点都是满足的。\r\n\r\n如果将index最底层的page换成heap会怎样？\r\n或者说index不变，只是其指向的不再是tuple，而是page。逻辑上会发生什么变化。\r\n\r\n或者说成稀疏index，whatever？ 这样heap里面的tuple格式就与目标一致了，且insert不必总是更新两个页面。\r\n而版本清理后续还能通过undo机制优化。\r\n\r\nIOT的玩法对于scan也是一样，总是index scan。或者说这并非传统意义上的indexscan，这就是ac scan。\r\n如果能用索引，就直接定位到具体的heap page，如果不能，就从最左边的heap page开始。\r\n\r\nheap page仅支持单向扫描，干掉左边的指针。也可不支持指向parent，使得btree代码可以完全重用。\r\n\r\n优点：\r\n1，通常只需更新heap，可加快更新速度。\r\n2，砍掉了index头部，节省部分空间\r\n3，查询时不必额外拼装tuple。写入时也不必拆分。\r\n
148	899	attr	description	IOT使用场景：1，查询基本使用key。 2，除了index key之外表比较短小。 3，尽量少的second index。\r\n从BEAS理论来说这两点都是满足的。\r\n\r\npostgresql不支持IOT可能有两方面原因：\r\n1，通常IOT实现在index上增加可见信息，这与pg目前框架区别太大，代价非常高。\r\n2，IOT适用场景比较有限。\r\n\r\n\r\n如果将index最底层的page换成heap会怎样？\r\n或者说index不变，只是其指向的不再是tuple，而是page。逻辑上会发生什么变化。\r\n\r\n或者说成稀疏index，whatever？ 这样heap里面的tuple格式就与目标一致了，且insert不必总是更新两个页面。\r\n而版本清理后续还能通过undo机制优化。\r\n\r\nIOT的玩法对于scan也是一样，总是index scan。或者说这并非传统意义上的indexscan，这就是ac scan。\r\n如果能用索引，就直接定位到具体的heap page，如果不能，就从最左边的heap page开始。\r\n\r\nheap page仅支持单向扫描，干掉左边的指针。也可不支持指向parent，使得btree代码可以完全重用。\r\n\r\n优点：\r\n1，通常只需更新heap，可加快更新速度。\r\n2，砍掉了index头部，节省部分空间\r\n3，查询时不必额外拼装tuple。写入时也不必拆分。\r\n	IOT使用场景：1，查询基本使用key。 2，除了index key之外表比较短小。 3，尽量少的second index。\r\n从BEAS理论来说这两点都是满足的。\r\n\r\npostgresql不支持IOT可能有两方面原因：\r\n1，通常IOT实现在index上增加可见信息，这与pg目前框架区别太大，代价非常高。\r\n2，IOT适用场景比较有限。\r\n\r\npostgresql clusterd index：\r\nhttps://www.postgresql.org/docs/10/sql-cluster.html\r\n这代价有点大，而且需使用命令触发。\r\n\r\n\r\n如果将index最底层的page换成heap会怎样？\r\n或者说index不变，只是其指向的不再是tuple，而是page。逻辑上会发生什么变化。\r\n\r\n或者说成稀疏index，whatever？ 这样heap里面的tuple格式就与目标一致了，且insert不必总是更新两个页面。\r\n而版本清理后续还能通过undo机制优化。\r\n\r\nIOT的玩法对于scan也是一样，总是index scan。或者说这并非传统意义上的indexscan，这就是ac scan。\r\n如果能用索引，就直接定位到具体的heap page，如果不能，就从最左边的heap page开始。\r\n\r\nheap page仅支持单向扫描，干掉左边的指针。也可不支持指向parent，使得btree代码可以完全重用。\r\n\r\n优点：\r\n1，通常只需更新heap，可加快更新速度。\r\n2，砍掉了index头部，节省部分空间\r\n3，查询时不必额外拼装tuple。写入时也不必拆分。\r\n
150	903	attr	subject	PG IOT	PG CI-IOT
153	912	attr	description	索引记录的存储结构为\r\nX|Y|Z\r\nZ = heap header | count | pkid, Z是定长结构。\r\n\r\n该方案只需在中间层做些手脚就可以了，不改btree，也不改heap。\r\n\r\n记录格式调整为:\r\nIndexTupleData + [ | IndexAttributeBitMapData] + [ | HeapHeaderData] + fields\r\n\r\n使用ItemPointerData的offset最高位表示是否为AC，对于该offset的使用一定要小心。\r\n	索引记录的存储结构为\r\nX|Y|Z\r\nZ = heap header | count | pkid, Z是定长结构。\r\n\r\n该方案只需在中间层做些手脚就可以了，不改btree，也不改heap。\r\n\r\n记录格式调整为:\r\nIndexTupleData + [ | IndexAttributeBitMapData] + [ | HeapHeaderData] + fields\r\n\r\n使用ItemPointerData的offset最高位表示是否为AC，对于该offset的使用一定要小心。\r\n这样可直接返回heapTuple。\r\n\r\n\r\n
155	926	attr	description	ac中大量重复的x和y是可以做压缩的。这样可以在很大程度上减小数据存储规模，同时保证其查找特性。\r\n这样将数据轻松放在SSD或内存中，爽爆	ac中大量重复的x和y是可以做压缩的。这样可以在很大程度上减小数据存储规模，同时保证其查找特性。\r\n最小化编码的可查找树，这样将数据轻松放在SSD或内存中，爽爆
156	928	attr	subject	数据交易市场	数据交易市场-让每个人获取更好的数据，让思考不再空穴来风
157	930	attr	description	评估方式：\r\n   时间复杂度\r\n   空间复杂度\r\n\r\n大维度：计算，存储，网络三大板块。\r\n   \r\n常用手段：\r\n   减小数据规模，砍掉不必要的东西\r\n   减少必须执行的步骤\r\n   优化每步的速度，使用不同的硬件，以及改进算法\r\n   批量执行\r\n   并行执行\r\n   预热处理，缓存技术，可以减少在重复执行时的一些步骤\r\n   副本技术，读写分离等减少资源冲突	评估方式：\r\n   时间复杂度\r\n   空间复杂度\r\n\r\n大维度：计算，存储，网络三大板块。\r\n   \r\n常用手段：\r\n   减小数据规模，砍掉不必要的东西\r\n   压缩减小存储空间\r\n   减少必须执行的步骤\r\n   优化每步的速度，使用不同的硬件，以及改进算法\r\n   批量执行\r\n   并行执行\r\n   预热处理，缓存技术，可以减少在重复执行时的一些步骤\r\n   副本技术，读写分离等减少资源冲突
158	939	attr	subject	工程师的工作套路	工程师的工作套路，效率
159	940	relation	relates	\N	465
160	941	relation	relates	\N	438
161	942	relation	relates	\N	439
162	943	relation	relates	\N	466
163	946	attr	status_id	17	4
173	1001	attachment	32	\N	redo_undo日志.png
172	992	attr	description	评估方式：\r\n   时间复杂度\r\n   空间复杂度\r\n\r\n大维度：计算，存储，网络三大板块。\r\n   \r\n常用手段：\r\n   减小数据规模，砍掉不必要的东西\r\n   压缩减小存储空间\r\n   减少必须执行的步骤\r\n   优化每步的速度，使用不同的硬件，以及改进算法\r\n   批量执行\r\n   并行执行\r\n   预热处理，缓存技术，可以减少在重复执行时的一些步骤\r\n   副本技术，读写分离等减少资源冲突	评估方式：\r\n   时间复杂度\r\n   空间复杂度\r\n\r\n大维度：计算，存储，网络三大板块。\r\n   \r\n常用手段：\r\n   减小数据规模，砍掉不必要的东西\r\n   压缩减小存储空间\r\n   减少必须执行的步骤\r\n   优化每步的速度，使用不同的硬件，以及改进算法\r\n   批量执行\r\n   并行执行\r\n   预热处理，缓存技术，可以减少在重复执行时的一些步骤\r\n   副本技术，读写分离等减少资源冲突\r\n   最小化锁冲突，无锁数据结构
176	1018	attr	subject	Postgresql中的money类型显示单位	Postgresql中的money符号
178	1020	attr	status_id	4	12
179	1021	attr	description	1，概率\r\n2，bloom\r\n3，抽样\r\n4，最终一致性\r\n\r\n当允许近似时，算法可能出现非常大的简化。	1，概率\r\n2，bloom\r\n3，抽样\r\n4，最终一致性\r\n\r\n当允许近似时，算法可能出现非常大的简化。\r\n而很多系统或场景是可以采用近似方法的。
182	1056	attr	subject	PG	PG索引-元数据解析
183	1071	attr	subject	快乐生活	幸福快乐生活
186	1092	attr	description	1，如何返回某个表的所有记录？\r\n2，如果x，y完全distinct，就如同一个主键表，主键是key。这时如何blocked存储？还是退化成普通存储？	问题是什么？基于行存的ac存在如下缺陷：\r\n1，无法支持多个ac的使用（这是执行器的问题）\r\n2，列存更利于分析\r\n3，依赖于数据重复，没有利用好ac数据可以blocked的特点。\r\n\r\n1，如何返回某个表的所有记录？\r\n2，如果x，y完全distinct，就如同一个主键表，主键是key。这时如何blocked存储？还是退化成普通存储？
187	1094	attr	subject	现有分布式kv系统的调研	kudu存储引擎
174	1010	attr	description	二阶段加锁：\r\nhttps://yq.aliyun.com/articles/626848\r\n\r\n锁都是针对资源的。资源可以是任何事物。\r\n锁可以分不同的模式，这是由资源的熟悉决定的。\r\n锁有明确的时间属性。所以分别有不同的实现方式。\r\n\r\n如果不是拿完立即释放就存在死锁的情况。数据库表锁和行锁就是这种。	二阶段加锁：\r\nhttps://yq.aliyun.com/articles/626848\r\n\r\n锁都是针对资源的。资源可以是任何事物。\r\n锁可以分不同的模式，这是由资源的熟悉决定的。\r\n锁有明确的时间属性。所以分别有不同的实现方式。\r\n\r\n如果不是拿完立即释放就存在死锁的情况。数据库表锁和行锁就是这种。\r\n\r\n理论上锁都是可以是纯逻辑的，比如红绿灯，其实可以不放红绿灯在那，放别的标志也是一样的。重要的是大家都得按锁规则来使用资源。
175	1011	attr	description	1，为什么需要redo\r\n2，为什么需要undo\r\n3，为什么需要checkpoint\r\n4，为什么需要后台wal线程，后台写数据线程\r\n5，为什么需要GC\r\n6，空间管理有哪些形式\r\n7，hash索引与btree索引的优劣\r\n8，内存数据库与磁盘数据库加cache的真正区别是什么\r\n9，为什么需要列存储\r\n10，为什么会出现时序数据库\r\n11，为什么Span需要TrueTime API，时间意味着什么？\r\n12，什么操作不需要WAL，什么操作无法回滚？\r\n13，是否所有wal记录的操作都能具备幂等性?	1，为什么需要redo\r\n2，为什么需要undo\r\n3，为什么需要checkpoint\r\n4，为什么需要后台wal线程，后台写数据线程\r\n5，为什么需要GC\r\n6，空间管理有哪些形式\r\n7，hash索引与btree索引的优劣\r\n8，内存数据库与磁盘数据库加cache的真正区别是什么\r\n9，为什么需要列存储\r\n10，为什么会出现时序数据库\r\n11，为什么Span需要TrueTime API，时间意味着什么？\r\n12，什么操作不需要WAL，什么操作无法回滚？\r\n13，是否所有wal记录的操作都能具备幂等性?\r\n14，为什么说分布式事务本质上都是使用二阶段提交协议？\r\n15，什么是一阶段提交协议\r\n16，2PC与Paxos什么关系？\r\n17，MVCC,WAL与事务的关系
177	1019	attr	status_id	17	4
180	1027	attr	description	\r\n\r\n1, 问题是什么\r\n平衡树查询性能好，但是更新插入的性能低\r\n\r\n2，涉及的概念\r\n平衡树\r\n概率\r\n\r\n3，当前的现状\r\n4，出现的机遇\r\n5，趋势\r\n6，解决方案\r\n不做平衡，不保证严格意义上的平衡。\r\n想象所有节点在一条线上，skiplist就是随机生成上面的N层中间树节点一样。\r\n这样生成的是一棵平衡性很随机的树。\r\n\r\n7 实现思路\r\nhttps://blog.csdn.net/ict2014/article/details/17394259\r\n除了节点可以维持多个level的指针外。节点还可以维护步长，或者叫rank，从而可以根据rank查找记录。\r\n\r\n8 关键点\r\nheader自身不含key和value，但是用每个level的head指针，如果某个level的skiplist没有前置节点，则其前置就是head。\r\n\r\n9，验证方法\r\n10，维护	\r\n\r\n1, 问题是什么\r\n平衡树查询性能好，但是更新插入的性能低\r\n\r\n2，涉及的概念\r\n平衡树\r\n概率\r\n\r\n3，当前的现状\r\n4，出现的机遇\r\n5，趋势\r\n6，解决方案\r\n不做平衡，不保证严格意义上的平衡。\r\n想象所有节点在一条线上，skiplist就是随机生成上面的N层中间树节点一样。\r\n这样生成的是一棵平衡性很随机的树。\r\n\r\n7 实现思路\r\nhttps://blog.csdn.net/ict2014/article/details/17394259\r\n除了节点可以维持多个level的指针外。节点还可以维护步长，或者叫rank，从而可以根据rank查找记录。\r\n\r\n8 关键点\r\nheader自身不含key和value，但是用每个level的head指针，如果某个level的skiplist没有前置节点，则其前置就是head。\r\n随机算法为什么能构建一棵树，可以按概率计算。控制了每层的概率就控制了每层数据之间的比例。\r\n9，验证方法\r\n10，维护
181	1042	attr	subject	2019年9月活动量统计表	2019年9月活动量
184	1073	attr	project_id	7	24
185	1076	attr	subject	幸福快乐生活	如何生活
188	1119	attr	subject	羽毛球发力的特征	羽毛球发力的特征(高手之路)
189	1141	attr	subject	大数据分析的脉络，经典产品所处的位置	大数据，存储生态
190	1149	attr	subject	科学与神学	科学，数学与神学
191	1150	attr	description	科学是可证伪，但未被证伪的命题集合。\r\n逻辑与数学是抽象的，不具备可证伪性，因而不是侠义的科学。\r\n纯逻辑的事物其实都是自己的理论系统。\r\n\r\n比如神学与马克思哲学，其都没有提出完备的公理，其结论也未经某个公理系统推导，\r\n因而其结论也不具备广泛的可信度(至少与公理同样的可信度)	可证伪性是一个理论系统的属性，其中的公理如果具备可证伪性，说明这个系统是严格意义上科学的。\r\n但可证伪性不代表实际上一定具备环境来验证，比如牛顿第一定律。\r\n如果没法证明公理，则系统的可信度就是公理级别，而不是真理。\r\n\r\n可证伪性没必要作为科学的划分界限，其实基于公理之上的研究也是广义上科学的。\r\n人会死是公理，三段论也是公理。很多科学研究基本的那几条都是公理。\r\n\r\n\r\n逻辑与数学是抽象的，不具备可证伪性，因而不是侠义的科学。\r\n纯逻辑的事物其实都是自己的理论系统。\r\n\r\n比如神学与马克思哲学，其都没有提出完备的公理，其结论也未经某个公理系统推导，\r\n因而其结论也不具备广泛的可信度(至少与公理同样的可信度)
192	1152	attr	subject	创始者宣言	创世者宣言
193	1153	attr	description	创世者宣言：\r\n我们立志成为创世者，\r\n秉持科学精神，知行合一\r\n我们坚信直面问题，克服困难就是在制造快乐\r\n以真诚对待生命，看到自己，看到别人，接收自己，接收别人，改变自己。\r\n我们时刻活在当下，生机畅达。\r\n我们从不焦虑，因为我们已经在行动。\r\n我们从不被动挨打，因为我们在主动出击。\r\n我们从不虚度时光，因为那是在浪费美好。	创世者宣言：\r\n我们立志成为创世者，\r\n秉持科学精神，知行合一\r\n我们坚信直面问题，克服困难就是在制造快乐。\r\n以真诚对待生命，看到自己，看到别人，接收自己，接收别人，改变自己。\r\n我们时刻活在当下，生机畅达。\r\n我们从不焦虑，因为我们已经在行动。\r\n我们从不被动挨打，因为我们在主动出击。\r\n我们从不虚度时光，因为那是在浪费美好。
194	1164	attr	description	1，工作就是最好的修行\r\n2，付出不亚于任何人的努力\r\n3，把事情想到有颜色\r\n4，目标应该有挑战\r\n5，消除其他一切烦恼\r\n6，灵魂注入	1，工作就是最好的修行\r\n2，付出不亚于任何人的努力\r\n3，把事情想到有颜色\r\n4，目标应该有挑战\r\n5，消除其他一切烦恼\r\n6，灵魂注入\r\n7，积极出击\r\n8，不要问我知道什么，要问我不知道什么。
195	1167	attr	description	1，快速抬肘架拍\r\n2，蹬地转腰的同时开始倒拍\r\n3，腰转正之时也差不多是最高速挥拍，在完成蹬转发力链条期间内完成倒排挥拍动作。	1，快速抬肘架拍\r\n2，蹬地转腰的同时开始倒拍\r\n3，腰转正之时也差不多是最高速挥拍，在完成蹬转发力链条期间内完成倒排挥拍动作。\r\n4，手腕手指在前面阶段是不必介入的，等大臂带小臂把速度甩起来，最后击球阶段手腕手指介入。
196	1168	attr	description	1，工作就是最好的修行\r\n2，付出不亚于任何人的努力\r\n3，把事情想到有颜色\r\n4，目标应该有挑战\r\n5，消除其他一切烦恼\r\n6，灵魂注入\r\n7，积极出击\r\n8，不要问我知道什么，要问我不知道什么。	1，工作就是最好的修行\r\n2，付出不亚于任何人的努力\r\n3，把事情想到有颜色\r\n4，目标应该有挑战\r\n5，消除其他一切烦恼\r\n6，灵魂注入\r\n7，积极出击\r\n8，不要问我知道什么，要问我不知道什么。\r\n9，专注，把当下在做的事情做到极致，对工作而言，就是把手头上的事做到极致。
204	1194	attr	description	TODO list:\r\n1,超过配置时间的事务自行abort\r\n2，ci vacuum逻辑修正。\r\n3，delete需要遍历ci tree上多条记录，存在相同key不在同一个链上的情况。	TODO list:\r\n1,超过配置时间的事务自行abort\r\n2，ci vacuum逻辑修正。\r\n3，delete需要遍历ci tree上多条记录，存在相同key不在同一个链上的情况。\r\n4，hint的设置
205	1196	attr	description	TODO list:\r\n1,超过配置时间的事务自行abort\r\n2，ci vacuum逻辑修正。\r\n3，delete需要遍历ci tree上多条记录，存在相同key不在同一个链上的情况。\r\n4，hint的设置	TODO list:\r\n1,超过配置时间的事务自行abort\r\n2，ci vacuum逻辑修正。\r\n3，delete需要遍历ci tree上多条记录，存在相同key不在同一个链上的情况。\r\n4，hint的设置\r\n5，宏改为参数
206	1199	attr	description	1，完成添加ci清理进程\r\n2，弄清楚gp的分布式事务与本地事务的对应关系\r\n3，完善对coral的理解，找出疑问。why need coral？ what is coral？\r\n4，合入欧博代码，开始测试。	1，完成添加ci清理进程，顺便把参数加进去。\r\n2，弄清楚gp的分布式事务与本地事务的对应关系\r\n3，完善对coral的理解，找出疑问。why need coral？ what is coral？\r\n4，合入欧博代码，开始测试。
207	1200	attr	description	1，启动\r\n通过postgresMaster在serverloop中启动。\r\npostgresmaster随后不停监听进程状态。\r\n\r\n2，停止\r\nSIGCHLD，在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程，按系统默认将忽略此信号，\r\n如果父进程希望被告知其子系统的这种状态，则应捕捉此信号。\r\n\r\nreaper函数处理该信号，调用waitpid，得到退出的进程id，然后将该进程设置为0.\r\n这样postmaster在serverloop中检查到，就重新启动该类型进程。\r\n\r\n3，crash处理\r\ncrash之后共享内存可能处于不一致的状态，这时需要重新加载。\r\nHandleChildCrash函数处理这种情况，会给所有进程发送退出信号。\r\n然后修改pmState。	如何在postgres中添加一个后台进程。\r\n\r\nAuxiliaryProcess进程的生命周期。\r\n1，启动\r\n通过postgresMaster在serverloop中启动。\r\npostgresmaster随后不停监听进程状态。\r\n\r\n2，停止\r\nSIGCHLD，在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程，按系统默认将忽略此信号，\r\n如果父进程希望被告知其子系统的这种状态，则应捕捉此信号。\r\n\r\nreaper函数处理该信号，调用waitpid，得到退出的进程id，然后将该进程设置为0.\r\n这样postmaster在serverloop中检查到，就重新启动该类型进程。\r\n\r\n3，crash处理\r\ncrash之后共享内存可能处于不一致的状态，这时需要重新加载。\r\nHandleChildCrash函数处理这种情况，会给所有进程发送退出信号。\r\n然后修改pmState。\r\n\r\n添加一个后台进程步骤：\r\n1，增加一个pid\r\n2，增加启动和退出处理\r\n3，增加处理函数
210	1215	attr	subject	2020.3.12 (ci rollback功能)	2020.3.12 (ci rollback功能与代码review)
211	1217	attr	description	coral方案疑问整理：\r\n1，count在TPC-DS数据集下的效果，如果按时间维度组织数据。聚集效果会怎样？\r\n2，非基础ac的支持方式，非基础ac数据也按照时间维度分区，但是insert时也得检查是否已存在。如果存在则合并。\r\n   这样插入的代价会不会大到无法接受。\r\n3，coral的核心技术点在于？多维索引？ac划分数据？ 基于列存的IoT组织数据。	coral方案疑问整理：\r\n1，count在TPC-DS数据集下的效果，如果按时间维度组织数据。聚集效果会怎样？\r\n2，非基础ac的支持方式，非基础ac数据也按照时间维度分区，但是insert时也得检查是否已存在。如果存在则合并。\r\n   这样插入的代价会不会大到无法接受。非基础AC就像跨节点索引。\r\n\r\n3，coral的核心技术点在于？多维索引？ac划分数据？ 基于列存的IoT组织数据。\r\n4，用户怎么知道如何拆分AC，用户定义表。
219	1285	attr	due_date	\N	2020-05-22
220	1285	attr	done_ratio	0	100
197	1172	attr	description	1，撒谎者\r\n           生活在情绪的漩涡之中，并且身心遭受伤害，无法面对，只能逃避，撒谎，扭曲的方式来处理。\r\n2，体制者，依存，麻木，自我怀疑，迷失自我\r\n           容易因别人观念而做出选择，价值取向于所在集体相关。\r\n3，独立者，具备独立人格，开始直面个人之外的所有问题，以及基本的自信。\r\n           有了一定个人修为，能觉察自己，情绪控制与行为自律能力。\r\n\t\t   完全独立的人不再有对于人和事不在有因个人原因的恐惧。\r\n4，传世者，有了能力协助他人，散播爱的能力。1，觉知爱并因爱而行动 2，心外无物，能感知别人，并帮助其成长。	1，撒谎者\r\n           生活在情绪的漩涡之中，并且身心遭受伤害，无法面对，只能逃避，撒谎，扭曲的方式来处理。\r\n2，体制者，依存，麻木，自我怀疑，迷失自我，边界感缺失。\r\n           容易因别人观念而做出选择，价值取向于所在集体相关。\r\n3，独立者，具备独立人格，开始直面个人之外的所有问题，以及基本的自信。\r\n           有了一定个人修为，能觉察自己，情绪控制与行为自律能力。\r\n\t\t   完全独立的人不再有对于人和事不在有因个人原因的恐惧。\r\n4，传世者，有了能力协助他人，散播爱的能力。1，觉知爱并因爱而行动 2，心外无物，能感知别人，并帮助其成长。
198	1174	attr	subject	修行	修行之道
199	1189	attr	description		TODO list:\r\n1,超过配置时间的事务自行abort\r\n2，ci vacuum逻辑修正
200	1191	attr	description	TODO list:\r\n1,超过配置时间的事务自行abort\r\n2，ci vacuum逻辑修正	TODO list:\r\n1,超过配置时间的事务自行abort\r\n2，ci vacuum逻辑修正。\r\n3，delete需要遍历ci tree上多条记录，存在相同key不在同一个链上的情况。
201	1193	attachment	34	\N	少有人走的路-群体意识.png
202	1193	attachment	33	\N	少有人走的路-意识.png
203	1193	attachment	35	\N	少有人走的路.drawio
208	1201	attr	description	/*\r\n * Certain options can only be set at certain times. The rules are\r\n * like this:\r\n *\r\n * INTERNAL options cannot be set by the user at all, but only through\r\n * internal processes ("server_version" is an example).  These are GUC\r\n * variables only so they can be shown by SHOW, etc.\r\n *\r\n * POSTMASTER options can only be set when the postmaster starts,\r\n * either from the configuration file or the command line.\r\n *\r\n * SIGHUP options can only be set at postmaster startup or by changing\r\n * the configuration file and sending the HUP signal to the postmaster\r\n * or a backend process. (Notice that the signal receipt will not be\r\n * evaluated immediately. The postmaster and the backend check it at a\r\n * certain point in their main loop. It's safer to wait than to read a\r\n * file asynchronously.)\r\n *\r\n * BACKEND options can only be set at postmaster startup, from the\r\n * configuration file, or by client request in the connection startup\r\n * packet (e.g., from libpq's PGOPTIONS variable).  Furthermore, an\r\n * already-started backend will ignore changes to such an option in the\r\n * configuration file.  The idea is that these options are fixed for a\r\n * given backend once it's started, but they can vary across backends.\r\n *\r\n * SUSET options can be set at postmaster startup, with the SIGHUP\r\n * mechanism, or from SQL if you're a superuser.\r\n *\r\n * USERSET options can be set by anyone any time.\r\n */\r\ntypedef enum\r\n{\r\n\tPGC_INTERNAL,\r\n\tPGC_POSTMASTER,\r\n\tPGC_SIGHUP,\r\n\tPGC_BACKEND,\r\n\tPGC_SUSET,\r\n\tPGC_USERSET\r\n} GucContext;\r\n\r\n\r\n*生效方式*\r\nOption 1: From the command-line shell\r\nsu - postgres\r\n/usr/bin/pg_ctl reload\r\n\r\nOption 2: Using SQL\r\nSELECT pg_reload_conf();\r\nUsing either option will not interrupt any active queries or connections to the database, thus applying these changes seemlessly.\r\n\r\nSession内有效\r\nset命令\r\n\r\n查询：\r\nselect * from pg_settings;\r\nshow variableName;	<pre>\r\n/*\r\n * Certain options can only be set at certain times. The rules are\r\n * like this:\r\n *\r\n * INTERNAL options cannot be set by the user at all, but only through\r\n * internal processes ("server_version" is an example).  These are GUC\r\n * variables only so they can be shown by SHOW, etc.\r\n *\r\n * POSTMASTER options can only be set when the postmaster starts,\r\n * either from the configuration file or the command line.\r\n *\r\n * SIGHUP options can only be set at postmaster startup or by changing\r\n * the configuration file and sending the HUP signal to the postmaster\r\n * or a backend process. (Notice that the signal receipt will not be\r\n * evaluated immediately. The postmaster and the backend check it at a\r\n * certain point in their main loop. It's safer to wait than to read a\r\n * file asynchronously.)\r\n *\r\n * BACKEND options can only be set at postmaster startup, from the\r\n * configuration file, or by client request in the connection startup\r\n * packet (e.g., from libpq's PGOPTIONS variable).  Furthermore, an\r\n * already-started backend will ignore changes to such an option in the\r\n * configuration file.  The idea is that these options are fixed for a\r\n * given backend once it's started, but they can vary across backends.\r\n *\r\n * SUSET options can be set at postmaster startup, with the SIGHUP\r\n * mechanism, or from SQL if you're a superuser.\r\n *\r\n * USERSET options can be set by anyone any time.\r\n */\r\ntypedef enum\r\n{\r\n\tPGC_INTERNAL,\r\n\tPGC_POSTMASTER,\r\n\tPGC_SIGHUP,\r\n\tPGC_BACKEND,\r\n\tPGC_SUSET,\r\n\tPGC_USERSET\r\n} GucContext;\r\n</pre>\r\n\r\n\r\n*生效方式*\r\nOption 1: From the command-line shell\r\nsu - postgres\r\n/usr/bin/pg_ctl reload\r\n\r\nOption 2: Using SQL\r\nSELECT pg_reload_conf();\r\nUsing either option will not interrupt any active queries or connections to the database, thus applying these changes seemlessly.\r\n\r\nSession内有效\r\nset命令\r\n\r\n查询：\r\nselect * from pg_settings;\r\nshow variableName;
209	1202	attr	done_ratio	0	70
212	1219	attr	subject	PG log配置	PG log
213	1233	attachment	36	\N	Learn_english.jpg
214	1238	attr	description	dedicated \r\nrevisions：修改，修订\r\ncredentials：凭证，证书\r\nprompt：促使，导致，提示\r\n\r\n问题：\r\n1，etcd实现根据用户的资源隔离吗？\r\n2，etcd也有用户组？角色可以付给用户组吗？这样组内用户可以继承角色？\r\n3，用户可自定义角色吗？\r\n\r\netcd权限控制与s3的对比	dedicated \r\nrevisions：修改，修订\r\ncredentials：凭证，证书\r\nprompt：促使，导致，提示\r\n\r\n问题：\r\n1，etcd实现根据用户的资源隔离吗？\r\n  不支持，不必经过用户授权，其他用户可以看到别人修改。\r\n2，etcd也有用户组？角色可以付给用户组吗？这样组内用户可以继承角色？\r\n  没有用户组\r\n3，用户可自定义角色吗？\r\n  不支持\r\netcd权限控制与s3的对比
215	1239	attr	description	官方政策群体感染，缺乏医疗设备，提高免疫力，大家不必恐慌\r\nthe gv spokesman convey the strategy to the virus, because lack of sophistication instruction and elevate immunity.\r\nno need astonishment to this.\r\n引发游行，拉起巨幅画像游行，失望灰心弥漫，咒骂警察等公职人员\r\nthe parader pervasive the road，they has a dramatic magnificent painting of the figure。\r\nthey are dismay of the government,and have a torrent of abuse to the police. \r\nThe crowd tried to smash down the door of the police station.\r\n知识分子对此政策也非常吃惊，认为其不可理解，希望得到解释。\r\nsome conscientious intellectual has some consternation, they think the behave of gv is incomprehensible.\r\nthey dial the gv,and want they interpret the solution.\r\n\r\n警长关紧门，市长则坐在火炉旁吃着一盘葡萄。\r\npolice sergeant close the knob，the mayor near the stove eating a tray of grape.\r\nthey are conscious to set the trap to infect more people. this is the causality.\r\n	官方政策群体感染，缺乏医疗设备，提高免疫力，大家不必恐慌\r\nthe gv spokesman convey the strategy to the virus, because lack of sophistication instruction and elevate immunity.\r\nno need astonishment to this.\r\n引发游行，拉起巨幅画像游行，失望灰心弥漫，咒骂警察等公职人员\r\nthe parader pervasive the road，they has a dramatic magnificent painting of the figure。\r\nthey are dismay of the government,and have a torrent of abuse to the police. \r\nThe crowd tried to smash down the door of the police station.\r\n知识分子对此政策也非常吃惊，认为其不可理解，希望得到解释。\r\nsome conscientious intellectual also in consternation, they think the behave of gv is incomprehensible.\r\nthey dial the major to interpret the causality.\r\n\r\n警长关紧门，市长则坐在火炉旁吃着一盘葡萄。\r\npolice sergeant close the knob，the mayor near the stove eating a tray of grape.\r\nthey are conscious to set the trap to infect more people. \r\n
216	1243	attr	subject	octupus	octupus导入分区表的问题处理
217	1256	attr	tracker_id	6	8
218	1256	attr	start_date	2019-04-25	\N
221	1286	attr	done_ratio	0	100
222	1298	attr	subject	羽毛球入门-鞭打	羽毛球入门-鞭打(发力终极篇)
223	1300	attr	description	现在很多人看各种资讯，学习了各种知识，以为自己很了不起。\r\n但是在现实世界中，连开一个公司都做不到。\r\n公司是麻雀虽小，五脏俱全。这里涉及外交，消息，技术，交流，财务等各个方面。\r\n\r\n现实世界是很多人都不够强，也没有足够的行动。却有者不与自己能力不匹配的欲望。	现在很多人看各种资讯，学习了各种知识，以为自己很了不起。\r\n但是在现实世界中，连开一个公司都做不到。\r\n公司是麻雀虽小，五脏俱全。这里涉及外交，消息，技术，交流，财务等各个方面。\r\n\r\n现实世界是很多人都不够强，也没有足够的行动。却有者不与自己能力不匹配的欲望。\r\n\r\n还有一些人被现实击打之后，进行自我约束。
224	1310	attr	description	1，启动时就引拍，手与脚同步动。\r\n2，前中场引拍动作小而快。不然就只会挑球。\r\n3，越前面就越高动作越小。\r\n这有一个前提就是相信自己的手腕手指发力。	1，启动时就引拍，手与脚同步动。\r\n2，前中场引拍动作小而快。不然就只会挑球。\r\n3，越前面就越高动作越小。\r\n这有一个前提就是相信自己的手腕手指发力。\r\n\r\n步法上意识：\r\n1，启动快\r\n2，借力回动那一步要快
225	1319	attr	description	1，思考遗漏\r\n设计遗漏，实现遗漏，测试遗漏\r\n\r\n2，错误\r\n放在了错误的地方\r\n把孩子和洗澡水都倒掉了\r\n\r\n3，创意\r\n避免了上述2个陷阱之后，还有一个就是缺乏创意，即方案无竞争力，不够巧妙。	1，思考遗漏\r\n设计遗漏，实现遗漏，测试遗漏\r\n\r\n2，错误\r\n放在了错误的地方\r\n把孩子和洗澡水都倒掉了\r\n\r\n3，创意\r\n避免了上述2个陷阱之后，还有一个就是缺乏创意，即方案无竞争力，不够巧妙。\r\n\r\n思考的全面性，清晰性，创新性。
226	1336	attr	description	1，存储节点有状态与snowflake一样的存储节点无状态。\r\n这决定了存储节点的弹性扩展能力\r\n2，	1，存储节点有状态与snowflake一样的存储节点无状态。\r\n这决定了存储节点的弹性扩展能力\r\n存储节点如果仅把数据存到s3，那就相当于一个外部存储。
227	1337	attr	description	系统目标：\r\n热数据与温数据的快速分析。\r\n\r\n关键点：\r\n1，定长与变长分离存储\r\n这样可以确保定长总是inplace更新，即每列的rowid在更新时维持不变性。\r\n这点对于分离出的heap维护到定长部分的rowid也很关键。\r\n\r\n解决行式更新与列式查询的矛盾。\r\n\r\n2，in memory\r\n改变了buffer管理方式，这点影响了整个后端，包括刷脏，checkpoint机制。\r\n大块内存，device/segment方式管理内存，而不是hash查找。\r\n\r\n3，一致性问题\r\ncolumn隔离级别\r\n\r\n4，索引\r\n跨变长与定长部分的索引\r\n\r\nimcs单独刷脏页机制，等checkpoint刷可能太久。	系统目标：\r\n热数据与温数据的快速分析。\r\n\r\n关键点：\r\n1，定长与变长分离存储\r\n这样可以确保定长总是inplace更新，即每列的rowid在更新时维持不变性。\r\n这点对于分离出的heap维护到定长部分的rowid也很关键。\r\n\r\n解决行式更新与列式查询的矛盾。\r\n\r\n2，in memory\r\n改变了buffer管理方式，这点影响了整个后端，包括刷脏，checkpoint机制。\r\n大块内存，device/segment方式管理内存，而不是hash查找。\r\n\r\n3，一致性问题\r\ncolumn隔离级别\r\n\r\n4，索引\r\n跨变长与定长部分的索引\r\n\r\n5，接口层\r\n抽象am层，这样方便提供不同的表访问方式\r\n\r\nimcs单独刷脏页机制，等checkpoint刷可能太久。
228	1338	attr	description	系统目标：\r\n热数据与温数据的快速分析。\r\n\r\n关键点：\r\n1，定长与变长分离存储\r\n这样可以确保定长总是inplace更新，即每列的rowid在更新时维持不变性。\r\n这点对于分离出的heap维护到定长部分的rowid也很关键。\r\n\r\n解决行式更新与列式查询的矛盾。\r\n\r\n2，in memory\r\n改变了buffer管理方式，这点影响了整个后端，包括刷脏，checkpoint机制。\r\n大块内存，device/segment方式管理内存，而不是hash查找。\r\n\r\n3，一致性问题\r\ncolumn隔离级别\r\n\r\n4，索引\r\n跨变长与定长部分的索引\r\n\r\n5，接口层\r\n抽象am层，这样方便提供不同的表访问方式\r\n\r\nimcs单独刷脏页机制，等checkpoint刷可能太久。	系统目标：\r\n热数据与温数据的快速分析。\r\n\r\n关键点：\r\n1，定长与变长分离存储\r\n这样可以确保定长总是inplace更新，即每列的rowid在更新时维持不变性。\r\n这点对于分离出的heap维护到定长部分的rowid也很关键。\r\n\r\n解决行式更新与列式查询的矛盾。\r\n\r\n2，in memory\r\n改变了buffer管理方式，这点影响了整个后端，包括刷脏，checkpoint机制。\r\n大块内存，device/segment方式管理内存，而不是hash查找。\r\n\r\n3，一致性问题\r\ncolumn隔离级别\r\n\r\n4，索引\r\n跨变长与定长部分的索引\r\n\r\n5，接口层\r\n抽象am层，这样方便提供不同的表访问方式\r\n抽象md层，对接不同存储\r\n\r\nimcs单独刷脏页机制，等checkpoint刷可能太久。
229	1345	attr	description	系统目标：\r\n热数据与温数据的快速分析。\r\n\r\n关键点：\r\n1，定长与变长分离存储\r\n这样可以确保定长总是inplace更新，即每列的rowid在更新时维持不变性。\r\n这点对于分离出的heap维护到定长部分的rowid也很关键。\r\n\r\n解决行式更新与列式查询的矛盾。\r\n\r\n2，in memory\r\n改变了buffer管理方式，这点影响了整个后端，包括刷脏，checkpoint机制。\r\n大块内存，device/segment方式管理内存，而不是hash查找。\r\n\r\n3，一致性问题\r\ncolumn隔离级别\r\n\r\n4，索引\r\n跨变长与定长部分的索引\r\n\r\n5，接口层\r\n抽象am层，这样方便提供不同的表访问方式\r\n抽象md层，对接不同存储\r\n\r\nimcs单独刷脏页机制，等checkpoint刷可能太久。	系统目标：\r\n热数据与温数据的快速分析。\r\n\r\n关键点：\r\n1，定长与变长分离存储\r\n这样可以确保定长总是inplace更新，即每列的rowid在更新时维持不变性。\r\n这点对于分离出的heap维护到定长部分的rowid也很关键。\r\n\r\n解决行式更新与列式查询的矛盾。\r\n\r\n2，in memory\r\n引入in memory的目的是为了提高更新效率。\r\n改变了buffer管理方式，这点影响了整个后端，包括刷脏，checkpoint机制。\r\n大块内存，device/segment方式管理内存，而不是hash查找。\r\n\r\n3，一致性问题\r\ncolumn隔离级别\r\n\r\n4，索引\r\n跨变长与定长部分的索引\r\n\r\n5，接口层\r\n抽象am层，这样方便提供不同的表访问方式\r\n抽象md层，对接不同存储\r\n\r\nimcs单独刷脏页机制，等checkpoint刷可能太久。
230	1349	attr	description	1，itl不是每条记录都有，itl就是锁区。\r\n2，记录可以指向itl，这样查找老版本的效率更高\r\n\r\nPCR是page consistent read\r\nRCR是row consistent。\r\nCR是consistent read，CC是concurrent \r\n通过SCN干掉了snapshot机制，使用SCN来判断可见性。\r\n\r\n改造点：\r\n1，double write替代fullwrite\r\n2，scn替代snapshot\r\n3，redo buffer支持多part\r\n4，增量checkpoint\r\n5，CR buffer\r\n使得读写不在相同buffer上冲突\r\n6，undo，干掉vacuum\r\n7，buffer管理，预读，干掉page cache\r\n8，含事务信息的index\r\n9，闪回，not PITR	1，itl不是每条记录都有，itl就是锁区。\r\n2，记录可以指向itl，这样查找老版本的效率更高\r\n\r\nPCR是page consistent read\r\nRCR是row consistent。\r\nCR是consistent read，CC是concurrent \r\n通过SCN干掉了snapshot机制，使用SCN来判断可见性。\r\n\r\n改造点：\r\n1，double write替代fullwrite\r\n2，scn替代snapshot\r\n3，redo buffer支持多part\r\n4，增量checkpoint\r\n5，CR buffer\r\n使得读写不在相同buffer上冲突\r\n6，undo，干掉vacuum\r\n7，buffer管理，预读，干掉page cache\r\n8，含事务信息的index\r\n9，闪回，not PITR\r\n10，支持跨页的tuple migrate
234	1361	attr	subject	思辨与立场	思辨与立场(批判性思维)
236	1370	attr	description	1，分布式事务2阶段提交，如果prepare失败，在prepare abort过程没有执行undo rollback，导致数据不一致。	1，分布式事务2阶段提交，如果prepare失败，在prepare abort过程没有执行undo rollback，导致数据不一致。\r\n2, rollback动作执行的位置不对，没有放在释放锁之后，导致执行时出现锁已经获取的错误。
237	1383	attr	subject	山与海	山与海，与自己相处
231	1358	attr	description	某系统生产期间会持续产生产品相关的记录，格式如下：\r\n{\r\n\t"编号": 10,\r\n\t"型号": 100,\r\n\t"批次": 1001,\r\n\t"责任人": "张三",\r\n}\r\n其中产品编号是递增的。\r\n现要求实现一个存储子模块，记录上述产品生产信息，\r\n支持基于编号的查询，以及删除过老产品记录。\r\n\r\n考察点：\r\n1，C基础\r\n2，抽象能力，概念的运用，迭代器使用\r\n3，设计能力，接口设计，封装\r\n4，工程实现，比如日志，错误处理，停机的考虑\r\n5，并发，三种操作之间的并发\r\n6，cache运用，flush再应答\r\n7，算法，索引的运用，记录与二分查找	某系统生产期间会持续产生产品相关的记录，\r\n格式如下：\r\n{\r\n\t"编号": 10,\r\n\t"型号": 100,\r\n\t"批次": 1001,\r\n\t"责任人": "张三",\r\n}\r\n其中产品编号是递增的。\r\n现要求实现一个存储子模块，记录上述产品生产信息，\r\n支持基于编号的查询，以及删除过老产品记录。\r\n\r\n考察点：\r\n1，C基础\r\n2，抽象能力，概念的运用，迭代器使用\r\n3，设计能力，接口设计，封装\r\n4，工程实现，比如日志，错误处理，停机的考虑\r\n5，并发，三种操作之间的并发\r\n6，cache运用，flush再应答\r\n7，算法，索引的运用，记录与二分查找
232	1359	attr	description	某系统生产期间会持续产生产品相关的记录，\r\n格式如下：\r\n{\r\n\t"编号": 10,\r\n\t"型号": 100,\r\n\t"批次": 1001,\r\n\t"责任人": "张三",\r\n}\r\n其中产品编号是递增的。\r\n现要求实现一个存储子模块，记录上述产品生产信息，\r\n支持基于编号的查询，以及删除过老产品记录。\r\n\r\n考察点：\r\n1，C基础\r\n2，抽象能力，概念的运用，迭代器使用\r\n3，设计能力，接口设计，封装\r\n4，工程实现，比如日志，错误处理，停机的考虑\r\n5，并发，三种操作之间的并发\r\n6，cache运用，flush再应答\r\n7，算法，索引的运用，记录与二分查找	其中产品编号是单调增加(非严格)的。\r\n现要求实现一个存储子模块，记录上述产品生产信息，\r\n支持基于编号的查询(单个编号或编号范围)，以及删除过老产品记录以释放存储空间。\r\n(注:不明部分可使用伪代码表示)\r\n\r\n考察点：\r\n1，C基础\r\n2，抽象能力，适当的考虑变化，概念的运用，分块，迭代器\r\n3，设计能力，接口设计，封装\r\n4，工程，比如日志，错误处理，停机的考虑，测试，监控\r\n5，并发，三种操作之间的并发\r\n6，cache运用，flush再应答\r\n7，算法，索引的运用，二分查找
233	1360	attr	description	其中产品编号是单调增加(非严格)的。\r\n现要求实现一个存储子模块，记录上述产品生产信息，\r\n支持基于编号的查询(单个编号或编号范围)，以及删除过老产品记录以释放存储空间。\r\n(注:不明部分可使用伪代码表示)\r\n\r\n考察点：\r\n1，C基础\r\n2，抽象能力，适当的考虑变化，概念的运用，分块，迭代器\r\n3，设计能力，接口设计，封装\r\n4，工程，比如日志，错误处理，停机的考虑，测试，监控\r\n5，并发，三种操作之间的并发\r\n6，cache运用，flush再应答\r\n7，算法，索引的运用，二分查找	某系统生产期间会持续产生产品相关的记录，格式如下：\r\n{\r\n\t"编号": 10,\r\n\t"批次": 1001,\r\n\t"型号": 100,\r\n\t"责任人": "张三",\r\n}\r\n其中产品编号是单调增加(非严格)的。\r\n现要求实现一个存储子模块，记录上述产品生产信息，\r\n支持基于编号的查询(单个编号或编号范围)，以及删除过老产品记录以释放存储空间。\r\n(注:不明部分可使用伪代码表示)\r\n\r\n考察点：\r\n1，C基础\r\n2，抽象能力，适当的考虑变化，概念的运用，分块，迭代器\r\n3，设计能力，接口设计，封装\r\n4，工程，比如日志，错误处理，停机的考虑，测试，监控\r\n5，并发，三种操作之间的并发\r\n6，cache运用，flush再应答\r\n7，算法，索引的运用，二分查找
235	1363	attr	subject	写程序难在哪里？	程序员的核心能力
240	1392	attr	subject	论意义	论程序与意义
241	1392	attr	description	意义是人追求的一种状态，在这种状态下人会觉得幸福。\r\n所以每个人的意义并不一样。这就是生物多样性。\r\n\r\n同一性对于生物通常是灾难。	意义是人追求的一种状态，在这种状态下人会觉得幸福。\r\n所以每个人的意义并不一样。这就是生物多样性。\r\n\r\n同一性对于生物通常是灾难。\r\n\r\n人生就如程序，区别在于人赋予了自己运行程序的意义，而软件程序的意义是人赋予的。\r\n这样其本质上是人的延申与增强。\r\n\r\n人执行各种操作，各种言行都是程序，其自由意志赋予程序意义。\r\n所以没有找到意义的人本质上就跟计算机一样，是他人驱动的人生。
243	1415	attr	description	1，知识就是权力\r\n2，领导者不希望员工掌握非常多的知识\r\n3，公司要求员工产出\r\n\r\n其中2和3是一个矛盾。\r\n不懂政治，无法斗争。	1，知识就是权力\r\n2，领导者不希望员工掌握非常多的知识\r\n3，公司要求员工产出\r\n\r\n其中2和3是一个矛盾。\r\n不懂政治，无法斗争。\r\n\r\n最终模式就是华为这样的，所以国内流行996.
244	1416	attr	subject	软件从业者困境	软件从业者困境(论996)
246	1440	attr	description	系统目标：\r\n热数据与温数据的快速分析。\r\n\r\n关键点：\r\n1，定长与变长分离存储\r\n这样可以确保定长总是inplace更新，即每列的rowid在更新时维持不变性。\r\n这点对于分离出的heap维护到定长部分的rowid也很关键。\r\n\r\n解决行式更新与列式查询的矛盾。\r\n\r\n2，in memory\r\n引入in memory的目的是为了提高更新效率。\r\n改变了buffer管理方式，这点影响了整个后端，包括刷脏，checkpoint机制。\r\n大块内存，device/segment方式管理内存，而不是hash查找。\r\n\r\n3，一致性问题\r\ncolumn隔离级别\r\n\r\n4，索引\r\n跨变长与定长部分的索引\r\n\r\n5，接口层\r\n抽象am层，这样方便提供不同的表访问方式\r\n抽象md层，对接不同存储\r\n\r\nimcs单独刷脏页机制，等checkpoint刷可能太久。	系统目标：\r\n热数据与温数据的快速分析。\r\n\r\n关键点：\r\n1，定长与变长分离存储\r\n这样可以确保定长总是inplace更新，即每列的rowid在更新时维持不变性。\r\n这点对于分离出的heap维护到定长部分的rowid也很关键。\r\n\r\n解决行式更新与列式查询的矛盾。\r\n\r\n2，in memory\r\n引入in memory的目的是为了提高更新效率。\r\n改变了buffer管理方式，这点影响了整个后端，包括刷脏，checkpoint机制。\r\n大块内存，device/segment方式管理内存，而不是hash查找。\r\n\r\n3，一致性问题\r\ncolumn隔离级别\r\n\r\n4，索引\r\n跨变长与定长部分的索引\r\n\r\n5，接口层\r\n抽象am层，这样方便提供不同的表访问方式\r\n抽象md层，对接不同存储\r\n\r\nimcs单独刷脏页机制，等checkpoint刷可能太久。\r\n\r\n其实核心主要3点：\r\n1，行锁与列锁的选择\r\n2，列式存储\r\n3，批量操作
238	1383	attr	description	山是旅途，海是情欲，太阳是心，田园是言行，道路是思考。\r\n人们展现给外人的通常就是田园。但我们能模糊的看到别人的山，也能嗅到别人海的气息。\r\n\r\n山就像人的三观，它在慢慢生长，孕育着财富。充满的风景也有险峰。\r\n海就像人的情欲，它难以驯服，有时风平浪静，有时波涛汹涌。\r\n自我就是这个世界中的小孩，他偶尔来田园看看，也偶尔在山边，海边逛逛。\r\n但他不一定准备好登山，也不一定准备好出海。\r\n\r\n他偶尔还会迷路，不知道自己在哪里。他惊慌失措，恐惧不安。\r\n直到有天他搞清楚了方向和目的地。\r\n\r\n有时别人想进来看看山和海的风景，但小孩拒绝了，他自己还没领略，也没准备好约人一起登山，一起下海。\r\n\r\n	身体是地壳土壤，山是旅途，海是情欲，太阳月亮是心，田园是言行，道路是思考。\r\n人们展现给外人的通常就是田园。但我们能模糊的看到别人的山，也能嗅到别人海的气息。\r\n\r\n山就像人的三观，它在慢慢生长，孕育着财富。充满的风景也有险峰。\r\n海就像人的情欲，它难以驯服，有时风平浪静，有时波涛汹涌。\r\n自我就是这个世界中的小孩，他偶尔来田园看看，也偶尔在山边，海边逛逛。\r\n但他不一定准备好登山，也不一定准备好出海。\r\n\r\n他偶尔还会迷路，不知道自己在哪里。他惊慌失措，恐惧不安。\r\n直到有天他搞清楚了方向和目的地。\r\n\r\n有时别人想进来看看山和海的风景，但小孩拒绝了，他自己还没领略，也没准备好约人一起登山，一起下海。\r\n\r\n\r\n学会与自己相处，就是找到自我在自我世界中的路。\r\n让那个小孩成长，从迷途，困惑中走出，与山妖海兽斗争。最终得以领略风景同时也能避开危险。\r\n\r\n向外找无法让自己安定祥和，情志不安本是内部问题。\r\n
239	1389	attr	description	1，心灵自由\r\n不被压制，也不被心魔控制，自然，生动活泼\r\n2，精神自由\r\n相信有一个理性的外在世界，意识追随理性，科学。\r\n人的非理性也是理性的部分，据此处理自我与世界，他人的关系。\r\n不从精神上依恋个人或组织，君王，鬼神，也不以自我为中心。\r\n这一点也是西方科学起源的根因。即存在一个外在的中心，即理性世界。\r\n3，物质，身体自由\r\n4，交易自由\r\n交易是在公开互利原则下进行。自愿交易被允许。\r\n受迫交易是非自由交易状态。\r\n5，行动自由\r\n知行合一，能按照自由的精神来行事。\r\n即要有一致性，不矛盾。有矛盾就解决矛盾，\r\n这样对于个人才是一个不断延展的世界。	1，心灵自由\r\n不被压制，也不被心魔控制，自然，生动活泼\r\n2，精神自由\r\n相信有一个理性的外在世界，意识追随理性，科学。\r\n人的非理性也是理性的部分，据此处理自我与世界，他人的关系。即独立联系。\r\n不从精神上依恋个人或组织，君王，鬼神，也不以自我为中心。\r\n这一点也是西方科学起源的根因。即存在一个外在的中心，即理性世界。\r\n3，物质，身体自由\r\n4，交易自由\r\n交易是在公开互利原则下进行。自愿交易被允许。\r\n受迫交易是非自由交易状态。\r\n5，行动自由\r\n知行合一，能按照自由的精神来行事。\r\n即要有一致性，不矛盾。有矛盾就解决矛盾，\r\n这样对于个人才是一个不断延展的世界。
242	1412	attr	subject	软件设计方法	软件设计与实现
245	1433	attr	description	1，思考离散数学如何运用于编程\r\n2，总结现有问题，以及常用算法的解法。\r\n3，总结编程方法\r\n如何最有效率的实现一个系统，并且支持在实施过程中纠偏。\r\n及时编译和测试的重要性。局部性问题原理。独立性原理。软件的根本特性。\r\n	1，思考离散数学如何运用于编程\r\n2，总结现有问题，以及常用算法的解法。\r\n3，总结编程方法\r\n如何最有效率的实现一个系统，并且支持在实施过程中纠偏。\r\n及时编译和测试的重要性。局部性问题原理。独立性原理。软件的根本特性。\r\n3.1 如何利用现有系统借力。\r\n4，平时看什么，提高路径。\r\n5，我的奇兵在哪？以何为副业。\r\n
247	1448	attr	description	1，熵增定律，事物朝着结构无序化发展，结构复杂化让其获得了更好的特性，但失去了稳定性。\r\n2，逻辑规律，人类智慧建立的基础\r\n3，人生规律，活在当下，直面问题，人们太喜欢生活在过去，而过去只能带点经验，无法直接改变当下的状态。\r\n4，算法规律，行为与状态，就是我们当下生活的世界，执着于状态是无法成为高等生物，人体不过皮囊，算法才是人类胜出的根本。	1，熵增定律，事物朝着结构无序化发展，结构复杂化让其获得了更好的特性，但失去了稳定性。\r\n2，逻辑及因果规律，人类智慧建立的基础\r\n3，人生规律，活在当下，直面问题，人们太喜欢生活在过去，而过去只能带点经验，无法直接改变当下的状态。\r\n            练习可以改变身体，也可以改变大脑。\r\n4，算法规律，行为与状态，就是我们当下生活的世界，执着于状态是无法成为高等生物，算法与数据更重要。\r\n                       他人也是人，是算法系统的部分。
248	1449	attr	description	1，熵增定律，事物朝着结构无序化发展，结构复杂化让其获得了更好的特性，但失去了稳定性。\r\n2，逻辑及因果规律，人类智慧建立的基础\r\n3，人生规律，活在当下，直面问题，人们太喜欢生活在过去，而过去只能带点经验，无法直接改变当下的状态。\r\n            练习可以改变身体，也可以改变大脑。\r\n4，算法规律，行为与状态，就是我们当下生活的世界，执着于状态是无法成为高等生物，算法与数据更重要。\r\n                       他人也是人，是算法系统的部分。	1，熵增定律，事物朝着结构无序化发展，结构复杂化让其获得了更好的特性，但失去了稳定性。\r\n2，逻辑及因果规律，人类智慧建立的基础\r\n3，人生规律，活在当下，直面问题，人们太喜欢生活在过去的感觉，而过去只能带点经验，无法直接改变当下的状态。\r\n            练习可以改变身体，也可以改变大脑。\r\n4，算法规律，行为与状态，就是我们当下生活的世界，执着于状态是无法成为高等生物，算法与数据更重要。\r\n                       他人也是人，是算法系统的部分。\r\n4.1 批判性思维算法，改变算法本身
252	1461	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，可以自创点套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。\r\n特点：出招就是合适的，就那么自然。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，可以自创点套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。\r\n特点：快，出招就是合适的，就那么自然。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
451	2147	attr	description	1，锁，atomic与volatile\r\n2，mmap\r\n3，cacheline\r\n4，DIRECT与SYNC ioflag的作用。\r\n5，TCP\r\n6，hashtable的冲突解决方法以及应用场景\r\n7，cache算法有哪些，区别是什么\r\n8，怎么理解ACID。\r\n9，MVCC是什么概念	基础知识：CPU，内存，网络，存储\r\n1，锁，atomic与volatile\r\n2，mmap\r\n3，cacheline\r\n4，DIRECT与SYNC ioflag的作用。\r\n5，TCP\r\n6，hashtable的冲突解决方法以及应用场景\r\n7，cache算法有哪些，区别是什么\r\n8，怎么理解ACID。\r\n9，MVCC是什么概念\r\n\r\n数据结构与算法：\r\n\r\n开放问题：编码技术与架构\r\n1，常见的内存管理手段，如何做并发控制\r\n2，里氏替换原则的理解。\r\n
249	1454	attr	description	1，熵增定律，事物朝着结构无序化发展，结构复杂化让其获得了更好的特性，但失去了稳定性。\r\n2，逻辑及因果规律，人类智慧建立的基础\r\n3，人生规律，活在当下，直面问题，人们太喜欢生活在过去的感觉，而过去只能带点经验，无法直接改变当下的状态。\r\n            练习可以改变身体，也可以改变大脑。\r\n4，算法规律，行为与状态，就是我们当下生活的世界，执着于状态是无法成为高等生物，算法与数据更重要。\r\n                       他人也是人，是算法系统的部分。\r\n4.1 批判性思维算法，改变算法本身	1，熵增定律，事物朝着结构无序化发展，结构复杂化让其获得了更好的特性，但失去了稳定性。\r\n2，逻辑及因果规律，人类智慧建立的基础\r\n3，人生规律，活在当下，直面问题，人们太喜欢生活在过去的感觉，而过去只能带点经验，无法直接改变当下的状态。\r\n            练习可以改变身体，也可以改变大脑。\r\n3.1 沉默成本法则\r\n3.2 交易法则\r\n3.3 丛林法则\r\n    强者有更好的生存空间，但是强者不一定快乐。\r\n3.4 快乐法则\r\n    唯有直面问题，突破困难，获得进步，新奇与进步才能让人快乐。\r\n4，算法规律，行为与状态，就是我们当下生活的世界，执着于状态是无法成为高等生物，算法与数据更重要。\r\n                       他人也是人，是算法系统的部分。\r\n4.1 批判性思维算法，改变算法本身
250	1459	attr	description	1，熵增定律，事物朝着结构无序化发展，结构复杂化让其获得了更好的特性，但失去了稳定性。\r\n2，逻辑及因果规律，人类智慧建立的基础\r\n3，人生规律，活在当下，直面问题，人们太喜欢生活在过去的感觉，而过去只能带点经验，无法直接改变当下的状态。\r\n            练习可以改变身体，也可以改变大脑。\r\n3.1 沉默成本法则\r\n3.2 交易法则\r\n3.3 丛林法则\r\n    强者有更好的生存空间，但是强者不一定快乐。\r\n3.4 快乐法则\r\n    唯有直面问题，突破困难，获得进步，新奇与进步才能让人快乐。\r\n4，算法规律，行为与状态，就是我们当下生活的世界，执着于状态是无法成为高等生物，算法与数据更重要。\r\n                       他人也是人，是算法系统的部分。\r\n4.1 批判性思维算法，改变算法本身	1，熵增定律，事物朝着结构无序化发展，结构复杂化让其获得了更好的特性，但失去了稳定性。\r\n2，逻辑及因果规律，人类智慧建立的基础\r\n3，人生规律，活在当下，直面问题，人们太喜欢生活在过去的感觉，而过去只能带点经验，无法直接改变当下的状态。\r\n            练习可以改变身体，也可以改变大脑。\r\n3.1 沉默成本法则\r\n    沉迷于过去就无法改变未来。\r\n3.2 交易法则\r\n    与他人主要是交易，感情也算的话。\r\n3.3 丛林法则\r\n    强者有更好的生存空间，但是强者不一定快乐。\r\n3.4 快乐法则\r\n    唯有直面问题，突破困难，获得进步，新奇与进步才能让人快乐。\r\n3.5 训练原则\r\n    大脑和身体都需训练，雕刻，否则难以改变。\r\n4，算法规律，行为与状态，就是我们当下生活的世界，执着于状态是无法成为高等生物，算法与数据更重要。\r\n                       他人也是人，是算法系统的部分。\r\n4.1 批判性思维算法，改变算法本身
251	1460	attr	description	1，熵增定律，事物朝着结构无序化发展，结构复杂化让其获得了更好的特性，但失去了稳定性。\r\n2，逻辑及因果规律，人类智慧建立的基础\r\n3，人生规律，活在当下，直面问题，人们太喜欢生活在过去的感觉，而过去只能带点经验，无法直接改变当下的状态。\r\n            练习可以改变身体，也可以改变大脑。\r\n3.1 沉默成本法则\r\n    沉迷于过去就无法改变未来。\r\n3.2 交易法则\r\n    与他人主要是交易，感情也算的话。\r\n3.3 丛林法则\r\n    强者有更好的生存空间，但是强者不一定快乐。\r\n3.4 快乐法则\r\n    唯有直面问题，突破困难，获得进步，新奇与进步才能让人快乐。\r\n3.5 训练原则\r\n    大脑和身体都需训练，雕刻，否则难以改变。\r\n4，算法规律，行为与状态，就是我们当下生活的世界，执着于状态是无法成为高等生物，算法与数据更重要。\r\n                       他人也是人，是算法系统的部分。\r\n4.1 批判性思维算法，改变算法本身	1，熵增定律，事物朝着结构无序化发展，结构复杂化让其获得了更好的特性，但失去了稳定性。\r\n2，逻辑及因果规律，人类智慧建立的基础\r\n   知道为什么，才能慢慢深入事物。\r\n3，人生规律，活在当下，直面问题，人们太喜欢生活在过去的感觉，而过去只能带点经验，无法直接改变当下的状态。\r\n            练习可以改变身体，也可以改变大脑。\r\n3.1 沉默成本法则\r\n    沉迷于过去就无法改变未来。\r\n3.2 交易法则\r\n    与他人主要是交易，感情也算的话。\r\n3.3 丛林法则\r\n    强者有更好的生存空间，但是强者不一定快乐。但如果你在讨论生存空间，那就应该以丛林法则行事。\r\n    这就是公司的算法。你是领导者也会这样决策。\r\n3.4 快乐法则\r\n    唯有直面问题，突破困难，获得进步，才有快乐。这与起点没关系，与状态更新有关系。新奇与进步才能让人快乐。\r\n3.5 训练原则\r\n    大脑和身体都需训练，雕刻，否则难以改变。\r\n4，算法规律，行为与状态，就是我们当下生活的世界，执着于状态是无法成为高等生物，算法与数据更重要。\r\n                       他人也是人，是算法系统的部分。\r\n4.1 批判性思维算法，改变算法本身
253	1462	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，可以自创点套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。\r\n特点：快，出招就是合适的，就那么自然。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，可以自创点套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
255	1464	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，可以自创点套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
315	1658	attr	description	基本概念：实体，行为，关系\r\n          结构，封装，约束\r\n上述概念可以扩展延伸，形成更多的子概念体系，比如行为可以并发，可以重入，可以组合。\r\n关系可以有强弱，有依存，有共生，有特定范式下的关系。\t  \r\n拓展概念：状态(可变性)，共享实体，并发行为。\r\n系统的出现都是解决问题，适应环境而存在。因具备了某些特性而得以存在。\r\n\r\n语言是一个符号系统，用于描述概念的。所以真敢号称语言无所谓的人，得真实的理解编程。\r\n就像剑客说剑无所谓，那前提是剑术达到出神入化的境界。\r\n\t\t  \r\n不安全：未定义的系统行为\r\n类型系统：本质上是约束\r\n    动态类型，静态类型，强类型，弱类型。上述类型可换为约束。\r\n封装：可见性本质上就是依赖关系\r\n引用或指针：表达的是共享	基本概念：实体，行为，关系\r\n          结构，封装，约束\r\n上述概念可以扩展延伸，形成更多的子概念体系，比如行为可以并发，可以重入，可以组合。\r\n关系可以有强弱，有依存，有共生，有特定范式下的关系。\t  \r\n拓展概念：状态(可变性)，共享实体，并发行为。\r\n系统的出现都是解决问题，适应环境而存在。因具备了某些特性而得以存在。\r\n\r\n语言是一个符号系统，用于描述概念的。所以真敢号称语言无所谓的人，得真实的理解编程。\r\n就像剑客说剑无所谓，那前提是剑术达到出神入化的境界。\r\n\t\t  \r\n不安全：未定义的系统行为\r\n类型系统：本质上是约束\r\n    动态类型，静态类型，强类型，弱类型。上述类型可换为约束。\r\n封装：可见性本质上就是依赖关系\r\n引用或指针：表达的是共享，有些场景必须使用共享，比如计数。clone得到的是另一个实体，无法完成计数能力。\r\n            共享还有一个目的是为了性能。为了读拷贝一个实体代价很大。
254	1463	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，可以自创点套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，可以自创点套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
256	1465	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
260	1469	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。而且作为职业他们压力很大，因为对于老板他们创造价值太小。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的秘密。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。而且作为职业他们压力很大，直接面临失业风险，因为对于老板他们创造价值太小。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的秘密。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
261	1470	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。而且作为职业他们压力很大，直接面临失业风险，因为对于老板他们创造价值太小。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的秘密。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n      而且作为职业他们压力很大，直接面临失业风险，或尝试更换职业，得不到很好的尊重，对于老板他们创造价值太小。\r\n      但反过来看这些都是促进他进步的因素，直面问题解决问题得到提高，否则继续面对压力。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n      以此为职业可以独立从容生活了。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的秘密。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
382	1886	attr	subject	编程如临深渊，如履薄冰，怎么破-靠计算和迭代	编程如临深渊，如履薄冰，怎么破
257	1466	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千万倍。这就是财富差异的秘密。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
258	1467	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千万倍。这就是财富差异的秘密。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的秘密。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
259	1468	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的秘密。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。而且作为职业他们压力很大，因为对于老板他们创造价值太小。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的秘密。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
262	1471	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n      而且作为职业他们压力很大，直接面临失业风险，或尝试更换职业，得不到很好的尊重，对于老板他们创造价值太小。\r\n      但反过来看这些都是促进他进步的因素，直面问题解决问题得到提高，否则继续面对压力。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n      以此为职业可以独立从容生活了。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的秘密。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n      而且作为职业他们压力很大，直接面临失业风险，或尝试更换职业，得不到很好的尊重，对于老板他们创造价值太小。\r\n      但反过来看这些都是促进他进步的因素，直面问题解决问题得到提高，否则继续面对压力。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n      以此为职业可以独立从容生活了。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的来源。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
266	1476	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n      而且作为职业他们压力很大，直接面临失业风险，或尝试更换职业，得不到很好的尊重，对于老板他们创造价值太小。\r\n      但反过来看这些都是促进他进步的因素，直面问题解决问题得到提高，否则继续面对压力。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考。\r\n或名：衣带渐宽终不悔，为伊消得人憔悴。\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n或名：独上高楼，望尽天涯路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n      以此为职业可以独立从容生活了。继续提升是出于个人追求。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n或民：默然回首，那人却在灯火阑珊处。\r\n特点：快，出招就是合适的，就那么自然。他们窥探了造物主的奥秘。因而明了事物为何需如此的缘来。\r\n      他们是最顶级的架构师，能设计出经历时间考验的系统。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的来源。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n      而且作为职业他们压力很大，直接面临失业风险，或尝试更换职业，得不到很好的尊重，对于老板他们创造价值太小。\r\n      但反过来看这些都是促进他进步的因素，直面问题解决问题得到提高，否则继续面对压力。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考。\r\n或名：衣带渐宽终不悔，为伊消得人憔悴。\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n或名：独上高楼，望尽天涯路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n      以此为职业可以独立从容生活了。继续提升是出于个人追求。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n或民：默然回首，那人却在灯火阑珊处。\r\n特点：快，出招就是合适的，就那么自然。他们窥探了造物主的奥秘，掌握了物理事物原理或数学规律。因而明了事物为何需如此的缘来。\r\n      他们是最顶级的架构师，能设计出经历时间考验的系统。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的来源。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
267	1477	attr	subject	程序员的核心能力	程序员&架构师的核心能力
268	1482	attr	description	c is common or coral。\r\n1，支持异步\r\n2，调研s3和hdfs接口，本地文件接口\r\n3，中间状态	c is common or coral。\r\n1，支持异步\r\n2，调研s3和hdfs接口，本地文件接口\r\n3，中间状态\r\n4，对于元数据的支持
383	1893	attr	subject	SSDR12 软件数据结构的学问	SSDR12 软件数据结构的学问(软件复杂度)
263	1472	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n      而且作为职业他们压力很大，直接面临失业风险，或尝试更换职业，得不到很好的尊重，对于老板他们创造价值太小。\r\n      但反过来看这些都是促进他进步的因素，直面问题解决问题得到提高，否则继续面对压力。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n      以此为职业可以独立从容生活了。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的来源。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n      而且作为职业他们压力很大，直接面临失业风险，或尝试更换职业，得不到很好的尊重，对于老板他们创造价值太小。\r\n      但反过来看这些都是促进他进步的因素，直面问题解决问题得到提高，否则继续面对压力。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n      以此为职业可以独立从容生活了。继续提升是出于个人追求。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的来源。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
264	1473	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n      而且作为职业他们压力很大，直接面临失业风险，或尝试更换职业，得不到很好的尊重，对于老板他们创造价值太小。\r\n      但反过来看这些都是促进他进步的因素，直面问题解决问题得到提高，否则继续面对压力。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n      以此为职业可以独立从容生活了。继续提升是出于个人追求。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的来源。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n      而且作为职业他们压力很大，直接面临失业风险，或尝试更换职业，得不到很好的尊重，对于老板他们创造价值太小。\r\n      但反过来看这些都是促进他进步的因素，直面问题解决问题得到提高，否则继续面对压力。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考。\r\n或名：衣带渐宽终不悔，为伊消得人憔悴。\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n或名：独上高楼，望尽天涯路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n      以此为职业可以独立从容生活了。继续提升是出于个人追求。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n或民：默然回首，那人却在灯火阑珊处。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的来源。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
265	1475	attr	description	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n      而且作为职业他们压力很大，直接面临失业风险，或尝试更换职业，得不到很好的尊重，对于老板他们创造价值太小。\r\n      但反过来看这些都是促进他进步的因素，直面问题解决问题得到提高，否则继续面对压力。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考。\r\n或名：衣带渐宽终不悔，为伊消得人憔悴。\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n或名：独上高楼，望尽天涯路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n      以此为职业可以独立从容生活了。继续提升是出于个人追求。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n或民：默然回首，那人却在灯火阑珊处。\r\n特点：快，出招就是合适的，就那么自然。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的来源。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n	1，工具人，拷贝人\r\n应随模仿阶段\r\n特点：慢，能解决一些问题，但可能引入更致命问题。\r\n应对：避免他们出错，一个办法就是给他们规矩，模板。\r\n人群：一般1-3年内新手处于这个阶段。如果不思考也可能长期在这个阶段。是纯业余玩家，这时候还谈不上爱好。\r\n      仅仅是谋生手段或者玩下而已的状态，几乎不会在业余时间自觉思考。\r\n      而且作为职业他们压力很大，直接面临失业风险，或尝试更换职业，得不到很好的尊重，对于老板他们创造价值太小。\r\n      但反过来看这些都是促进他进步的因素，直面问题解决问题得到提高，否则继续面对压力。\r\n\r\n2，技术人\r\n应变阶段，根据问题进行推导思考。\r\n或名：衣带渐宽终不悔，为伊消得人憔悴。\r\n特点：有点慢，能解决问题同时不至于引发大问题。\r\n应对：这阶段的人需要人指点，否则容易遗漏，进入胡同，做事很慢。\r\n人群：在阶段1的人看来这类就是业余高手了，在这个阶段有些积累之后就开始有点爱好了。开始会花业余时间研究琢磨。\r\n      还可以指导下新手的问题。这类人职场压力也大，需要花时间来弥补慢的问题，非常辛苦。\r\n\r\n3，专家\r\n套路招式阶段，掌握了一些规律，开始有套路了，对技术涉及的各方面都有一些心得，可以自创套路。\r\n或名：独上高楼，望尽天涯路。\r\n特点：快，能解决问题。但是有时候解决的不很好，不优雅。\r\n人群：到这阶段，就有点专业了，开始投入大量精力练习研究，找人探讨...（待续）\r\n      以此为职业可以独立从容生活了。继续提升是出于个人追求。\r\n\r\n4，大神\r\n无招阶段，已经掌握了太多规律，了解很多事务的本质。应对全新事物也很从容。\r\n或民：默然回首，那人却在灯火阑珊处。\r\n特点：快，出招就是合适的，就那么自然。他们窥探了造物主的奥秘。因而明了事物为何需如此的缘来。\r\n      他们是最顶级的架构师，能设计出经历时间考验的系统。\r\n人群：这类人基本不出现在一般技术沙龙，会议中了，也不参与一般的赛事了。\r\n      他们只在华山之巅，在最有含量的舞台上亮相了。\r\n\r\n阶段可以跳跃吗？\r\n我觉得不能，看不见树的人，自然看不见森林，更无法看到整个山。\r\n这是一个量变过程。是需要进行大脑训练的。\r\n\r\n80%的人处在1，2阶段，可能创造了领域30%价值。\r\n而20%的3，4阶段的人，可能一起创造了70%价值。\r\n顶尖1%的4阶段人，可能创造了30%价值。\r\n所以最大差距，在阶段4的人可能比阶段1的人创造价值高出千，万倍。这就是财富差异的来源。\r\n\r\n自评：\r\n1，编程和羽毛球水平我目前应该都在第二段位的中后段。都需要大量练习提升。\r\n\r\n
270	1491	attr	description	在《程序原本》中我提到程序员的4种能力：\r\n1，逻辑推理\r\n2，算法\r\n3，数据结构\r\n4，沟通\r\n\r\n现在我要加上2种能力：\r\n1，执行力\r\n2，领导力\r\n\r\n关于执行力：\r\n1，在工作中我们经常求快的心理不会去弄清楚事情的本来面目，分析清楚各个细节就开始行动了。\r\n2，还有一点就是沟通上，有些地方需要与其他模块沟通的，也未进行充分沟通就开始行动。\r\n3，执行力还需要全局的视野。\r\n真正合格的模块开发者首先必须是对模块最了解的人，而不是架构师一问三不知。\r\n模块开发者应该主动去了解本模块涉及的所有细节，与其他模块存在的各种交互，就像打球一样，不停琢磨动作该怎么做，\r\n还有那些地方可以完善，想到有颜色，想到兴奋睡不着。。。\r\n\r\n所以编程执行力要求我们有条不紊的做好每个细节，将未展开的地方展开，将该做到位的动作做到位。\r\n“开发软件的难点在于弄清楚它应该做什么，而不是如何让它工作。有一个关于 10x 程序员的神话，\r\n但它并不是指程序员在实现问题时有多英勇，而是指他们重述问题的能力。”\r\n\r\n执行力还有一个方面是不断推进的能力，有时候我们未展开时，以为自己在高歌猛进，实际上我们由于没细分而踌躇不前。\r\n执行力就是关于如何把大的事情完成的方法论。\r\n\r\n关于领导力：\r\n领导力是指在做一件事情时能够引领自己和别人。\r\n领导力要求一个人具备开拓精神，创新精神，独立自由精神(选择与担当)，以及博爱精神。\r\n这样才能做出具有领导力的软件。	在《程序原本》中我提到程序员的4种能力：\r\n1，逻辑推理\r\n2，算法\r\n3，数据结构\r\n4，沟通\r\n\r\n现在我要加上2种能力：\r\n1，执行力\r\n2，领导力\r\n\r\n关于执行力：\r\n1，在工作中我们经常求快的心理不会去弄清楚事情的本来面目，分析清楚各个细节就开始行动了。\r\n2，还有一点就是沟通上，有些地方需要与其他模块沟通的，也未进行充分沟通就开始行动。\r\n3，执行力还需要全局的视野。\r\n真正合格的模块开发者首先必须是对模块最了解的人，而不是架构师一问三不知。\r\n模块开发者应该主动去了解本模块涉及的所有细节，与其他模块存在的各种交互，就像打球一样，不停琢磨动作该怎么做，\r\n还有那些地方可以完善，想到有颜色，想到兴奋睡不着。。。\r\n\r\n所以编程执行力要求我们有条不紊的做好每个细节，将未展开的地方展开，将该做到位的动作做到位。\r\n“开发软件的难点在于弄清楚它应该做什么，而不是如何让它工作。有一个关于 10x 程序员的神话，\r\n但它并不是指程序员在实现问题时有多英勇，而是指他们重述问题的能力。”\r\n\r\n执行力还有一个方面是不断推进的能力，有时候我们未展开时，以为自己在高歌猛进，实际上我们由于没细分而踌躇不前。\r\n执行力就是关于如何把大的事情完成的方法论。\r\n\r\n执行力要克服迷恋，要求我们活在当下，"过往不恋，未来不迎，当下不负"。\r\n执行力还要克服内心的恐惧，过往生活带给我们的深藏于身体的伤，让我们内心充满了恐惧。对于他人的恐惧，对于可能面临指责的恐惧，\r\n对于可能失败的恐惧，对于未知的恐惧。恐惧让我们甚至不能完成一些本身能够去做的事，去积累能力，知行脱节，也让我们无法改变以得到自己想要的状态。\r\n梦想成了遥不可及的梦。执行力就是当我们决定了执行这个计划(算法)，就要客观求实的解决问题，我们自身的改变也是计划的一部分，计划本身的达成才是最重要的。\r\n最终事情磨炼升华了我们，总有一天俗世不再是我们的囚笼，看见真实不易但也充满可能性的美丽世界。\r\n\r\n关于领导力：\r\n领导力是指在做一件事情时能够引领自己和别人。\r\n领导力要求一个人具备开拓精神，创新精神，独立自由精神(选择与担当)，以及博爱精神。\r\n这样才能做出具有领导力的软件。
274	1504	attr	description	1，并发update问题分析，4小时。 \r\n成果：发现undo的回收并非是按使用顺序，即后面的undo block可能先回收，这样需检查undo版本，并且在跨块时需要机制发现需要的undo被回收的情况。\r\n\r\n2，单表并行与多表在相同总数据量下性能低的原因分析。 2小时\r\n成果：无，运行时间很短，不适合perf分析。\r\n猜想：spinlock影响，考虑将其屏蔽看看。\r\n\r\n3，volador讨论。 1小时\r\n成果：加速作为一种产品形态，是特定模式的优化。 coral和swordfish提供通用的数据存储和使用能力。	1，并发update问题分析，4小时。 \r\n成果：发现undo的回收并非是按使用顺序，即后面的undo block可能先回收，这样需检查undo版本，并且在跨块时需要机制发现需要的undo被回收的情况。\r\n\r\n2，单表并行与多表在相同总数据量下性能低的原因分析。 2小时\r\n成果：无，运行时间很短，不适合perf分析。\r\n猜想：spinlock影响，考虑将其屏蔽看看。\r\n\r\n3，volador讨论。 1小时\r\n成果：加速作为一种产品形态，是特定模式的优化。 coral和swordfish提供通用的数据存储和使用能力。\r\n\r\n4，coral架构思考，1小时\r\n成果：明确采用新架构，并提出了几个待解决问题。
275	1506	attr	description	1，分析并发挂掉问题\r\n2，修复bug\r\n3，review代码\r\n4，继续分析性能问题。	1，分析并发挂掉问题。 2小时\r\n2，修复bug， 2小时\r\n3，review代码， 2小时\r\n4，继续分析性能问题。2小时
278	1521	attr	subject	2021.1.14	2021.1.12
269	1489	attr	description	在《程序原本》中我提到程序员的4种能力：\r\n1，逻辑推理\r\n2，算法\r\n3，数据结构\r\n4，沟通\r\n\r\n现在我要加上2种能力：\r\n1，执行力\r\n2，领导力\r\n\r\n关于执行力：\r\n1，在工作中我们经常求快的心理不会去弄清楚事情的本来面目，分析清楚各个细节就开始行动了。\r\n2，还有一点就是沟通上，有些地方需要与其他模块沟通的，也未进行充分沟通就开始行动。\r\n真正合格的模块开发者首先必须是对模块最了解的人，而不是架构师一问三不知。\r\n模块开发者应该主动去了解本模块涉及的所有细节，与其他模块存在的各种交互，就像打球一样，不停琢磨动作该怎么做，\r\n还有那些地方可以完善，想到有颜色，想到兴奋睡不着。。。\r\n\r\n所以编程执行力要求我们有条不紊的做好每个细节，将未展开的地方展开，将该做到位的动作做到位。\r\n“开发软件的难点在于弄清楚它应该做什么，而不是如何让它工作。有一个关于 10x 程序员的神话，\r\n但它并不是指程序员在实现问题时有多英勇，而是指他们重述问题的能力。”\r\n\r\n执行力还有一个方面是不断推进的能力，有时候我们未展开时，以为自己在高歌猛进，实际上我们由于没细分而踌躇不前。\r\n执行力就是关于如何把大的事情完成的方法论。\r\n\r\n关于领导力：\r\n领导力是指在做一件事情时能够引领自己和别人。\r\n领导力要求一个人具备开拓精神，创新精神，独立自由精神(选择与担当)，以及博爱精神。\r\n这样才能做出具有领导力的软件。	在《程序原本》中我提到程序员的4种能力：\r\n1，逻辑推理\r\n2，算法\r\n3，数据结构\r\n4，沟通\r\n\r\n现在我要加上2种能力：\r\n1，执行力\r\n2，领导力\r\n\r\n关于执行力：\r\n1，在工作中我们经常求快的心理不会去弄清楚事情的本来面目，分析清楚各个细节就开始行动了。\r\n2，还有一点就是沟通上，有些地方需要与其他模块沟通的，也未进行充分沟通就开始行动。\r\n3，执行力还需要全局的视野。\r\n真正合格的模块开发者首先必须是对模块最了解的人，而不是架构师一问三不知。\r\n模块开发者应该主动去了解本模块涉及的所有细节，与其他模块存在的各种交互，就像打球一样，不停琢磨动作该怎么做，\r\n还有那些地方可以完善，想到有颜色，想到兴奋睡不着。。。\r\n\r\n所以编程执行力要求我们有条不紊的做好每个细节，将未展开的地方展开，将该做到位的动作做到位。\r\n“开发软件的难点在于弄清楚它应该做什么，而不是如何让它工作。有一个关于 10x 程序员的神话，\r\n但它并不是指程序员在实现问题时有多英勇，而是指他们重述问题的能力。”\r\n\r\n执行力还有一个方面是不断推进的能力，有时候我们未展开时，以为自己在高歌猛进，实际上我们由于没细分而踌躇不前。\r\n执行力就是关于如何把大的事情完成的方法论。\r\n\r\n关于领导力：\r\n领导力是指在做一件事情时能够引领自己和别人。\r\n领导力要求一个人具备开拓精神，创新精神，独立自由精神(选择与担当)，以及博爱精神。\r\n这样才能做出具有领导力的软件。
271	1492	attr	description	在《程序原本》中我提到程序员的4种能力：\r\n1，逻辑推理\r\n2，算法\r\n3，数据结构\r\n4，沟通\r\n\r\n现在我要加上2种能力：\r\n1，执行力\r\n2，领导力\r\n\r\n关于执行力：\r\n1，在工作中我们经常求快的心理不会去弄清楚事情的本来面目，分析清楚各个细节就开始行动了。\r\n2，还有一点就是沟通上，有些地方需要与其他模块沟通的，也未进行充分沟通就开始行动。\r\n3，执行力还需要全局的视野。\r\n真正合格的模块开发者首先必须是对模块最了解的人，而不是架构师一问三不知。\r\n模块开发者应该主动去了解本模块涉及的所有细节，与其他模块存在的各种交互，就像打球一样，不停琢磨动作该怎么做，\r\n还有那些地方可以完善，想到有颜色，想到兴奋睡不着。。。\r\n\r\n所以编程执行力要求我们有条不紊的做好每个细节，将未展开的地方展开，将该做到位的动作做到位。\r\n“开发软件的难点在于弄清楚它应该做什么，而不是如何让它工作。有一个关于 10x 程序员的神话，\r\n但它并不是指程序员在实现问题时有多英勇，而是指他们重述问题的能力。”\r\n\r\n执行力还有一个方面是不断推进的能力，有时候我们未展开时，以为自己在高歌猛进，实际上我们由于没细分而踌躇不前。\r\n执行力就是关于如何把大的事情完成的方法论。\r\n\r\n执行力要克服迷恋，要求我们活在当下，"过往不恋，未来不迎，当下不负"。\r\n执行力还要克服内心的恐惧，过往生活带给我们的深藏于身体的伤，让我们内心充满了恐惧。对于他人的恐惧，对于可能面临指责的恐惧，\r\n对于可能失败的恐惧，对于未知的恐惧。恐惧让我们甚至不能完成一些本身能够去做的事，去积累能力，知行脱节，也让我们无法改变以得到自己想要的状态。\r\n梦想成了遥不可及的梦。执行力就是当我们决定了执行这个计划(算法)，就要客观求实的解决问题，我们自身的改变也是计划的一部分，计划本身的达成才是最重要的。\r\n最终事情磨炼升华了我们，总有一天俗世不再是我们的囚笼，看见真实不易但也充满可能性的美丽世界。\r\n\r\n关于领导力：\r\n领导力是指在做一件事情时能够引领自己和别人。\r\n领导力要求一个人具备开拓精神，创新精神，独立自由精神(选择与担当)，以及博爱精神。\r\n这样才能做出具有领导力的软件。	在《程序原本》中我提到程序员的4种能力：\r\n1，逻辑推理\r\n2，算法\r\n3，数据结构\r\n4，沟通\r\n\r\n现在我要加上2种能力：\r\n1，执行力\r\n2，领导力\r\n\r\n关于执行力：\r\n1，在工作中我们经常求快的心理不会去弄清楚事情的本来面目，分析清楚各个细节就开始行动了。\r\n2，还有一点就是沟通上，有些地方需要与其他模块沟通的，也未进行充分沟通就开始行动。\r\n3，执行力还需要全局的视野。\r\n真正合格的模块开发者首先必须是对模块最了解的人，而不是架构师一问三不知。\r\n模块开发者应该主动去了解本模块涉及的所有细节，与其他模块存在的各种交互，就像打球一样，不停琢磨动作该怎么做，\r\n还有那些地方可以完善，想到有颜色，想到兴奋睡不着。。。\r\n\r\n所以编程执行力要求我们有条不紊的做好每个细节，将未展开的地方展开，将该做到位的动作做到位。\r\n“开发软件的难点在于弄清楚它应该做什么，而不是如何让它工作。有一个关于 10x 程序员的神话，\r\n但它并不是指程序员在实现问题时有多英勇，而是指他们重述问题的能力。”\r\n\r\n执行力还有一个方面是不断推进的能力，有时候我们未展开时，以为自己在高歌猛进，实际上我们由于没细分而踌躇不前。\r\n执行力就是关于如何把大的事情完成的方法论。\r\n\r\n执行力要克服迷恋，要求我们活在当下，"过往不恋，未来不迎，当下不负"。\r\n执行力还要克服内心的恐惧，过往生活带给我们的深藏于身体的伤，让我们内心充满了恐惧。对于他人的恐惧，对于可能面临指责的恐惧，\r\n对于可能失败的恐惧，对于未知的恐惧。恐惧让我们甚至不能完成一些本身能够去做的事，去积累能力，知行脱节，也让我们无法改变以得到自己想要的状态。\r\n逃避以及其痛苦的记忆化作隐形的伤埋入我们的身体，梦想成了遥不可及的梦。\r\n执行力就是当我们决定了执行这个计划(算法)，就要客观求实的解决问题，我们自身的改变也是计划的一部分，计划本身的达成是第一位的。\r\n最终事情磨炼升华了我们，终有一天俗世不再是我们的囚笼。\r\n\r\n关于领导力：\r\n领导力是指在做一件事情时能够引领自己和别人。\r\n领导力要求一个人具备开拓精神，创新精神，独立自由精神(选择与担当)，以及博爱精神。\r\n这样才能做出具有领导力的软件。
272	1496	attr	description	人的能量值来源于2个方面，一是能力，二是认知与行动。\r\n认知和行动本身也会积累能力。\r\n即人的能量来自于不断的认知与行动。\r\n\r\n按人的能量值人可以分为4类：\r\n1，寄生者 （无问题，陷于局部状态）\r\n2，逃避者 （因逃避问题，而忙于解决问题）\r\n3，行动体验者 （执行行动，算法），生存得以改善\r\n4，探索者 （思考追求行为与算法），生命得以升华\r\n	人的能量值来源于2个方面，一是能力，二是认知与行动。\r\n认知和行动本身也会积累能力。\r\n即人的能量来自于不断的认知与行动。\r\n\r\n按人的能量值人可以分为4类：\r\n1，寄生者 （无问题，陷于局部状态）\r\n2，逃避者 （因逃避问题，而忙于解决问题）\r\n3，行动体验者 （执行行动，算法），生存得以改善\r\n4，探索者 （思考追求行为与算法），生命得以升华，追求某个领域的最高境界，超神的美妙，恢复殿堂的荣光。\r\n
273	1503	attr	description	如果说人的第一重境界是直面问题。\r\n第二重境界就是不着相。不着相的情况下人应该追求什么？应该去干什么？\r\n兴趣仅仅是一方面，不着相的人必须有坚定而宏伟的目标，才能持之以恒。\r\n\r\n本来无一物 何处若尘埃 比 时时勤拂拭，勿使若尘埃境界不一样，前者不着相。	如果说人的第一重境界是直面问题。\r\n第二重境界就是不着相。不着相的情况下人应该追求什么？应该去干什么？\r\n兴趣仅仅是一方面，不着相的人必须有坚定而宏伟的目标，才能持之以恒。\r\n不着相容易进入虚无境界，即无意义无作为。就像说空并非没有，空是变化。\r\n\r\n本来无一物 何处若尘埃 比 时时勤拂拭，勿使若尘埃境界不一样，前者不着相。
276	1509	attr	description	可以参加社区比赛。混双或男双\r\n\r\n差距：\r\n1，发力基本功到位\r\n2，步伐基本功到位\r\n3，小球技术\r\n4，观察对手，发现并攻击漏洞的作战能力。\r\n5，战术调整能力	可以参加社区或公司级比赛。混双或男双\r\n\r\n差距：\r\n1，发力基本功到位\r\n2，步伐基本功到位\r\n3，小球技术\r\n4，观察对手，发现并攻击漏洞的作战能力。\r\n5，战术调整能力
277	1512	attr	description	1，解决内存越界问题\r\n2，review代码\r\n3，整理后续要做的事情	1，解决内存越界问题 2小时\r\n2，review代码  2小时\r\n3，整理后续要做的事情 1小时
279	1522	attr	description	1，继续review ucvhar的代码 2小时\r\n2，合入性能优化代码  2小时\r\n\r\nTableDict是否违反依赖关系\r\n\r\n学习anchorBase代码：\r\n3，将anchorBase代码分责任田进行深圳这边的讲解。\r\n	1，继续review ucvhar的代码 2小时\r\n2，合入性能优化代码  2小时\r\n\r\nTableDict是否违反依赖关系？\r\n\r\n学习anchorBase代码：\r\n3，将anchorBase代码分责任田进行深圳这边的讲解。\r\n
280	1528	attr	description	佛家空性可渡自己，或渡自己的门徒，渡不了以家庭为单位的社会，是小路。\r\n道家无为，容易进入避世，且当下人不具备避世能力，环境也缺乏支持，是岔路。\r\n儒家修身学习，构建家庭组织秩序，不断更新维持，建功立业，儒家是大路。\r\n\r\n但是大路也难走，其竞争激烈，内卷严重。因为生存压力或膨胀的欲望，人们已疲惫不堪，\r\n更何谈自强不息。但这样就陷入不良循环，没精力提升，不提升就继续面对非常多的竞争。\r\n不花功夫立志做点事就脱离不了这环境。\r\n\r\n\r\n孔子将人分类：\r\n1，庸人\r\n内心没有信念，做事随意，说话没有底线，随波逐流，迷恋于声色犬马。\r\n孔子对庸人的定义，就是为人处世，不能善始善终，不能掌控自己的人生命运。\r\n\r\n2，士人\r\n有原则，有信念。孔子说的，就是当时普通的读书人，学问未必深，\r\n但有自己的观点和主张；事业未必成功，但做事有条理。\r\n\r\n3，君子\r\n孔子评价君子，跟功业无关，看品性，君子但问耕耘，无论收获，知命敬业，排除妄念，\r\n实事求是，得之我幸，失之我命，不纠结。小人不是个小，而是面对现实，患得患失！\r\n君子固穷，说明君子要立志，自强不息，坚韧不拔。\r\n\r\n4，贤人\r\n有经世济用之才，同时能够身体力行，为社会人群建功立业！贤人的品行无可置疑，\r\n贤人的功业是可见，经得住时间考验的！\r\n\r\n5，圣人\r\n圣人的标准是思想可以影响一个国家甚至整个世界的大善之人。想成为圣人，先得成为文化之集大成者，\r\n在文化层面立得住，然后砥砺前行，教化世人，形成影响千年的文化流派。	佛家空性可渡自己，或渡自己的门徒，渡不了以家庭为单位的社会，是小路。\r\n道家无为，容易进入避世，且当下人不具备避世能力，环境也缺乏支持，是岔路。\r\n儒家修身学习，构建家庭组织秩序，不断更新维持，建功立业，儒家是大路。\r\n\r\n但是大路也难走，其竞争激烈，内卷严重。因为生存压力或膨胀的欲望，人们已疲惫不堪，\r\n更何谈自强不息。但这样就陷入不良循环，没精力提升，不提升就继续面对非常多的竞争。\r\n不花功夫立志做点事就脱离不了这环境。也没能力脱离。\r\n\r\n\r\n孔子将人分类：\r\n1，庸人\r\n内心没有信念，做事随意，说话没有底线，随波逐流，迷恋于声色犬马。\r\n孔子对庸人的定义，就是为人处世，不能善始善终，不能掌控自己的人生命运。\r\n\r\n2，士人\r\n有原则，有信念。孔子说的，就是当时普通的读书人，学问未必深，\r\n但有自己的观点和主张；事业未必成功，但做事有条理。\r\n\r\n3，君子\r\n孔子评价君子，跟功业无关，看品性，君子但问耕耘，无论收获，知命敬业，排除妄念，\r\n实事求是，得之我幸，失之我命，不纠结。小人不是个小，而是面对现实，患得患失！\r\n君子固穷，说明君子要立志，自强不息，坚韧不拔。\r\n\r\n4，贤人\r\n有经世济用之才，同时能够身体力行，为社会人群建功立业！贤人的品行无可置疑，\r\n贤人的功业是可见，经得住时间考验的！\r\n\r\n5，圣人\r\n圣人的标准是思想可以影响一个国家甚至整个世界的大善之人。想成为圣人，先得成为文化之集大成者，\r\n在文化层面立得住，然后砥砺前行，教化世人，形成影响千年的文化流派。
281	1529	attr	subject	立志	谈立志
282	1533	attr	done_ratio	30	100
283	1534	attr	status_id	19	24
284	1534	attr	assigned_to_id	\N	5
285	1535	attr	status_id	4	12
286	1535	attr	done_ratio	0	100
287	1538	attr	done_ratio	0	40
288	1541	attr	done_ratio	40	100
289	1542	attr	status_id	4	12
290	1557	attr	subject	谈宽容与感恩	谈宽容与感恩，君子与小人
291	1560	attr	done_ratio	0	40
292	1561	attr	subject	2021.0.21	2021.1.21
293	1562	attr	description	继续coral设计	继续coral设计分几大部分：\r\n1，本地元数据设计与子模块划分\r\n2，coral文件格式设计\r\n3，objectstore设计\r\n4，元数据同步设计\r\n5，本地存储设计\r\n6，通用接口设计
294	1577	attr	done_ratio	0	80
295	1583	attr	project_id	9	5
296	1585	attr	description	按人从18岁开始工作，每年收入10万，工作50年即500百万，可以独立生活。\r\n这里不计算养育小孩，以及赡养老人，假设是等价的。\r\n\r\n即正常生活的人价值500万。以此为标准，价值一个亿，则需要提升20倍。\r\n就是说年收入要到200百万。而且考虑到有些工作没法持续，实际上要求更高。\r\n\r\n这里谈价值而不谈钱，因为实际钱能多少不好说，但人的价值是可以模糊衡量的。	按人从18岁开始工作，每年收入10万，工作50年即500百万，可以独立生活。\r\n这里不计算养育小孩，以及赡养老人，假设是等价的。\r\n\r\n即正常生活的人价值500万。以此为标准，价值一个亿，则需要提升20倍。\r\n就是说年收入要到200百万。而且考虑到有些工作没法持续，实际上要求更高。\r\n\r\n这里谈价值而不谈钱，因为实际钱能多少不好说，但人的价值是可以模糊衡量的。\r\n\r\n比一般人强20倍难不难？有点难，但是并非不可实现。只要坚定的不断提升自己，10年足以。
297	1586	attr	description	按人从18岁开始工作，每年收入10万，工作50年即500百万，可以独立生活。\r\n这里不计算养育小孩，以及赡养老人，假设是等价的。\r\n\r\n即正常生活的人价值500万。以此为标准，价值一个亿，则需要提升20倍。\r\n就是说年收入要到200百万。而且考虑到有些工作没法持续，实际上要求更高。\r\n\r\n这里谈价值而不谈钱，因为实际钱能多少不好说，但人的价值是可以模糊衡量的。\r\n\r\n比一般人强20倍难不难？有点难，但是并非不可实现。只要坚定的不断提升自己，10年足以。	按人从18岁开始工作，每年收入10万，工作50年即500百万，可以独立生活。\r\n这里不计算养育小孩，以及赡养老人，假设是等价的。\r\n\r\n即正常生活的人价值500万。以此为标准，价值一个亿，则需要提升20倍。\r\n就是说年收入要到200百万。而且考虑到有些工作没法持续，实际上要求更高。\r\n\r\n这里谈价值而不谈钱，因为实际钱能多少不好说，但人的价值是可以模糊衡量的。\r\n\r\n比一般人强20倍难不难？有点难，但是并非不可实现。效能提升20倍，只要坚定的不断提升自己，10年足以。
298	1599	attr	project_id	9	6
299	1602	attr	description	回望历史，已有先人指路\r\n探寻风景，亦有文人骚客\r\n我将何往，八荒之极。	回望历史，已有先人指路\r\n探寻风景，亦有文人骚客\r\n我将何往，八荒之极。\r\n这世间真知，就蕴含于万物之中，只是时机不成熟的人无法探知。
300	1603	attr	description	回望历史，已有先人指路\r\n探寻风景，亦有文人骚客\r\n我将何往，八荒之极。\r\n这世间真知，就蕴含于万物之中，只是时机不成熟的人无法探知。	回望历史，已有先人指路\r\n探寻风景，亦有文人骚客\r\n我将何往，八荒之极。\r\n这世间真知，就蕴含于万物之中，只是时机不成熟的人无法探知。\r\n真善美智乐强权色皆我所求也，中庸之极，随心所欲。\r\n心实而强。\r\n强大的目标，专注的意识，才有良好的行动方案和执行力。
302	1608	attr	subject	对象数据库	对象行为-数据库
308	1628	attr	done_ratio	0	100
311	1637	attachment	42	\N	Oos_framework.png
312	1638	attr	description	1，稳定优先\r\n1.1 不要轻易杀球\r\n1.2 使用小发力精确控制\r\n1.3 持续的制造机会，保持耐心\r\n1.4 保持动作连贯\r\n\r\n2，对于弱点的观察，变化的理解。	1，稳定优先\r\n1.1 不要轻易杀球\r\n1.2 使用小发力精确控制\r\n1.3 持续的制造机会，保持耐心\r\n1.4 保持动作连贯\r\n\r\n2，对于弱点的观察，变化的理解。\r\n\r\n3，基本面\r\n发力到位，每个球都能达到目的。
384	1895	attr	description	软件错误的来源：\r\n1，不对称的动作\r\n  隐含的约束动作是很多bug的根源，直接造成实体的损害。\r\n2，错误的变量值\r\n  计算表达式不对，边界异常\r\n3，因果错误\r\n  读写变量的因果无法得以保证等引起的问题。	软件错误的来源：\r\n1，不对称的动作\r\n  隐含的约束动作是很多bug的根源，直接造成实体的损害。\r\n2，错误的变量值\r\n  计算表达式不对，边界异常\r\n3，因果错误，并发下的因果错误\r\n  读写变量的因果无法得以保证等引起的问题。\r\n  不可并发也是一种常见的因果错误。
301	1605	attr	description		建造者模式是对行为的包装，即行为动作序列不变。但行为本身有差别。\r\n\r\n设计模式的作用：\r\n1，隔离变化\r\n2，约束关系\r\n   生成，一般与特殊，观察者，适配器，桥接器，迭代器\r\n   \r\n关系有强弱，对应于耦合，内聚\r\n关系有M:N\r\n\r\n设计的第一步是分解组合，得到基本的实体，第一层分解之后通常叫架构模式。\r\n第二层分解是一个模块之内，分解实体之后，一个任务就是明确他们之前的关系。这就是设计模式。\r\n分解的重点在于明确实体关系，未来可能增加的实体，或实体可能增加的行为并对这些可变性作出隔离。\r\n还有一个很重要的是增加虚拟实体，比如迭代器这种。虚拟实体可以辅助构建实体关系。\r\n当然这不是一蹴而就的，有些变化提前未知，因而在开发过程中涉及重构。   \r\n\r\n继承与多态是相辅相成的，没有继承则类型不能作为其他类型的替代而出现，就没有多态。\r\n封装+继承多态是实体关系的根基。即从整体而言系统是一个树状结构的。\r\n树状结构一个常见动作还有上提下拉。上提则共享，下拉则分化。\r\n\r\n还有一种并非描述实体关系的，而是行为关系的，或叫开发模式吧\r\n其作用是抽象相同行为，将关联行为进行约束，以避免代码出现bug。\r\n比如析构，生命周期，所有权这套。\r\n常见软件错误：\r\n数据类：1，错误的理解变量含义与范围。 2，不一致的状态。 3，离开作用域的数据。\r\n行为类：1，缺失或多出或乱序的动作。 2，动作的边际效应。 3，没有约定好的接口\r\n设计类：1，缺乏实体包装引起的复杂性 2，不合适的实体关系。 3，弥散的隐式依赖，包括行为的。\r\n\r\n
303	1609	attr	description	以前看小说拿到啥武功秘籍，修炼之后功力大增。感觉不太靠谱。\r\n现在想想，也并非不可能。 \r\n修炼修的是啥，是思考方式，去观看一切的角度。\r\n如有经典系统阐述深刻的思想，就是经，就是武功秘籍。\r\n\r\n经者，径也。	以前看小说拿到啥武功秘籍，修炼之后功力大增。感觉不太靠谱。\r\n现在想想，也并非不可能。 \r\n修炼修的是啥，是思考方式，去观看一切的角度。\r\n如有经典系统阐述深刻的思想，就是经，就是武功秘籍。\r\n\r\n经者，径也。\r\n\r\n如从实体划分，实体关系，实体行为，行为关系，多行为关系，状态等等角度来看待程序，则能入木三分，进到程序之内。\r\n如果流于表面，没有使用内心去看，那只能隔岸观赏了。\r\n其区别在哪？我们内心有了运行的程序。在我们的脑中，程序不再是外部符号信息。\r\n\r\n我要写一本书，编程心法。从此心法去看当下的一切。\r\n心学是否也如此？即在心中运转事物，达到通达。便可进入高手境界。
304	1616	attr	description	如果将实现行为作为软件的根本。\r\n则设计对应于实体的划分与组合。\r\n设计模式是实体关系的一些常见模式。\r\n开发是实体行为以及状态的实现。	如果将实现行为作为软件的根本。\r\n则设计对应于实体的划分与组合。将系统中的过程抽象为一个组件并不容易，尤其是一个全新系统。这就是创造的过程。\r\n设计模式是实体关系的一些常见模式。\r\n开发是实体行为以及状态的实现。
305	1617	attr	subject	设计，设计模式，开发的关系	设计，设计模式，开发的关系（如何掌握事物）
306	1620	attr	description	1，在xslot上的设计缺陷，anchorBase没有很好的封装xslot，导致其相关逻辑每个struct都得实现一遍。\r\n\r\n谢锐 2-26 08:49:38\r\nZHEAP：重造PostgreSQL的存储引擎\r\n谢锐 2-26 08:51:38\r\n我之前也考虑把anchorbase中元祖事务信息抽离成独立页面 看上述介绍zheap是这样实现的\r\n谢锐 2-26 08:52:46\r\n把抽出的事物信息页面作为具有行概念结构的通用机制。\r\n\r\n而且这是存储底座最复杂的部分。\r\n\r\n2，undo模块的设计也存在瑕疵：\r\n谢锐 3-19 14:56:12\r\nundo这地方目前还有点别扭，目前涉及加锁的undo格式是 UndoRow + Xslot(option) + Ura + Head + Data。与其他改页面的格式不一样。 Xslot这部分的添加放入了undo底层。Ura在各个模块自己的undo里面。 但是Xslot的undo逻辑不在undo底层，而且xslot与页面关联，能否执行跟DataObjectOid也有关系。。 我觉得顺一点是 UndoRow + | BlockHead + Xslot(option) + Ura(option) | + Data，如果不考虑极致空间效率(实际也浪费不了多少，大部分undo都涉及页面) 可以把中间部分也纳入undo底座。增加的undo主要是关心data部分\r\n谢锐 3-19 14:57:45\r\nxslot，ura跟undo确实有些关系，但是这2者又都属于页面内容\r\n谢锐 3-19 15:02:46\r\n其实考虑空间使用也没问题，在UndoRow中加个flag，把BlockHead也变成option\r\n谢锐 3-19 15:03:37\r\n现在我写undoLock函数，没法按记录的顺序来弄，得先找到Head判断能否执行，然后执行undo xslot，ura。\r\n\r\n如果页面提供了获取xslot位置的能力，则undoXslot就可以落入底座，或者说xslot独立页面直接放入undo模块之中。\r\n这样结构层完全不感知。\r\n\r\n3，原子操作的封装是经典\r\n4，PCR机制很经典\r\n5，segment，undo经典\r\n6，底层对字段无感，与元数据解耦很经典。	1，在xslot上的设计缺陷，anchorBase没有很好的封装xslot，导致其相关逻辑每个struct都得实现一遍。\r\n\r\n谢锐 2-26 08:49:38\r\nZHEAP：重造PostgreSQL的存储引擎\r\n谢锐 2-26 08:51:38\r\n我之前也考虑把anchorbase中元祖事务信息抽离成独立页面 看上述介绍zheap是这样实现的\r\n谢锐 2-26 08:52:46\r\n把抽出的事物信息页面作为具有行概念结构的通用机制。\r\n\r\n而且这是存储底座最复杂的部分。\r\n\r\n2，undo模块的设计也存在瑕疵：\r\n谢锐 3-19 14:56:12\r\nundo这地方目前还有点别扭，目前涉及加锁的undo格式是 UndoRow + Xslot(option) + Ura + Head + Data。与其他改页面的格式不一样。 Xslot这部分的添加放入了undo底层。Ura在各个模块自己的undo里面。 但是Xslot的undo逻辑不在undo底层，而且xslot与页面关联，能否执行跟DataObjectOid也有关系。。 我觉得顺一点是 UndoRow + | BlockHead + Xslot(option) + Ura(option) | + Data，如果不考虑极致空间效率(实际也浪费不了多少，大部分undo都涉及页面) 可以把中间部分也纳入undo底座。增加的undo主要是关心data部分\r\n谢锐 3-19 14:57:45\r\nxslot，ura跟undo确实有些关系，但是这2者又都属于页面内容\r\n谢锐 3-19 15:02:46\r\n其实考虑空间使用也没问题，在UndoRow中加个flag，把BlockHead也变成option\r\n谢锐 3-19 15:03:37\r\n现在我写undoLock函数，没法按记录的顺序来弄，得先找到Head判断能否执行，然后执行undo xslot，ura。\r\n现在相当于每个模块自己实现相关逻辑了。\r\n\r\n如果页面提供了获取xslot位置的能力，则undoXslot就可以落入底座，或者说xslot独立页面直接放入undo模块之中。\r\n这样结构层完全不感知。\r\n页面提供2个接口：1，遍历xslot。 2，获取xslot地址\r\n\r\n3，原子操作的封装是经典\r\n4，PCR机制很经典\r\n5，segment，undo经典\r\n6，底层对字段无感，与元数据解耦很经典。
307	1625	attr	subject	心学	心学的理解
309	1632	attr	subject	强而不恶	强者，不恶
310	1636	attr	subject	rust中关于锁的问题	rust中关于获取锁内成员
313	1648	attr	subject	对自己做的东西要有清晰的定位，避免进入死胡同	实体划分，避免不清晰的思维，死胡同
314	1655	attr	subject	封装与依赖	封装与实体依赖，妙哉
317	1664	attr	subject	强者，不恶	善且强
319	1670	attr	description	领袖：阿拉贡\r\n神辅：甘道夫\r\n任务组：xxx\r\n\r\n每个人都有磨难，也都有成长。	极具挑战且艰巨的任务：战胜魔王\r\n领袖：阿拉贡\r\n神辅：甘道夫\r\n任务组：xxx\r\n\r\n每个人都有磨难，也都有成长。
320	1680	attr	description	基本概念：实体，行为，关系\r\n          结构，封装，约束\r\n上述概念可以扩展延伸，形成更多的子概念体系，比如行为可以并发，可以重入，可以组合。\r\n关系可以有强弱，有依存，有共生，有特定范式下的关系。\t  \r\n拓展概念：状态(可变性)，共享实体，并发行为。\r\n系统的出现都是解决问题，适应环境而存在。因具备了某些特性而得以存在。\r\n\r\n语言是一个符号系统，用于描述概念的。所以真敢号称语言无所谓的人，得真实的理解编程。\r\n就像剑客说剑无所谓，那前提是剑术达到出神入化的境界。\r\n\t\t  \r\n不安全：未定义的系统行为\r\n类型系统：本质上是约束\r\n    动态类型，静态类型，强类型，弱类型。上述类型可换为约束。\r\n封装：可见性本质上就是依赖关系\r\n引用或指针：表达的是共享，有些场景必须使用共享，比如计数。clone得到的是另一个实体，无法完成计数能力。\r\n            共享还有一个目的是为了性能。为了读拷贝一个实体代价很大。	基本概念：实体，行为，关系\r\n基本属性：结构，封装(可见性)，约束\r\n\r\n上述概念可以扩展延伸，形成更多的子概念体系，比如行为可以并发，可以重入，可以组合。\r\n关系可以有强弱，有依存，有共生，有特定范式下的关系。\t  \r\n拓展概念：状态(可变性)，共享实体，并发行为。\r\n系统的出现都是解决问题，适应环境而存在。因具备了某些特性而得以存在。\r\n\r\n语言是一个符号系统，用于描述概念的。所以真敢号称语言无所谓的人，得真实的理解编程。\r\n就像剑客说剑无所谓，那前提是剑术达到出神入化的境界。\r\n\t\t  \r\n不安全：未定义的系统行为\r\n类型系统：本质上是约束，或者说约束的表现形式就是类型系统。\r\n    动态类型，静态类型，强类型，弱类型。上述类型可换为约束。\r\n封装：可见性，本质上就是依赖关系\r\n引用或指针：表达的是共享，有些场景必须使用共享，比如计数。clone得到的是另一个实体，无法完成计数能力。\r\n            共享还有一个目的是为了性能。为了读拷贝一个实体代价很大。
316	1660	attr	description	为什么可变不共享，共享不可变？为什么单线程下也只有一个可变引用？\r\n首先我们要理解共享，引用一个变量即意味着在某个语境下使用它。\r\n如果将变量使用的上下文描述为task，那么变量与其引用存在于不同的task中。\r\n上述规则即避免了2个task中语义相关干扰。\r\ntask的执行可以在单线程，也可以分别在不同线程。\r\n举个例子：\r\nfn main() {\r\n    let mut foo = vec![1, 2, 3];\r\n\r\n\tfor e in &foo {\r\n\t\tif e % 2 == 0 {\r\n\t\t\tfoo.push(e+1);\r\n\t\t}\r\n\t}\r\n}\r\n该例中就同时出现了可变与不可变，\r\n其中for e in &foo的task是遍历foo。\r\n而foo本身在下面执行了push。\r\n\r\n再举一个例子，比如task：判断链表是否有某个元素，如果没有则添加该元素。\r\n但是判断和添加分2个动作执行。\r\n执行顺序如下：\r\ntask1.check\r\ntask2.check\r\ntask1.add\r\ntask2.add\r\n最终增加了2个元素，也就是说在单线程下，不同语境下同时修改变量可能不满足语义要求。\r\n当然同时修改一个变量并非总有问题，比如add 1操作，此操作本身语义并不冲突。理论上可同时修改。\r\nrust加强了这种限制，以便于静态检查。代价是即便有些代码是安全的，仍然不能以安全rust写，必须使用非安全代码。\r\n比如计数器。即便单线程使用的Rc，必须使用非安全代码才能写出来。\r\n\r\n另外Cell和RefCell也没打破规则，Cell只能整体来set或replace其中的成员，取出只能拷贝方式。\r\n而RefCell是在运行时检查是否有违反上述规则，违反了就panic。好处是根据实际借用时间来判断冲突。\r\n比如：\r\nlet mut p = 4;\r\nlet x = &p;\r\np = 1;\r\nprintln!("{}", x);\r\n显然上述在语义上没冲突，x虽然引用了p，但是还没开始使用。但编译时只能根据作用域判断认定冲突。\r\n使用RefCell解决该问题：\r\nlet p = RefCell::new(4);\r\nlet x = &p;\r\nprintln!("{}", x.borrow());\r\n*p.borrow_mut() = 1;\r\nprintln!("{}", x.borrow());	为什么可变不共享，共享不可变？为什么单线程下也只有一个可变引用？\r\n首先我们要理解共享，引用一个变量即意味着在某个语境下使用它。\r\n如果将变量使用的上下文描述为task，那么变量与其引用存在于不同的task中。\r\n上述规则即避免了2个task中语义相关干扰。\r\ntask的执行可以在单线程，也可以分别在不同线程。\r\n举个例子：\r\n\r\n<pre>\r\nfn main() {\r\n    let mut foo = vec![1, 2, 3];\r\n\r\n\tfor e in &foo {\r\n\t\tif e % 2 == 0 {\r\n\t\t\tfoo.push(e+1);\r\n\t\t}\r\n\t}\r\n}\r\n</pre>\r\n\r\n该例中就同时出现了可变与不可变，\r\n其中for e in &foo的task是遍历foo。\r\n而foo本身在下面执行了push。\r\n\r\n再举一个例子，比如task：判断链表是否有某个元素，如果没有则添加该元素。\r\n但是判断和添加分2个动作执行。\r\n执行顺序如下：\r\ntask1.check\r\ntask2.check\r\ntask1.add\r\ntask2.add\r\n最终增加了2个元素，也就是说在单线程下，不同语境下同时修改变量可能不满足语义要求。\r\n当然同时修改一个变量并非总有问题，比如add 1操作，此操作本身语义并不冲突。理论上可同时修改。\r\nrust加强了这种限制，以便于静态检查。代价是即便有些代码是安全的，仍然不能以安全rust写，必须使用非安全代码。\r\n比如计数器。即便单线程使用的Rc，必须使用非安全代码才能写出来。\r\n\r\n另外Cell和RefCell也没打破规则，Cell只能整体来set或replace其中的成员，取出只能拷贝方式。\r\n而RefCell是在运行时检查是否有违反上述规则，违反了就panic。好处是根据实际借用时间来判断冲突。\r\n比如：\r\n\r\n<pre>\r\nlet mut p = 4;\r\nlet x = &p;\r\np = 1;\r\nprintln!("{}", x);\r\n</pre>\r\n\r\n显然上述在语义上没冲突，x虽然引用了p，但是还没开始使用。但编译时只能根据作用域判断认定冲突。\r\n使用RefCell解决该问题：\r\n\r\n\r\n<pre>\r\nlet p = RefCell::new(4);\r\nlet x = &p;\r\nprintln!("{}", x.borrow());\r\n*p.borrow_mut() = 1;\r\nprintln!("{}", x.borrow());\r\n</pre>
318	1668	attr	subject	边界的感知，解决注意力涣散的问题	边界的感知，解决注意力涣散的问题，要思考也要聚焦
321	1684	attr	subject	rust性能优化器	rust性能优化-软件的未来
322	1684	attr	description	程序员专注于正确性与扩展性，性能优化的事交给优化器。\r\n极致优化版。	程序员专注于正确性与扩展性，性能优化的事交给优化器。\r\n极致优化版。\r\n就像跨平台的需要一样，被编程语言解决了。\r\n安全性问题被rust部分解决了。\r\n\r\n也许有一天软件的复杂度，扩展性问题也得以解决，那程序员就退出历史的舞台了。\r\n事情都交给了程序体，可以想见那时的人类将大不一样？是好还是坏，说不清楚，但技术的车轮必然这样走过。\r\n\r\n未来会怎么样？\r\n变得更好或者更坏？\r\n没人能够预见，也没人能设定\r\n我们只能在这特定的时空下\r\n生生不息\r\n演绎仅属于我们的故事\r\n
323	1695	attr	description	windows系统中当我们在删除某个文件或文件夹时有时会提示该文件有程序在使用不能被删除，这时相当惆怅。那么可以用这个方法来找到是哪个进程在占用该文件：  \r\n\r\n1：打开任务管理器选择“性能”  \r\n2：单击下部的“资源监视器”  \r\n3：选择“CPU”，在下部可以看到“关联的句柄”搜索框  \r\n4：在该搜索框中输入要删除的文件名回车  \r\n\r\n在下面就会列出来占用该文件的进程名，右键该进程单击“结束进程”，OK，可以删除了:	windows系统中当我们在删除某个文件或文件夹时有时会提示该文件有程序在使用不能被删除，这时相当惆怅。那么可以用这个方法来找到是哪个进程在占用该文件：  \r\n\r\n1：打开任务管理器选择“性能”  \r\n2：单击下部的“资源监视器”  \r\n3：选择“CPU”，在下部可以看到“关联的句柄”搜索框  \r\n4：在该搜索框中输入要删除的文件名回车  \r\n\r\n在下面就会列出来占用该文件的进程名，右键该进程单击“结束进程”，OK，可以删除了:\r\n\r\nhttps://www.cnblogs.com/liushui-sky/p/8135292.html
326	1706	attr	description	1，并发执行模型\r\n   线程池模型，异步框架，内核绑定\r\n2，数据结构的并发能力\r\n   数据冲突，cache，内存池。\r\n   并行扫描\r\n3，单线程单点操作延时\r\n4，单线程批量操作吞吐量\r\n5，编解码，压缩\r\n6，零拷贝\r\n7，存储连续读优化\r\n8，内联，静态等编程语言优化	1，并行/并发执行模型\r\n   线程池模型，异步框架，内核绑定\r\n2，数据结构的并发/并行能力\r\n   数据冲突，cache，内存池。\r\n   并行扫描\r\n3，单线程单点操作延时\r\n4，单线程批量操作吞吐量\r\n6，内存相关：零拷贝\r\n   内存性能优化的关键就是减少拷贝。\r\n   本质上程序就是在重组织数据，查找数据，以及转换数据(运算).\r\n   内存拷贝与并发是矛盾的，不拷贝则冲突范围扩大。除非是Arc的。\r\n\r\n7，存储优化\r\n   压缩，对齐读，顺序读，合并sync\r\n\r\n8，内联，静态等编程语言优化\r\n9，算法优化\r\n   最精简的动作和辅助结构\r\n\r\n总结下有如下性能优化手段：\r\n1，执行模型优化\r\n2，内存优化\r\n3，磁盘优化\r\n4，算法优化\r\n5，语言优化
327	1707	attr	description	1，并行/并发执行模型\r\n   线程池模型，异步框架，内核绑定\r\n2，数据结构的并发/并行能力\r\n   数据冲突，cache，内存池。\r\n   并行扫描\r\n3，单线程单点操作延时\r\n4，单线程批量操作吞吐量\r\n6，内存相关：零拷贝\r\n   内存性能优化的关键就是减少拷贝。\r\n   本质上程序就是在重组织数据，查找数据，以及转换数据(运算).\r\n   内存拷贝与并发是矛盾的，不拷贝则冲突范围扩大。除非是Arc的。\r\n\r\n7，存储优化\r\n   压缩，对齐读，顺序读，合并sync\r\n\r\n8，内联，静态等编程语言优化\r\n9，算法优化\r\n   最精简的动作和辅助结构\r\n\r\n总结下有如下性能优化手段：\r\n1，执行模型优化\r\n2，内存优化\r\n3，磁盘优化\r\n4，算法优化\r\n5，语言优化	1，并行/并发执行模型\r\n   线程池模型，异步框架，内核绑定\r\n2，数据结构的并发/并行能力\r\n   数据冲突，cache，内存池。\r\n   并行扫描\r\n3，单线程单点操作延时\r\n4，单线程批量操作吞吐量\r\n6，内存相关：零拷贝\r\n   内存性能优化的关键就是减少拷贝。\r\n   本质上程序就是在重组织数据，查找数据，以及转换数据(运算).\r\n   内存拷贝与并发是矛盾的，不拷贝则冲突范围扩大。除非是Arc的。\r\n\r\n7，存储优化\r\n   压缩，对齐读，顺序读，合并sync\r\n\r\n8，内联，静态等编程语言优化\r\n9，算法优化\r\n   最精简的动作和辅助结构\r\n\r\n总结下有如下性能优化手段：\r\n1，执行模型优化\r\n2，内存优化\r\n3，磁盘优化\r\n4，算法优化\r\n5，语言优化\r\n6，计算机架构优化\r\n   绑定内核，内存等。
329	1709	attr	description	元数据组织：\r\n\r\n表\r\n  --分片\r\n      -- 分区\r\n\t     -- del\r\n\t     -- grouplist\r\n\t\t -- group0\r\n\t\t -- group1\r\n\t\t    -- slicelist\r\n\t\t\t-- slice0\r\n\t\t\t-- slice1\r\n\r\nslicelist中包含slice基本信息，以及统计信息等，以加速整个slice过滤。	元数据组织：\r\n\r\n<pre>\r\n表\r\n  --分片\r\n      -- 分区\r\n\t     -- del\r\n\t     -- grouplist\r\n\t\t -- group0\r\n\t\t -- group1\r\n\t\t    -- slicelist\r\n\t\t\t-- slice0\r\n\t\t\t-- slice1\r\n</pre>\r\nslicelist中包含slice基本信息，以及统计信息等，以加速整个slice过滤。
332	1717	attr	subject	解惑:心智	解惑:心智 最深处的秘密
333	1730	attr	description	做事情一定要追求真懂，未真懂之前都是瞎摸。\r\n但真懂是一个过程，有时单纯思考不如实验来得快。\r\n\r\n但终究问题在那里，解决问题的根本在于真正弄明白。	做事情一定要追求真懂，未真懂之前都是瞎摸。\r\n但真懂是一个过程，有时单纯思考不如实验来得快。\r\n\r\n但终究问题在那里，解决问题的根本在于真正弄明白。这就是知识的力量。
324	1700	attr	description	使用大版本是因为目标变了。\r\n我不再以成为最好的程序员为目标，也不再以达到多强为目标。\r\n\r\n真善美：可以无限追求，那是心灵的天空。\r\n权，强，财，色：取自己那份，够了就好。多了也没啥用，老的时候也享受不了，身外之物。美女3千太过了，几个就好。资产上亿，财富自由？ 够用就行。\r\n                但不够的时候还是要调整自己去获取的。\r\n人生最重要的就是这个旅途，我们想以什么样的方式去渡过。\r\n如果我喜欢写程序并且还能获取物质等，当然非常好。\r\n如果长期做自己不喜欢的事去获取超过实际需要的物质，无疑是在对自己作恶。其实内心是不接收的。\r\n\r\n善良：就是接收改进的意思。顺从本心，且着手改变，这就是生机勃发。\r\n\r\n被恶遮蔽就看不到光明，听不见悦耳真实的声音，看不到美丽纯粹的颜色。\r\n\r\n所以我们去做一件事，从根本上是我们喜欢它，接受它。这是一段美妙的旅程不是吗？\r\n\r\n人生观：人生本就是一个体验事和物的过程，生生不息，生机畅达。\r\n\r\n我的定位：programmer，speaker\r\n作为programmer，我喜欢去理解人和事物，并用程序表达他们。\r\n作为speaker，我会努力去用自己的善去影响别人，用自己学到的知识帮助别人去体验。\r\n\r\n\r\n\r\n\r\n	使用大版本是因为目标变了。\r\n我不再以成为最好的程序员为目标，也不再以达到多强为目标。\r\n\r\n真善美：可以无限追求，那是心灵的天空。\r\n权，强，财，色：取自己那份，够了就好。多了也没啥用，老的时候也享受不了，身外之物。美女3千太过了，几个就好。资产上亿，财富自由？ 够用就行。\r\n                但不够的时候还是要调整自己去获取的。\r\n人生最重要的就是这个旅途，我们想以什么样的方式去渡过。\r\n如果我喜欢写程序并且还能获取物质等，当然非常好。\r\n如果长期做自己不喜欢的事去获取超过实际需要的物质，无疑是在对自己作恶。其实内心是不接收的。\r\n\r\n善良：就是接收改进的意思。顺从本心，且着手改变，这就是生机勃发。\r\n\r\n被恶遮蔽就看不到光明，听不见悦耳真实的声音，看不到美丽纯粹的颜色。\r\n\r\n所以我们去做一件事，从根本上是我们喜欢它，接受它。这是一段美妙的旅程不是吗？\r\n\r\n人生观：人生本就是一个体验事和物的过程，生生不息，生机畅达。\r\n\r\n我的定位：programmer，speaker\r\n作为programmer，我喜欢去理解人和事物，并用程序表达他们。\r\n作为speaker，我会努力去用自己的善去影响别人，用自己学到的知识帮助别人去体验。\r\n             作为一个自我管理者，一个教育者，帮助其他人，分享自己。\r\n\r\n\r\n\r\n\r\n
325	1703	attr	description	1，并发执行模型\r\n   线程池模型，异步框架，内核绑定\r\n2，数据结构的并发能力\r\n   数据冲突，cache，内存池\r\n3，单线程单点操作延时\r\n4，单线程批量操作吞吐量\r\n5，编解码，压缩\r\n6，零拷贝	1，并发执行模型\r\n   线程池模型，异步框架，内核绑定\r\n2，数据结构的并发能力\r\n   数据冲突，cache，内存池。\r\n   并行扫描\r\n3，单线程单点操作延时\r\n4，单线程批量操作吞吐量\r\n5，编解码，压缩\r\n6，零拷贝\r\n7，存储连续读优化\r\n8，内联，静态等编程语言优化
328	1708	attr	description	1，并行/并发执行模型\r\n   线程池模型，异步框架，内核绑定\r\n2，数据结构的并发/并行能力\r\n   数据冲突，cache，内存池。\r\n   并行扫描\r\n3，单线程单点操作延时\r\n4，单线程批量操作吞吐量\r\n6，内存相关：零拷贝\r\n   内存性能优化的关键就是减少拷贝。\r\n   本质上程序就是在重组织数据，查找数据，以及转换数据(运算).\r\n   内存拷贝与并发是矛盾的，不拷贝则冲突范围扩大。除非是Arc的。\r\n\r\n7，存储优化\r\n   压缩，对齐读，顺序读，合并sync\r\n\r\n8，内联，静态等编程语言优化\r\n9，算法优化\r\n   最精简的动作和辅助结构\r\n\r\n总结下有如下性能优化手段：\r\n1，执行模型优化\r\n2，内存优化\r\n3，磁盘优化\r\n4，算法优化\r\n5，语言优化\r\n6，计算机架构优化\r\n   绑定内核，内存等。	1，并行/并发执行模型\r\n   线程池模型，异步框架，内核绑定\r\n2，数据结构的并发/并行能力\r\n   数据冲突，cache，内存池。\r\n   并行扫描\r\n3，单线程单点操作延时\r\n4，单线程批量操作吞吐量\r\n6，内存相关：零拷贝\r\n   内存性能优化的关键就是减少拷贝。\r\n   本质上程序就是在重组织数据，查找数据，以及转换数据(运算).\r\n   内存拷贝与并发是矛盾的，不拷贝则冲突范围扩大。除非是Arc的。\r\n\r\n7，存储优化\r\n   压缩，对齐读，顺序读，合并sync\r\n\r\n8，内联，静态等编程语言优化\r\n9，算法优化\r\n   最精简的动作和辅助结构\r\n\r\n总结下有如下性能优化手段：\r\n1，执行模型优化\r\n2，内存优化\r\n3，磁盘优化\r\n4，算法优化\r\n5，语言优化\r\n   JIT优化，编译优化\r\n6，计算机架构优化\r\n   绑定内核，内存，特殊指令等。
330	1713	attr	description	slice生成是不存在并发的，slice合并也不存在并发。\r\n我们总是在最新的group生成slice。只会对老的slice合并，如果要并行合并。\r\n可以分别对不同的group执行。	slice生成是不存在并发的，slice合并也不存在并发。\r\n我们总是在最新的group生成slice。只会对老的slice合并，如果要并行合并。\r\n可以分别对不同的group执行。\r\n\r\n且我们不支持跨group合并。可支持group内没slice时删除group。
331	1715	attachment	43	\N	brain.png
335	1742	attachment	44	\N	培训材料-列数据存储组织.pptx
337	1744	attachment	46	\N	培训材料-列数据存储组织.pptx
338	1744	attachment	47	\N	swf.drawio
339	1745	attr	description	1，本地存储考虑使用anchorBase，直接使用上层接口\r\n   考虑单独使用一个表。\r\n2，group概念暴露，如暴露则其规则应该非常明确。\r\n   如果以目录展示，则说明该概念也暴露。\r\n3，cache缓存解码后的数据。	1，本地存储考虑使用anchorBase，直接使用上层接口\r\n   考虑单独使用一个表。\r\n2，group概念暴露，如暴露则其规则应该非常明确。\r\n   如果以目录展示，则说明该概念也暴露。\r\n3，cache缓存解码后的数据。\r\n   改造parquet-reader，读取后可以跳过编解码这步。
342	1770	attr	subject	Coral的调整(痛心)	Coral的设计调整(痛心)
343	1772	attr	description	1，意图\r\n   why制造一个系统？为了性能？生态？现有产品一致性(因为在不同分化路径上)？\r\n\r\n2，正确性\r\n   逻辑正确性论证，设计是否能满足意图需求？\r\n   一致性，这也是正确性相关的话题，设计尽量不要犯政治或平台选择上的错误。实现意图有很多种方法，实现一个系统也有很多种方法。\r\n\r\n3，扩展性\r\n   系统在那些地方是稳定的，基本不可变的，在那些地方可以扩展。\r\n   完全不稳定性的系统是不可用的。\r\n\r\n4，连接\r\n   系统在那些地方与外部连接，怎样连接。	1，意图\r\n   why制造一个系统？为了性能？生态？现有产品一致性(因为在不同分化路径上)？\r\n   意图需要我们理解问题，理解对方，没有理解就没有善，没有理解就在门外，谈何意图。\r\n\r\n2，战略  \r\n   第二步是战略，有意图，但是没有竞争优势就会失败，我们选择去做一个系统或分化它是因为我们看到了什么。\r\n   这就是战略。\r\n\r\n3，正确性\r\n   逻辑正确性论证，设计是否能满足意图需求？\r\n   一致性，这也是正确性相关的话题，设计尽量不要犯政治或平台选择上的错误。实现意图有很多种方法，实现一个系统也有很多种方法。\r\n\r\n4，扩展性\r\n   系统在那些地方是稳定的，基本不可变的，在那些地方可以扩展。\r\n   完全不稳定性的系统是不可用的。\r\n\r\n5，连接\r\n   系统在那些地方与外部连接，怎样连接。
344	1777	attachment	51	\N	clion_cmake_project.png
345	1778	attachment	52	\N	列数据存储组织.pptx
346	1779	attachment	53	\N	列数据存储组织V1.0.pptx
388	1906	attr	description	问题处理：\r\n1，处理obs loader cpu占用高问题\r\n2，处理max rowsize问题\r\n3，\r\n\r\n方案设计：\r\n\r\n功能实现：\r\n\r\n方案讨论：\r\n代码review：\r\n\r\n	问题处理：\r\n1，处理obs loader cpu占用高问题 (12.22)\r\n2，处理max rowsize问题(进行中)\r\n\r\n性能优化：\r\n1，yasdb与ck性能对比分析，确定优化点(12.24)\r\n\r\n方案设计：\r\n\r\n功能实现：\r\n\r\n方案讨论：\r\n代码review：\r\n\r\n
334	1731	attr	description	1，parquet中上层定义类型与兼容性的矛盾。\r\n   arrow项目本质上就意图解决该问题，虽然parquet是通用格式，但是由于上层格式未统一，不同系统之间仍然需进行类型转换。\r\n\r\n   如arrow成为标准内存格式，则其他系统如格式不兼容只需与arrow做格式转换。但arrow的性能也是一个大问题。其不绑定底层格式，但这样性能很差劲。\r\n   这或许是一个选择，类型系统，兼容性，性能三者的权衡。算法也是在权衡，选择。	1，parquet中上层定义类型与兼容性的矛盾。\r\n   arrow项目本质上就意图解决该问题，虽然parquet是通用格式，但是由于上层格式未统一，不同系统之间仍然需进行类型转换。\r\n\r\n   如arrow成为标准内存格式，则其他系统如格式不兼容只需与arrow做格式转换。但arrow的性能也是一个大问题。其不绑定底层格式，但这样性能很差劲。\r\n   这或许是一个选择，类型系统，兼容性，性能三者的权衡。算法也是在权衡，选择。\r\n\r\nstruct DataPageHeaderV2 {\r\n  /** Number of values, including NULLs, in this data page. **/\r\n  1: required i32 num_values\r\n  /** Number of NULL values, in this data page.\r\n      Number of non-null = num_values - num_nulls which is also the number of values in the data section **/\r\n  2: required i32 num_nulls\r\n  /** Number of rows in this data page. which means pages change on record boundaries (r = 0) **/\r\n  3: required i32 num_rows\r\n  /** Encoding used for data in this page **/\r\n  4: required Encoding encoding\r\n  明确了values的数量。
336	1743	attachment	45	\N	培训材料-列数据存储组织.pptx
340	1749	attachment	49	\N	docx_generator.py
341	1751	attachment	50	\N	docx_generator.py
348	1788	attachment	54	\N	列数据存储组织V2.0.pptx
349	1789	attr	subject	我将在本周内基本完成培训材料写作	列存新员工培训材料
351	1792	attr	subject	gitsubmodule  fatal: reference is not a tree	git submodule update失败：  fatal: reference is not a tree
352	1795	attr	description	重构的原因：dataset的内存管理，构建，以及dataset本身没有很好的分离，导致接口耦合，无法扩展不同的资源管理模式。\r\n重构的过程：在方案上我多次徘徊，有时候想彻底重构，但是又觉得工作量太大，搞了部分放弃了。\r\n            然后又想往dataset塞入内存分配器，仍然有不灵活的问题，需要给dataset中的列更好内存分配器。而且这样代码复杂度将继续上涨。\r\n            最后又折回，还是把构建与内存管理扣出来了。\r\n为啥反复： 因为想不清楚啊，看不出利弊，想不清楚到底是否要增加子结构，不同结构是否需进一步拆分。\r\n教训： 除了方案上的反复外，\r\n       做事情真是拼实力啊，什么是循环渐进，为啥要拆分很多小步骤。步骤一多，涉及的实体一多，就会乱。\r\n       做软件就得循序渐进，无法渐变很可能会失败。\r\n       没测试就没有重构，没接口就没有代码。	重构的原因：dataset的内存管理，构建，以及dataset本身没有很好的分离，导致接口耦合，无法扩展不同的资源管理模式。\r\n重构的过程：在方案上我多次徘徊，有时候想彻底重构，但是又觉得工作量太大，搞了部分放弃了。\r\n            然后又想往dataset塞入内存分配器，仍然有不灵活的问题，需要给dataset中的列更好内存分配器。而且这样代码复杂度将继续上涨。\r\n            最后又折回，还是把构建与内存管理扣出来了。\r\n为啥反复： 因为想不清楚啊，看不出利弊，想不清楚到底是否要增加子结构，不同结构是否需进一步拆分。\r\n教训： 除了方案上的反复外，\r\n       做事情真是拼实力啊，什么是循环渐进，为啥要拆分很多小步骤。步骤一多，涉及的实体一多，就会乱。\r\n       做软件就得循序渐进，无法渐变很可能会失败。\r\n       没测试就没有重构，没接口就没有代码。\r\n\r\n改接口代价大，这也是架构师的作用。\r\n\r\n软件的核心矛盾就是：复杂度+可变性+功能/性能。\r\n                    复杂度要求我们认知事物，在不同的层次，不同的广度上。\r\n                    可变性要求我们以生长的方式来对待软件，过于复杂的系统必然无法可变。\r\n                    \r\n
353	1796	attr	subject	从打羽毛球领悟做事技巧-从别人的角度来评估选择策略	从打羽毛球领悟做事技巧-从别人的角度来评估选择策略（要事优先）
354	1797	attr	subject	从打羽毛球领悟做事技巧-从别人的角度来评估选择策略（要事优先）	从打羽毛球领悟做事技巧-从别人的角度来评估选择策略（统合综效，要事优先）
355	1799	attr	done_ratio	0	100
356	1803	attr	description	接口优先，尤其是作为接口的数据结构，应该提前稳定。\r\n\r\n不要自我重复\r\n\r\n重构而不是重写，重写意味着更换，而不是进化。其实做很多事情都有此原则，不进化则难进步，人只能在进化的路上增强，就像更换工作一样，频繁换方向肯定是不利的，每个方向都得走别人的老路。\r\n\r\n事件机器，小步快跑\r\n显式约束，约束必然存在，约束让事物成为他自己\r\n最小知识，可见性是软件可变性的灵魂，自然法则\r\n依赖和独裁是一对，依赖意味着变化就带来极大痛苦，减少依赖控制，明确互赖是更合适的道路。\r\n\r\n组合通常胜过继承，公司制胜过家族制，本质还是在于更好的可变性。\r\n稳定性是高手之间的差距，也是难做的	接口优先，尤其是作为接口的数据结构，应该提前稳定。\r\n\r\n不要自我重复\r\n\r\n重构而不是重写，重写意味着更换，而不是进化。其实做很多事情都有此原则，不进化则难进步，人只能在进化的路上增强，就像更换工作一样，频繁换方向肯定是不利的，每个方向都得走别人的老路。\r\n\r\n事件机器，小步快跑\r\n显式约束，约束必然存在，约束让事物成为他自己\r\n最小知识，可见性是软件可变性的灵魂，这也是自然法则，自然也没有把所有复杂性直接展现给人。\r\n依赖和独裁是一对，依赖意味着变化就带来极大痛苦，减少依赖控制，明确互赖是更合适的道路。\r\n\r\n组合通常胜过继承，公司制胜过家族制，本质还是在于更好的可变性。\r\n稳定性是高手之间的差距，也是难做的
357	1807	attr	description	当然可能几乎没有软件工程师敢声称自己的软件是正确的。\r\n正确在这里是指在各种输入，各种并发，任何时刻的故障下软件的行为是可预期的。\r\n这件事情为何难以做到？\r\n因为在一个复杂系统中，存在很多隐式约束和没有处理的漏洞。\r\n尤其是一个系统在不断发展演进的过程中。	当然可能几乎没有软件工程师敢声称自己的软件是正确的。\r\n正确在这里是指在各种输入，各种并发，任何时刻的故障下软件的行为是可预期的。\r\n这件事情为何难以做到？\r\n因为在一个复杂系统中，存在很多隐式约束和没有处理的漏洞。\r\n尤其是一个系统在不断发展演进的过程中。\r\n\r\n最终软件的进化变得缓慢，经常查缺补漏，又不断重构或重写部分逻辑。
364	1834	attr	description	1，计算机的发明\r\n  这是数学理论（二进制，布尔代数，数理逻辑）等学科发展，以及物理（电磁，晶体管）等发展的背景下产生的。\r\n  也是计算需求激增下的必然，为什么计算激增？这又跟航海和军事等有关系。\r\n2，指针是什么\r\n  指针是可变的间接地址。不是直接地址(变量名)，也不是间接地址（引用）。\r\n3，C语言引入了什么？\r\n  确定了高级语言的雏形，作用域？类型系统？结构体？编译跨平台？\r\n4，动作，增删改查 4个基本动作，执行流程，顺序，选择，循环执行的理解\r\n5，实体，数据结构，组合与关系的理解\r\n6，接口与抽象\r\n6，可见性，不同层次\r\n6，模块化，空间隔离性，空间的本质就是隔离性，在有限时间内不可达到。\r\n7，可变性\r\n8，原子性\r\n9，一致性，顺序，因果\r\n10，时间\r\n11，持久性\r\n12，复杂性\r\n12，并发性	1，计算机的发明\r\n  这是数学理论（二进制，布尔代数，数理逻辑）等学科发展，以及物理（电磁，晶体管）等发展的背景下产生的。\r\n  也是计算需求激增下的必然，为什么计算激增？这又跟航海和军事等有关系。\r\n2，指针是什么\r\n  指针是可变的间接地址。不是直接地址(变量名)，也不是间接地址（引用）。\r\n3，C语言引入了什么？\r\n  确定了高级语言的雏形，作用域？类型系统？结构体？编译跨平台？\r\n4，动作，增删改查 4个基本动作，执行流程，顺序，选择，循环执行的理解\r\n5，实体，数据结构，组合与关系的理解\r\n6，接口与抽象\r\n6，可见性，不同层次\r\n6，模块化，空间隔离性，空间的本质就是隔离性，在有限时间内不可达到。\r\n7，可变性\r\n8，原子性\r\n9，一致性，顺序，因果\r\n10，时间，时间是顺序，也是因果，时间具备全局性。\r\n11，持久性\r\n12，复杂性\r\n12，并发性
391	1923	attr	description	1，架构的目的是为了投入尽可能少的资源来完成系统，维护系统。	1，架构的目的是为了投入尽可能少的资源来完成系统，维护系统。\r\n   由此看构建成本当然非常重要。程序员每天都消耗于安装环境，构建，运行测试用例，生命都白白浪费了。
347	1780	attr	description	5.1回家，看着老家周围的村庄被拆除，机场高速的破土而出。我内心有一种说不出的感觉。\r\n村子未来也可能拆除，再也回不到那个是家的地方，我有一种说不出的感觉。\r\n但也有一种如释重负的感觉，或许这里将不再有人认识我，而我也可以做自己。\r\n\r\n我想我是强烈依赖于环境的。否则我怎么会害怕失去家园，\r\n害怕亲人不和，害怕表达自己的看法，害怕发表不完善的成果即便接近deadline，害怕汇报工作？\r\n我知道自己内心是害怕的，直到我直面这种感觉。直到冬寅不在家，甚至一直不回我该如何面对。\r\n\r\n有时我也想如果自己一个人该如何生活。\r\n如果那些依存，依恋，依赖都不存在了。我一个人于这个世界该如何生活？\r\n	5.1回家，看着老家周围的村庄被拆除，机场高速的破土而出。我内心有一种说不出的感觉。\r\n村子未来也可能拆除，再也回不到那个是家的地方，我有一种说不出的感觉。\r\n但也有一种如释重负的感觉，或许这里将不再有人认识我，而我也可以做自己。\r\n\r\n我想我是强烈依赖于环境的。否则我怎么会害怕失去家园，\r\n害怕亲人不和，害怕表达自己的看法，害怕发表不完善的成果即便接近deadline，害怕汇报工作？\r\n我知道自己内心是害怕的，直到我直面这种感觉。直到冬寅不在家，甚至一直不回我该如何面对。\r\n\r\n有时我也想如果自己一个人该如何生活。\r\n如果那些依存，依恋，依赖都不存在了。我一个人于这个世界该如何生活？\r\n\r\n20年前如果说突然的变故带来的是灾难，20年后的今天我无可逃避，我选择面对。\r\n每个人都当写下自己的独立宣言\r\n
350	1791	attr	subject	安装clang高版本	centos7 安装clang高版本
358	1808	attr	description	当然可能几乎没有软件工程师敢声称自己的软件是正确的。\r\n正确在这里是指在各种输入，各种并发，任何时刻的故障下软件的行为是可预期的。\r\n这件事情为何难以做到？\r\n因为在一个复杂系统中，存在很多隐式约束和没有处理的漏洞。\r\n尤其是一个系统在不断发展演进的过程中。\r\n\r\n最终软件的进化变得缓慢，经常查缺补漏，又不断重构或重写部分逻辑。	当然可能几乎没有软件工程师敢声称自己的软件是正确的。\r\n正确在这里是指在各种输入，各种并发，任何时刻的故障下软件的行为是可预期的。\r\n这件事情为何难以做到？\r\n因为在一个复杂系统中，存在很多隐式约束和没有处理的漏洞。\r\n尤其是一个系统在不断发展演进的过程中。\r\n\r\n后续的修改可能又在不断增加债务。增加不合理的依赖或隐式约束，或漏洞。\r\n\r\n最终软件的进化变得缓慢，经常查缺补漏，又不断重构或重写部分逻辑。
359	1809	attr	subject	计算的力量-孙子兵法，原则	计算与思考 - 孙子兵法，原则
360	1809	attr	description	其实就是计算机器，程序的力量。\r\n使用模型进行运算。	其实就是计算机器，程序的力量。\r\n使用模型进行运算。\r\n\r\n思考通常是发散式的，综合归纳式的，创新式的，需要灵感。\r\n\r\n对于确定性问题，使用计算效果更好。\r\n对于非确定性问题，需要想象力，灵感，思考。
361	1810	attr	description	其实就是计算机器，程序的力量。\r\n使用模型进行运算。\r\n\r\n思考通常是发散式的，综合归纳式的，创新式的，需要灵感。\r\n\r\n对于确定性问题，使用计算效果更好。\r\n对于非确定性问题，需要想象力，灵感，思考。	其实就是计算机器，程序的力量。\r\n使用模型进行运算。计算是精确的，可量化，可重复的。\r\n\r\n思考通常是发散式的，综合归纳式的，创新式的，需要灵感。\r\n得到的结果通常是概括性，抽象性的。\r\n\r\n对于确定性问题，使用计算效果更好。\r\n对于非确定性问题，需要想象力，灵感，思考。
362	1812	attr	description	没有人能完全从别人视角看待问题，没有人能让其他人成长，因而人必须独立而自由。\r\n这样才能发展与改变。\r\n\r\n生机畅达只能来源于生活本身，没有一个外在纯然存在的精神力量或地方能让人保持愉悦。\r\n想想打羽毛球，什么动力让人去羽毛球馆，是纯粹打羽毛球过程中的快乐，\r\n挥汗如雨给身体带来的体验，进步带来的信心，领悟带来的兴奋感，杀球带来的快感。\r\n\r\n生活中很多事情都是熵增过程，人在生活中要不断面对这些，比如疾病，比如感情变淡，\r\n取得一些成长也难，所有我们体验过的感觉可能都会慢慢变淡。\r\n吃喝玩乐显然是有难度的，原先吃的，吃多了就不喜欢了。\r\n\r\n\r\n我曾以为是人生理想让人能坚持不断完善，但是即便如此谁会每时每刻提醒自己？\r\n现在我不这么认为了，是刺激和快乐让人不断的去做一些事情。\r\n人和人的不同在于不同的事情给人的快乐并不一样，有些人能发现一些事情的快乐，\r\n而另外的人则不能。\r\n\r\n基于真善美，在自然与社会的规律下，过得最快乐。\r\n很多人并不懂怎么快乐，不是吗？ 快乐有方法有技巧。\r\n在一个人没发现一件事情的纯然快乐时，要靠坚持和耐心渡过一些时期。\r\n或许还要一些技巧。	没有人能完全从别人视角看待问题，没有人能让其他人成长，人必须独立而自由。\r\n利用动物的能动性，人的沟通能力和智力去开启自己的奇幻旅程。\r\n\r\n生机畅达只能来源于生活本身，没有一个外在纯然存在的精神力量或地方能让人保持愉悦。\r\n想想打羽毛球，什么动力让人去羽毛球馆，是纯粹打羽毛球过程中的快乐，\r\n挥汗如雨给身体带来的体验，进步带来的信心，领悟带来的兴奋感，杀球带来的快感。\r\n\r\n生活中很多事情都是熵增过程，人在生活中要不断面对这些，比如疾病，比如感情变淡，\r\n取得一些成长也难，所有我们体验过的感觉可能都会慢慢变淡。\r\n吃喝玩乐显然是有难度的，原先吃的，吃多了就不喜欢了。\r\n没有一种躺平就有的快乐，也没有一种不变状态能让人一直快乐。\r\n人也没法像机器一样，纯然理性下一直快乐。\r\n\r\n我曾以为是人生理想让人能坚持不断完善，但是即便如此谁会每时每刻提醒自己？\r\n现在我不这么认为了，是刺激和快乐让人不断的去做一些事情。\r\n人和人的不同在于不同的事情给人的快乐并不一样，有些人能发现一些事情的快乐，\r\n而另外的人则不能。\r\n\r\n基于真善美，在自然与社会的规律下，过得最快乐。\r\n很多人并不懂怎么快乐，不是吗？ 快乐有方法有技巧。\r\n在一个人没发现一件事情的纯然快乐时，要靠坚持和耐心渡过一些时期。\r\n或许还要一些技巧。
363	1817	attr	description	source /opt/rh/llvm-toolset-7/enable\r\nsource /opt/rh/devtoolset-7/enable\r\n\r\n注意有时候加到bashrc也没生效，可能是有些脚本启动后环境变化引起。\r\n可以在当前session中再次执行上述命令，再执行脚本试试	升级：\r\n$ sudo yum install centos-release-scl\r\n$ sudo yum install devtoolset-7\r\n\r\n生效：\r\n$ source /opt/rh/devtoolset-7/enable\r\nor\r\n$ source scl_source enable devtoolset-7\r\n\r\nsource /opt/rh/llvm-toolset-7/enable\r\nsource /opt/rh/devtoolset-7/enable\r\n\r\n注意有时候加到bashrc也没生效，可能是有些脚本启动后环境变化引起。\r\n可以在当前session中再次执行上述命令，再执行脚本试试
366	1837	attr	description	1，计算机的发明\r\n  这是数学理论（二进制，布尔代数，数理逻辑）等学科发展，以及物理（电磁，晶体管）等发展的背景下产生的。\r\n  也是计算需求激增下的必然，为什么计算激增？这又跟航海和军事等有关系。\r\n2，指针是什么\r\n  指针是可变的间接地址。不是直接地址(变量名)，也不是间接地址（引用）。\r\n3，C语言引入了什么？\r\n  确定了高级语言的雏形，作用域？类型系统？结构体？编译跨平台？\r\n4，动作，增删改查 4个基本动作，执行流程，顺序，选择，循环执行的理解\r\n4.1 动作对称性\r\n5，实体，数据结构，组合与关系的理解\r\n6，接口与抽象\r\n6，可见性，不同层次\r\n6，模块化，空间隔离性，空间的本质就是隔离性，在有限时间内不可达到。\r\n7，可变性\r\n8，原子性\r\n9，一致性，顺序，因果\r\n10，时间，时间是顺序，也是因果，时间具备全局性。\r\n11，持久性\r\n12，复杂性\r\n12，并发性\r\n13，约束	1，计算机的发明\r\n  这是数学理论（二进制，布尔代数，数理逻辑）等学科发展，以及物理（电磁，晶体管）等发展的背景下产生的。\r\n  也是计算需求激增下的必然，为什么计算激增？这又跟航海和军事等有关系。\r\n2，指针是什么\r\n  指针是可变的间接地址。不是直接地址(变量名)，也不是间接地址（引用）。\r\n3，C语言引入了什么？\r\n  确定了高级语言的雏形，作用域？类型系统？结构体？编译跨平台？\r\n4，动作，增删改查 4个基本动作，执行流程，顺序，选择，循环执行的理解\r\n4.1 动作对称性\r\n5，实体，数据结构，组合与关系的理解\r\n6，接口与抽象，接口的本质是等价性，等价性有个特征是可替换，即实现了内部可变性。\r\n6，可见性，不同层次\r\n6，模块化，空间隔离性，空间的本质就是隔离性，在有限时间内不可达到。\r\n7，可变性\r\n8，原子性\r\n9，一致性，顺序，因果\r\n10，时间，时间是顺序，也是因果，时间具备全局性。\r\n11，持久性\r\n12，复杂性\r\n12，并发性\r\n13，约束
365	1836	attr	description	1，计算机的发明\r\n  这是数学理论（二进制，布尔代数，数理逻辑）等学科发展，以及物理（电磁，晶体管）等发展的背景下产生的。\r\n  也是计算需求激增下的必然，为什么计算激增？这又跟航海和军事等有关系。\r\n2，指针是什么\r\n  指针是可变的间接地址。不是直接地址(变量名)，也不是间接地址（引用）。\r\n3，C语言引入了什么？\r\n  确定了高级语言的雏形，作用域？类型系统？结构体？编译跨平台？\r\n4，动作，增删改查 4个基本动作，执行流程，顺序，选择，循环执行的理解\r\n5，实体，数据结构，组合与关系的理解\r\n6，接口与抽象\r\n6，可见性，不同层次\r\n6，模块化，空间隔离性，空间的本质就是隔离性，在有限时间内不可达到。\r\n7，可变性\r\n8，原子性\r\n9，一致性，顺序，因果\r\n10，时间，时间是顺序，也是因果，时间具备全局性。\r\n11，持久性\r\n12，复杂性\r\n12，并发性	1，计算机的发明\r\n  这是数学理论（二进制，布尔代数，数理逻辑）等学科发展，以及物理（电磁，晶体管）等发展的背景下产生的。\r\n  也是计算需求激增下的必然，为什么计算激增？这又跟航海和军事等有关系。\r\n2，指针是什么\r\n  指针是可变的间接地址。不是直接地址(变量名)，也不是间接地址（引用）。\r\n3，C语言引入了什么？\r\n  确定了高级语言的雏形，作用域？类型系统？结构体？编译跨平台？\r\n4，动作，增删改查 4个基本动作，执行流程，顺序，选择，循环执行的理解\r\n4.1 动作对称性\r\n5，实体，数据结构，组合与关系的理解\r\n6，接口与抽象\r\n6，可见性，不同层次\r\n6，模块化，空间隔离性，空间的本质就是隔离性，在有限时间内不可达到。\r\n7，可变性\r\n8，原子性\r\n9，一致性，顺序，因果\r\n10，时间，时间是顺序，也是因果，时间具备全局性。\r\n11，持久性\r\n12，复杂性\r\n12，并发性\r\n13，约束
367	1842	attr	description	需要将其结合起来，心灵意识让我们有了认知，客观与实践让我们修正认识。\r\n\r\n科学的一个重要特征是可证伪，即判断的统一标准。\r\n而宗教，基督教最初对于统一认知的追求促进了科学的发展。\r\n宗教显然比追求利益的政治团体更能促进科学的进步。\r\n我觉得这是很多团队无法孕育出科学的根本原因。\r\n\r\n各路大神，牛人都在搞什么，就是在看自己能认知世界万物到什么层次。	需要将其结合起来，心灵意识让我们有了认知，客观与实践让我们修正认识。\r\n\r\n科学的一个重要特征是可证伪，即判断的统一标准。\r\n而宗教，基督教最初对于统一认知的追求促进了科学的发展。\r\n宗教显然比追求利益的政治团体更能促进科学的进步。\r\n我觉得这是很多团队无法孕育出科学的根本原因。\r\n\r\n各路大神，牛人都在搞什么，就是在看自己能认知世界万物到什么层次。以及能做出什么样的行为。
368	1853	attr	description	真相是我们做自由抉择的基础，如果没有真相，那就没有自由。\r\n为什么理解很重要。	真相是我们做自由抉择的基础，如果没有真相，那就没有自由。\r\n为什么理解很重要。选择我们所关注的事情很重要，没人应该做乌合之众。没人应该把自己的大脑交给别人。
369	1855	attr	description	冰与火：只有一个神，就是死神。\r\n不必恐惧，每个人都有自己当下的状态，不能说我们没达到某个状态就心生恐惧。	冰与火：只有一个神，就是死神。\r\n不必恐惧，每个人都有自己当下的状态，不能说我们没达到某个状态就心生恐惧。\r\n\r\n强大得有强大的世界观和方法论。按逻辑而行。\r\n经济只是世界的一个维度，有人以为它超越了灵魂的重要性。
370	1856	attr	subject	逻辑，真相，抉择	逻辑，真相，抉择, 死亡
371	1860	attr	description	这两问题都没有终极答案，但是我们可以在自己的认知内给出自己的答案。\r\n\r\n我把世界等有复杂结构的事物称为系统。系统的逻辑维度观察称为形式系统。\r\n不同形式系统之间能否相容取决于公理(即共识，所以为什么共识如此重要，信用如此重要)。\r\n大家公认的建立共识的方法是辩证法，科学，是要求符合大家所观察的客观系统，即世界或宇宙系统。\r\n当然部分信徒之间可能是信仰神学。\r\n因此人是一个形式系统，动物是一个形式系统，计算机是一个形式系统。\r\n形式系统主要研究主体是概念定义，公理，定理，规则逻辑，行为，变化，关系等等。\r\n\r\n以计算机举例，计算机系统就是通过数学方法表达事物的某些维度特征(编码)，\r\n然后进行计算，和转换得到我们想要的行为或软件实体的过程。从某种角度看状态和行为是统一的，就像变量和函数在形式上也可以统一。\r\n\r\n另外人还有一个系统是情感系统，人的恐惧，悲伤，爱恨情仇属于这个系统，这个系统并非形式化的。\r\n而且通常人是被这个系统所支配的。这个系统人类有非常多的研究思考，道家，儒家，佛家，以及心理学等等。\r\n\r\n如同通篇来看一个人，形式系统如同高山，情感系统如同大海。高山虽高，但只要不失足不走死胡同，总可以达到更高境界。\r\n大海则没有绝对的方向，心安风平浪静，焦躁则暴风骤雨。魔怪就在自己心中。\r\n\r\n以上是一点点感悟的总结，当然尤其我这个形式系统的认知所限，特地限定了自己的思维范围。\r\n广阔的宇宙，微观的粒子，恶魔的炼狱，荣耀的圣殿，没思考或未能身临其境不做设想。\r\n\r\n\r\n\r\n	这两问题都没有终极答案，但是我们可以在自己的认知内给出自己的答案。\r\n\r\n我把世界等有复杂结构的事物称为系统。系统的逻辑维度观察称为形式系统。\r\n不同形式系统之间能否相容取决于公理(即共识，所以为什么共识如此重要，信用如此重要)。\r\n大家公认的建立共识的方法是辩证法，科学，是要求符合大家所观察的客观系统，即世界或宇宙系统。\r\n当然部分信徒之间可能是信仰神学。\r\n因此人是一个形式系统，动物是一个形式系统，计算机是一个形式系统。\r\n形式系统主要研究主体是概念定义，公理，定理，规则逻辑，行为，变化，关系等等。\r\n\r\n以计算机举例，计算机系统就是通过数学方法表达事物的某些维度特征(编码)，\r\n然后进行计算，和转换得到我们想要的行为或软件实体的过程。从某种角度看状态和行为是统一的，就像变量和函数在形式上也可以统一。\r\n\r\n另外人还有一个系统是情感系统，人的恐惧，悲伤，爱恨情仇属于这个系统，这个系统并非形式化的。\r\n而且通常人是被这个系统所支配的。这个系统人类有非常多的研究思考，道家，儒家，佛家，以及心理学等等。\r\n\r\n如同通篇来看一个人，形式系统如同高山，情感系统如同大海。高山虽高，但只要不失足不走死胡同，总可以达到更高境界。\r\n大海则没有绝对的方向，心安风平浪静，焦躁则暴风骤雨。魔怪就在自己心中。\r\n\r\n以上是一点点感悟的总结，当然尤其我这个形式系统的认知所限，特地限定了自己的思维范围。\r\n广阔的宇宙，微观的粒子，恶魔的炼狱，荣耀的圣殿，没思考或未能身临其境不做设想。\r\n\r\n另外知识也不应该是霸凌的理由，任何人不应该因为缺乏知识(即自己形式系统的完善度)而让自己的情感系统被别人压制。\r\n也就是赛德克巴莱中原始部落反抗的意义，科技，文明低等并不代表情感也低等，灵魂也低等。\r\n\r\n\r\n
372	1861	attr	description	这两问题都没有终极答案，但是我们可以在自己的认知内给出自己的答案。\r\n\r\n我把世界等有复杂结构的事物称为系统。系统的逻辑维度观察称为形式系统。\r\n不同形式系统之间能否相容取决于公理(即共识，所以为什么共识如此重要，信用如此重要)。\r\n大家公认的建立共识的方法是辩证法，科学，是要求符合大家所观察的客观系统，即世界或宇宙系统。\r\n当然部分信徒之间可能是信仰神学。\r\n因此人是一个形式系统，动物是一个形式系统，计算机是一个形式系统。\r\n形式系统主要研究主体是概念定义，公理，定理，规则逻辑，行为，变化，关系等等。\r\n\r\n以计算机举例，计算机系统就是通过数学方法表达事物的某些维度特征(编码)，\r\n然后进行计算，和转换得到我们想要的行为或软件实体的过程。从某种角度看状态和行为是统一的，就像变量和函数在形式上也可以统一。\r\n\r\n另外人还有一个系统是情感系统，人的恐惧，悲伤，爱恨情仇属于这个系统，这个系统并非形式化的。\r\n而且通常人是被这个系统所支配的。这个系统人类有非常多的研究思考，道家，儒家，佛家，以及心理学等等。\r\n\r\n如同通篇来看一个人，形式系统如同高山，情感系统如同大海。高山虽高，但只要不失足不走死胡同，总可以达到更高境界。\r\n大海则没有绝对的方向，心安风平浪静，焦躁则暴风骤雨。魔怪就在自己心中。\r\n\r\n以上是一点点感悟的总结，当然尤其我这个形式系统的认知所限，特地限定了自己的思维范围。\r\n广阔的宇宙，微观的粒子，恶魔的炼狱，荣耀的圣殿，没思考或未能身临其境不做设想。\r\n\r\n另外知识也不应该是霸凌的理由，任何人不应该因为缺乏知识(即自己形式系统的完善度)而让自己的情感系统被别人压制。\r\n也就是赛德克巴莱中原始部落反抗的意义，科技，文明低等并不代表情感也低等，灵魂也低等。\r\n\r\n\r\n	这两问题都没有终极答案，但是我们可以在自己的认知内给出自己的答案。\r\n\r\n我把世界等有复杂结构的事物称为系统。系统的逻辑维度观察称为形式系统。\r\n不同形式系统之间能否相容取决于公理(即共识，所以为什么共识如此重要，信用如此重要)。\r\n大家公认的建立共识的方法是辩证法，科学，是要求符合大家所观察的客观系统，即世界或宇宙系统。\r\n当然部分信徒之间可能是信仰神学。\r\n因此人是一个形式系统，动物是一个形式系统，计算机是一个形式系统。\r\n形式系统主要研究主体是概念定义，公理，定理，规则逻辑，行为，变化，关系等等。\r\n\r\n以计算机举例，计算机系统就是通过数学方法表达事物的某些维度特征(编码)，\r\n然后进行计算，和转换得到我们想要的行为或软件实体的过程。从某种角度看状态和行为是统一的，就像变量和函数在形式上也可以统一。\r\n\r\n另外人还有一个系统是情感系统，人的恐惧，悲伤，爱恨情仇属于这个系统，这个系统并非形式化的。\r\n而且通常人是被这个系统所支配的。这个系统人类有非常多的研究思考，道家，儒家，佛家，以及心理学等等。\r\n\r\n如同通篇来看一个人，形式系统如同高山，情感系统如同大海。高山虽高，但只要不失足不走死胡同，总可以达到更高境界。\r\n大海则没有绝对的方向，心安风平浪静，焦躁则暴风骤雨。魔怪就在自己心中。\r\n\r\n以上是一点点感悟的总结，当然尤其我这个形式系统的认知所限，特地限定了自己的思维范围。\r\n广阔的宇宙，微观的粒子，恶魔的炼狱，荣耀的圣殿，没思考或未能身临其境不做设想。\r\n\r\n另外知识也不应该是霸凌的理由，任何人不应该因为缺乏知识(即自己形式系统的完善度)而让自己的情感系统被别人压制。\r\n也就是赛德克巴莱中原始部落反抗的意义，科技，文明低等并不代表情感也低等，灵魂也低等，虽然落后会挨打。\r\n这就是自由平等。失去财富人不一定会反抗，但失去灵魂也不反抗就真的死亡了。\r\n\r\n\r\n
373	1862	attr	description	这两问题都没有终极答案，但是我们可以在自己的认知内给出自己的答案。\r\n\r\n我把世界等有复杂结构的事物称为系统。系统的逻辑维度观察称为形式系统。\r\n不同形式系统之间能否相容取决于公理(即共识，所以为什么共识如此重要，信用如此重要)。\r\n大家公认的建立共识的方法是辩证法，科学，是要求符合大家所观察的客观系统，即世界或宇宙系统。\r\n当然部分信徒之间可能是信仰神学。\r\n因此人是一个形式系统，动物是一个形式系统，计算机是一个形式系统。\r\n形式系统主要研究主体是概念定义，公理，定理，规则逻辑，行为，变化，关系等等。\r\n\r\n以计算机举例，计算机系统就是通过数学方法表达事物的某些维度特征(编码)，\r\n然后进行计算，和转换得到我们想要的行为或软件实体的过程。从某种角度看状态和行为是统一的，就像变量和函数在形式上也可以统一。\r\n\r\n另外人还有一个系统是情感系统，人的恐惧，悲伤，爱恨情仇属于这个系统，这个系统并非形式化的。\r\n而且通常人是被这个系统所支配的。这个系统人类有非常多的研究思考，道家，儒家，佛家，以及心理学等等。\r\n\r\n如同通篇来看一个人，形式系统如同高山，情感系统如同大海。高山虽高，但只要不失足不走死胡同，总可以达到更高境界。\r\n大海则没有绝对的方向，心安风平浪静，焦躁则暴风骤雨。魔怪就在自己心中。\r\n\r\n以上是一点点感悟的总结，当然尤其我这个形式系统的认知所限，特地限定了自己的思维范围。\r\n广阔的宇宙，微观的粒子，恶魔的炼狱，荣耀的圣殿，没思考或未能身临其境不做设想。\r\n\r\n另外知识也不应该是霸凌的理由，任何人不应该因为缺乏知识(即自己形式系统的完善度)而让自己的情感系统被别人压制。\r\n也就是赛德克巴莱中原始部落反抗的意义，科技，文明低等并不代表情感也低等，灵魂也低等，虽然落后会挨打。\r\n这就是自由平等。失去财富人不一定会反抗，但失去灵魂也不反抗就真的死亡了。\r\n\r\n\r\n	这两问题都没有终极答案，但是我们可以在自己的认知内给出自己的答案。\r\n\r\n我把世界等有复杂结构的事物称为系统。系统的逻辑维度观察称为形式系统。\r\n不同形式系统之间能否相容取决于公理(即共识，所以为什么共识如此重要，信用如此重要)。\r\n大家公认的建立共识的方法是辩证法，科学，是要求符合大家所观察的客观系统，即世界或宇宙系统。\r\n当然部分信徒之间可能是信仰神学。\r\n因此人是一个形式系统，动物是一个形式系统，计算机是一个形式系统。\r\n形式系统主要研究主体是概念定义，公理，定理，规则逻辑，行为，变化，关系等等。\r\n\r\n以计算机举例，计算机系统就是通过数学方法表达事物的某些维度特征(编码)，\r\n然后进行计算，和转换得到我们想要的行为或软件实体的过程。从某种角度看状态和行为是统一的，就像变量和函数在形式上也可以统一。\r\n\r\n另外人还有一个系统是情感系统，人的恐惧，悲伤，爱恨情仇属于这个系统，这个系统并非形式化的。\r\n而且通常人是被这个系统所支配的。这个系统人类有非常多的研究思考，道家，儒家，佛家，以及心理学等等。\r\n\r\n如同通篇来看一个人，形式系统如同高山，情感系统如同大海。高山虽高，但只要不失足不走死胡同，总可以达到更高境界。\r\n大海则没有绝对的方向，心安风平浪静，焦躁则暴风骤雨。魔怪就在自己心中。\r\n\r\n以上是一点点感悟的总结，当然尤其我这个形式系统的认知所限，特地限定了自己的思维范围。\r\n广阔的宇宙，微观的粒子，恶魔的炼狱，荣耀的圣殿，没思考或未能身临其境不做设想。\r\n\r\n另外知识也不应该是霸凌的理由，任何人不应该因为缺乏知识(即自己形式系统完善度低)而让自己的情感系统被别人压制。\r\n也就是赛德克巴莱中原始部落反抗的意义，科技，文明低等并不代表情感也低等，灵魂也低等，虽然落后会挨打。\r\n这就是自由平等。失去财富人不一定会反抗，但失去灵魂也不反抗就真的死亡了。\r\n\r\n\r\n
374	1868	attr	subject	coral库性能测试	coral库预读性能测试
375	1873	attr	description	1，开发平台会提供硬件，操作系统，语言的抽象\r\n2，开发平台提供解决日志，运维，分布式，复制，网络，线程运行主体等通用功能。\r\n3，软件开发人员只需做逻辑部分即可。\r\n\r\n能否利用rust语言提供的这种能力去做到呢？	1，开发平台会提供硬件，操作系统，语言的抽象\r\n2，开发平台提供解决日志，运维，分布式，复制，网络，线程运行主体等通用功能。\r\n3，软件开发人员只需做逻辑部分即可。\r\n4，开发平台应该能自动化测试程序，并且检查程序的各种环节，命名统一性等等。\r\n\r\n能否利用rust语言提供的这种能力去做到呢？\r\n开发人员拿到平台，只写逻辑代码即可。\r\n
376	1875	attr	subject	开发平台的发展方向	开发平台的发展方向（用语言来包裹平台）
377	1878	attr	project_id	6	7
378	1879	attr	subject	动作的复杂性	动作的特征
379	1879	attr	description	动作复杂有三个方面：\r\n1，动作分非常多的工序\r\n2，动作涉及很多实体\r\n3，动作有一定的特性要求，比如原子性，一致性	动作复杂有三个方面：\r\n1，动作分非常多的工序\r\n2，动作涉及很多实体\r\n3，动作有一定的特性要求，比如原子性，一致性\r\n\r\n动作完备性是软件的bug之源，而对称性是解决完备性的方法之一。
380	1882	attr	subject	事务的问题	事务并发问题(存储开发的基本功，高价值)
381	1883	attr	description	1，减少不必要的工作，算法优化\r\n  比如数据库中的filter以及project，都是去掉实际不参与运算的数据。\r\n2，并行化，分布式\r\n  多个人干活\r\n3，批量化\r\n  一次处理更多，吞吐量优化\r\n4，cache以及预计算\r\n  cache本质上是将动作缓存，即用空间换时间，用状态缓存代替运算动作。\r\n\r\n基本原理：\r\n1，木桶原理\r\n	1，减少不必要的工作，算法优化\r\n  比如数据库中的filter以及project，都是去掉实际不参与运算的数据。\r\n  减少数据拷贝，copyOnWrite，减少io，减少网络交互。\r\n2，并行化，分布式，无锁化\r\n  多个人干活\r\n3，批量化\r\n  一次处理更多，吞吐量优化\r\n4，cache以及预计算\r\n  cache本质上是将动作缓存，即用空间换时间，用状态缓存代替运算动作。\r\n\r\n基本原理：\r\n1，木桶原理\r\n
385	1896	attr	description	软件错误的来源：\r\n1，不对称的动作\r\n  隐含的约束动作是很多bug的根源，直接造成实体的损害。\r\n2，错误的变量值\r\n  计算表达式不对，边界异常\r\n3，因果错误，并发下的因果错误\r\n  读写变量的因果无法得以保证等引起的问题。\r\n  不可并发也是一种常见的因果错误。	软件错误的来源：\r\n1，不对称的动作\r\n  隐含的约束动作是很多bug的根源，直接造成实体的损害。\r\n  此问题rust无法杜绝(因而rust仍然有资源泄漏等问题)\r\n2，错误的变量值\r\n  计算表达式不对（当然rust也没法杜绝这种错误）\r\n  边界异常等(通过边界检查，rust可杜绝此类错误)\r\n3，因果错误，并发下的因果错误，持久化重启后的因果错误。\r\n  读写变量的因果无法得以保证等引起的问题。\r\n  不可并发也是一种常见的因果错误。（通过唯一可变的约束，以及锁等保护）
386	1898	attr	description	软件错误的来源：\r\n1，不对称的动作\r\n  隐含的约束动作是很多bug的根源，直接造成实体的损害。\r\n  此问题rust无法杜绝(因而rust仍然有资源泄漏等问题)\r\n2，错误的变量值\r\n  计算表达式不对（当然rust也没法杜绝这种错误）\r\n  边界异常等(通过边界检查，rust可杜绝此类错误)\r\n3，因果错误，并发下的因果错误，持久化重启后的因果错误。\r\n  读写变量的因果无法得以保证等引起的问题。\r\n  不可并发也是一种常见的因果错误。（通过唯一可变的约束，以及锁等保护）	软件错误的来源：\r\n1，不对称的动作\r\n  隐含的约束动作是很多bug的根源，直接造成实体的损害。\r\n  此问题rust无法杜绝(因而rust仍然有资源泄漏等问题)\r\n2，错误的变量值\r\n  计算表达式不对（当然rust也没法杜绝这种错误）\r\n  边界异常等(通过边界检查，rust可杜绝此类错误)\r\n3，因果错误，并发下的因果错误，持久化重启后的因果错误。\r\n  读写变量的因果无法得以保证等引起的问题。\r\n  不可并发也是一种常见的因果错误。（通过唯一可变的约束，以及锁等保护）\r\n4，间接因果，条件因果\r\n  比如if a {\r\n       do b;\r\n       do c;\r\n       do d; \r\n     }\r\n  b,c,d能修改的间接原因是a，如果a在其他地方变化，就会影响这里的果。\r\n  \r\n  \r\n\r\n 
387	1903	attr	description	编码：\r\nck列的类型可指定。\r\n\r\nhttps://clickhouse.com/docs/en/\r\nCH存在的原因，OLAP业务特征。\r\n\r\nhttps://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/custom-partitioning-key/\r\nhttps://www.modb.pro/db/55689\r\n这篇文章介绍了CH是写入就形成片段，然后在后台做合并的写入模式。适合导入但不适合写入。\r\n新版本增加WAL提升写入性能。\r\n\r\n配置项：\r\nhttps://clickhouse.com/docs/en/operations/settings/settings/?version=2.5.50000.157&platform=win\r\n\r\n压缩算法：None、LZ4、ZSTD，默认使用的lz4.\r\nuse_uncompressed_cache\r\nWhether to use a cache of uncompressed blocks. Accepts 0 or 1. By default, 0 (disabled). 优化小查询\r\n相关配置merge_tree_max_rows_to_use_cache，merge_tree_max_bytes_to_use_cache\r\n\r\n预读\r\n从目前资料看没支持预读，利用的文件系统的预读能力。\r\n\r\ncache\r\nhttps://clickhouse.com/docs/en/operations/caches/\r\nuncompressed_cache机制：针对短小的请求进行数据缓存。\r\nhttps://clickhouse.com/docs/en/operations/settings/settings/#setting-use_uncompressed_cache\r\n\r\nDictionaries data cache：这个可支持使用SSD_CACHE\r\n\r\nCH的基本介绍，以及使用\r\nhttps://toutiao.io/posts/ugmca67/preview	编码：\r\nck列的类型可指定。压缩类型也可指定\r\n\r\nhttps://clickhouse.com/docs/en/\r\nCH存在的原因，OLAP业务特征。\r\n\r\nhttps://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/custom-partitioning-key/\r\nhttps://www.modb.pro/db/55689\r\n这篇文章介绍了CH是写入就形成片段，然后在后台做合并的写入模式。适合导入但不适合写入。\r\n新版本增加WAL提升写入性能。\r\n\r\n配置项：\r\nhttps://clickhouse.com/docs/en/operations/settings/settings/?version=2.5.50000.157&platform=win\r\n\r\n压缩算法：None、LZ4、ZSTD，默认使用的lz4.\r\nuse_uncompressed_cache\r\nWhether to use a cache of uncompressed blocks. Accepts 0 or 1. By default, 0 (disabled). 优化小查询\r\n相关配置merge_tree_max_rows_to_use_cache，merge_tree_max_bytes_to_use_cache\r\n\r\n预读\r\n从目前资料看没支持预读，利用的文件系统的预读能力。\r\n\r\ncache\r\nhttps://clickhouse.com/docs/en/operations/caches/\r\nuncompressed_cache机制：针对短小的请求进行数据缓存。\r\nhttps://clickhouse.com/docs/en/operations/settings/settings/#setting-use_uncompressed_cache\r\n\r\nDictionaries data cache：这个可支持使用SSD_CACHE\r\n\r\nCH的基本介绍，以及使用\r\nhttps://toutiao.io/posts/ugmca67/preview
389	1908	attr	description	概念解释：\r\nextent：extent是column的一个数据片段，包含一个或多个block，其是压缩和IO的单位。\r\nblock：block是一个数据片段，对于列来说其是固定记录数量的，是编码的单位。\r\nzonemap：按页粒度的统计信息。因而数据过滤的单位也是页。\r\n\r\n数据布局(列数据布局，每列如此)：\r\n1，所有block元数据，extent元数据，zonemap作为列的元数据单独一个文件存放。\r\n2，数据的所有block单独存放。	概念解释：\r\nextent：extent是一个数据片段，包含一个或多个block，其是压缩和IO的单位。\r\nblock：block是一个数据片段，对于列来说其是固定记录数量的，是编码的单位。\r\nzonemap：按页粒度的统计信息。因而数据过滤的单位也是页。\r\n\r\n数据布局(列数据布局，每列如此)：\r\n1，所有block元数据，extent元数据，zonemap作为列的元数据单独一个文件存放。\r\n2，数据的所有block单独存放。\r\n\r\n列元数据结构:\r\ncolumn metadata {\r\n\textent\r\n\tblock\r\n\t[min,max]\t\r\n\t[aux(dictionary)]\r\n\t[history.min, history.max],\r\n\tcolumn meta\r\n}\r\n\r\n列数据结构：\r\nblock\r\n+\r\nblock\r\n+\r\nblock\r\n+\r\n...\r\n\r\nblock对于不同列，可能包含的数据稍微有点差别。
390	1911	attr	description	45岁之前功成的标准-500万，还完贷款，并且结余200万现金。\r\n实现途径：\r\n1，通过技术提升，找到年薪120万+的工作。\r\n2，做成一个项目并套现\r\n\r\n\r\n	45岁之前功成的标准-500万，还完贷款，并且结余200万现金。\r\n实现途径：\r\n1，通过技术提升，找到年薪120万+的工作。\r\n2，做成一个项目并套现。\r\n\r\n练功就得练到功成。\r\n\r\n\r\n
392	1924	attr	description	1，作为接口的数据结构其复杂度应该维持再多少？是暴露接口还是暴露结构？\r\n2，如何提前判断核心结构有无变化的可能性，从而导致接口无法适应？\r\n   比如undo接口，约定每次写入一条undo，且undo之间没关系？\r\n   比如Dc假设对象不会频繁truncate导致膨胀？当这种变化出现的时候，新需求原模块并没考虑到。如果仅仅为了功能糊上去就会有各种问题。软件随之腐烂。\r\n    	1，作为接口的数据结构其复杂度应该维持再多少？是暴露接口还是暴露结构？\r\n2，如何提前判断核心结构有无变化的可能性，从而导致接口无法适应？\r\n   比如undo接口，原来用法是prepare一次，把页面内的undo和xslot一起写入。\r\n   但是列存下，多个cbu都单独写undo，不能每次写一条undo就更新xslot。\r\n  原方案做成感知undo内部格式的，造成了强耦合，且逻辑上存在风险，判断undo页面复用有问题(需要在链上记录上一条undo 页面的version，然而方案中undo链没了)\r\n   这种情况实际上只能考虑在上层封装了，上层不应该直接遍历undo页面。这种最强耦合模式导致代码腐烂。\r\n   每个模块都有自己的接口，除了接口之外，使用者不应该有其他依赖。   \r\n\r\n   比如Dc假设对象不会频繁truncate导致膨胀？当这种变化出现的时候，新需求原模块并没考虑到。如果仅仅为了功能糊上去就会有各种问题。软件随之腐烂。\r\n    
449	2145	attr	description	1，锁，atomic与volatile\r\n2，mmap\r\n3，cacheline\r\n4，hashtable的冲突解决方法以及应用场景\r\n5，cache算法有哪些，区别是什么\r\n6，怎么理解ACID。\r\n7，MVCC是什么概念	1，锁，atomic与volatile\r\n2，mmap\r\n3，cacheline\r\n4，DIRECT与SYNC ioflag的作用。\r\n5，hashtable的冲突解决方法以及应用场景\r\n6，cache算法有哪些，区别是什么\r\n7，怎么理解ACID。\r\n8，MVCC是什么概念
393	1937	attr	description	IDE的核心功能：\r\n1，方便快速的在最近工作中来回切。\r\n  最近的文件应该以栈方式出现，方便找到。\r\n  应该能很方便的显示当前文件所在的目录，以及跳转到目录\r\n2，应该很方便的展示调用关系，查找使用的地方\r\n  Clion贴心的是把读写也分开了。\r\n3，要方便编辑，补全，提示，拼写检查，格式化等\r\n4，要能方便调试\r\n  Clion支持运行单个用例，VS也有，但是经常识别不了。  	IDE的核心功能：\r\n1，方便快速的在最近工作中来回切。\r\n  最近的文件应该以栈方式出现，方便找到。\r\n  应该能很方便的显示当前文件所在的目录，以及跳转到目录\r\n2，应该很方便的展示调用关系，查找使用的地方\r\n  Clion贴心的是把读写也分开了。\r\n  VS有个收费工具FastFind还不错\r\n3，要方便编辑，补全，提示，拼写检查，格式化等\r\n4，要能方便调试\r\n  Clion支持运行单个用例，VS也有，但是经常识别不了。  
394	1940	attr	description	目标\r\n算法与架构\r\n设计与计划\r\n编码\r\n测试\r\n\r\n如果从5个层次给程序员划分效能。\r\n那么掌握越高层次的人，效率越高，可能是*3关系。\r\n这样最优秀的执行任务的人跟普通人差距可能有243倍。\r\n如果普通打工人收入是10万，那么顶级人员按效能算，可以是2430万。\r\n\r\n注意我们在做事的效率取决于：\r\n1，从顶层我们能设计考虑到什么程度，如何纠偏，如何正确高效的做事。\r\n2，从底层如何落实，如何发现问题反馈给顶层，以做出调整。\r\n\r\n目标----痛感----效能 可以是一个三角。\r\n目标：应该是可以执行的，不然不称为事，即不可执行。\r\n痛感：保持痛感是生存的必须，但是并非恐惧，焦虑与狂躁。\r\n效能：人的做人做事能力，这个是改变的力量。没有此力量，人在自然规律，社会规则下就会到处受制，自由就是要不断的自我抉择，调整自己更好使得适应环境，改变环境。\r\n      这是生命该有的样子。也是少有人走的路，也是目的论的出发点。\r\n	目标\r\n算法与架构\r\n设计与计划\r\n编码\r\n测试\r\n\r\n如果从5个层次给程序员划分效能。\r\n那么掌握越高层次的人，效率越高，可能是*3关系。\r\n这样最优秀的执行任务的人跟普通人差距可能有243倍。\r\n如果普通打工人收入是10万，那么顶级人员按效能算，可以是2430万。\r\n\r\n注意我们在做事的效率取决于：\r\n1，从顶层我们能设计考虑到什么程度，如何纠偏，如何正确高效的做事。\r\n   从程序来说从顶层，我们可以将结构细化到何种程度？认知到哪些事物之间的关系？\r\n2，从底层如何落实，如何发现问题反馈给顶层，以做出调整。\r\n   对于认知不到的，再继续挖还不如干来得快，那我们先做一部分，然后再反推顶层。\r\n\r\n切记越高层越牛逼，不要为了短期完成任务蛮干而不掌握顶层能力。\r\n\r\n目标----痛感----效能 可以是一个三角。\r\n目标：应该是可以执行的，不然不称为事，即不可执行。\r\n痛感：保持痛感是生存的必须，但是并非恐惧，焦虑与狂躁。\r\n效能：人的做人做事能力，这个是改变的力量。没有此力量，人在自然规律，社会规则下就会到处受制，自由就是要不断的自我抉择，调整自己更好使得适应环境，改变环境。\r\n      这是生命该有的样子。也是少有人走的路，也是目的论的出发点。\r\n
398	1959	attachment	56	\N	软件真相.png
399	1960	attr	subject	SSDR 18: 里氏替换原则(扩展新实现的困难)	SSDR 18: 设计原则的理解
403	1969	attr	subject	SSDR5:原子性与一致性	SSDR5:并发性，原子性，一致性
404	1970	attr	subject	SSDR5:并发性，原子性，一致性	SSDR5: 行为的特性： 并发性，原子性，一致性
407	1976	attr	subject	研究兴趣-编译原理与代码生成	研究兴趣-编译原理与代码生成，及管理革命
409	1981	attr	description	内联函数的coredump堆栈异常问题\r\n\r\n代码函数如下：\r\n\r\nxx.h\r\nstatic inline function doxx()\r\n{\r\n\r\n  COD_ASSERT(xx)\r\n}\r\n\r\nyy.c\r\nfunction example() \r\n{\r\n   COD_ASSERT(xx);\r\n   doxx();  \r\n}\r\n\r\n代码core掉，coredump堆栈显示core在doxx的COD_ASSERT.\r\n然而定位下来发现实际core是在example中的COD_ASSERT。\r\n\r\n这样导致误判问题出现的现场，怎么分析都发现不了问题。\r\n切记存在该情况，如果带inline函数，实际core的地方可能并非如coredump所示。	<pre>\r\n内联函数的coredump堆栈异常问题\r\n\r\n代码函数如下：\r\n\r\nxx.h\r\nstatic inline function doxx()\r\n{\r\n\r\n  COD_ASSERT(xx)\r\n}\r\n\r\n注:.c中的inline同样有此问题,单纯static无此问题\r\n\r\nyy.c\r\nfunction example() \r\n{\r\n   COD_ASSERT(xx);\r\n   doxx();  \r\n}\r\n\r\n代码core掉，coredump堆栈显示core在doxx的COD_ASSERT.\r\n然而定位下来发现实际core是在example中的COD_ASSERT。\r\n\r\n这样导致误判问题出现的现场，怎么分析都发现不了问题。\r\n切记存在该情况，如果带inline函数，实际core的地方可能并非如coredump所示。\r\n</pre>
410	1986	attr	subject	编程如临深渊，如履薄冰，怎么破	编程如临深渊，如履薄冰，怎么破 (如无约束即可为)
417	2028	attr	description	1，需求调研 -- 系统与哲学，经济学等等\r\n2，设计   -- 数学\r\n3，执行  --管理学\r\n4，开发与自验证  -- 语义，逻辑，语言以及工程\r\n5，review  -- 沟通交流\r\n6，publish - 沟通	1，需求调研 -- 系统与哲学，经济学等等\r\n2，设计   -- 数学，从问题抽象，以及原理上阐述。\r\n3，执行  --管理学， 执行表单算法，可以随时补缺，跟踪进度。\r\n4，开发与自验证  -- 语义，逻辑，语言以及工程\r\n5，review  -- checklist，沟通交流\r\n6，publish - 沟通
419	2033	attr	subject	SSDR 35:如何描述问题	SSDR 35:如何描述问题或目标
420	2034	attr	description	原则：在保持连贯的前提下尽可能少费力的快速移动。\r\n\r\n要少费力必须减少起跳和并步。\r\n那问题就在于如何发挥交叉步的威力。\r\n\r\n交叉步与散步区别在于驱动力不一样。散步时是大腿上抬发力。交叉步是大腿小腿蹬地发力。\r\n显然蹬地更快，也稍微费力点，但是比起跳和并步对小腿力量要求好很多。	原则：在保持连贯的前提下尽可能少费力的快速移动。\r\n\r\n要少费力必须减少起跳和并步。\r\n那问题就在于如何发挥交叉步的威力。\r\n\r\n交叉步与散步区别在于驱动力不一样。散步时是大腿上抬发力。交叉步是大腿小腿蹬地发力。\r\n显然蹬地更快，也稍微费力点，但是比起跳和并步对小腿力量要求好很多。\r\n\r\n1，保持持续移动，利用惯性，不要停下来。\r\n2，把握节奏，改变步伐对上节奏。\r\n
421	2036	attr	description	首先我们得有实体结构，然后我们需要回答：\r\n1，谁的问题\r\n  如果搞不清楚这个，通常解决方案是混乱的。\r\n  甚至我们不能把问题分开，问题a和问题b是什么关系？\r\n\r\n2，什么问题，这个要用数学，逻辑语言来描述。\r\n  要证明为什么能解决问题，方案的优劣等。\r\n  不要用应该是，可能，大概率等。这样得不出什么，也构建不了知识的大厦。	首先我们得有实体结构，然后我们需要回答：\r\n1，谁的问题\r\n  如果搞不清楚这个，通常解决方案是混乱的。\r\n  甚至我们不能把问题分开，问题a和问题b是什么关系？\r\n\r\n2，什么问题，这个要用数学，逻辑语言来描述。\r\n  要证明为什么能解决问题，方案的优劣等。\r\n  不要用应该是，可能，大概率等。这样得不出什么，也构建不了知识的大厦。\r\n\r\n3，不同的目标或问题分别对待，以降低复杂度。如无必要尽量分离。（低耦合）
422	2046	attr	subject	朴素辩证法-太极，松弛，矛盾	朴素辩证法-自然的归纳-太极，松弛，矛盾
423	2046	attr	description	其本质都在描述事物内部不仅有矛盾，而且内部力量必然引起转化。\r\n而且这种转化不仅是必然的，而且是需要的。\r\n\r\n而我们就应该专注于当下，才能让毛和盾都完满。犹如太极。	其本质都在描述事物内部不仅有矛盾，而且内部力量必然引起转化。\r\n而且这种转化不仅是必然的，而且是需要的。\r\n\r\n而我们就应该专注于当下，才能让毛和盾都完满。犹如太极。\r\n又犹如打羽毛球，必须很松，然后才能很紧。\r\n这是因为事物都有内部矛盾，即有变化。
395	1941	attr	description	目标\r\n算法与架构\r\n设计与计划\r\n编码\r\n测试\r\n\r\n如果从5个层次给程序员划分效能。\r\n那么掌握越高层次的人，效率越高，可能是*3关系。\r\n这样最优秀的执行任务的人跟普通人差距可能有243倍。\r\n如果普通打工人收入是10万，那么顶级人员按效能算，可以是2430万。\r\n\r\n注意我们在做事的效率取决于：\r\n1，从顶层我们能设计考虑到什么程度，如何纠偏，如何正确高效的做事。\r\n   从程序来说从顶层，我们可以将结构细化到何种程度？认知到哪些事物之间的关系？\r\n2，从底层如何落实，如何发现问题反馈给顶层，以做出调整。\r\n   对于认知不到的，再继续挖还不如干来得快，那我们先做一部分，然后再反推顶层。\r\n\r\n切记越高层越牛逼，不要为了短期完成任务蛮干而不掌握顶层能力。\r\n\r\n目标----痛感----效能 可以是一个三角。\r\n目标：应该是可以执行的，不然不称为事，即不可执行。\r\n痛感：保持痛感是生存的必须，但是并非恐惧，焦虑与狂躁。\r\n效能：人的做人做事能力，这个是改变的力量。没有此力量，人在自然规律，社会规则下就会到处受制，自由就是要不断的自我抉择，调整自己更好使得适应环境，改变环境。\r\n      这是生命该有的样子。也是少有人走的路，也是目的论的出发点。\r\n	目标\r\n算法与架构\r\n设计与计划\r\n编码\r\n测试\r\n\r\n如果从5个层次给程序员划分效能。\r\n那么掌握越高层次的人，效率越高，可能是*3关系。\r\n这样最优秀的执行任务的人跟普通人差距可能有243倍。\r\n如果普通打工人收入是10万，那么顶级人员按效能算，可以是2430万。\r\n\r\n注意我们在做事的效率取决于：\r\n1，从顶层我们能设计考虑到什么程度，如何纠偏，如何正确高效的做事。\r\n   从程序来说从顶层，我们可以将结构细化到何种程度？认知到哪些事物之间的关系？\r\n2，从底层如何落实，如何发现问题反馈给顶层，以做出调整。\r\n   对于认知不到的，再继续挖还不如干来得快，那我们先做一部分，然后再反推顶层。\r\n\r\n切记越高层越牛逼，不要为了短期完成任务蛮干而不掌握顶层能力。\r\n\r\n目标----痛感----效能 可以是一个三角。\r\n目标：应该是可以执行的，不然不称为事，即不可执行。\r\n痛感：保持痛感是生存的必须，但是并非恐惧，焦虑与狂躁。\r\n效能：人的做人做事能力，积极作为，这个是改变的力量。没有此力量，人在自然规律，社会规则下就会到处受制，自由就是要不断的自我抉择，调整自己更好使得适应环境，改变环境。这是生命该有的样子。也是少有人走的路，也是目的论的出发点。\r\n
396	1944	attr	description	安装图形化界面\r\n\r\n步骤一：Centos7安装图形化界面\r\n\r\n切换到root用户\r\n\r\n# yum groupinstall "Server with GUI"\r\n# ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target\r\n# reboot\r\n\r\n步骤二：安装xrdp\r\n# yum install -y epel-release\r\n# yum install -y xrdp\r\n# systemctl enable xrdp\r\n# systemctl start xrdp\r\n# systemctl status xrdp\r\n\r\n步骤三：设置防火墙\r\n# firewall-cmd --permanent --zone=public --add-port=3389/tcp\r\n# firewall-cmd --reload\r\n# systemctl enable xrdp && systemctl restart xrdp\r\n\r\n步骤四：远程连接\r\n\r\nhttps://www.itzgeek.com/how-tos/linux/centos-how-tos/install-gnome-gui-on-centos-7-rhel-7.html	安装图形化界面\r\n\r\n步骤一：Centos7安装图形化界面，安装gnome\r\n\r\n切换到root用户，或sudo\r\n\r\n\r\n# yum groupinstall "Server with GUI"\r\n# ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target\r\n# reboot\r\n\r\n步骤二：安装xrdp\r\n# yum install -y epel-release\r\n# yum install -y xrdp\r\n# systemctl enable xrdp\r\n# systemctl start xrdp\r\n# systemctl status xrdp\r\n\r\n步骤三：设置防火墙\r\n# firewall-cmd --permanent --zone=public --add-port=3389/tcp\r\n# firewall-cmd --reload\r\n# systemctl enable xrdp && systemctl restart xrdp\r\n\r\n步骤四：远程连接\r\n\r\nhttps://www.itzgeek.com/how-tos/linux/centos-how-tos/install-gnome-gui-on-centos-7-rhel-7.html
397	1958	attachment	55	\N	软件真相.png
400	1964	attr	description	设计模式本质上是教我们一些常见场景的最佳编程实践。\r\n\r\n完全不用拘泥于23种或依赖关系。\r\n常用的有：\r\n状态机，\r\n应用栈，\r\n工厂(支持可变的生产商)，\r\n代理，\r\n构建器(处理复杂可变的构建过程)，\r\n克隆，\r\n单例，\r\n迭代器，\r\n适配器(From/to),\r\n事件监听器（处理有复杂多变的事件以及接收者）。\r\n	设计模式本质上是教我们一些常见场景的编程实践。当然是围绕如何处理可变性来的。\r\n\r\n完全不用拘泥于23种或依赖关系。\r\n常用的有：\r\n状态机（封装状态转换的原则），\r\n应用栈（简化N多对象分配和释放），\r\n工厂(支持可变的生产商)，\r\n代理（处理中间关系），\r\n构建器(处理复杂可变的构建过程)，\r\n克隆，\r\n单例，\r\n迭代器，\r\n适配器(From/to),\r\n事件监听器（处理有复杂多变的事件以及接收者）。\r\n
401	1967	attachment	57	\N	计算机认知.drawio
402	1967	attachment	58	\N	计算机认知-Page-2.png
405	1972	attr	subject	static & inline	static & inline & extern & 前置声明
406	1974	attr	description	SQL8 CK慢有两个原因：类似于select count(*) from ads_upc_online_store_sales_detail WHERE district = '乳源瑶族自治县' and sls_amt < 9999\r\n数据量3亿：\r\n1， district = '乳源瑶族自治县' 条件CK没法过滤，Coast可以过滤掉3/7 block。\r\n2， tightly优化，虽然扫描了接近1.8亿数据，但是满足的只有5万多条。不解码的数据拷贝功不可没。\r\n3， number类型计算慢，这个比1影响更大\r\n\r\n	SQL8 CK慢有两个原因：类似于select count(*) from ads_upc_online_store_sales_detail WHERE district = '乳源瑶族自治县' and sls_amt < 9999\r\n数据量3亿：\r\n1， district = '乳源瑶族自治县' 条件CK没法过滤，Coast可以过滤掉3/7 block。\r\n2， 行式过滤及tightly优化，虽然扫描了接近1.8亿数据，但是满足的只有5万多条。不解码的数据拷贝功不可没。\r\n3， number类型计算慢，这个比1影响更大\r\n\r\n
408	1977	attr	subject	技术的4个层次	技术的4个层次，程序员等级，评级
411	1995	attr	subject	SSDR5: 行为的特性： 并发性，原子性，一致性	SSDR5: 行为的特性： 原子性，顺序性，可见性，一致性
412	2005	attr	subject	SSDR 32：编程的维度	SSDR 32：编程需要考虑的维度
413	2005	attr	description	编程的维度：\r\n逻辑编程：\r\n1，正确性\r\n2，并发性，原子性，隔离，并发编程\r\n3，扩展性：接口与泛型编程\r\n\r\n硬件编程：\r\n1，高性能，硬件指令与算法优化\r\n2，分布性，协议与网络编程\r\n6，持久性，事务\r\n\r\n工程编程：\r\n7，兼容性，\r\n8，可靠性，副本冗余技术\r\n9，可维护性，可监控性，运维编程技术	编程的维度：\r\n逻辑编程：\r\n1，正确性\r\n   分布性，协议与网络编程\r\n   持久性，事务\r\n   并发性，原子性，隔离，并发编程\r\n2，可行性\r\n3，可维护\r\n\r\n效率编程：\r\n1，扩展性：接口与泛型编程\r\n2，高性能，硬件指令与算法优化\r\n3，兼容性\r\n4，资源消耗优化\r\n\r\n友好编程：\r\n1，人体工学，色彩，行为等\r\n2，可探测性\r\n3，引导性\r\n4，智能性
414	2012	attr	subject	佛洛依德与阿德勒	<被讨厌的勇气> 佛洛依德与阿德勒
415	2016	attr	subject	解决双重焦虑，再见光明	解决双重焦虑，再见光明(或是我的墓志铭)
416	2022	attr	subject	SSDR 32：编程需要考虑的维度	SSDR 32：编程需要考虑的维度  CheckList
450	2146	attr	description	1，锁，atomic与volatile\r\n2，mmap\r\n3，cacheline\r\n4，DIRECT与SYNC ioflag的作用。\r\n5，hashtable的冲突解决方法以及应用场景\r\n6，cache算法有哪些，区别是什么\r\n7，怎么理解ACID。\r\n8，MVCC是什么概念	1，锁，atomic与volatile\r\n2，mmap\r\n3，cacheline\r\n4，DIRECT与SYNC ioflag的作用。\r\n5，TCP\r\n6，hashtable的冲突解决方法以及应用场景\r\n7，cache算法有哪些，区别是什么\r\n8，怎么理解ACID。\r\n9，MVCC是什么概念
418	2029	attr	description	1，逻辑结构\r\n   目录结构：storage_root_path -> bucket -> tablet -> schemaHash(table)-> segments\r\n   单个表按行划分的逻辑结构：partition-> bucket -> rowsets。\r\n  \r\n   https://xie.infoq.cn/article/4f7d09d6185fb3055d4e7e51c\r\n   与coast对比：没有extent概念，page固定空间大小，默认64K。 按行对齐需使用OrdinalIndex，其是一个Btree索引。\r\n   编码单位：整列\r\n   压缩单位：Page\r\n   zonemap单位：Segment/Page\r\n   Bitmap索引：更像我们的字典编码\r\n\r\n   \r\n2，模块结构\r\n\r\n3，物理结构\r\n\r\n4，插入实现\r\n   https://xie.infoq.cn/article/4cc8416c0054bf6f2cdb8b16c\r\n   \r\n5，UniqueKey的更新/删除实现\r\n   https://xie.infoq.cn/article/4cc8416c0054bf6f2cdb8b16c   \r\n   unique key的实现：使用rowset记录删除/更新。但是需要进行逻辑合并。\r\n   \r\n6，UniqueKey查询实现\r\n   读时合并技术，基于UniqueKey。必须要unique，因为合并是根据key来的，而非rowid。\r\n   \r\n7，PrimaryKey下的更新/删除\r\n   https://docs.starrocks.com/zh-cn/main/table_design/Data_model\r\n   https://zhuanlan.zhihu.com/p/513426455	<pre>\r\n1，存储结构\r\n目录结构：storage_root_path -> bucket -> tablet -> schemaHash(table)-> segments\r\nhttps://xie.infoq.cn/article/4f7d09d6185fb3055d4e7e51c\r\n\r\n\r\n2，模块结构\r\n\r\n3，物理结构\r\n\r\n4，插入实现\r\nhttps://xie.infoq.cn/article/4cc8416c0054bf6f2cdb8b16c\r\n\r\n5，UniqueKey的更新/删除实现\r\nhttps://xie.infoq.cn/article/4cc8416c0054bf6f2cdb8b16c\r\nunique key的实现：\r\n\r\n使用rowset记录删除/更新。但是需要进行逻辑合并。\r\n\r\n更新：利用多版本，由于key是unique的，因而同一个key只要最新版本即可。\r\n\r\n删除：记录谓词条件。\r\n\r\n6，UniqueKey查询实现\r\n读时合并技术，基于UniqueKey。必须要unique，因为合并是根据key来的，而非rowid。\r\n\r\n参考源码：TabletReader::_init_collector\r\n\r\nhttps://www.slidestalk.com/doris.apache/15457\r\n\r\n7，PrimaryKey下的更新/删除\r\nhttps://docs.starrocks.com/zh-cn/main/table_design/Data_model\r\nhttps://zhuanlan.zhihu.com/p/513426455\r\n\r\n使用rocksdb存储del vector，采用roaring bitmap编码。\r\n\r\n\r\n\r\n8，预读\r\n\r\n没预读，使用文件系统预读能力。多线程直接读。\r\n\r\n\r\n\r\n9，缓存\r\n\r\nindex page 元数据与数据分离。都使用page cache，但是元数据会占一定比例。\r\n\r\n另外像PrimaryIndex这类数据支持缓存到内存，并未使用page cache。\r\n</pre>
424	2047	attr	subject	推动-迭代二特性设计风险排查	迭代二特性设计风险排查
426	2050	attr	description	错误：表达了因规格限制或物理限制(资源不足等)等原因导致行为失败。\r\nPANIC：没有妥当处理的错误。\r\nASSERT：表示不可打破的逻辑规则或约束。把这些潜在的规则或约束显式化。\r\n        \r\n\r\n问题：ASSERT与错误的区别是什么？能否用错误处理代替ASSERT？\r\n     区别是规则是否可能打破，可能则必须用错误处理。那么不可打破的规则能否使用错误？\r\n\r\n     可以，但是要考虑代价，性能代价和错误处理编写维护的代价。\r\n     如确实不可打破且明确以后也不可打破，还是使用ASSERT。\r\n\t \r\n\t \r\n问题：什么时候不需要对潜在的约束或规则使用assert保护？\r\n     首先如果能逻辑证明该规则在现有代码下可以确保没问题。\r\n\t 其次以后改动打破规则的可能性也不存在。	错误：表达了因规格限制或物理限制(资源不足等)等原因导致行为失败。\r\nPANIC：没有妥当处理的错误。\r\nASSERT：表示不可打破的逻辑规则或约束。把这些潜在的规则或约束显式化。\r\n        \r\n\r\n问题：ASSERT与错误的区别是什么？能否用错误处理代替ASSERT？\r\n     区别是规则是否可能打破，可能则必须用错误处理。\r\n     如果规则经过很多层，难以确保在以后演变中保证该规则不被打破，那也可以使用错误处理。\r\n\r\n     那么不可打破的规则能否使用错误？\r\n     可以，但是要考虑代价，性能代价和错误处理编写维护的代价。\r\n     如确实不可打破且明确以后也不可打破，还是使用ASSERT。\r\n\t \r\n\t \r\n问题：什么时候不需要对潜在的约束或规则使用assert保护？\r\n     首先如果能逻辑证明该规则在现有代码下可以确保没问题。\r\n\t 其次以后改动打破规则的可能性也不存在。
427	2058	attr	done_ratio	0	100
429	2068	attr	subject	列存更新方法	列存更新方法(HTAP技术线路)
431	2082	attr	description	专利保护的是方法或装置，是别人不好绕过去的实现路径。\r\n\r\n专利意见：\r\n1，一点要写明白active/stable与main/delta差异在哪?\r\n  如果别人使用内存的列存呢，merge有优势？\r\n2，实施例可以展开点写\r\n  一种实施例直接在active slice之上做编码(可更新编码)，局部压缩，稀疏索引。同时维持几乎不变的更新能力。\r\n  第二种在第一种基础上将active slice 基本不更新的列抽取出来，做编码压缩。但不重排序。同样维持几乎不变的更新能力。\r\n  //第三种在第一种基础上，把指定列抽取出来，并且进行重排序，剔除无效行，但是需要维护到之前的行映射。\r\n  第四种将active slice完成转换成stable slice，并且重排序，剔除无效行，编码，压缩。但stable slice不支持本地更新。\r\n\r\n  二是active中扣出部分列做编码压缩，排序，然后合并。\r\n  三是将active中数据扣出来。重新组织，但是事务信息仍然一体化。\r\n\r\n仍然体现冷热，但是冷之后进行转换处理，转换的重点是将数据扣出来。\r\n而不是将新数据合入。即将热转出。\r\n好处是可以维持更新删除能力。\r\n	专利保护的是方法或装置，是别人不好绕过去的实现路径。\r\n\r\n专利意见：\r\n1，一点要写明白active/stable与main/delta差异在哪?\r\n  如果别人使用内存的列存呢，merge有优势？\r\n2，实施例可以展开点写\r\n  一种实施例直接在active slice之上做编码压缩(可更新的编码压缩)，稀疏索引。同时维持几乎不变的更新能力。\r\n  第二种在第一种基础上将active slice 基本不更新的列抽取出来，做编码压缩。但不重排序。其他列维持几乎不变的更新能力。\r\n  //第三种在第一种基础上，把指定列抽取出来，并且进行重排序，剔除无效行，但是需要维护到之前的行映射。\r\n  第四种将active slice完成转换成stable slice，并且重排序，剔除无效行，编码，压缩。但stable slice不支持本地更新。\r\n\r\n  二是active中扣出部分列做编码压缩，排序，然后合并。\r\n  三是将active中数据扣出来。重新组织，但是事务信息仍然一体化。\r\n\r\n仍然体现冷热，但是冷之后进行转换处理，转换的重点是将数据扣出来。\r\n而不是将新数据合入。即将热转出。\r\n好处是可以维持更新删除能力。\r\n
438	2109	attr	description	1，相关度原则\r\n \r\n2，稳定依赖\r\n   依赖时间更长，结构更加稳定，行为更加稳定的。\r\n\r\n3，替换原则\r\n\r\n4，可见性-内部可变原则\r\n\r\n5，最小沟通原则\r\n\r\n   	1，相关度原则\r\n \r\n2，稳定依赖\r\n   依赖时间更长，结构更加稳定，行为更加稳定的。\r\n\r\n3，替换原则\r\n\r\n4，可见性-内部可变原则\r\n\r\n5，最小沟通原则\r\n   实现实体或行为，需要参与的人越少越好。\r\n\r\n   
439	2110	attr	description	1，相关度原则\r\n \r\n2，稳定依赖\r\n   依赖时间更长，结构更加稳定，行为更加稳定的。\r\n\r\n3，替换原则\r\n\r\n4，可见性-内部可变原则\r\n\r\n5，最小沟通原则\r\n   实现实体或行为，需要参与的人越少越好。\r\n\r\n   	1，相关度原则\r\n \r\n2，稳定依赖\r\n   依赖时间更长，结构更加稳定，行为更加稳定的。\r\n   将对数据的依赖尽量转换为对接口的依赖，保持结构独立性\r\n\r\n3，替换原则\r\n\r\n4，可见性-内部可变原则\r\n\r\n5，最小沟通原则\r\n   实现实体或行为，需要参与的人越少越好。\r\n\r\n   
443	2124	attr	description	软件开发的水平主要体现也就在这两个地方：\r\n1，软件想出错都难，这需要测试平台，以及软件开发方法支撑。\r\n2，软件可以快速发布\r\n   这要求很高的软件管理水平，组织内文档资料，测试套，概念体系等等都能及时跟上。\r\n\r\n在软件开发公司中，经常出现经验压制情况：\r\n即不以理论说法，而是搞经验压制，我有这个经验，可以行得通，所以听我的。\r\n	软件开发的水平主要体现在：\r\n1，软件想出错都难，这需要测试平台，以及软件开发方法支撑。\r\n2，软件可以持续快速的增加新功能\r\n   这需要得益于清晰良好的架构\r\n3，牛逼的算法\r\n4，软件可以快速发布\r\n   这要求很高的软件管理水平，组织内文档资料，测试套，概念体系，发布等等都能及时跟上。\r\n
447	2142	attachment	60	\N	tuningtip-kunpenggrf.pdf
448	2144	attr	description	1，锁，atomic与volatile\r\n2，hashtable的冲突解决方法以及应用场景\r\n3，cache算法有哪些，区别是什么\r\n4，怎么理解ACID。\r\n5，MVCC是什么概念	1，锁，atomic与volatile\r\n2，mmap\r\n3，cacheline\r\n4，hashtable的冲突解决方法以及应用场景\r\n5，cache算法有哪些，区别是什么\r\n6，怎么理解ACID。\r\n7，MVCC是什么概念
425	2049	attr	description	错误：表达了因规格限制或物理限制(资源不足等)等原因导致行为失败。\r\nPANIC：没有妥当处理的错误。\r\nASSERT：表示不可打破的逻辑规则或约束。把这些潜在的规则或约束显式化。\r\n        \r\n\r\n问题：ASSERT与错误的区别是什么？能否用错误处理代替ASSERT？\r\n     区别是规则是否可能打破，可能则必须用错误处理。那么不可打破的规则能否使用错误？\r\n\t 可以但是要考虑代价，性能代价和错误处理编写维护的代价。\r\n\t \r\n\t \r\n问题：什么时候不需要对潜在的约束或规则使用assert保护？\r\n     首先如果能逻辑证明该规则在现有代码下可以确保没问题。\r\n\t 其次以后改动打破规则的可能性也不存在。	错误：表达了因规格限制或物理限制(资源不足等)等原因导致行为失败。\r\nPANIC：没有妥当处理的错误。\r\nASSERT：表示不可打破的逻辑规则或约束。把这些潜在的规则或约束显式化。\r\n        \r\n\r\n问题：ASSERT与错误的区别是什么？能否用错误处理代替ASSERT？\r\n     区别是规则是否可能打破，可能则必须用错误处理。那么不可打破的规则能否使用错误？\r\n\r\n     可以，但是要考虑代价，性能代价和错误处理编写维护的代价。\r\n     如确实不可打破且明确以后也不可打破，还是使用ASSERT。\r\n\t \r\n\t \r\n问题：什么时候不需要对潜在的约束或规则使用assert保护？\r\n     首先如果能逻辑证明该规则在现有代码下可以确保没问题。\r\n\t 其次以后改动打破规则的可能性也不存在。
428	2062	attr	description	hologres：delete + insert memtable\r\nhttp://119.23.14.122:10083/\r\n\r\n\r\nstarrock: delete + insert \r\nhttps://zhuanlan.zhihu.com/p/513426455\r\n同时介绍了其他更新手段。\r\n\r\nstarrock没有支持行级事务的结构，可能产生很多rowset。	hologres：delete + insert memtable\r\nhttp://119.23.14.122:10083/\r\n\r\n\r\nstarrock: delete + insert \r\nhttps://zhuanlan.zhihu.com/p/513426455\r\n同时介绍了其他更新手段。\r\n\r\nstarrock没有支持行级事务的结构，可能产生很多rowset。\r\n\r\n方案三：\r\nbase + delta (delta只有一个)\r\nhttps://blog.csdn.net/TiDBer/article/details/126103052\r\n\r\n这个方案有starrock描述的问题，没有delete bitmap，即必须先合并数据再过滤。
430	2072	attr	subject	没有真相就没有自由	论自由
432	2085	attr	subject	我的软件开发流程	我的软件开发流程(以创业之心来做事)
433	2087	attr	subject	我的软件开发流程(以创业之心来做事)	我的软件开发流程，套路(以创业之心来做事)
434	2093	attr	description	1，review 陈宜顺交底书\r\n2，将S3提交到拉出的分支	1，review 陈宜顺交底书\r\n2，将S3提交到拉出的分支\r\n3，阿港数据湖测试用例
435	2096	attr	subject	何为道	何为修道
436	2107	attr	subject	SSDR 38：我所期望的软件开发	SSDR 38：我所期望的软件开发(辩证法在软件开发中的运用)
437	2108	attr	subject	SSDR21: 程序员的效能	SSDR21: 什么是他妈的好代码
440	2111	attr	description	1，相关度原则\r\n \r\n2，稳定依赖\r\n   依赖时间更长，结构更加稳定，行为更加稳定的。\r\n   将对数据的依赖尽量转换为对接口的依赖，保持结构独立性\r\n\r\n3，替换原则\r\n\r\n4，可见性-内部可变原则\r\n\r\n5，最小沟通原则\r\n   实现实体或行为，需要参与的人越少越好。\r\n\r\n   	1，相关度原则\r\n   实体内成员之所以在一起，是因为其存在某种内在关系。\r\n   比如物体，其具有公共移动的特点。\r\n   而对于软件实体，其通常具备 *公共存在，同时改变* 的特点。\r\n   \r\n \r\n2，稳定依赖\r\n   依赖时间更长，结构更加稳定，行为更加稳定的。\r\n   将对数据的依赖尽量转换为对接口的依赖，保持结构独立性\r\n\r\n3，替换原则\r\n\r\n4，可见性-内部可变原则\r\n\r\n5，最小沟通原则\r\n   实现实体或行为，需要参与的人越少越好。\r\n   减少人之间的依赖。\r\n\r\n   
441	2113	attr	subject	软件的性质理解	软件的性质
442	2114	attr	subject	SSDR 40：实体与行为封装原则 --- 软件可变性问题	SSDR 40：实体与行为封装原则 --- 依赖 - 软件可变性问题
444	2128	attr	description	软件开发的水平主要体现在：\r\n1，软件想出错都难，这需要测试平台，以及软件开发方法支撑。\r\n2，软件可以持续快速的增加新功能\r\n   这需要得益于清晰良好的架构\r\n3，牛逼的算法\r\n4，软件可以快速发布\r\n   这要求很高的软件管理水平，组织内文档资料，测试套，概念体系，发布等等都能及时跟上。\r\n	软件开发的水平主要体现在：\r\n1，软件想出错都难，这需要测试平台，以及软件开发方法支撑。\r\n   实现不应该随便打乱设计\r\n2，软件可以持续快速的增加新功能\r\n   这需要得益于清晰良好的架构\r\n3，牛逼的算法\r\n4，软件可以快速发布\r\n   这要求很高的软件管理水平，组织内文档资料，测试套，概念体系，发布等等都能及时跟上。\r\n
445	2129	attr	description	并发控制当然会用到锁。\r\n事务锁的本质实际就是2点：\r\n1，状态，冲突判断，可见性判断。\r\n2，锁，这里是内存锁，确保在事务期间是锁定的。\r\n\r\n并发控制策略的不同主要在于如何使用锁。\r\n1，比如mvcc，通过多版本支持了读不加锁。\r\n2，比如行锁与块内共享锁，体现了不同的锁资源管理方法。\r\n	并发控制当然会用到锁。\r\n事务锁的本质实际就是2点：\r\n1，状态，冲突判断，可见性判断。\r\n2，锁，这里是内存锁，确保在事务期间是锁定的。\r\n\r\n并发控制策略的不同主要在于如何使用锁。\r\n1，比如mvcc，通过多版本支持了读不加锁。\r\n2，比如行锁与块内共享锁，体现了不同的锁资源管理方法。\r\n    行锁与块锁都不适合列存。\r\n   行锁，数量太多，不利于批量查询。\r\n   块锁按块组织，其数量变化太大，不利于列存的空间管理。\r\n
446	2138	attr	description	专利的核心是创新且有益的发明。如果把技术发明看成科技树，那么专利就是点亮一个新的路径。\r\n但是通常这个路径最好不是一步，而是走了两三步，专利保护的就是这种路径。\r\n\r\n有益性：要阐述清楚问题是什么，新发明的价值在哪。\r\n\r\n此外就是专利不能是已有的。也不能是拼装的，比如将已有技术A和技术B组合。必须找到根基。	专利的核心是创新且有益的发明。如果把技术发明看成科技树，那么专利就是点亮一个新的路径。\r\n但是通常这个路径最好不是一步，而是走了两三步，专利保护的就是这种路径。\r\n\r\n有益性：要阐述清楚问题是什么，新发明的价值在哪。\r\n\r\n此外就是专利不能是已有的。也不能是拼装的，比如将已有技术A和技术B组合。\r\n必须找到根基。不然很难写保护点。
452	2153	attr	subject	SSRD课题1：什么是软件架构	SSRD1：什么是软件架构
453	2157	attr	description	接口层：DML访问接口，事务接口(分布式事务)，复制接口，DDL，启停\r\n对象层：字典，系统表(DDL)，视图，表，索引，IOT.\r\n结构层：heap，btree, swf\r\n缓存层：buffer，cache(只读页面缓存)\r\n事务层：事务，undo，锁，空间管理(表空间，segment)\r\n持久层：控制文件，双写，redo, checkpoint，归档，物理和逻辑复制\r\n资源层: device文件，线程，内存池	接口层：DML访问接口，事务接口(分布式事务)，复制接口，DDL，启停\r\n对象层：字典，系统表(DDL)，视图，表，索引，IOT. 分区\r\n结构层：heap，btree, swf\r\n缓存层：buffer，cache(只读页面缓存)\r\n事务层：事务，undo，锁，空间管理(表空间，segment)\r\n持久层：控制文件，双写，redo, checkpoint，归档，物理和逻辑复制\r\n资源层: device文件，线程，内存池
454	2161	attr	subject	SSDR 38：我所期望的软件开发(辩证法在软件开发中的运用)	SSDR 38：软件的4个要求(我所期望的软件开发(辩证法在软件开发中的运用))
455	2161	attr	description	软件开发的水平主要体现在：\r\n1，软件想出错都难，这需要测试平台，以及软件开发方法支撑。\r\n   实现不应该随便打乱设计\r\n2，软件可以持续快速的增加新功能\r\n   这需要得益于清晰良好的架构\r\n3，牛逼的算法\r\n4，软件可以快速发布\r\n   这要求很高的软件管理水平，组织内文档资料，测试套，概念体系，发布等等都能及时跟上。\r\n	软件开发的水平主要体现在：\r\n1，软件是创新的，具备先进性\r\n   软件是用于解决新矛盾新问题的，应该有其先进性。\r\n2，软件不仅要是正确的，而且是要防错的。\r\n   软件想出错都难，这需要测试平台，以及软件开发方法支撑。\r\n   实现不应该随便打乱设计\r\n3，软件是有效率的，不仅是运行效率，还有沟通效率，以及适应变化。\r\n   软件可以持续快速的增加新功能\r\n   这需要得益于清晰良好的架构\r\n   软件可以快速发布\r\n   这要求很高的软件管理水平，组织内文档资料，测试套，概念体系，发布等等都能及时跟上。\r\n4，软件是可维护的\r\n
456	2165	attr	description	1，技术标准，行业标准。\r\n2，规范测试\r\n3，用户场景\r\n\r\n从这些维度去了解云数仓。	1，技术标准，行业标准。\r\n2，规范测试\r\n3，用户场景\r\n   到底解决了啥问题\r\n\r\n从这些维度去了解云数仓。
457	2168	attr	description	一致性问题主要有两种情况：\r\n1，关联数据的一致性。比如元数据与数据一致性。\r\n2，多份数据的一致性，比如cache一致性，副本一致性。\r\n\r\n一致性问题是伴随着并发出现的。\r\n这问题通常有两种解法：\r\n1，原子性。\r\n实用两阶段锁把数据x和数据y给锁起来，保证读写一致性。\r\n2，多版本。\r\n读取的人可读到对应的老版本。写总是基于最新版本。\r\n2.1 通常老版本维护的时间有限，这时又出现了新的一致性问题。\r\n比如：1，block被同segment复用问题。 2，undo链上的页面被复用问题。\r\n\r\n3，校验\r\n通过机制发现不一致的情况，然后报错或重试。\r\n3.1 重试的前提是可重入的。\r\n比如upsert，如果更新失败，必须先回滚再重新执行整个语句。\r\n\r\n场景分析：\r\n1，元数据与数据一致性\r\n典型场景就是存储结构中的元数据。\r\n如果元数据不支持多版本，数据支持多版本。那显然就有问题，\r\n代码从元数据入口找不到对应的老数据了。\r\n\r\n2，cache一致性\r\n比如数据库字典，字典不支持多版本，如果不失效，以及通过引用机制来使用。\r\n那么老的查询可能没法拿到对应版本的字典，而dml也没法使用最新的字典。\r\n为了不搞字典多版本，闪回查询不支持跨越ddl，而cache中也只支持放与ddl相关的内容。\r\n\r\n3，副本一致性问题\r\n比如原子操作包装的相关页面，在备机读取时如果没有对应的措施，就很容易出现一致性问题。\r\n\r\n	一致性问题主要有两种情况：\r\n1，关联数据的一致性。比如元数据与数据一致性。\r\n2，多份数据的一致性，比如cache一致性，副本一致性。\r\n\r\n一致性问题是伴随着并发出现的。\r\n这问题通常有两种解法：\r\n1，原子性。\r\n实用两阶段锁把数据x和数据y给锁起来，保证读写一致性。\r\n2，多版本。\r\n读取的人可读到对应的老版本。写总是基于最新版本。\r\n2.1 通常老版本维护的时间有限，这时又出现了新的一致性问题。\r\n比如：1，block被同segment复用问题。 2，undo链上的页面被复用问题。\r\n\r\n3，校验\r\n通过机制发现不一致的情况，然后报错或重试。\r\n3.1 重试的前提是可重入的。\r\n比如upsert，如果更新失败，必须先回滚再重新执行整个语句。\r\n\r\n数据库一致性场景分析：\r\n1，元数据与数据一致性\r\n典型场景就是存储结构中的元数据。\r\n如果元数据不支持多版本，数据支持多版本。那显然就有问题，\r\n代码从元数据入口找不到对应的老数据了。\r\n\r\n2，cache一致性\r\n比如数据库字典，字典不支持多版本，如果不失效，以及通过引用机制来使用。\r\n那么老的查询可能没法拿到对应版本的字典，而dml也没法使用最新的字典。\r\n为了不搞字典多版本，闪回查询不支持跨越ddl，而cache中也只支持放与ddl相关的内容。\r\n\r\n3，副本一致性问题\r\n比如原子操作包装的相关页面，在备机读取时如果没有对应的措施，就很容易出现一致性问题。\r\n通过页面锁保证。所以页面锁也得记录redo。\r\n\r\n4，数据block与undo一致性\r\nundo写入需在页面加锁期间，否则可能出现block数据与undo不一致问题。\r\n\r\n\r\n
458	2169	attr	description	1，列锁方案或许行得通。\r\n  行锁方案虽然与行表一致，但是undo没有与页面对应。\r\n  需要处理各种undo一致性问题。\r\n2，每列segment，要考虑drop列之后被其他列或同列再次使用的情况。\r\n  即如果并发每个segment有唯一标识，则需要其他标识识别这种情况。避免读操作误读页面。\r\n3，逻辑页面是一个不错的设计，再加上缓存对于AP基本够用。\r\n  但是TP场景下，操作离散，查找物理页面成了高冲突高代价操作。\r\n4，并发插入错开xbu页面很有必要，对TPCC性能。\r\n5，swf元数据一开始没有多版本就是错误设计，没考虑一致性。\r\n6，vds link对变长列性能很有帮助。\r\n7，一开始就应该支持条件下推\r\n	1，列锁方案或许行得通。\r\n  行锁方案虽然与行表一致，但是undo没有与页面对应。\r\n  需要处理各种undo一致性问题。\r\n2，每列segment，要考虑drop列之后被其他列或同列再次使用的情况。\r\n  即如果并发每个segment有唯一标识，则需要其他标识识别这种情况。避免读操作误读页面。\r\n3，逻辑页面是一个不错的设计，再加上缓存对于AP基本够用。\r\n  但是TP场景下，操作离散，查找物理页面成了高冲突高代价操作。\r\n4，并发插入错开xbu页面很有必要，对TPCC性能。\r\n  列表的页面冲突是性能杀手。\r\n5，swf元数据一开始没有多版本就是错误设计，没考虑一致性。\r\n   swf其实可以没有元数据，作为其他结构的子结构，其元数据可由其他模块提供。\r\n   主要问题在于dc应该要轻量级，dc离散加载页面是非常耗性能的，元数据应该尽量简化。\r\n6，vds link对变长列性能很有帮助。\r\n7，一开始就应该支持条件下推\r\n8，通过在cursor上提供函数获取查询某行中某列的数据是一个不错的设计，统一了行表和列表获取数据的方式。\r\n9，行列数据格式不一样是个隐形炸弹。保不准哪里需要做转换。\r\n10，针对批量插入走特殊路径是有意义的。\r\n
459	2179	attachment	61	\N	存储功能.png
460	2182	attr	description	首先尝试解决计算组内的弹性扩展问题。\r\n对于新一代云数仓和我们的架构。\r\n\r\n拉起全量同步。	首先尝试解决计算组内的弹性扩展问题。\r\n对于新一代云数仓和我们的架构。 其实我们只是多了一层而已。\r\n我们一个计算组就相当于别人的整体架构。\r\n\r\n拉起全量同步。
461	2187	attr	description	产品涉及的人的架构，与产品本身的架构具备一致性。\r\n底层软件为啥开源，因为其客户是开发者。因而需要很好的技术文档，需要开放性。\r\n\r\n而作为研发人员创业方向也最好是：\r\n1，直面客户\r\n比如手机app，或云上服务，或开源软件。\r\n企业软件那套需要相应的摸爬滚打才行，时间周期都较长。\r\n\r\n	产品涉及的人的架构，与产品本身的架构具备一致性。\r\n底层软件为啥开源，因为其客户是开发者。因而需要很好的技术文档，需要开放性。\r\n\r\n而作为研发人员创业方向也最好是：\r\n1，直面客户\r\n比如手机app，或云上服务，或开源软件。\r\n企业软件那套需要相应的摸爬滚打才行，时间周期都较长。\r\n\r\n只有两个方向：\r\n1，开源软件共建平台\r\n2，服务模式\r\n   走在线模式。\r\n\r\n佛道的本质都是反秩序，即建立自己的秩序。\r\n世间以多，快为好，没人愿意处在下层结构，斗争反复而不安。\r\n佛道并非避世，而是开创自己的秩序。\r\n不论什么学说必然走斗争独立自由道路，否则就是一条死路。\r\n\r\n即不论何时人都要独立发展自己的秩序，可以在前人或平台基础上，但这个秩序必须从自己内心生长出来。\r\n\r\n从这个角度出发，现代基于互联网提供服务不失为一种新秩序。\r\n\r\n我想建立一个小秩序，这是我的软件。等小弟长大了，他们也需要构建自己的秩序。\r\n\r\n\r\n
465	2199	attr	subject	论生活的方法	论生活与工作的方法
466	2205	attachment	64	\N	软件架构.png
469	2215	attr	description	表的基本信息：\r\n1，TAB$,COL$等元数据\r\n2，SEG相关元数据，其中总入口在TAB$, COL_SEG$\r\n3, TableDict，SwfDict关系，swfDict挂在tableDict上\r\n4, dataOid来源\r\n5，数据\r\n\r\nPTT：\r\n1，元数据在handler上\r\n2，swfDict内存自己分配，与tableDict独立\r\n3，handler->pttDcCtx\r\n4，handler上临时\r\n\r\n\r\nGTT：\r\n1，TAB$,COL$等元数据\r\n2，记录在tempSegCache上\r\n3，从stack上临时分配 （这里其实不太适合swf）\r\n4，	表的基本信息：\r\n1，TAB$,COL$等元数据\r\n2，SEG相关元数据，其中总入口在TAB$, COL_SEG$\r\n3, TableDict，SwfDict关系，swfDict挂在tableDict上，tableDict挂在DictEntry。\r\n4, dataOid来源\r\n5，数据\r\n\r\nPTT：\r\n1，元数据在handler上\r\n2，swfDict内存自己分配，与tableDict独立\r\n3，handler->pttDcCtx\r\n4，handler上临时\r\n\r\nDictEntry是独立的\r\n\r\n\r\nGTT：\r\n1，TAB$,COL$等元数据\r\n2，记录在tempSegCache上\r\n3，从stack上临时分配 （这里其实不太适合swf）\r\n4，\r\n\r\nDictEntry是共享的，因而不能将tableDict挂到DictEntry上。
462	2188	attr	description	SSB测试识别的问题：\r\n1，CK date使用2 bytes，yashandb使用8字节，没有对应的短类型。\r\n2，yashandb不支持带函数的条件下推，SSB有6条语句在此场景下过滤效率非常好\r\n3，slice文件调大利于首次性能，但是不利于并行查询(取决于slice总数).\r\n4, dictionary(rle) 比 dictionary(plain)能节省大量空间。\r\n   char(N) N在10左右\r\n5，varchar类型的长度部分需要编码。\r\n	SSB测试识别的问题：\r\n1，不支持带函数的时间条件下推。因而部分语句yashandb扫描的行数多出N倍。\r\n\r\n    如extract(year from LO_ORDERDATE)= 1993，to_char(LO_ORDERDATE, 'YYYYMM') = '199401' \r\n\r\n2，扫描数据量接近时\r\n\r\n     非首次yashandb性能跟ck接近。如语句4~9,11等。\r\n\r\n     首次性能经过调整slice大小以及编码方式后差距大幅缩小，部分已接近。\r\n\r\n3，yashandb slice文件太小，离散IO。要支持更大的slice，但是可能不利于并行查询(跟slice总数有关系).\r\n\r\n4，CK date类型使用2 bytes，yashandb使用8字节，且没有对应的短类型。\r\n\r\n5,  dictionary(rle) 比 dictionary(plain)能节省大量空间，可优选dictionary(rle)。\r\n\r\n6，varchar类型的长度部分需要编码。\r\n\r\n7，带order key过滤的语句即便改写性能也与ck差距非常大。\r\n\r\n     可能是排序粒度影响了，2M粒度下虽然过滤效果也不差，但是IO比较离散(这里还有io放大问题)。\r\n\r\n     order key作为最明显的过滤条件，应该在有此条件时最优化。order粒度要支持更大。\r\n8，充分利用order key，做二分或快速查找
463	2193	attr	subject	SSDR 35:如何描述问题或目标	SSDR 35:如何描述问题或目标(软件开发困难之二)
464	2196	attr	description	限定词的含义。\r\n全局临时的表，局部临时的表。\r\n全局临时是一个修饰符，修饰本身意味着特征，能力，同时还有约束。\r\n\r\n限定词应该用接口或trait来表示。\r\n这样我们才能很清楚的明确当一种结构的表，要实现临时或全局临时的时候该做什么。\r\n并且有效的将这些属性相关的实现，与其他属性相互隔离。	限定词的含义。\r\n全局临时的表，局部临时的表。\r\n全局临时是一个修饰符，修饰本身意味着特征，能力，同时还有约束。\r\n\r\n限定词应该用接口或trait来表示。\r\n这样我们才能很清楚的明确当一种结构的表，要实现临时或全局临时的时候该做什么。\r\n并且有效的将这些属性相关的实现，与其他属性相互隔离。\r\n\r\n\r\n那些差异被某些实体作为flag或其他形式携带，然后在代码的各个分支都得进行处理。\r\n一旦漏掉就可能产生未定义的行为。\r\n尤其是我们有一些大的类型，一切都能塞入其中，就更容易出现这种情况，加一个标记，然后加分支是显而易见的处理方案。
467	2209	attr	subject	yashandb架构腐烂记	yashandb架构恶化记
468	2213	attr	description	底层提供存在基本元数据的页面封装，事务页，空间管理，空闲空间管理，数据页的封装。\r\n\r\n元数据页面需支持多版本，事务能力。\r\n空间管理是只追加申请，整体回收的，因而不必提供回滚能力。\r\n空闲空间在事务期间主要是申请，回收是延迟的。其通过页面锁的并发来实现，也不必实现多版本。\r\n数据页是需要多版本的。\r\n其实还需原子操作接口，因为有些情况不会提供undo，只要这些操作一起成功一致性就得以保证。\r\n\r\nundo/redo,redo group 锁页的redo/原子操作/checkpoint	底层提供存在基本元数据的页面封装，事务页，空间管理，空闲空间管理，数据页的封装。\r\n\r\n元数据页面需支持多版本，事务能力。\r\n空间管理是只追加申请，整体回收的，因而不必提供回滚能力。\r\n空闲空间在事务期间主要是申请，回收是延迟的。其通过页面锁的并发来实现，也不必实现多版本。\r\n数据页是需要多版本的。\r\n其实还需原子操作接口，因为有些情况不会提供undo，只要这些操作一起成功一致性就得以保证。\r\n\r\nundo/redo,redo group 锁页的redo/原子操作/checkpoint\r\n\r\n空间管理坑很多，要考虑到各种页面复用场景，某列的页面被自己复用，某列页面被同表其他页面复用。还有undo与页面对不上的场景。\r\n这些情况都需要报snapshot too old。
470	2218	attr	subject	SSDR49：一个干净的模块	SSDR49：一个干净的模块（你真的懂模块化编程吗）
471	2228	attr	subject	SSDR 25：高质量编程的技巧	SSDR 25：高质量编程的技巧 (deprecated)
472	2229	attr	description	1，软件是什么\r\n1.1 软件思维\r\n\r\n2，软件实体\r\n2.1 行为的理解\r\n2.2 模块化编程\r\n \r\n\r\n3，软件结构\r\n3.1，软件复杂度\r\n3.3  分化与泛化\r\n3.2，设计原则\r\n3.3，设计模式\r\n\r\n\r\n4，怎么做软件\r\n    其实就同怎么做事一样。\r\n4.1 政治\r\n4.2 怎么分析需求\r\n4.3 怎么交流讨论\r\n4.4 怎么设计\r\n4.5 怎么编码\r\n4.6 设计的完备性与技术债务\r\n4.7 软件正确性\r\n\r\n5，数据结构\r\n\r\n6，算法	1，软件是什么\r\n1.1 软件思维\r\n\r\n2，软件实体\r\n2.1 行为的理解\r\n2.2 模块化编程\r\n \r\n\r\n3，软件结构\r\n3.1，软件复杂度\r\n3.3  分化与泛化\r\n3.2，设计原则\r\n3.3，设计模式\r\n\r\n\r\n4，怎么做软件\r\n    其实就同怎么做事一样。\r\n4.1 政治\r\n4.1.1 引入矛盾斗争\r\n4.1.2 获取与运用资源\r\n4.1.3 开明的政治 \r\n\r\n4.2 怎么分析需求\r\n4.3 怎么交流讨论\r\n4.4 怎么设计\r\n4.5 怎么编码\r\n4.6 设计的完备性与技术债务\r\n4.7 软件正确性\r\n\r\n5，数据结构\r\n\r\n6，算法
474	2231	attr	description	1，软件是什么\r\n1.1 软件思维\r\n\r\n2，软件实体\r\n2.1 行为的理解\r\n2.2 模块化编程\r\n \r\n\r\n3，软件结构\r\n3.1，软件复杂度\r\n3.2, 分化与泛化\r\n3.3，设计原则\r\n3.4，设计模式\r\n\r\n\r\n4，怎么做软件\r\n    其实就同怎么做事一样。\r\n4.1 政治\r\n4.1.1 引入矛盾斗争\r\n4.1.2 获取与运用资源\r\n4.1.3 开明的政治 \r\n\r\n4.2 怎么分析需求\r\n4.3 怎么交流讨论\r\n4.4 怎么设计\r\n4.5 怎么编码\r\n4.6 设计的完备性与技术债务\r\n4.7 软件正确性\r\n\r\n5，数据结构\r\n\r\n6，算法\r\n\r\n7，编程语言	1，软件是什么\r\n1.1 软件思维\r\n\r\n2，软件实体\r\n2.1 行为的理解\r\n2.2 模块化编程\r\n \r\n\r\n3，软件结构\r\n3.1，软件复杂度\r\n3.2, 分化与泛化\r\n3.3，设计原则\r\n3.4，设计模式\r\n\r\n\r\n4，怎么做软件\r\n    其实就同怎么做事一样。\r\n4.1 政治\r\n4.1.1 引入矛盾斗争\r\n4.1.2 获取与运用资源\r\n4.1.3 开明的政治 \r\n\r\n4.2 怎么分析需求\r\n4.3 怎么交流讨论\r\n4.4 怎么设计\r\n4.4.1 逻辑设计\r\n4.4.2 可靠性，高可用，兼容性.... \r\n\r\n4.5 怎么编码\r\n4.6 设计的完备性与技术债务\r\n4.7 软件正确性\r\n\r\n5，数据结构\r\n\r\n6，算法\r\n\r\n7，编程语言
473	2230	attr	description	1，软件是什么\r\n1.1 软件思维\r\n\r\n2，软件实体\r\n2.1 行为的理解\r\n2.2 模块化编程\r\n \r\n\r\n3，软件结构\r\n3.1，软件复杂度\r\n3.3  分化与泛化\r\n3.2，设计原则\r\n3.3，设计模式\r\n\r\n\r\n4，怎么做软件\r\n    其实就同怎么做事一样。\r\n4.1 政治\r\n4.1.1 引入矛盾斗争\r\n4.1.2 获取与运用资源\r\n4.1.3 开明的政治 \r\n\r\n4.2 怎么分析需求\r\n4.3 怎么交流讨论\r\n4.4 怎么设计\r\n4.5 怎么编码\r\n4.6 设计的完备性与技术债务\r\n4.7 软件正确性\r\n\r\n5，数据结构\r\n\r\n6，算法	1，软件是什么\r\n1.1 软件思维\r\n\r\n2，软件实体\r\n2.1 行为的理解\r\n2.2 模块化编程\r\n \r\n\r\n3，软件结构\r\n3.1，软件复杂度\r\n3.2, 分化与泛化\r\n3.3，设计原则\r\n3.4，设计模式\r\n\r\n\r\n4，怎么做软件\r\n    其实就同怎么做事一样。\r\n4.1 政治\r\n4.1.1 引入矛盾斗争\r\n4.1.2 获取与运用资源\r\n4.1.3 开明的政治 \r\n\r\n4.2 怎么分析需求\r\n4.3 怎么交流讨论\r\n4.4 怎么设计\r\n4.5 怎么编码\r\n4.6 设计的完备性与技术债务\r\n4.7 软件正确性\r\n\r\n5，数据结构\r\n\r\n6，算法\r\n\r\n7，编程语言
475	2232	attr	description	1，软件是什么\r\n1.1 软件思维\r\n\r\n2，软件实体\r\n2.1 行为的理解\r\n2.2 模块化编程\r\n \r\n\r\n3，软件结构\r\n3.1，软件复杂度\r\n3.2, 分化与泛化\r\n3.3，设计原则\r\n3.4，设计模式\r\n\r\n\r\n4，怎么做软件\r\n    其实就同怎么做事一样。\r\n4.1 政治\r\n4.1.1 引入矛盾斗争\r\n4.1.2 获取与运用资源\r\n4.1.3 开明的政治 \r\n\r\n4.2 怎么分析需求\r\n4.3 怎么交流讨论\r\n4.4 怎么设计\r\n4.4.1 逻辑设计\r\n4.4.2 可靠性，高可用，兼容性.... \r\n\r\n4.5 怎么编码\r\n4.6 设计的完备性与技术债务\r\n4.7 软件正确性\r\n\r\n5，数据结构\r\n\r\n6，算法\r\n\r\n7，编程语言	道：\r\n有道无术,术尚可求,有术无道,止于术.神即道,道法自然,如来!\r\n吾生也有涯，而知也无涯。以有涯随无涯，殆已\r\n为学日益，为道日损\r\n\r\n\r\n1，软件是什么\r\n1.1 软件思维\r\n\r\n2，软件实体\r\n2.1 行为的理解\r\n2.2 模块化编程\r\n \r\n\r\n3，软件结构\r\n3.1，软件的性质\r\n3.1.1 复杂度\r\n3.2, 分化与泛化\r\n3.3，设计原则\r\n\r\n术\r\n4，怎么做软件\r\n    其实就同怎么做事一样。\r\n4.1 政治\r\n4.1.1 引入矛盾斗争\r\n4.1.2 获取与运用资源\r\n4.1.3 开明的政治 \r\n\r\n4.2 怎么分析需求\r\n4.3 怎么交流讨论\r\n4.4 怎么设计\r\n4.4.1 逻辑设计，设计模式\r\n4.4.2 可靠性，高可用，兼容性.... \r\n\r\n4.5 怎么编码\r\n4.6 设计的完备性与技术债务\r\n4.7 软件正确性\r\n\r\n5，数据结构\r\n\r\n6，算法\r\n\r\n7，编程语言
476	2234	attr	description	软件实体是包含特定行为的抽象结构。\r\n抽象可以是针对人物或辅助结构。\r\n\r\n其核心在于行为，这是其本质特征，结构是为行为服务的。\r\n结构是多变的，通常服务于主要行为。如果其主要行为发生变化，那么实体也就不是原来的实体了。\r\n比如锅铲，木的，铁的都可以，但是筷子不是锅铲。\r\n\r\n推论：\r\n实体应该很好的封装，就像自然界的物一样。其具备可见性，整体性等特征。\r\n实体不应该随便被修改，程序员经常做出用锄头炒菜，用脚盆洗脸的事。\r\n因为这并不像社会上的事物那样显而易见。\r\n\r\n从诞生之初，实体就应该具有明确的含义，行为。且具备一定的稳定性。\r\n\r\n例如内存分配，Stack和MemoryContext都有分配内存的能力，但其主要行为其实有差异。\r\nStack有push和pop，save，restore。 Context的主要行为则是多次分配，一次性回收，整体复用。\r\n我们不能以为某个实体能做这个事就直接用，或随意给stack加功能使其同时具备MemoryContext的能力。\r\n而在某些场景下，其主要行为不被使用，或不同行为之间不可同时使用等。\r\n\r\n实体的内部结构应该对外不可见。	软件实体是包含特定行为的抽象结构。\r\n抽象可以是针对人物或辅助结构。\r\n\r\n其核心在于行为，这是其本质特征，结构是为行为服务的。\r\n结构是多变的，通常服务于主要行为。如果其主要行为发生变化，那么实体也就不是原来的实体了。\r\n比如锅铲，木的，铁的都可以，但是筷子不是锅铲。\r\n\r\n推论：\r\n实体应该很好的封装，就像自然界的物一样。其具备可见性，整体性等特征。\r\n实体不应该随便被修改，程序员经常做出用锄头炒菜，用脚盆洗脸的事。\r\n因为这并不像社会上的事物那样显而易见。\r\n\r\n从诞生之初，实体就应该具有明确的含义，行为。且具备一定的稳定性。\r\n\r\n例如内存分配，Stack和MemoryContext都有分配内存的能力，但其主要行为其实有差异。\r\nStack有push和pop，save，restore。 Context的主要行为则是多次分配，一次性回收，整体复用。\r\n我们不能以为某个实体能做这个事就直接用，或随意给stack加功能使其同时具备MemoryContext的能力。\r\n而在某些场景下，其主要行为不被使用，或不同行为之间不可同时使用等。\r\n\r\n实体的内部结构应该对外不可见。\r\n\r\n实体对外应该尽量泛化，不应该于外部环境，这样才可以在各种环境下复用。
479	2242	attr	description	软件结构通常是有顶层结构，来自于最外层实体，以及其行为。\r\n\r\n然后内部结构如同人体系统一样，是一个森林。\r\n上层结构是不断分化而成，不存在反向依赖。\r\n\r\n软件结构对外泛化，对内分化。\r\n这样有更精细的行为，同时有更广的使用场景，降低软件复杂度。\r\n\r\n推理：\r\n软件结构下有哪些发展方向。\r\n\r\n	软件结构通常是有顶层结构，来自于最外层实体，以及其行为。\r\n\r\n然后内部结构如同人体系统一样，是一个森林。\r\n上层结构是不断分化而成，不存在反向依赖。\r\n\r\n软件通常有的系统有：内存资源，线程资源，日志系统，监控业务，业务系统等。\r\n\r\n软件结构对外泛化，对内分化。\r\n这样有更精细的行为，同时有更广的使用场景，降低软件复杂度。\r\n软件系统内有很多结构是单实例的，也有不少结构是多实例，即复用的。\r\n通常底层架构是单实例的，高层是多实例的。这两部分设计上都有难度。\r\n底层要考虑各种不同场景，各种功能，涉及架构伤筋动骨。\r\n高层复用性高，要考虑用法的各种变化，要极好的封装，否则改动成本大。\r\n所以新手最好在中间层工作。\r\n\r\n由软件结构可以指导软件的完备性设计。\r\n\r\n软件的表示法：\r\n用实体和行为来表达。\r\n我们为了实现行为增加子结构，但子结构通常会影响父结构的其他行为。\r\n结构有行为，行为催生结构。\r\n按照上述软件结构思想，可以用目录树一样的结构来表达软件。\r\n然后系统的需求，设计均可以通过该方式来描述。\r\n\r\n软件的发展：\r\n先用最不可或缺的场景，以及基本功能来设计软件。\r\n然后扩展其功能以及使用场景
483	2262	attr	subject	关于卖方的决定	关于卖房的决定
484	2270	attr	subject	SSDR 48：需求的类型以及理解	SSDR 48：什么是软件需求
485	2272	attr	subject	SSDR14：软件正确性	SSDR14：软件约束与正确性
477	2237	attr	description	ptmalloc算法缺陷：\r\n只有当栈顶内存释放时，且栈顶空闲超过一定大小时，通过brk分配的小内存才能释放回系统。\r\n即ptmalloc是后申请先释放的机制。\r\n否则free时，内存会交给ptmalloc管理。\r\n下述程序可以验证：\r\n1，mmap分配的内存不会影响brk分配的内存释放给系统。\r\n2，brk 后申请内存未释放，则先申请内存无法释放\r\n\r\n\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <unistd.h>\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n    //mallopt(M_TRIM_THRESHOLD, 64*1024);\r\n    //MemoryLeak\r\n    char * Array[2064];\r\n    for (int j=0; j<2063; j++) {\r\n        char *Buff = (char *)malloc(3*1024);\r\n        for (int i=0; i<3*1024; i++) \r\n            Buff[i] = i;\r\n        Array[j] = Buff;\r\n    }\r\n    char *Buff1 = (char *)malloc(256*1024);\r\n    Array[2063] = (char *)malloc(3*1024);\r\n\r\n    sleep(25);\r\n    printf("Delete start\\n");\r\n \r\n    //for (int j=0; j<2064; j++) //check mmap and brk together.\r\n    for (int j=0; j<2063; j++) \r\n        free(Array[j]);\r\n\r\n    printf("Delete All\\n");\r\n\r\n    //sleep(10);\r\n    //malloc_trim(0);\r\n    //cout << "strim" << endl;\r\n\r\n    while(1) sleep(10);\r\n}\r\n\r\n\r\n那么为什么会导致内存耗尽呢？即为什么free给ptmalloc的内存不能复用呢？\r\n这跟内存片的生命周期有关系。\r\n\r\n比如申请了内存m1,m2,m3。但是m3一直不释放，m1,m2释放无法归还系统。\r\n则后分配m4,m5,m6。同样m6存在更久，m4,m5不归还。\r\n当然这前提是m4,m5,m6无法复用m1,m2。即小内存碎片无法复用。\r\n如果系统中大小内存交叉分配就比较容易出现。\r\n即glic的内存暴涨有两个诱因：\r\n1，大小内存交叉分配\r\n2，部分内存生命周期过长。\r\n\r\n改造思路就是对于小内存自己使用内存池管理，将其与长生命周期的内存分离开。\r\n长生命周期的内存尽量大块分配，使用mmap，这样不干扰小内存的回收。\r\n\r\n如果一个小内存不回收，则其之前分配的内存永远不可回收，如果因为碎片化等因素导致其不可复用，则系统的内存会持续暴涨。\r\n直到ptmalloc合并减少碎片化，使得其管理的内存能符合进程的需要，但这本身就具备不确定性。\r\n由此推论：长期不回收的内存应该使用mmap。	ptmalloc算法引起内存暴涨\r\nrule：\r\n只有当栈顶内存释放时，且栈顶空闲超过一定大小时，通过brk分配的小内存才能释放回系统。\r\n即ptmalloc是后申请先释放的机制。否则free时，内存会交给ptmalloc管理，并通过其内部机制复用。\r\n\r\n\r\n下述程序可以验证：\r\n1，mmap分配的内存不会影响brk分配的内存释放给系统。\r\n2，brk 后申请内存未释放，则先申请内存无法释放\r\n\r\n<pre><code class="c">\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <unistd.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n//mallopt(M_TRIM_THRESHOLD, 64*1024);\r\n//MemoryLeak\r\nchar * Array2064;\r\nfor (int j=0; j<2063; j++) {\r\nchar *Buff = (char *)malloc(3*1024);\r\nfor (int i=0; i<3*1024; i++)\r\nBuff[i] = i;\r\nArray[j] = Buff;\r\n}\r\nchar *Buff1 = (char *)malloc(256*1024);\r\nArray2063 = (char *)malloc(3*1024);\r\n\r\nsleep(25);\r\n    printf("Delete start\\n");\r\n\r\n//for (int j=0; j&lt;2064; j++) //check mmap and brk together.\r\n    for (int j=0; j&lt;2063; j++) \r\n        free(Array[j]);\r\n\r\nprintf("Delete All\\n");\r\n\r\n//sleep(10);\r\n    //malloc_trim(0);\r\n    //cout << "strim" << endl;\r\n\r\nwhile(1) sleep(10);\r\n}\r\n</code></pre>\r\n\r\n那么为什么会导致内存耗尽呢？即为什么free给ptmalloc的内存不能复用呢？\r\n这跟内存片的生命周期和内存碎片化有关系。\r\n\r\n1，如果一个小内存不回收，则其之前分配的内存永远不可回收，如果因为碎片化等因素导致其不可复用，则系统的内存会持续暴涨。\r\n直到ptmalloc合并减少碎片化，使得其管理的内存能符合进程的需要，但这本身就具备不确定性。\r\n2，如果该小内存在很久后才回收，即分配的内存部分生命周期很长，部分短。那么短生命周期的内存也可能长期无法回收。\r\n系统内存仍然可能暴涨。\r\n   比如申请了内存m1,m2,m3。但是m3一直不释放，m1,m2释放无法归还系统。\r\n则后分配m4,m5,m6。同样m6存在更久，m4,m5不归还。\r\n当然这前提是m4,m5,m6无法复用m1,m2。即小内存碎片无法复用。\r\n如果系统中大小内存交叉分配就比较容易出现。\r\n\r\n解决办法：\r\n1，长生命周期内存尽量使用mmap，减少对短期内存的影响。\r\n2，尽量减少碎片化内存。
478	2239	attr	subject	SSDR52: 兼容性设计	SSDR54: 兼容性设计
480	2249	attachment	66	\N	p1.png
481	2249	attachment	65	\N	p2.png
482	2256	attr	subject	SSRD1：什么是软件架构	SSRD1：软件架构是什么
486	2275	attr	description	1, 事物是在辨证中发展的。\r\n   并非在原地踏步，事物在不断的发展，虽然这种发展通常是利弊都有，但通过其他代价消除弊端，\r\n   然后继续往前发展，所有事物莫不如此。所以不要真躺平，人还是要学会认知和改造世界，矛盾不会自然消散。\r\n 何况这社会本身就容易制造各种新矛盾。\r\n   \r\n2, 该怎么做：人应该以良性的方式去发展。\r\n  脱离世俗标准，拒绝恐惧，贪婪，愚昧化。回归本质并建立自己的体系才可能强大。\r\n  非良性就会引起反嗜。拒绝超身心负荷运转，以人为本。\r\n\r\n3, 与他人关系：以合作与斗争的心态去对待身边的人，就像我们改造其他事物一样。\r\n  因为客观规律无法违背，人性也如此，将其考虑在内。\r\n  老实的本质是处事不够机智变通，考虑问题不够全面。即不够聪明智慧。\r\n\r\n4, 如何看待负面情绪：有时是应急需要，有时是非安全环境，以及非良性生活的指示灯。\r\n  所以拿出寻根问底的精神去解决问题。\r\n\r\n5, 与自我的关系：不要自我否定，人都会被淘汰\r\n他们需要安全和稳定，对他们来说，认为“自己出了问题”，比认为“他不能依赖那些他赖以为生的人”要好得多。\r\n“自我PUA”是一个比“自我厌恶”更加复杂、更加隐秘的心理状态。它还可能与我们的创伤体验有关，与羞耻感有关，与对完美的不合理期待有关。最重要的是，它所提供的“掌控感”，是我们内心非常渴望的体验。 \r\n\r\n我们之所以一直难以摆脱自我的操控，正是因为这些操控是有效的、是有好处的、是能达成目的的。因此，我们更需要借助外界的力量，去打破它们。参考https://zhuanlan.zhihu.com/p/377250858\r\n\r\n所有人都有被淘汰的一天，所有结构最终都会消亡。所以不要害怕斗争失败，环境恶化。\r\n即便我们依赖的环境再好，我们也得坚持走自己的路，这就是独立自由。\r\n有强大的内心，我们就能生发出一切，而前提就是我们的自信与独立。	1, 事物是在辨证中发展的。\r\n   并非在原地踏步，事物在不断的发展，虽然这种发展通常是利弊都有，但通过其他代价消除弊端，\r\n   然后继续往前发展，所有事物莫不如此。所以不要真躺平，人还是要学会认知和改造世界，矛盾不会自然消散。\r\n 何况这社会本身就容易制造各种新矛盾。\r\n   \r\n2, 该怎么做：人应该以良性的方式去发展。\r\n  脱离世俗标准，拒绝恐惧，贪婪，愚昧化。回归本质并建立自己的体系才可能强大。\r\n  非良性就会引起反嗜。拒绝超身心负荷运转，以人为本。\r\n  人活着就是在做一件事：不断丰富自己的结构，身体和思想，同时保持结构的良性发展。\r\n\r\n3, 与他人关系：以合作与斗争的心态去对待身边的人，就像我们改造其他事物一样。\r\n  不要害怕合作与斗争，这些都是客观存在的。当然这需要我们有一颗强大的内心，而强大的内心来自于个人独立的世界观，价值观，人生观。\r\n  因为客观规律无法违背，人性也如此，将其考虑在内。\r\n  老实的本质是处事不够机智变通，考虑问题不够全面。即不够聪明智慧。\r\n\r\n4, 如何看待负面情绪：有时是应急需要，有时是非安全环境，以及非良性生活的指示灯。\r\n  所以拿出寻根问底的精神去解决问题。\r\n\r\n5, 与自我的关系：不要自我否定，人都会被淘汰\r\n他们需要安全和稳定，对他们来说，认为“自己出了问题”，比认为“他不能依赖那些他赖以为生的人”要好得多。\r\n“自我PUA”是一个比“自我厌恶”更加复杂、更加隐秘的心理状态。它还可能与我们的创伤体验有关，与羞耻感有关，与对完美的不合理期待有关。最重要的是，它所提供的“掌控感”，是我们内心非常渴望的体验。 \r\n\r\n我们之所以一直难以摆脱自我的操控，正是因为这些操控是有效的、是有好处的、是能达成目的的。因此，我们更需要借助外界的力量，去打破它们。参考https://zhuanlan.zhihu.com/p/377250858\r\n\r\n所有人都有被淘汰的一天，所有结构最终都会消亡。所以不要害怕斗争失败，环境恶化。\r\n即便我们依赖的环境再好，我们也得坚持走自己的路，这就是独立自由。\r\n认知自我，并构建出有生命力的自我，强大的内心，我们就能生发出一切，而前提就是我们的自信与独立。
487	2276	attr	description	其实也不复杂，在单机事物基础上增加全局事物id，死锁，以及全局scn，然后实现xa协议。\r\n分布式事务xid会映射到本地事务。\r\n另外要考虑一些异常场景：\r\n1,多cn查询时scn的不同步问题\r\n 因为GTS本地缓存引起的一致性问题\r\n2,多dn查询时一致性问题，可能一个dn看到事务提交，另外一个看到未提交。\r\n 要处理这种中间态。如已开始第二阶段，要相应的等待。\r\n\r\n事务说白了主要就3个问题：\r\n1,一致提交与回滚\r\n2,冲突判断\r\n3,可见性判断\r\n即AI问题，C约束和持久化比较显然。\r\n\r\n\r\nhttps://zhuanlan.zhihu.com/p/573680047	其实也不复杂，在单机事物基础上增加全局事物id，死锁，以及全局scn，然后实现xa协议。\r\n分布式事务xid会映射到本地事务。\r\n另外要考虑一些异常场景：\r\n1,多cn查询时scn的不同步问题\r\n 因为GTS本地缓存引起的一致性问题\r\n2,多dn查询时一致性问题，可能一个dn看到事务提交，另外一个看到未提交。\r\n 要处理这种中间态。如已开始第二阶段，要相应的等待。\r\n\r\n事务说白了主要就3个问题：\r\n1,一致提交与回滚\r\n2,冲突判断\r\n3,可见性判断\r\n即AI问题，C约束和持久化比较显然。\r\n\r\n但这里面有很多细化场景需要考虑，比如记录移动引起的miss update。\r\n所有数据包括元数据都得支持快照读能力。不支持的情况得额外处理。\r\n\r\nhttps://zhuanlan.zhihu.com/p/573680047
488	2280	attr	description	1，首次存算分离架构的技术优势是非常明显的。\r\n   相对mpp架构。\r\n   成本下降，同时性能打折并不多。这得益于存储带宽的能力。\r\n2，VM资源隔离架构相比MPP计算组内扩容有更好的隔离优势。\r\n3，计算完全无状态，在计算弹性扩缩上还是有一定优势。\r\n\r\n2,3这两点或许是yashandb以后的架构劣势。	1，首次存算分离架构的技术优势是非常明显的。\r\n   相对mpp架构。\r\n   成本下降，同时性能打折并不多。这得益于存储带宽的能力。\r\n2，VM资源隔离架构相比MPP计算组内扩容有更好的隔离优势。\r\n3，计算完全无状态，在计算弹性扩缩上还是有一定优势。\r\n\r\n2,3这两点或许是yashandb以后的架构劣势。\r\n主要区别在于元数据管理上，计算无状态了，因而不存在计算组的概念。\r\n\r\n当然我们也可以搞vm，但是需要考虑将当前DN上元数据同步给新的vm中的DN，这样代价是比较大的。\r\n优势是流式，实时性更强。\r\n
489	2288	attr	subject	列存引擎技术点	列存引擎亮点以及技术点
\.


--
-- Name: journal_details_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.journal_details_id_seq', 489, true);


--
-- Data for Name: journals; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.journals (id, journalized_id, journalized_type, user_id, notes, created_on, private_notes) FROM stdin;
5	3	Issue	5	出现该问题的原因可能是io路径上有中间层没有重试机制导致的。\r\n虽然说tcp有丢包重传，但是超过一定次数之后，tcp也不再重试。所以出现hang必然是软件层错误处理存在问题。\r\n\r\n解决方法是在rgw这层增加超时重试机制。\r\n注意要区分一些情况：\r\n一个请求可能确实需要获取大量数据，比如同步非常大的对象，所以在获取到数据的时候，超时时间应该重置\r\n请求可能在rgw内部阻塞，所以如果仅处理网络超时，应该是针对linked request。	2017-09-10 12:05:14.431767	f
8	5	Issue	5	while (!marker_tracker->can_do_op(key) && (sync_status == 0)) 是修改之后的。\r\n之前是\r\nwhile (!marker_tracker->can_do_op(key)	2017-09-11 08:23:27.210021	f
10	3	Issue	5	超时给上层返回值 应该使用EAGAIN，不然RGWMetaSyncShardCR::incremental_sync 不会处理这种错误	2017-09-11 08:58:41.33899	f
11	3	Issue	5	测试方法：\r\n1，使用tc配置丢包率\r\ntc qdisc add dev eth0 root netem loss 30%\r\n\r\n2，使用s3.sh脚本循环创建1000 bucket，同步成功后再删除掉。\r\n\r\n观察是否有bucket没创建成功，或者没删除成功。	2017-09-11 11:52:33.226829	f
12	3	Issue	5	测试通过	2017-09-11 11:53:01.175772	f
13	3	Issue	5	提到到社区	2017-09-11 11:53:15.276353	f
15	5	Issue	5	<pre><code class="cpp">\r\nwhile (!marker_tracker->can_do_op(key) && (sync_status == 0)) {\r\n          if (!updated_status) {\r\n            set_status() << "can't do op, conflicting inflight operation";\r\n            updated_status = true;\r\n          }\r\n          ldout(sync_env->cct, 5) << *this << ": [inc sync] can't do op on key=" << key << " need to wait for conflicting operation to complete" << dendl;\r\n          yield wait_for_child();\r\n          bool again = true;\r\n          while (again) {\r\n            again = collect(&ret, lease_stack.get());\r\n            if (ret < 0) {\r\n              ldout(sync_env->cct, 0) << "ERROR: a child operation returned error (ret=" << ret << ")" << dendl;\r\n              sync_status = ret;\r\n              /* we have reported this error */\r\n            }\r\n          }\r\n        }\r\n\r\n        if (sync_status != 0) {\r\n          ldout(sync_env->cct, 0) << "ERROR:exit increment sync and retry" << dendl;\r\n          break;\r\n        }\r\n</code></pre>\r\n\r\n该日志确实可以打出来，说明确实存在这种情况。\r\n\r\n2017-09-11 09:23:02.805409 7fbc96bff700  5 _complete_request request http://172.18.0.100:8080/xx3/obj_23?rgwx-zonegroup=eefd67c0-f35e-4c99-a709-4e396cb84be6&rgwx-prepend-metadata=eefd67c0-f35e-4c99-a709-4e396cb84be6 complete -11\r\n2017-09-11 09:23:02.805417 7fbc96bff700  1  request timeout\r\n2017-09-11 09:23:02.805498 7fbc96bff700  0 store->fetch_remote_obj() returned r=-5\r\n2017-09-11 09:23:02.805569 7fbc837fd700  5 Sync:9e09ddca:data:Object:xx3:9e09ddca-a536-4951-89b5-d93aab87265e.4138.1:1/obj_23[0]:done, retcode=-5\r\n2017-09-11 09:23:02.805578 7fbc837fd700  0 ERROR: failed to sync object: xx3:9e09ddca-a536-4951-89b5-d93aab87265e.4138.1:1/obj_23\r\n2017-09-11 09:23:02.814598 7fbc837fd700  5 Sync:9e09ddca:data:Object:xx3:9e09ddca-a536-4951-89b5-d93aab87265e.4138.1:1/obj_23[0]:finish\r\n2017-09-11 09:23:02.814612 7fbc837fd700  0 ERROR: a child operation returned error (ret=-5)\r\n2017-09-11 09:23:02.814615 7fbc837fd700  0 ERROR:*exit increment sync and retry*\r\n\r\n\r\n重现方法：\r\n1，使用bi shard为4的bucket\r\n2，设置rgw_curl_timeout时间为20s\r\n3，使用tc，配置丢包率在30%，20%\r\n4，使用脚本密集写一些对象\r\n\r\n#!/bin/sh\r\n\r\nNUM=50\r\nCN=1\r\nwhile [ 1 == 1 ]; do\r\n    CN=1\r\n    while [ $CN -le $NUM ] ; \r\n    do\r\n        echo ${CN}\r\n        ./s3.sh upload_object ./s3.sh xx3 obj_${CN}\r\n    #sleep 1\r\n        CN=$((CN + 1))\r\n    done\r\ndone\r\n\r\n通过在日志中搜索"a child operation returned error"，如果出现该日志，在修复之前的版本就有可能出现hang的情况了。	2017-09-11 15:07:06.2593	f
9	5	Issue	5	使用tc模拟丢包来重现，但是需要一点就是后来上传的对象的名字要与之前的一样，否则不会走到这里。\r\n可以把bucket的shard搞小点，这样比较好测试\r\n\r\n测试的时候还发现另一种情况：\r\nRGWBucketShardIncrementalSyncCR的spwan stack都完成了，只剩lease stack，但是lease stack并未结束 （第一个发现时，lease stack结束了 retcode = -16）。\r\n同样卡在2573行，且该cr不会被调度了。	2017-09-11 08:31:22.917385	f
14	5	Issue	5	只要确保所有child stack错误处理应该就不会卡在这里。\r\nchild stack必然经过collect处理，所以parent总是能感知child上发生的错误。	2017-09-11 14:42:41.27964	f
21	8	Issue	5	然在来这里设置的\r\n\r\n<pre><code class="cpp">\r\nmode_t get_mode(headers_t& meta, const char* path, bool checkdir, bool forcedir)\r\n{\r\n  mode_t mode = 0;\r\n  bool isS3sync = false;\r\n  headers_t::const_iterator iter;\r\n\r\n  if(meta.end() != (iter = meta.find("x-amz-meta-mode"))){\r\n    mode = get_mode((*iter).second.c_str());\r\n  }else{\r\n    if(meta.end() != (iter = meta.find("x-amz-meta-permissions"))){ // for s3sync\r\n      mode = get_mode((*iter).second.c_str());\r\n      isS3sync = true;\r\n    }\r\n  }\r\n  // Checking the bitmask, if the last 3 bits are all zero then process as a regular\r\n  // file type (S_IFDIR or S_IFREG), otherwise return mode unmodified so that S_IFIFO,\r\n  // S_IFSOCK, S_IFCHR, S_IFLNK and S_IFBLK devices can be processed properly by fuse.\r\n  if(!(mode & S_IFMT)){\r\n    if(!isS3sync){\r\n      if(checkdir){\r\n        if(forcedir){\r\n          mode |= S_IFDIR;\r\n        }else{\r\n          if(meta.end() != (iter = meta.find("Content-Type"))){\r\n            string strConType = (*iter).second;\r\n            // Leave just the mime type, remove any optional parameters (eg charset)\r\n            string::size_type pos = strConType.find(";");\r\n            if(string::npos != pos){\r\n              strConType = strConType.substr(0, pos);\r\n            }\r\n            if(strConType == "application/x-directory"){\r\n              mode |= S_IFDIR;\r\n            }else if(path && 0 < strlen(path) && '/' == path[strlen(path) - 1]){\r\n              if(strConType == "binary/octet-stream" || strConType == "application/octet-stream"){\r\n                mode |= S_IFDIR;\r\n              }else{\r\n                if(complement_stat){\r\n                  // If complement lack stat mode, when the object has '/' charactor at end of name\r\n                  // and content type is text/plain and the object's size is 0 or 1, it should be\r\n                  // directory.\r\n                  off_t size = get_size(meta);\r\n                  if(strConType == "text/plain" && (0 == size || 1 == size)){\r\n                    mode |= S_IFDIR;\r\n                  }else{\r\n                    mode |= S_IFREG;\r\n                  }\r\n                }else{\r\n                  mode |= S_IFREG;\r\n                }\r\n              }\r\n            }else{\r\n              mode |= S_IFREG;\r\n            }\r\n          }else{\r\n            mode |= S_IFREG;\r\n          }\r\n        }\r\n      }\r\n      // If complement lack stat mode, when it's mode is not set any permission,\r\n      // the object is added minimal mode only for read permission.\r\n      if(complement_stat && 0 == (mode & (S_IRWXU | S_IRWXG | S_IRWXO))){\r\n        mode |= (S_IRUSR | (0 == (mode & S_IFDIR) ? 0 : S_IXUSR));\r\n      }\r\n    }else{\r\n      if(!checkdir){\r\n        // cut dir/reg flag.\r\n        mode &= ~S_IFDIR;\r\n        mode &= ~S_IFREG;\r\n      }\r\n    }\r\n  }\r\n  return mode;\r\n}\r\n</code></pre>\r\n	2017-09-12 19:34:19.497896	f
16	5	Issue	5	经测试问题得到解决	2017-09-11 20:34:12.784617	f
17	5	Issue	5		2017-09-11 20:34:30.828187	f
18	8	Issue	5	(gdb) p (char *)0x7f5b7c001d80 \r\n$19 = 0x7f5b7c001d80 "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?><ListBucketResult xmlns=\\"http://s3.amazonaws.com/doc/2006-03-01/\\"><Name>xx1</Name><Prefix></Prefix><Marker></Marker><MaxKeys>1000</MaxKeys><Delimiter>/</Delimiter><IsTruncated>false</IsTruncated><Contents><Key>cr.dump</Key><LastModified>2017-09-12T09:57:51.565Z</LastModified><ETag>&quot;29ea96a1b63dc3596db60be0542cf1f1&quot;</ETag><Size>360968</Size><StorageClass>STANDARD</StorageClass><Owner><ID>nuser</ID><DisplayName>nuser</DisplayName></Owner></Contents><CommonPrefixes><Prefix>vv/</Prefix></CommonPrefixes></ListBucketResult>"\r\n\r\n\r\n这是一个正常的结果	2017-09-12 14:30:42.230703	f
22	8	Issue	5		2017-09-12 19:47:54.452545	f
23	8	Issue	5	 注意s3broswer的content-type是空的，head命令返回时没有携带该header\r\n 所以需要改的是这里\r\n     }else{\r\n           * if (path && 0 < strlen(path) && '/' == path[strlen(path) - 1])\r\n              mode |= S_IFDIR;\r\n            else\r\n              mode |= S_IFREG;*\r\n          }\r\n\r\n测试通过！	2017-09-12 19:49:50.53188	f
26	10	Issue	5	#1  0x00007f2ba368fe6a in Wait (mutex=..., this=0x7f2b53ccb0c0) at ./common/Cond.h:56\r\n#2  Throttle::_wait (this=this@entry=0x7f2b9d54cfd0, c=c@entry=4194304) at common/Throttle.cc:107\r\n#3  0x00007f2ba3690aa7 in Throttle::get (this=0x7f2b9d54cfd0, c=4194304, m=0) at common/Throttle.cc:177\r\n#4  0x00007f2ba35f0b25 in Objecter::_throttle_op (this=this@entry=0x7f2b9d54cb00, op=op@entry=0x7f2a24811c80, sul=..., op_budget=op_budget@entry=4194304) at osdc/Objecter.cc:3114\r\n#5  0x00007f2ba35fd3b8 in _take_op_budget (sul=..., op=0x7f2a24811c80, this=0x7f2b9d54cb00) at osdc/Objecter.h:1931\r\n#6  Objecter::_op_submit_with_budget (this=this@entry=0x7f2b9d54cb00, op=op@entry=0x7f2a24811c80, sul=..., ptid=ptid@entry=0x7f2a248b2b30, ctx_budget=ctx_budget@entry=0x0) at osdc/Objecter.cc:2154\r\n#7  0x00007f2ba35fd5bd in Objecter::op_submit (this=0x7f2b9d54cb00, op=op@entry=0x7f2a24811c80, ptid=ptid@entry=0x7f2a248b2b30, ctx_budget=ctx_budget@entry=0x0) at osdc/Objecter.cc:2138\r\n#8  0x00007f2ba35d2b80 in librados::IoCtxImpl::aio_operate_read (this=0x7f2b644aac00, oid=..., o=0x7f2b4a4fd100, c=0x7f2a248b2a80, flags=flags@entry=0, pbl=pbl@entry=0x0) at librados/IoCtxImpl.cc:749\r\n#9  0x00007f2ba359eb5f in librados::IoCtx::aio_operate (this=this@entry=0x7f2b5f3fc0c0, oid="bae868b8-766d-4963-b5ad-66f46cc22f87.27202.2__shadow_.Fm9FwIwFIy0-KODJi2AIl-GV2LYkFqg_95", c=c@entry=0x7f2a24890930, o=o@entry=0x7f2b5f3fc0d0, pbl=pbl@entry=0x0) at librados/librados.cc:1463\r\n#10 0x00007f2bae44f532 in RGWRados::get_obj_iterate_cb (this=0x7f2b9d52ac00, ctx=<optimized out>, astate=0x7f2a24881098, obj=..., obj_ofs=398458880, read_ofs=read_ofs@entry=0, len=4194304, is_head_obj=false, arg=arg@entry=0x7f2a24813a80) at rgw/rgw_rados.cc:9573\r\n#11 0x00007f2bae44fcee in _get_obj_iterate_cb (obj=..., obj_ofs=<optimized out>, read_ofs=0, len=<optimized out>, is_head_obj=<optimized out>, astate=<optimized out>, arg=0x7f2a24813a80) at rgw/rgw_rados.cc:9427\r\n#12 0x00007f2bae452ae4 in RGWRados::iterate_obj (this=this@entry=0x7f2b9d52ac00, obj_ctx=..., obj=..., ofs=398458880, ofs@entry=0, end=end@entry=419430399, max_chunk_size=4194304, iterate_obj_cb=iterate_obj_cb@entry=0x7f2bae44fcb0 <_get_obj_iterate_cb(rgw_obj&, off_t, off_t, off_t, bool, RGWObjState*, void*)>, arg=arg@entry=0x7f2a24813a80) at rgw/rgw_rados.cc:9677\r\n#13 0x00007f2bae452f22 in RGWRados::Object::Read::iterate (this=this@entry=0x7f2b5f3fc920, ofs=0, end=419430399, cb=cb@entry=0x7f2b5f3fc8b0) at rgw/rgw_rados.cc:9608\r\n#14 0x00007f2bae4042cb in RGWGetObj::execute (this=0x7f29cdd95600) at rgw/rgw_op.cc:1311\r\n#15 0x00007f2bae416128 in process_request (store=0x7f2b9d52ac00, rest=0x7ffefbf124b0, req=req@entry=0x7f29cdea9e80, client_io=client_io@entry=0x7f2b5f3fd710, olog=0x0) at rgw/rgw_process.cc:174\r\n#16 0x00007f2bb7eb4140 in RGWFCGXProcess::handle_request (this=0x7f2b9d5bc300, r=0x7f29cdea9e80) at rgw/rgw_fcgi_process.cc:121\r\n#17 0x00007f2bb7eb5a90 in RGWProcess::RGWWQ::_process (this=0x7f2b9d5bc5b8, req=0x7f29cdea9e80) at rgw/rgw_process.h:85\r\n#18 0x00007f2bae7743de in ThreadPool::worker (this=0x7f2b9d5bc370, wt=0x7f2b6480e1c0) at common/WorkQueue.cc:128\r\n#19 0x00007f2bae7752c0 in ThreadPool::WorkThread::entry (this=<optimized out>) at common/WorkQueue.h:445\r\n#20 0x00007f2bad76edc5 in start_thread () from /lib64/libpthread.so.0\r\n#21 0x00007f2bacd7a21d in clone () from /lib64/libc.so.6\r\n\r\n\r\n\r\n#0  0x00007f2bad7726d5 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\r\n#1  0x00007f2ba359db41 in Wait (mutex=..., this=0x7f2b96d6fed8) at ./common/Cond.h:56\r\n#2  wait_for_safe_and_cb (this=0x7f2b96d6fe80) at ./librados/AioCompletionImpl.h:111\r\n#3  librados::AioCompletion::wait_for_safe_and_cb (this=this@entry=0x7f2b96c0e7e0) at librados/librados.cc:1011\r\n#4  0x00007f2bae452f60 in wait_next_io (done=<synthetic pointer>, this=0x7f2b96c4d800) at rgw/rgw_rados.cc:9303\r\n#5  RGWRados::Object::Read::iterate (this=this@entry=0x7f2b01f86920, ofs=0, end=419430399, cb=cb@entry=0x7f2b01f868b0) at rgw/rgw_rados.cc:9615\r\n#6  0x00007f2bae4042cb in RGWGetObj::execute (this=0x7f29f14e5e00) at rgw/rgw_op.cc:1311\r\n#7  0x00007f2bae416128 in process_request (store=0x7f2b9d52ac00, rest=0x7ffefbf124b0, req=req@entry=0x7f29cde32740, client_io=client_io@entry=0x7f2b01f87710, olog=0x0) at rgw/rgw_process.cc:174\r\n#8  0x00007f2bb7eb4140 in RGWFCGXProcess::handle_request (this=0x7f2b9d5bc300, r=0x7f29cde32740) at rgw/rgw_fcgi_process.cc:121\r\n#9  0x00007f2bb7eb5a90 in RGWProcess::RGWWQ::_process (this=0x7f2b9d5bc5b8, req=0x7f29cde32740) at rgw/rgw_process.h:85\r\n#10 0x00007f2bae7743de in ThreadPool::worker (this=0x7f2b9d5bc370, wt=0x7f2b6482dd00) at common/WorkQueue.cc:128\r\n#11 0x00007f2bae7752c0 in ThreadPool::WorkThread::entry (this=<optimized out>) at common/WorkQueue.h:445\r\n#12 0x00007f2bad76edc5 in start_thread () from /lib64/libpthread.so.0\r\n#13 0x00007f2bacd7a21d in clone () from /lib64/libc.so.6\r\n\r\n\r\n\r\n#0  0x00007f846a3386d5 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\r\n#1  0x00007f846b32d02a in Wait (mutex=..., this=0x7f8421829b00) at ./common/Cond.h:56\r\n#2  Throttle::_wait (this=this@entry=0x7f84454306f8, c=c@entry=4194304) at common/Throttle.cc:107\r\n#3  0x00007f846b32dc67 in Throttle::get (this=this@entry=0x7f84454306f8, c=c@entry=4194304, m=m@entry=0) at common/Throttle.cc:177\r\n#4  0x00007f846b01518c in RGWRados::get_obj_iterate_cb (this=0x7f845a12ac00, ctx=<optimized out>, astate=0x7f84454a3098, obj=..., obj_ofs=20971520, read_ofs=read_ofs@entry=0, len=4194304, is_head_obj=false, arg=arg@entry=0x7f8445430580) at rgw/rgw_rados.cc:9557\r\n#5  0x00007f846b015cee in _get_obj_iterate_cb (obj=..., obj_ofs=<optimized out>, read_ofs=0, len=<optimized out>, is_head_obj=<optimized out>, astate=<optimized out>, arg=0x7f8445430580) at rgw/rgw_rados.cc:9427\r\n#6  0x00007f846b018ae4 in RGWRados::iterate_obj (this=this@entry=0x7f845a12ac00, obj_ctx=..., obj=..., ofs=20971520, ofs@entry=0, end=end@entry=419430399, max_chunk_size=4194304, iterate_obj_cb=iterate_obj_cb@entry=0x7f846b015cb0 <_get_obj_iterate_cb(rgw_obj&, off_t, off_t, off_t, bool, RGWObjState*, void*)>, arg=arg@entry=0x7f8445430580) at rgw/rgw_rados.cc:9677\r\n#7  0x00007f846b018f22 in RGWRados::Object::Read::iterate (this=this@entry=0x7f83f1bf1920, ofs=0, end=419430399, cb=cb@entry=0x7f83f1bf18b0) at rgw/rgw_rados.cc:9608\r\n#8  0x00007f846afca2cb in RGWGetObj::execute (this=0x7f8421519a00) at rgw/rgw_op.cc:1311\r\n#9  0x00007f846afdc128 in process_request (store=0x7f845a12ac00, rest=0x7fff6d6d7300, req=req@entry=0x7f82722cc540, client_io=client_io@entry=0x7f83f1bf2710, olog=0x0) at rgw/rgw_process.cc:174\r\n#10 0x00007f8474a7a140 in RGWFCGXProcess::handle_request (this=0x7f845a1bc300, r=0x7f82722cc540) at rgw/rgw_fcgi_process.cc:121\r\n#11 0x00007f8474a7ba90 in RGWProcess::RGWWQ::_process (this=0x7f845a1bc5b8, req=0x7f82722cc540) at rgw/rgw_process.h:85\r\n#12 0x00007f846b33a3de in ThreadPool::worker (this=0x7f845a1bc370, wt=0x7f84214196a0) at common/WorkQueue.cc:128\r\n#13 0x00007f846b33b2c0 in ThreadPool::WorkThread::entry (this=<optimized out>) at common/WorkQueue.h:445\r\n#14 0x00007f846a334dc5 in start_thread () from /lib64/libpthread.so.0\r\n#15 0x00007f846994021d in clone () from /lib64/libc.so.6\r\n\r\n一些throttle	2017-09-25 15:37:06.235366	f
232	76	Issue	5	没了unlink instance之后，删除delete marker成了一个问题。 通用路径上需要get到对象才能删除。\r\n但是delete marker又比较特殊。\r\n\r\n搞到单机功能可用，就合入。	2018-07-04 13:43:27.790996	f
234	76	Issue	5	干掉rgw_bucket_entry_ver	2018-07-06 11:36:45.598122	f
236	76	Issue	5	delete_at， if_match, if_not_match 标记的处理	2018-07-06 12:44:01.359579	f
237	76	Issue	5	*实现gc*	2018-07-06 12:54:48.978748	f
240	79	Issue	5	obj_tag改为使用instance，rados instance，作为对象的唯一标识。\r\n\r\n在读取对象信息时，将删除掉的obj读取出来怎么样？\r\n但是这样就得读取多次。\r\n\r\n在成功之后，直接调用cls_get 接口获取需要delete的entry。但是并非总是一个。比如修改bi成功之后，添加到gc失败了。 下次来就有更多的delete。\r\n\r\n	2018-07-11 13:32:44.361288	f
319	98	Issue	5	定义每个文档的负责人。\r\n定义清楚人的工作职责	2018-09-17 09:50:26.339011	f
604	216	Issue	5	支持模拟运行，可对接本地的rocksdb和目录运行。\r\n支持性能统计，以及故障随机注入等。	2019-02-16 14:38:05.603978	f
19	8	Issue	5	<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?><ListBucketResult xmlns=\\"http://s3.amazonaws.com/doc/2006-03-01/\\"><Name>xx1</Name><Prefix></Prefix><Marker></Marker><MaxKeys>1000</MaxKeys><Delimiter>/</Delimiter><IsTruncated>false</IsTruncated><Contents><Key>cr.dump</Key><LastModified>2017-09-12T09:57:51.565Z</LastModified><ETag>&quot;29ea96a1b63dc3596db60be0542cf1f1&quot;</ETag><Size>360968</Size><StorageClass>STANDARD</StorageClass><Owner><ID>nuser</ID><DisplayName>nuser</DisplayName></Owner></Contents><CommonPrefixes><Prefix>ddd/</Prefix></CommonPrefixes><CommonPrefixes><Prefix>vv/</Prefix></CommonPrefixes></ListBucketResult>\r\n\r\n异常时，s3fs收到的数据，其中ddd应该是目录\r\n\r\n而且调试也是走的dir\r\nBreakpoint 2, S3ObjList::insert (this=this@entry=0x7f5b894df930, name=name@entry=0x7f5b8417e570 "ddd", etag=0x0, is_dir=is_dir@entry=true) at s3fs_util.cpp:76\r\n76\ts3fs_util.cpp: No such file or directory.\r\n(gdb) c\r\nContinuing.\r\n\r\nBreakpoint 2, S3ObjList::insert (this=this@entry=0x7f5b894df930, name=name@entry=0x7f5b8417e570 "vv", etag=0x0, is_dir=is_dir@entry=true) at s3fs_util.cpp:76\r\n76\tin s3fs_util.cpp\r\n(gdb) c\r\nContinuing.\r\n\r\n但是显示的却是：\r\n[root@localhost s3fs-fuse-1.82]# ls -l /tmp/xx2\r\ntotal 354\r\n----------. 1 root root 360968 Sep 12 05:57 cr.dump\r\n----------. 1 root root      0 Sep 12 06:15 ddd\r\nd---------. 1 root root      0 Sep 12 04:58 vv	2017-09-12 15:46:18.396585	f
20	8	Issue	5	172.18.0.1 - - [12/Sep/2017:13:30:36 +0000] "GET /xx1?prefix=&max-keys=1000&delimiter=%2F HTTP/1.1" 200 697 "-" "CloudBerryLab.Base.HttpUtil.Client 5.0.3 (http://www.cloudberrylab.com/)" "-"\r\n172.18.0.1 - - [12/Sep/2017:13:30:40 +0000] "HEAD /xx1/kk/ HTTP/1.1" 404 0 "-" "CloudBerryLab.Base.HttpUtil.Client 5.0.3 (http://www.cloudberrylab.com/)" "-"\r\n172.18.0.1 - - [12/Sep/2017:13:30:40 +0000] "PUT /xx1/kk/ HTTP/1.1" 200 0 "-" "CloudBerryLab.Base.HttpUtil.Client 5.0.3 (http://www.cloudberrylab.com/)" "-"\r\n172.18.0.1 - - [12/Sep/2017:13:30:40 +0000] "GET /xx1?prefix=&max-keys=1000&delimiter=%2F HTTP/1.1" 200 750 "-" "CloudBerryLab.Base.HttpUtil.Client 5.0.3 (http://www.cloudberrylab.com/)" "-"\r\n172.18.0.1 - - [12/Sep/2017:13:30:48 +0000] "GET /xx1/?delimiter=/&max-keys=1000&prefix= HTTP/1.1" 200 750 "-" "s3fs/1.80 (commit hash unknown; OpenSSL)" "-"\r\n172.18.0.1 - - [12/Sep/2017:13:31:14 +0000] "HEAD /xx1/kk/ HTTP/1.1" 200 0 "-" "s3fs/1.80 (commit hash unknown; OpenSSL)" "-"\r\n\r\n这是gdb调试的过程，可见s3fs做了一次cache，新创建的目录kk执行了HEAD命令。	2017-09-12 19:03:36.596826	f
24	9	Issue	5	处理的handle是RGWHandler_REST_Service_S3 就是list bucket的请求handle\r\n\r\n但是这个handler并没有OPTIONS方法。所以返回值的是405. 请求被禁止	2017-09-14 16:02:19.517578	f
25	10	Issue	5	100个cosbench并发读取400M文件：\r\n\r\nop1: read \t748 ops \t313.73 GB \t43431.18 ms \t11828.07 ms \t1.68 op/s \t703.79 MB/S \t74.8% \r\n\r\n第二次记录100并发：\r\nop1: read \t740 ops \t310.38 GB \t48013.19 ms \t17354.92 ms \t1.56 op/s \t655.66 MB/S \t74% \r\n\r\n50个并发：\r\nop1: read \t280 ops \t117.44 GB \t27852.87 ms \t3414.41 ms \t0.79 op/s \t329.62 MB/S \t56% \r\n\r\n第二次50并发测试\r\nop1: read \t319 ops \t133.8 GB \t25651.13 ms \t4085.41 ms \t0.92 op/s \t386.41 MB/S \t63.8%\r\n\r\n再次记录50并发：\r\nop1: read \t385 ops \t161.48 GB \t28168.32 ms \t1363.48 ms \t1.23 op/s \t516.76 MB/S \t77% \r\n\r\n\r\n疑问;带宽都跑不满，为什么还有这么多超时？\r\n\r\n后面再跑 性能又上来了，同样的压力\r\n\r\nop1: read \t500 ops \t209.72 GB \t19276.92 ms \t1787.86 ms \t2.6 op/s \t1.09 GB/S \t100% \r\n\r\ncosbench测试波动非常大，是不是有请求阻塞了呢？ 目前有什么手段分析超时请求么？	2017-09-25 13:17:05.910798	f
27	10	Issue	5	civetweb效果：\r\n50并发：\r\nop1: read \t500 ops \t209.72 GB \t17371.17 ms \t1123.35 ms \t2.88 op/s \t1.21 GB/S \t100% \r\n100并发\r\nop1: read \t1 kops \t      419.43 GB \t35341.8 ms \t2156.81 ms \t2.83 op/s \t1.19 GB/S \t100% \r\n\r\n100个callback线程，16在调用send， 84个在throttle wait。即便这样还能把带宽跑满。\r\n不知道他们的流控参数怎样，何以都不处于流控状态？\r\n\r\nop1: read \t2 kops \t838.86 GB \t73014.83 ms \t4020.73 ms \t2.74 op/s \t1.15 GB/S \t100% \r\n看不懂cosbench的超时到底是多久？\r\n看来s3的请求也不是sb形式的.中间能收到数据包可能不会超时。\r\n\r\n"get": 2000,\r\n        "get_b": 8190000,\r\n        "get_initial_lat": {\r\n            "avgcount": 2000,\r\n            "sum": 30.675071437  （时间单位是s）\r\n        },\r\n	2017-09-25 21:23:14.88661	f
29	10	Issue	5	java.net.SocketTimeoutException: Read timed out\r\n        at java.net.SocketInputStream.socketRead0(Native Method)\r\n        at java.net.SocketInputStream.socketRead(Unknown Source)\r\n        at java.net.SocketInputStream.read(Unknown Source)\r\n        at java.net.SocketInputStream.read(Unknown Source)\r\n        at org.apache.http.impl.io.AbstractSessionInputBuffer.read(AbstractSessionInputBuffer.java:198)\r\n        at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:178)\r\n        at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:137)\r\n        at com.amazonaws.internal.SdkFilterInputStream.read(SdkFilterInputStream.java:72)\r\n        at com.amazonaws.event.ProgressInputStream.read(ProgressInputStream.java:151)\r\n        at com.amazonaws.internal.SdkFilterInputStream.read(SdkFilterInputStream.java:72)\r\n        at com.amazonaws.services.s3.model.S3ObjectInputStream.read(S3ObjectInputStream.java:155)\r\n        at com.amazonaws.internal.SdkFilterInputStream.read(SdkFilterInputStream.java:72)\r\n堆栈在这里	2017-09-26 15:58:56.652481	f
28	10	Issue	5	civetweb不适合做高性能服务器，但是这种大快可能也不存在问题。 \r\n\r\n谢锐(x8671r@163.com)  11:48:21\r\n我测试cosbench 400并发读400MB文件 在civetweb下都没超时。只是延迟增大了很多\r\nop1: read \t4 kops \t1.68 TB \t144089.9 ms \t7844.06 ms \t2.78 op/s \t1.16 GB/S \t100% \r\n谢锐(x8671r@163.com)  11:50:04\r\n看来cosbench超时并不是看的处理总时间 可能是看多久都没回任何应答\r\n\r\n使用3个cosbench dirver跑效果差不多，600并发。延迟200多s，也出现超时了\r\nop1: read \t3.09 kops \t1.3 TB \t207271.57 ms \t12194.16 ms \t2.54 op/s \t1.07 GB/S \t85.89%\r\n\r\n\r\n所以这个问题原因基本可以排除是单纯的civetweb性能问题。\r\n有多种可能：\r\n1，网卡带宽不够，压力过大\r\n2，civetweb在hammer版本存在bug\r\n3，业务模型比我们测试更加复杂，受业务模型影响。\r\n\r\n还需要定位的问题是为什么fastcgi的表现这么差，就算50并发也有超时？ 我觉得可能跟并发数量的限制有点关系。\r\n网络没到瓶颈，rados osd节点也没压力，那只能是nginx 或者rgw有性能问题了。\r\n	2017-09-26 07:30:39.88514	f
30	11	Issue	5	该环境上出现主板损坏，在恢复之后，osd被拉起几分钟后出现了时间变化。大约隔了8个小时	2017-09-29 12:36:24.73952	f
31	11	Issue	5	bucket index记录条数达到10万级别时，scrub和recovery这个对象需要多久，这个需要验证下。\r\n如果时间过长，可能得想办法缩小bucket index。\r\n\r\n经验证，一个bucket index内10万数据秒间完成。难道是总对象数量太少了？	2017-09-30 07:34:39.771971	f
32	12	Issue	5	2017-10-09 02:22:29.246669 7f47d4bfe700 10 received header:HTTP/1.1 400 Bad Request\r\n2017-10-09 02:22:29.246673 7f47d4bfe700 10 receive_http_header\r\n2017-10-09 02:22:29.246673 7f47d4bfe700 10 received header:content-type: text/plain; charset=UTF-8\r\n2017-10-09 02:22:29.246678 7f47d4bfe700 10 receive_http_header\r\n2017-10-09 02:22:29.246679 7f47d4bfe700 10 received header:content-length: 126\r\n	2017-10-09 08:07:17.420433	f
251	82	Issue	5	输出V5.2.0迭代计划。	2018-07-23 08:01:24.421458	f
33	12	Issue	5	从tcpdump结果看，json格式数据并没问题。看来可能是/导致的。\r\n如何验证呢\r\n\r\n{\r\n                "_index": "rgw-china-f9fc7c72", \r\n                "_type": "object", \r\n                "_id": "99c3ac9e-e654-4fd9-9f9f-4a68eb74240e.4147.1:xie.png:null", \r\n                "_score": 1, \r\n                "_source": {\r\n                    "bucket": "xxx1", \r\n                    "name": "xie.png", \r\n                    "instance": "", \r\n                    "versioned_epoch": 0, \r\n                    "owner": {\r\n                        "id": "nuser", \r\n                        "display_name": "nuser"\r\n                    }, \r\n                    "permissions": [\r\n                        "nuser"\r\n                    ], \r\n                    "meta": {\r\n                        "size": 2062, \r\n                        "mtime": "2017-09-22T03:10:20.822Z", \r\n                        "content_type": "image/png", \r\n                        "etag": "faaee68556e04f6000f68d8c85dac00b", \r\n                        "x-amz-acl": "private", \r\n                        "x-amz-copy-source": "/xxx1/xie.png", \r\n                        "x-amz-date": "Fri, 22 Sep 2017 03:21:05 GMT", \r\n                        "x-amz-metadata-directive": "REPLACE", \r\n                        "x-amz-storage-class": "STANDARD"\r\n                    }\r\n                }\r\n            }, \r\n\r\n这个结构怎么来的。\r\n\r\n"_index": "rgw-china-f9fc7c72", \r\n"_type": "object", \r\n"_id": "99c3ac9e-e654-4fd9-9f9f-4a68eb74240e.4147.1:xie.png:null", \r\n"_score": 1, \r\n"_source"\r\n这部分是es的元数据	2017-10-09 12:17:27.095247	f
35	12	Issue	5	  string get_obj_path(const RGWBucketInfo& bucket_info, const rgw_obj_key& key) {\r\n    string id;\r\n    url_encode(key.name, id);\r\n    return index_path +  "/object/" + bucket_info.bucket.bucket_id + ":" + id + ":" + (key.instance.empty() ? "null" : key.instance);\r\n  }\r\n \r\n  加个url_encode 看看	2017-10-09 15:27:13.461325	f
37	13	Issue	5	增加分词符号也许是一个解决办法。	2017-10-10 12:19:39.770212	f
39	13	Issue	5	文件名称的分词方法，规则可以更多。比如. / 都可以作为分词符号，不仅是空格。	2017-10-10 12:45:46.072892	f
41	13	Issue	5	keyword字段类型不对，并且要选择合适的analyzer。\r\n\r\n修改方法：\r\n1，修改字段类型，使用text\r\n2，修改默认的分词器，使用中文分词\r\n\r\n每个字段定义分词方式有点难受。	2017-10-10 14:18:24.074706	f
42	14	Issue	5	用法不对，少了--    但是radosgw-admin没提示\r\n\r\nbin/radosgw-admin zone modify --rgw-zone=SZES --endpoints=http://172.18.0.130:8082	2017-10-11 07:34:19.775305	f
45	16	Issue	5	不仅通知可能丢失，30s一次的记录data log也是不可靠的。\r\n但是这不影响最终的数据同步，只是同步的时间可能被拉的非常长。	2017-10-11 13:21:34.464854	f
47	15	Issue	5	修复es的bug\r\n多版本的详细介绍\r\nEC实现的详细介绍\r\n	2017-10-13 13:08:55.209733	f
48	18	Issue	5		2017-10-16 13:16:26.772704	f
49	18	Issue	5	NotifyMessage携带编解码问题。\r\n定义notify的type，提供encode/decode方法\r\n\r\n每个notify的type，提供处理方法\r\ntemplate <typename I>\r\nbool ImageWatcher<I>::handle_payload\r\n\r\nAcquireRequest是什么？ImageCtx header如何刷新？\r\nAioImageRequestWQ::_void_dequeue在这里面判断了，只是代码架构调整了。\r\n\r\n增加了类ImageState\r\n\r\n如果需要refresh，那么就在refresh成功之后，才把普通op丢到处理队列。\r\n\r\nImageWatcher还搞一个泛型，真是日了狗了。\r\n\r\nrbd命令参数--help看不到：\r\nvoid get_add_arguments(po::options_description *positional,\r\n                       po::options_description *options) {\r\n  at::add_image_spec_options(positional, options, at::ARGUMENT_MODIFIER_NONE);\r\n  add_id_option(positional);\r\n  options->add_options()\r\n    ("shared", po::value<std::string>(), "shared lock tag");\r\n}\r\n日了，这是。泛型搞的source insight基本没法看c++了\r\nvoid add_id_option(po::options_description *positional) {\r\n  positional->add_options()\r\n    ("lock-id", "unique lock id");\r\n}\r\nbin/rbd lock add lock-id mylock --image xr1\r\n\r\n\r\n这个lock特性就是给单边使用的。rbd map等，只能一个节点可以读写。	2017-10-16 15:39:27.942695	f
51	18	Issue	5	有个奇怪的现象 一个sqlite打开db之后，会主动抢占锁。\r\n另外一个继续操作就会报：\r\nsqlite> .tables\r\nError: database disk image is malformed\r\n\r\n但是并不退出。\r\n\r\n但数据库实际上并未损坏，只是没法读写而已。	2017-10-18 14:02:23.952447	f
55	19	Issue	5	es同步情况：\r\n\r\n{\r\n        "key": 14,\r\n        "val": {\r\n            "status": "incremental-sync",\r\n            "full_marker": {\r\n                "position": {\r\n                    "name": "aabbcc.mp3",\r\n                    "instance": "null"\r\n                },\r\n                "count": 1\r\n            },\r\n            "inc_marker": {\r\n                "position": "00000000023.30.3"\r\n            }\r\n        }\r\n    },\r\n\r\nmaster zone，bilog也是到这里\r\n\r\n{\r\n        "op_id": "14#00000000021.27.10",\r\n        "op_tag": "0000000059e481eau3291g7c0ld3z0fq",\r\n        "op": "link_olh",\r\n        "object": "aabbcc.mp3",\r\n        "instance": "4npayy3yx56tp1uy-sSS3gqgGM6F9pv",\r\n        "state": "complete",\r\n        "index_ver": 21,\r\n        "timestamp": "2017-10-16 09:54:50.097805579Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 2\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n\r\n2017-10-19 07:27:20.551952 7f2a9bbff700 20 parsed entry: id=00000000059.341.9 iter->object=sds-osd.rar iter->instance=hqrRIfstpKnCSxqdg05oo.BXlgjo08P name=sds-osd.rar instance= ns=\r\n2017-10-19 07:27:20.551955 7f2a9bbff700 20 [inc sync] skipping object: xx5:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6:20/sds-osd.rar[hqrRIfstpKnCSxqdg05oo.BXlgjo08P]: squashed operation\r\n\r\n居然link_olh的bilog被squashed了。\r\n显然有bug\r\nhttp://tracker.ceph.com/issues/18208\r\n	2017-10-19 13:51:41.141199	f
50	18	Issue	5	看来可以想办法借用上lock exclusive特性。这个是为lun的互斥访问量身定做的。\r\n先摸清楚用法\r\n\r\ntemplate <typename I>\r\nvoid ReacquireRequest<I>::set_cookie() {\r\n  CephContext *cct = m_image_ctx.cct;\r\n  ldout(cct, 10) << dendl;\r\n\r\n  librados::ObjectWriteOperation op;\r\n  rados::cls::lock::set_cookie(&op, RBD_LOCK_NAME, LOCK_EXCLUSIVE, m_old_cookie,\r\n                               ExclusiveLock<>::WATCHER_LOCK_TAG, m_new_cookie);\r\n\r\n  librados::AioCompletion *rados_completion = create_rados_safe_callback<\r\n    ReacquireRequest<I>, &ReacquireRequest<I>::handle_set_cookie>(this);\r\n  int r = m_image_ctx.md_ctx.aio_operate(m_image_ctx.header_oid,\r\n                                         rados_completion, &op);\r\n  assert(r == 0);\r\n  rados_completion->release();\r\n}\r\n\r\n测试用例中有用法。\r\n\r\nsqlite open：\r\nopen\r\nacquire lock\r\n\r\nclose\r\nrelease lock\r\n\r\nom：\r\ncheck lock\r\nbreak lock\r\n\r\n需要验证一下	2017-10-17 15:13:51.330058	f
56	19	Issue	5		2017-10-19 14:05:53.381769	f
34	12	Issue	5	\r\n解决方法\r\n没有约束.可以使用正斜杠.但是为了在REST API中使用这样的id,它必须被url编码:\r\n\r\n$ curl -XPUT "localhost:9200/id-test-index/rec/1+1%2F2" -d '{"field" : "one and a half"}'\r\n这个方法好使。\r\n例如：\r\ncurl -XPUT http://172.18.0.151:9200/rgw-china-f9fc7c72/object/99c3ac9e-e654-4fd9-9f9f-4a68eb74240e.4147.1:test3%2F:jerry -d '{"field" : "test3/jerry"}'\r\n\r\nname如果不使用全名，怎么找到对象？ 如果使用全名，是否影响搜索？\r\n搜索通常不会使用目录名吧，\r\n[root@localhost ~]# curl -XGET 172.18.0.151:9200/_search?q=field:jerry\r\n{"took":4,"timed_out":false,"_shards":{"total":20,"successful":20,"failed":0},"hits":{"total":1,"max_score":0.25811607,"hits":[{"_index":"rgw-china-f9fc7c72","_type":"object","_id":"99c3ac9e-e654-4fd9-9f9f-4a68eb74240e.4147.1:test3/:jerry","_score":0.25811607,"_source":{"field" : "test3/jerry"}}]}}\r\n\r\n[root@localhost ~]# curl -XGET 172.18.0.151:9200/_search?q=field:test3/jerry\r\n{"error":{"root_cause":[{"type":"query_shard_exception","reason":"Failed to parse query [field:test3/jerry]","index_uuid":"-XlvdsplTayDFIwREo0N7g","index":"rgw-china-95fdffb3"},{"type":"query_shard_exception","reason":"Failed to parse query [field:test3/jerry]","index_uuid":"69sFlh-SSN-knd0l1iHMbQ","index":"rgw-china-f9fc7c72"}],"type":"search_phase_execution_exception","reason":"all shards failed","phase":"query","grouped":true,"failed_shards":[{"shard":0,"index":"rgw-china-95fdffb3","node":"rog_3_rvTj6Kj04ZbcpOwA","reason":{"type":"query_shard_exception","reason":"Failed to parse query [field:test3/jerry]","index_uuid":"-XlvdsplTayDFIwREo0N7g","index":"rgw-china-95fdffb3","caused_by":{"type":"parse_exception","reason":"Cannot parse 'field:test3/jerry': Lexical error at line 1, column 18.  Encountered: <EOF> after : \\"/jerry\\"","caused_by":{"type":"token_mgr_error","reason":"Lexical error at line 1, column 18.  Encountered: <EOF> after : \\"/jerry\\""}}}},{"shard":0,"index":"rgw-china-f9fc7c72","node":"rog_3_rvTj6Kj04ZbcpOwA","reason":{"type":"query_shard_exception","reason":"Failed to parse query [field:test3/jerry]","index_uuid":"69sFlh-SSN-knd0l1iHMbQ","index":"rgw-china-f9fc7c72","caused_by":{"type":"parse_exception","reason":"Cannot parse 'field:test3/jerry': Lexical error at line 1, column 18.  Encountered: <EOF> after : \\"/jerry\\"","caused_by":{"type":"token_mgr_error","reason":"Lexical error at line 1, column 18.  Encountered: <EOF> after : \\"/jerry\\""}}}}]},"status":400}[root@localhost ~]# \r\n[root@localhost ~]# \r\n[root@localhost ~]# curl -XGET 172.18.0.151:9200/_search?q=field:test3%2Fjerry\r\n{"error":{"root_cause":[{"type":"query_shard_exception","reason":"Failed to parse query [field:test3/jerry]","index_uuid":"-XlvdsplTayDFIwREo0N7g","index":"rgw-china-95fdffb3"},{"type":"query_shard_exception","reason":"Failed to parse query [field:test3/jerry]","index_uuid":"69sFlh-SSN-knd0l1iHMbQ","index":"rgw-china-f9fc7c72"}],"type":"search_phase_execution_exception","reason":"all shards failed","phase":"query","grouped":true,"failed_shards":[{"shard":0,"index":"rgw-china-95fdffb3","node":"rog_3_rvTj6Kj04ZbcpOwA","reason":{"type":"query_shard_exception","reason":"Failed to parse query [field:test3/jerry]","index_uuid":"-XlvdsplTayDFIwREo0N7g","index":"rgw-china-95fdffb3","caused_by":{"type":"parse_exception","reason":"Cannot parse 'field:test3/jerry': Lexical error at line 1, column 18.  Encountered: <EOF> after : \\"/jerry\\"","caused_by":{"type":"token_mgr_error","reason":"Lexical error at line 1, column 18.  Encountered: <EOF> after : \\"/jerry\\""}}}},{"shard":0,"index":"rgw-china-f9fc7c72","node":"rog_3_rvTj6Kj04ZbcpOwA","reason":{"type":"query_shard_exception","reason":"Failed to parse query [field:test3/jerry]","index_uuid":"69sFlh-SSN-knd0l1iHMbQ","index":"rgw-china-f9fc7c72","caused_by":{"type":"parse_exception","reason":"Cannot parse 'field:test3/jerry': Lexical error at line 1, column 18.  Encountered: <EOF> after : \\"/jerry\\"","caused_by":{"type":"token_mgr_error","reason":"Lexical error at line 1, column 18.  Encountered: <EOF> after : \\"/jerry\\""}}}}]},"status":400}\r\n\r\n这样是不支持的，转移了这样用也不行\r\n	2017-10-09 13:02:59.686813	f
36	12	Issue	5	该方案似乎可行 需要进一步测试。\r\n	2017-10-10 11:50:36.729748	f
38	13	Issue	5	董雷(836444522)  15:04:48\r\nname用的是match\r\n谢锐(x8671r@163.com)  15:06:06\r\n[root@localhost ~]#  curl -XGET 172.18.0.151:9200/_search -d '{"query":{"match":{"name":"2.5版本性能测试报告_64_release2.xlsx"}}}'\r\n{"took":2,"timed_out":false,"_shards":{"total":20,"successful":20,"failed":0},"hits":{"total":1,"max_score":0.9808292,"hits":[{"_index":"rgw-china-95fdffb3","_type":"object","_id":"99c3ac9e-e654-4fd9-9f9f-4a68eb74240e.4147.1:2.5版本性能测试报告_64_release2.xlsx:null","_score":0.9808292,"_source":{"bucket":"xxx1","name":"2.5版本性能测试报告_64_release2.xlsx","instance":"","versioned_epoch":0,"owner":{"id":"nuser","display_name":"nuser"},"permissions":["nuser"],"meta":{"size":33664,"mtime":"2017-10-10T06:42:05.024Z","content_type":"application\\/vnd.openxmlformats-officedocument.spreadsheetml.sheet","etag":"8739cde1c900a41a2e204a50a68c98c3","x-amz-date":"Tue, 10 Oct 2017 06:53:46 GMT"}}}]}}[root@localhost ~]# \r\n[root@localhost ~]#  curl -XGET 172.18.0.151:9200/_search -d '{"query":{"match":{"name":"性能测试"}}}'\r\n{"took":1,"timed_out":false,"_shards":{"total":20,"successful":20,"failed":0},"hits":{"total":0,"max_score":null,"hits":[]}}[root@localhost ~]# \r\n像这种我用全名也可以检索到，但是用部分检索不到	2017-10-10 12:38:12.496754	f
40	13	Issue	5	[root@localhost ~]# curl -XGET 172.18.0.151:9200/rgw-china-f9fc7c72?pretty=1\r\n{\r\n  "rgw-china-f9fc7c72" : {\r\n    "aliases" : { },\r\n    "mappings" : {\r\n      "object" : {\r\n        "properties" : {\r\n          "bucket" : {\r\n            "type" : "keyword"\r\n          },\r\n          "field" : {\r\n            "type" : "text",\r\n            "fields" : {\r\n              "keyword" : {\r\n                "type" : "keyword",\r\n                "ignore_above" : 256\r\n              }\r\n            }\r\n          },\r\n          "instance" : {\r\n            "type" : "keyword"\r\n          },\r\n          "meta" : {\r\n            "properties" : {\r\n              "cache_control" : {\r\n                "type" : "keyword"\r\n              },\r\n              "content_disposition" : {\r\n                "type" : "keyword"\r\n              },\r\n              "content_encoding" : {\r\n                "type" : "keyword"\r\n              },\r\n              "content_language" : {\r\n                "type" : "keyword"\r\n              },\r\n              "content_type" : {\r\n                "type" : "keyword"\r\n              },\r\n              "custom-date" : {\r\n                "type" : "nested",\r\n                "properties" : {\r\n                  "name" : {\r\n                    "type" : "keyword"\r\n                  },\r\n                  "value" : {\r\n                    "type" : "date"\r\n                  }\r\n                }\r\n              },\r\n              "custom-int" : {\r\n                "type" : "nested",\r\n                "properties" : {\r\n                  "name" : {\r\n                    "type" : "keyword"\r\n                  },\r\n                  "value" : {\r\n                    "type" : "long"\r\n                  }\r\n                }\r\n              },\r\n              "custom-string" : {\r\n                "type" : "nested",\r\n                "properties" : {\r\n                  "name" : {\r\n                    "type" : "keyword"\r\n                  },\r\n                  "value" : {\r\n                    "type" : "keyword"\r\n                  }\r\n                }\r\n              },\r\n              "etag" : {\r\n                "type" : "keyword"\r\n              },\r\n              "expires" : {\r\n                "type" : "keyword"\r\n              },\r\n              "mtime" : {\r\n                "type" : "date"\r\n              },\r\n              "size" : {\r\n                "type" : "long"\r\n              },\r\n              "x-amz-acl" : {\r\n                "type" : "text",\r\n                "fields" : {\r\n                  "keyword" : {\r\n                    "type" : "keyword",\r\n                    "ignore_above" : 256\r\n                  }\r\n                }\r\n              },\r\n              "x-amz-copy-source" : {\r\n                "type" : "text",\r\n                "fields" : {\r\n                  "keyword" : {\r\n                    "type" : "keyword",\r\n                    "ignore_above" : 256\r\n                  }\r\n                }\r\n              },\r\n              "x-amz-date" : {\r\n                "type" : "text",\r\n                "fields" : {\r\n                  "keyword" : {\r\n                    "type" : "keyword",\r\n                    "ignore_above" : 256\r\n                  }\r\n                }\r\n              },\r\n              "x-amz-metadata-directive" : {\r\n                "type" : "text",\r\n                "fields" : {\r\n                  "keyword" : {\r\n                    "type" : "keyword",\r\n                    "ignore_above" : 256\r\n                  }\r\n                }\r\n              },\r\n              "x-amz-storage-class" : {\r\n                "type" : "text",\r\n                "fields" : {\r\n                  "keyword" : {\r\n                    "type" : "keyword",\r\n                    "ignore_above" : 256\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          },\r\n          "name" : {\r\n            "type" : "keyword"\r\n          },\r\n          "owner" : {\r\n            "properties" : {\r\n              "display_name" : {\r\n                "type" : "text",\r\n                "fields" : {\r\n                  "keyword" : {\r\n                    "type" : "keyword",\r\n                    "ignore_above" : 256\r\n                  }\r\n                }\r\n              },\r\n              "id" : {\r\n                "type" : "text",\r\n                "fields" : {\r\n                  "keyword" : {\r\n                    "type" : "keyword",\r\n                    "ignore_above" : 256\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          },\r\n          "permissions" : {\r\n            "type" : "text",\r\n            "fields" : {\r\n              "keyword" : {\r\n                "type" : "keyword",\r\n                "ignore_above" : 256\r\n              }\r\n            }\r\n          },\r\n          "versioned_epoch" : {\r\n            "type" : "long"\r\n          }\r\n        }\r\n      }\r\n    },\r\n    "settings" : {\r\n      "index" : {\r\n        "creation_date" : "1505983035961",\r\n        "number_of_shards" : "10",\r\n        "number_of_replicas" : "1",\r\n        "uuid" : "69sFlh-SSN-knd0l1iHMbQ",\r\n        "version" : {\r\n          "created" : "5050299"\r\n        },\r\n        "provided_name" : "rgw-china-f9fc7c72"\r\n      }\r\n    }\r\n  }\r\n}	2017-10-10 13:05:40.591471	f
43	14	Issue	5	咱不解决	2017-10-11 07:35:08.973809	f
44	13	Issue	5	ok了，默认分词也可以分辨中文。\r\n\r\n将name字段改为text类型即可。	2017-10-11 08:27:39.307885	f
46	17	Issue	5	暂时不解决	2017-10-13 13:07:12.097834	f
52	18	Issue	5	sh-4.2# bin/rbd lock rm lock-id "auto 140330338880752" 1 -p sys client.4343\r\nrbd: too many arguments\r\nsh-4.2# bin/rbd lock rm lock-id "auto 139858966235872" --image image1 --pool test-librbd-localhost.localdomain-4668-1 client.4270^C\r\nsh-4.2# bin/rbd lock rm lock-id "auto 140330338880752" --image 1 -p sys client.4343\r\n\r\n莫名其妙的用法，还有如果在read/write的时候检查lock，那么进入直接就退出了。这好像也符合预期。\r\n什么乱七八槽的玩意，抢锁到底发生在哪里？\r\n\r\nsh-4.2# bin/rbd lock list 1-journal -p sys\r\nThere is 1 exclusive lock on this image.\r\nLocker      ID                   Address                  \r\nclient.4343 auto 140330338916640 172.18.0.130:0/346161615 \r\nsh-4.2# bin/rbd lock rm lock-id "auto 140330338916640" --image 1-journal -p sys client.4343\r\nsh-4.2# bin/rbd lock list 1-journal -p sys\r\n	2017-10-18 15:16:29.694772	f
53	18	Issue	5	还有个问题  sqlite3正常退出不会释放锁。\r\n\r\n似乎没有走正常的shutdown流程。但是这个框架基本上可以用了。\r\n\r\n在另一个进程打开rbd image的情况下，新的客户端无法打开。\r\n但是如果另外一个进程挂了，那么经过一旦时间后，可以打开。\r\n\r\n当然可以禁止访问，这是最重要的。	2017-10-18 15:36:26.369932	f
54	19	Issue	5	这问题非必现，但是有另外一个问题。\r\n董雷环境配置了一个业务rgw（没有启动run_sync_thread），一个es同步的rgw。\r\n\r\nes的rgw无法同步元数据。因为master zone没有sync 	2017-10-19 09:11:48.042713	f
58	19	Issue	5		2017-10-19 14:08:52.888829	f
57	19	Issue	5	创建一个bucket，上传一个大对象sds-osd.rar\r\n开启多版本，再次上传该对象。\r\n\r\nquery成功\r\n[root@localhost ceph]# curl -XGET 172.18.0.151:9200/_search?pretty=true -d '{"query":{"match":{"name":"sds-osd.rar"}}}'\r\n{\r\n  "took" : 3,\r\n  "timed_out" : false,\r\n  "_shards" : {\r\n    "total" : 30,\r\n    "successful" : 30,\r\n    "failed" : 0\r\n  },\r\n  "hits" : {\r\n    "total" : 2,\r\n    "max_score" : 2.8238168,\r\n    "hits" : [\r\n      {\r\n        "_index" : "rgw-china-4b191740",\r\n        "_type" : "object",\r\n        "_id" : "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4428.1:sds-osd.rar:null",\r\n        "_score" : 2.8238168,\r\n        "_source" : {\r\n          "bucket" : "xx6",\r\n          "name" : "sds-osd.rar",\r\n          "instance" : "",\r\n          "versioned_epoch" : 0,\r\n          "owner" : {\r\n            "id" : "nuser",\r\n            "display_name" : "nuser"\r\n          },\r\n          "permissions" : [\r\n            "nuser"\r\n          ],\r\n          "meta" : {\r\n            "size" : 57876485,\r\n            "mtime" : "2017-10-19T08:13:30.050Z",\r\n            "content_type" : "application/octet-stream",\r\n            "etag" : "651175b12c94bebfb80e6eab761c5a8b-7",\r\n            "x-amz-acl" : "private",\r\n            "x-amz-date" : "Thu, 19 Oct 2017 08:24:32 GMT"\r\n          }\r\n        }\r\n      },\r\n      {\r\n        "_index" : "rgw-china-4b191740",\r\n        "_type" : "object",\r\n        "_id" : "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4428.1:sds-osd.rar:KFWnBSg9DOPCarGXl-hnmfm-t-gfGTs",\r\n        "_score" : 0.51623213,\r\n        "_source" : {\r\n          "bucket" : "xx6",\r\n          "name" : "sds-osd.rar",\r\n          "instance" : "KFWnBSg9DOPCarGXl-hnmfm-t-gfGTs",\r\n          "versioned_epoch" : 2,\r\n          "owner" : {\r\n            "id" : "nuser",\r\n            "display_name" : "nuser"\r\n          },\r\n          "permissions" : [\r\n            "nuser"\r\n          ],\r\n          "meta" : {\r\n            "size" : 57876485,\r\n            "mtime" : "2017-10-19T08:15:57.109Z",\r\n            "content_type" : "application/octet-stream",\r\n            "etag" : "651175b12c94bebfb80e6eab761c5a8b-7",\r\n            "x-amz-acl" : "private",\r\n            "x-amz-date" : "Thu, 19 Oct 2017 08:26:59 GMT"\r\n          }\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}	2017-10-19 14:08:40.756778	f
59	20	Issue	5	谢锐(x8671r@163.com)  16:47:38\r\nIK分词结果 bbc.jpg; bbc;  jpg\r\n董雷(836444522)  16:48:52\r\nIK是指不同的分析器吗\r\n谢锐(x8671r@163.com)  16:49:13\r\n嗯 分词器\r\n这种分词结果 应该可以按后缀搜索\r\n谢锐(x8671r@163.com)  16:52:08\r\n默认分词器中文分词效率也比较低  我们需要替换下分词器\r\n杉岩数据性能指标.xlsx\r\n杉,岩,数据,性能指标,性能,能指,指标,xlsx\r\n董雷(836444522)  16:54:58\r\n默认的是中文好像是一个字一个字分	2017-10-19 14:26:26.552275	f
60	23	Issue	5	[深圳]bluefish 2017/10/23 14:54:31\r\nLicense安全加固\r\n\r\n当前版本使用license方案的缺点：\r\n1）使用machine_id、有效期、容量等信息生成的license_key，其中加密信息编解码算法使用的参数一般比较固定，为machine_id中携带的CPU的个数，然而服务器CPU个数一般都比较固定\r\n2）当前machine_id算法比较单一，要不使用的是服务器的主板id，要不就是MAC地址生成的等信息，可能会造成节点machine_id相同\r\n3）对于machine_id相同的节点，则同一个license_key对该节点进行注册使用也是有效的\r\n\r\n新的方案：\r\n1）License_key生成：\r\n输入：series_number和machine_id，有效期、容量等\r\n其中 series_number用于编解码算法使用，machine_id和有效期以及容量等是用于被加密的信息\r\nseries_number= fsid + 厂家id + cluster_created_time\r\n输出：license_key\r\n2）machine_id的生成\r\nOSD启动时候获取cpu、board_id、mem、mac等硬件组合信息进行hash运算，然后对hash值进行MD5值校验，取12个字节，前两个字节预留为了以后做CPU控制使用，最后该信息发送给MON进行bootstrap操作\r\n3）license_key注册\r\nMON收到license注册请求，用集群 series_number信息将该license_key进行解码，如果解码出来的machine_id与MON内部的保存的相同，则认为该license_key是有效的，否则是无效的\r\n新方案的优点：\r\n1）不同的集群 series_number肯定是不同的，保证了编解码算法的不同\r\n2）保证了节点生成的machine_id的不同\r\n3）即使machine_id相同，因为 series_number不同，同一个license_key也不能在其他集群节点使用	2017-10-23 12:58:58.173119	f
61	24	Issue	5	curl -L -i -v -X PUT -H "Date: Tue, 24 Oct 2017 07:30:33 GMT" -H "Authorization: AWS BVDUBNIUOW0JM72RE9MQ:eRByi/+uumK+9At2i1M/10lgiyM=" -H "x-amz-copy-source:/xx5/quick.txt?=versionId=5nI5y.Hmr3qFJhKrDfCoQKbyzpSQmj6" "http://172.18.0.130:8080/xx5/quick.txt"\r\n\r\ncopy_object () {\r\n    source=$1\r\n    bucket=/$2\r\n    resource=/$3\r\n    version_id=$4\r\n    dateValue="`TZ=GMT date +'%a, %d %b %Y %H:%M:%S GMT'`"\r\n    stringToSign="PUT\\n\\n\\n${dateValue}\\nx-amz-copy-source:$source?versionId=${version_id}\\n${bucket}${resource}"\r\n    signature=`echo -en ${stringToSign} | openssl sha1 -hmac ${Key} -binary | base64`\r\n    url="http://${host}${bucket}${resource}"\r\n    echo "begin copy bucket ${source} to ${url}"\r\n    cmd="curl -L -i -v -X PUT -H \\"Date: ${dateValue}\\" -H \\"Authorization: AWS ${Id}:${signature}\\" -H \\"x-amz-copy-source:$source?=versionId=${version_id}\\" \\"${url}\\""\r\n    echo "$cmd"\r\n    curl -L -i -v  -X PUT -H "Date: ${dateValue}" -H "Authorization: AWS ${Id}:${signature}" -H "x-amz-copy-source:$source?versionId=${version_id}" "${url}"\r\n    echo "end copy bucket"\r\n}\r\n\r\nx-amz-copy-source 加入到鉴权	2017-10-24 13:36:46.789251	f
62	24	Issue	5		2017-10-24 13:37:56.977452	f
63	24	Issue	5	s3命令使用curl请求作为客户端，调试还比较方便	2017-10-24 13:38:42.601743	f
64	22	Issue	5	目前采用了copy的方案，可以实现。\r\n\r\n将老的版本copy为当前版本。	2017-10-24 14:41:53.679564	f
100	29	Issue	5	测试出一个bug:\r\n\r\n先修改不带版本对象的acl，然后覆盖put一个对象。副本侧看同步完成，但是s3 browser看不到该版本。\r\n\r\n效果就相当于有具体版本的操作，但是没有olh操作，没有产生这种dir entry，但是有1000_的dir entry。\r\nsbsb.txt^@v906^@iqSjEL9lN1oDrqnifEEvdQ.D6NmiWVGA\r\nsbsb.txt^@v907^@iNoned93E3v5LpKMmmDlxJiPnDl2wLPT\r\n	2017-11-08 09:21:59.742747	f
66	25	Issue	5	logstash 如何使用呢？\r\n2个核心问题：\r\n1，怎么知道一个文件被处理完了？\r\n   我的需求是一个文件被处理了，并且长期没有变更，应该转移到其他目录。\r\n   方案1：\r\n   就按照logstash ignore_file的标准。在标记ignore的地方，转移到一个ignore的目录里面去。\r\n   方案2：\r\n   自己读取sincedb，根据文件名分析文件是否可能继续更新，如果不会，移到ignore目录。\r\n   \r\n2，文件的格式如何处理，格式化数据如何被更好的处理\r\n   这里给出了这个问题的解http://www.cnblogs.com/duanxuan/p/6517462.html	2017-10-25 12:21:09.388073	f
73	28	Issue	5	OPTION(rgw_usage_log_flush_threshold, OPT_INT, 1024) // threshold to flush pending log data\r\nOPTION(rgw_usage_log_tick_interval, OPT_INT, 30) // flush pending log data every X seconds\r\n\r\n这样看usage log跟datalog的规模差不多，bilog是最多的。\r\n\r\n都得考虑 trim的问题。而且bilog和bucket index在同样对象上面，影响可能比较大。	2017-10-27 07:43:06.461289	f
67	26	Issue	5	注意鉴权部分\r\n而且当前版本采用v4鉴权会报501 not implemented\r\n	2017-10-25 15:19:43.153252	f
68	26	Issue	5		2017-10-26 07:06:57.363681	f
69	27	Issue	5		2017-10-26 07:06:57.36687	f
70	24	Issue	5		2017-10-26 07:35:03.90107	f
72	25	Issue	5	input {\r\n    file {\r\n        path => ["/root/testlog/op*"]\r\n        type => "oplog"\r\n\tignore_older => 86400\r\n\tsincedb_path => "/root/logstash/oplog.sdb"\r\n        codec => json {\r\n            charset => "UTF-8"\r\n        } \r\n    }\r\n}\r\n\r\noutput {\r\n    elasticsearch {\r\n        hosts => ["172.18.0.151:9200"]\r\n        index => "logstash-rgw"\r\n        workers => 2\r\n        template_overwrite => true\r\n    }\r\n}	2017-10-26 13:35:35.994349	f
105	23	Issue	5		2017-11-08 13:28:26.275984	f
107	27	Issue	5	支持v4鉴权	2017-11-14 15:05:00.919454	f
109	36	Issue	5	没开多版本的bucket不支持回滚	2017-11-15 15:37:21.064511	f
252	82	Issue	5	申威编译(今晚投入)	2018-07-23 08:23:39.865665	f
255	82	Issue	5	考虑在pool名字到实际存储之间加一层映射？	2018-07-24 17:36:36.914398	f
321	98	Issue	5	海量小文件方案:\r\n设置bucket的rados shard数量。\r\n比如默认按5000万对象算，100个小文件合并为一个大文件。10kb~500kb文件，rados对象就是1M~50MB。\r\n总文件数50万。\r\n\r\n可支持动态修改。rados shard。但是之前的对象不会挪位置。	2018-09-17 17:20:27.853056	f
71	25	Issue	5	filewatch会打这个日志，可以帮助分辨，但需要打开logstash的日志\r\n\r\n@logger.debug? && @logger.debug("_discover_file: #{file}: skipping because it was last modified more than #{@ignore_older} seconds ago")\r\n\r\n[root@localhost ~]# cat /root/logstash/oplog.sdb \r\n106023883 0 64768 361\r\n[root@localhost ~]# file /root/testlog/oplog.2017-10-26 \r\n/root/testlog/oplog.2017-10-26: ASCII text, with very long lines\r\n[root@localhost ~]# ls -l /root/testlog/oplog.2017-10-26\r\n-rw-r--r--. 1 root root 361 Oct 26 14:41 /root/testlog/oplog.2017-10-26\r\n\r\nsincedb是明文的，可以写脚本分析日志是否处理完。也比较简单\r\n\r\n*注意使用vim修改文件，会重新parse文件。而echo "” 》 这种append方式不会。*\r\n\r\n[root@localhost logstash]# cat oplog.sdb \r\n106023883 0 64768 566\r\n106023882 0 64768 462\r\n106023884 0 64768 462\r\n106023885 0 64768 767\r\n其实是一个文件，但是vim打开写产生了新的inode。\r\nThe inode number (or equivalent).\r\nThe major device number of the file system (or equivalent).\r\nThe minor device number of the file system (or equivalent).\r\nThe current byte offset within the file.\r\n\r\n\r\n[root@localhost logstash]# cat oplog.sdb \r\n106023883 0 64768 566\r\n106023882 0 64768 462\r\n106023884 0 64768 462\r\n106023885 0 64768 767\r\n[root@localhost logstash]# ls -il /root/testlog/\r\ntotal 4\r\n106023885 -rw-r--r--. 1 root root 767 Oct 26 15:37 oplog.2017-10-26\r\n[root@localhost logstash]#\r\n根据inode清理	2017-10-26 09:16:20.475952	f
74	25	Issue	5	要支持自定义模板，数据类型。\r\n\r\n可自动识别数据类型。	2017-10-27 13:17:34.682376	f
84	20	Issue	5	{ \r\n"template" : "oplog_logstash*", \r\n"order":1,\r\n"settings" : { "index.refresh_interval" : "5s" }, \r\n"mappings" : { \r\n"_default_" : { \r\n"_all" : { "enabled" : false }, \r\n"dynamic_templates" : [{ \r\n"message_field" : { \r\n"match" : "message", \r\n"match_mapping_type" : "string", \r\n"mapping" : { "type" : "string", "index" : "analyzed" } \r\n} \r\n}, { \r\n"string_fields" : { \r\n"match" : "*", \r\n"match_mapping_type" : "string", \r\n"mapping" : { "type" : "string", "index" : "analyzed" } \r\n} \r\n}], \r\n"properties" : { \r\n"@version" : { "type" : "integer", "index" : "analyzed" }, \r\n"path" : { "type" : "string", "index" : "analyzed" },\r\n"host" : { "type" : "string", "index" : "analyzed" },\r\n"object" : { "type" : "text", "analyzer" : "ik_max_word" }\r\n} \r\n} \r\n}\r\n}\r\n\r\nik_max_word不是index，而是analyzer。\r\nik_smart类型无法解决abc.jpg按照后缀搜索问题，需要使用ik_max_word.	2017-10-27 20:25:22.357771	f
85	20	Issue	5	"bucket" : {\r\n"type" : "text" \r\n},\r\n"code" : {\r\n"type" : "long" \r\n},\r\n"date" : {\r\n"type" : "date" \r\n},\r\n"host" : {\r\n"type" : "text" \r\n},\r\n"object" : {\r\n"type" : "text",\r\n"analyzer" : "ik_max_word" \r\n},\r\n"op" : {\r\n"type" : "text" \r\n},\r\n"owner" : {\r\n"type" : "text" \r\n},\r\n"path" : {\r\n"type" : "text" \r\n},\r\n"type" : {\r\n"type" : "text" \r\n}	2017-10-27 20:25:41.558428	f
86	20	Issue	5	input {\r\nfile {\r\npath => ["/root/testlog/op*"]\r\ntype => "oplog" \r\nignore_older => 86400\r\nsincedb_path => "/root/logstash/oplog.sdb" \r\ncodec => json {\r\ncharset => "UTF-8" \r\n} \r\n}\r\n}\r\n\r\noutput {\r\nelasticsearch {\r\nhosts => ["192.168.4.50:9200"]\r\nindex => "oplog_logstash6" \r\nworkers => 2\r\ntemplate => "/root/logstash/ik_template.json" \r\ntemplate_name => "ik_template" \r\n}\r\n}\r\n\r\nlogstash配置文件	2017-10-27 20:26:05.699303	f
89	20	Issue	5	插件相当不好下载 \r\n./elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.6.1/elasticsearch-analysis-ik-5.6.1.zip\r\n\r\n当然这是网络问题，网络好的时候下载很快。	2017-10-27 20:29:04.301286	f
90	29	Issue	5	问题的原因在于：\r\n以前写多版本对象，复制仅在link_olh时进行。\r\n所以忽略了对存在版本的对象的处理，现在需要处理这种情况。\r\n\r\nlink_olh和产生对象的版本本来就是2个动作，为什么要过滤掉呢？\r\n\r\n多版本又是如何同步的呢？\r\n\r\nae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6_重阳.txt\r\nae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6__:s.ue4J9MnHG6ZRpVYcp5PHyGrBya-8-_测试对象.txt\r\nae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6__:oP4235G3Uccu91UAfu0ysf-lFc.jutc_重阳.txt\r\n\r\nolh对象和多版本的对象分别是怎么同步的？\r\n\r\n包含额外的元数据：\r\n1，olh的对象，这个对象记录了olh.info等属性。\r\n     olh.info   RGWOLHInfo   存储当前版本\r\n       olh.ver\r\n       olh.idtag\r\n     \r\n2，1001开头的bi olh entry\r\n     这个是用来记录bilog的\r\n3，BIVerObjEntry\r\n      这一个结构就管理了多版本的两种index，一种是bucket list index，也就是xie.pngv912iIe3QYVLBL78GY.Jo4B0.YE1IWEfBTp6 这种格式的。\r\n    另一种是以前老的作为version object的bi entry。\r\n\r\n写一个多版本的对象步骤：\r\n1，prepare\r\n2，写入多版本对象的head obj\r\n3，complete，这里就写入了1000_xie.pngiIe3QYVLBL78GY.Jo4B0.YE1IWEfBTp6 \r\n4，set olh，这步是多出来的，分为几个小步\r\n4.1，如果没有对象，要创建olh对象\r\n4.2，convert_plain_entry_to_versioned中写入非版本对象的bucket index key。\r\n        写入bi olh entry （这里就包含了bilog）\r\n        BIVerObjEntry::write （这里写了两个version object的index）	2017-10-30 08:23:17.057789	f
65	25	Issue	5	谢锐(x8671r@163.com)  10:28:45\r\n我在想审计日志在IO路径上写不是很合适，可能影响性能，还得考虑es挂的错误处理。\r\n能否这样，先像普通日志一样单独写一个审计日志文件。然后后台用工具导入到es\r\n谢锐(x8671r@163.com)  10:40:12\r\n把日志搞到es里面处理可能有现成工具，不过日志有格式化的和非格式化的\r\n\r\n\r\nrgw起异步进程也可以，搞个异步处理队列。不过这个对性能也没啥要求，放在外围做。以后好迁移版本。\r\n\r\n而且异步队列，在进程挂掉时可能丢数据，但是文件缓冲在文件系统，可以在一些情况下正常刷到文件。\r\n还有放队列存在处理不过来的情况，这些都得处理	2017-10-25 08:11:18.563547	f
75	20	Issue	5		2017-10-27 14:18:27.313591	f
76	29	Issue	5		2017-10-27 14:18:41.758636	f
91	4	Issue	5	[root@localhost ~]# ./s3.sh list_bucket \r\nbegin list bucket http://172.18.0.131:8080/ \r\ncurl -X GET -H "Date: Tue, 31 Oct 2017 03:37:25 GMT" -H "Authorization: AWS BVDUBNIUOW0JM72RE9MQ:/de000/nebsJcVBaSF5M8WH60m4=" "http://172.18.0.131:8080/" \r\ncurl: (28) Operation timed out after 100000 milliseconds with 0 out of -1 bytes received\r\nend list bucket\r\n\r\n在一次对rgw进程调试后出现\r\n\r\n172.18.0.130 - - [31/Oct/2017:03:41:45 +0000] "GET /admin/log/?type=data&id=48&info&rgwx-zonegroup=0fbaadfd-bbe6-465c-b594-122993af93f9 HTTP/1.1" 499 0 "-" "-" "-"\r\n172.18.0.130 - - [31/Oct/2017:03:41:45 +0000] "GET /admin/log/?type=data&id=103&info&rgwx-zonegroup=0fbaadfd-bbe6-465c-b594-122993af93f9 HTTP/1.1" 499 0 "-" "-" "-"\r\n172.18.0.130 - - [31/Oct/2017:03:42:12 +0000] "GET /admin/log/?type=data&id=22&info&rgwx-zonegroup=0fbaadfd-bbe6-465c-b594-122993af93f9 HTTP/1.1" 499 0 "-" "-" "-"\r\n172.18.0.130 - - [31/Oct/2017:03:42:21 +0000] "GET /admin/log/?type=data&id=27&info&rgwx-zonegroup=0fbaadfd-bbe6-465c-b594-122993af93f9 HTTP/1.1" 499 0 "-" "-" "-"\r\n\r\n发送list请求，nginx无任何日志，可见应该是nginx和rgw之间的链路断开了，但是为啥没重连呢？\r\nnginx发起重连了，但没成功\r\n2017/10/31 03:20:41 [error] 6701#0: *591995 connect() failed (111: Connection refused) while connecting to upstream, client: 172.18.0.130, server: , request: "POST /admin/realm/period?period=8759346e-474d-4176-90a9-5c5c1f1f0bf3&epoch=11&rgwx-zonegroup=0fbaadfd-bbe6-465c-b594-122993af93f9 HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "172.18.0.131:8080"\r\n2017/10/31 03:20:41 [error] 6701#0: *591997 connect() failed (111: Connection refused) while connecting to upstream, client: 172.18.0.130, server: , request: "GET /admin/log?type=data&rgwx-zonegroup=0fbaadfd-bbe6-465c-b594-122993af93f9 HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "172.18.0.131:8080"\r\n2017/10/31 03:20:41 [error] 6701#0: *591999 connect() failed (111: Connection refused) while connecting to upstream, client: 172.18.0.130, server: , request: "POST /admin/log?type=data&notify&source-zone=ae41357a-6f20-47bb-a3bd-1f0a166cd8f4&rgwx-zonegroup=0fbaadfd-bbe6-465c-b594-122993af93f9 HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "172.18.0.131:8080"\r\n\r\n\r\n\r\n2017-10-31 03:30:18.953959 7fec8df25700  1 heartbeat_map reset_timeout 'RGWProcess::m_tp thread 0x7fec8df25700' had timed out after 60\r\n2017-10-31 03:30:18.953980 7fec8e726700  1 heartbeat_map reset_timeout 'RGWProcess::m_tp thread 0x7fec8e726700' had timed out after 60\r\n2017-10-31 03:30:18.953989 7fed37ffe700  0 check_pending_requests request : http://172.18.0.130:8080/admin/log/?type=data&id=89&info&rgwx-zonegroup=0fbaadfd-bbe6-465c-b594-122993af93f9 timeout, last run at2017-10-31 03:21:57.782688\r\n2017-10-31 03:30:18.953994 7fecc0f8b700  1 heartbeat_map reset_timeout 'RGWProcess::m_tp thread 0x7fecc0f8b700' had timed out after 60\r\n2017-10-31 03:30:18.954012 7fec8c722700  1 heartbeat_map reset_timeout 'RGWProcess::m_tp thread 0x7fec8c722700' had timed out after 60	2017-10-31 12:13:50.635884	f
82	13	Issue	5		2017-10-27 20:23:42.441756	f
87	20	Issue	5		2017-10-27 20:26:17.116226	f
83	20	Issue	5	index.analysis.analyzer.default.type:ik\r\n\r\n报错了：\r\n[2017-10-27T17:42:29,491][INFO ][o.e.p.PluginsService ] [node-50] loaded plugin [analysis-ik]\r\n[2017-10-27T17:42:30,048][WARN ][o.e.c.s.SettingsModule ] [node-50] *****************************************************************************\r\nFound index level settings on node level configuration.\r\n\r\nSince elasticsearch 5.x index level settings can NOT be set on the nodes\r\nconfiguration like the elasticsearch.yaml, in system properties or command line\r\narguments.In order to upgrade all indices the settings must be updated via the\r\n/${index}/_settings API. Unless all settings are dynamic all indices must be closed\r\nin order to apply the upgradeIndices created in the future should use index templates\r\nto set default values.\r\n\r\nPlease ensure all required values are updated on all indices by executing:\r\n\r\ncurl -XPUT 'http://localhost:9200/_all/_settings?preserve_existing=true' -d '{\r\n"index.analysis.analyzer.default.type" : "ik" \r\n}'\r\n\r\n现在已经不支持这种用法了	2017-10-27 20:24:59.952059	f
88	25	Issue	5	input {\r\nfile {\r\npath => ["/root/testlog/op*"]\r\ntype => "oplog" \r\nignore_older => 86400\r\nsincedb_path => "/root/logstash/oplog.sdb" \r\ncodec => json {\r\ncharset => "UTF-8" \r\n} \r\n}\r\n}\r\n\r\noutput {\r\nelasticsearch {\r\nhosts => ["192.168.4.50:9200"]\r\nindex => "oplog_logstash6" \r\nworkers => 2\r\ntemplate => "/root/logstash/ik_template.json" \r\ntemplate_name => "ik_template" \r\n}\r\n}\r\n\r\nlogstash配置文件，支持自定义mapping的模板。\r\n\r\n{ \r\n"template" : "oplog_logstash*", \r\n"order":1,\r\n"settings" : { "index.refresh_interval" : "5s" }, \r\n"mappings" : { \r\n"_default_" : { \r\n"_all" : { "enabled" : false }, \r\n"dynamic_templates" : [{ \r\n"message_field" : { \r\n"match" : "message", \r\n"match_mapping_type" : "string", \r\n"mapping" : { "type" : "string", "index" : "analyzed" } \r\n} \r\n}, { \r\n"string_fields" : { \r\n"match" : "*", \r\n"match_mapping_type" : "string", \r\n"mapping" : { "type" : "string", "index" : "analyzed" } \r\n} \r\n}], \r\n"properties" : { \r\n"@version" : { "type" : "integer", "index" : "analyzed" }, \r\n"path" : { "type" : "string", "index" : "analyzed" },\r\n"host" : { "type" : "string", "index" : "analyzed" },\r\n"object" : { "type" : "text", "analyzer" : "ik_max_word" }\r\n} \r\n} \r\n}\r\n}	2017-10-27 20:27:57.956131	f
92	29	Issue	5	把olh和add bilog单独处理还比较麻烦，从逻辑角度看这是一个动作触发的。\r\n\r\n看看能否给增加tag这种元数据修改，使用额外的标签以区分。	2017-10-31 13:52:43.690454	f
93	30	Issue	5	s3browser操作需要apply changes才能生效。\r\n\r\n但是cloudberry很奇怪，不仅不能生效，而且原来在s3browser中增加的属性也没了。	2017-10-31 14:41:17.176377	f
95	30	Issue	5	应该是cloud berry有bug。\r\n从上面请求可以看出，http header走的是普通的put请求。在多版本下也会修改olh。这种实现是非常低效率的。	2017-10-31 14:51:47.096995	f
96	29	Issue	5	解决方案：\r\n增加额外操作类型\r\nCLS_RGW_OP_SETATTR = 7,\r\n这类操作可以单纯作用于多版本对象，也可以是非多版本对象。\r\n\r\n而且这类操作同步的时候是不必拷贝数据部分的，shit 修改个元数据，你让我同步全部数据？\r\n\r\n有一点这类操作的合并与 ADD有区别，需要额外处理。\r\n\r\n还有这种op是否写bilog？狗日的，真想把bilog重复写给合入了。\r\n\r\n同样面临的问题还有：在set attr失败之后如何回滚？\r\n使用跟对象操作一样的机制，但是在suggest的时候，根据prepare的类型决定实际op类型。\r\n\r\n在bilog同步合并的时候也需要一定策略，CLS_RGW_OP_SETATTR可以合入CLS_RGW_OP_ADD中。	2017-11-02 09:40:42.188921	f
94	29	Issue	5	http header是可以同步的，不过是通过olh，也就是说http header走的是正常的put请求。从请求的url也可以看出来。\r\n多版本修改http header会产生新的版本，完全就是一个put请求。\r\n\r\n经过RGWRados::set_attrs 来增加CLS_RGW_OP_ADD类型的bilog的，在多版本下都有风险，因为没有set olh。\r\n\r\n搞个set metadata的bilog？ 这样可单独处理各种只改属性的操作。	2017-10-31 14:49:05.328021	f
97	31	Issue	5	olh对象上设置acl是没用的，需要在版本对象上操作，就可以了\r\n\r\n在多zone之间同步问题，请参考 Bug #29	2017-11-07 09:15:27.115395	f
98	29	Issue	5	*set acl, tag等本身就不应该同步整个对象*\r\n\r\n所以这里优化后应该要实现仅同步对象元数据的功能。\r\n\r\n要支持这个还挺麻烦的，因为没法通过bilog知道哪个属性修改的。所以只能全部属性覆盖了，但是rados似乎没有clear已有属性的操作。	2017-11-07 12:48:37.117931	f
325	101	Issue	5	有一个命令反应osd整体的请求延时。\r\n读写请求总数，光看pg均衡情况无法反应真实的请求压力。不同的对象(如bi)上读写请求压力并不一样，有些bucket可能频繁访问。\r\n请求平均延时。	2018-09-25 09:48:11.867531	f
326	111	Issue	5	rgw同步应该考虑使用长连接	2018-10-08 09:46:15.902849	f
2111	1124	Issue	5		2022-09-13 09:14:06.452865	f
99	29	Issue	5	sbsb.txt\t\r\nrevision #: 3\t2017/11/8 10:17:09\t"8245850a9970806494b50a4a8e9d1eb6"\t20 bytes\tSTANDARD\tnuser (nuser)\tnI0aAeHcT78I42RKzT2jGMP-3PW0Ga8\t\r\nrevision #: 2 (current)\t2017/11/8 9:32:33\t"8245850a9970806494b50a4a8e9d1eb6"\t20 bytes\tSTANDARD\tnuser (nuser)\t2KlWSlU8tqMc1buKZV2mzqe4TTDEJ7B\t\r\nrevision #: 1\t2017/11/7 15:03:03\t"8245850a9970806494b50a4a8e9d1eb6"\t20 bytes\tSTANDARD\tnuser (nuser)\tiNUu.4VPalePLpnCLbUyiBPjWjlFofH\t\r\n\r\nslave zone like these，some bug there。why olh not linked?\r\n\r\n再次测试并未出现，非常奇怪。\r\n\r\n加强各种场景下的测试，也加强理论分析。\r\n在副本做bilog合并处理那块，可以构造一些用例：\r\n1，先写新对象，然后set attr，再同步\r\n2，先set attr，再写对象，再同步。	2017-11-08 08:13:40.799901	f
101	29	Issue	5	2017-11-08 06:14:56.230889 7f7c513ff700 20 bucket sync single entry (source_zone=ae41357a-6f20-47bb-a3bd-1f0a166cd8f4) b=xx5:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6:11/sbsb.txt[0] log_entry=00000000056.1010.4 op=7 op_state=1\r\n2017-11-08 06:14:56.230895 7f7c513ff700  5 Sync:ae41357a:data:Object:xx5:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6:11/sbsb.txt[0]:start\r\n2017-11-08 06:14:56.230902 7f7c513ff700 20 parsed entry: id=00000000057.1011.2 iter->object=sbsb.txt iter->instance=5dJn43PD374ff-3OMRaJ.H2SUgypCOp name=sbsb.txt instance= ns=\r\n2017-11-08 06:14:56.230908 7f7c513ff700 20 [inc sync] skipping object: xx5:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6:11/sbsb.txt[5dJn43PD374ff-3OMRaJ.H2SUgypCOp]: non-complete operation\r\n2017-11-08 06:14:56.230911 7f7c513ff700 20 parsed entry: id=00000000058.1012.3 iter->object=sbsb.txt iter->instance=5dJn43PD374ff-3OMRaJ.H2SUgypCOp name=sbsb.txt instance= ns=\r\n2017-11-08 06:14:56.230917 7f7c513ff700 20 [inc sync] skipping object: xx5:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6:11/sbsb.txt[5dJn43PD374ff-3OMRaJ.H2SUgypCOp]: squashed operation\r\n2017-11-08 06:14:56.230926 7f7c513ff700 20 parsed entry: id=00000000059.1013.9 iter->object=sbsb.txt iter->instance=5dJn43PD374ff-3OMRaJ.H2SUgypCOp name=sbsb.txt instance= ns=\r\n2017-11-08 06:14:56.230931 7f7c513ff700 20 [inc sync] syncing object: xx5:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6:11/sbsb.txt[5dJn43PD374ff-3OMRaJ.H2SUgypCOp]\r\n2017-11-08 06:14:56.230937 7f7c513ff700 20 operate(): entry->timestamp=2017-11-08 06:14:56.0.063785s\r\n2017-11-08 06:14:56.230956 7f7c513ff700 20 bucket sync single entry (source_zone=ae41357a-6f20-47bb-a3bd-1f0a166cd8f4) b=xx5:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6:11/sbsb.txt[5dJn43PD374ff-3OMRaJ.H2SUgypCOp][12] log_entry=00000000059.1013.9 op=4 op_state=1\r\n2017-11-08 06:14:56.230961 7f7c513ff700  5 Sync:ae41357a:data:Object:xx5:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6:11/sbsb.txt[5dJn43PD374ff-3OMRaJ.H2SUgypCOp][12]:start\r\n2017-11-08 06:14:56.230966 7f7c513ff700 20 operate(): listing bilog for incremental sync\r\n2017-11-08 06:14:56.230977 7f7c513ff700 10 multisite data sync should run between 0 - 24 now 6 = yes\r\n2017-11-08 06:14:56.230980 7f7c513ff700 20 cr:s=0x7f7b1498f100:op=0x7f7b0fb04000:26RGWBucketSyncSingleEntryCRISs11rgw_obj_keyE: operate()\r\n2017-11-08 06:14:56.230986 7f7c513ff700  5 bucket sync: sync obj attr: ae41357a-6f20-47bb-a3bd-1f0a166cd8f4/xx5(@{i=BJ.rgw.buckets.index,e=BJ.rgw.buckets.non-ec}BJ.rgw.buckets.data[ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6])/sbsb.txt[0]\r\n2017-11-08 06:14:56.230991 7f7c513ff700  5 Sync:ae41357a:data:Object:xx5:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6:11/sbsb.txt[0]:fetch\r\n2017-11-08 06:14:56.231009 7f7c513ff700 10 multisite data sync should run between 0 - 24 now 6 = yes\r\n2017-11-08 06:14:56.231012 7f7c513ff700 20 cr:s=0x7f7b1498f480:op=0x7f7b0fb04800:26RGWBucketSyncSingleEntryCRISs11rgw_obj_keyE: operate()\r\n2017-11-08 06:14:56.231016 7f7c513ff700  5 bucket sync: sync obj: ae41357a-6f20-47bb-a3bd-1f0a166cd8f4/xx5(@{i=BJ.rgw.buckets.index,e=BJ.rgw.buckets.non-ec}BJ.rgw.buckets.data[ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6])/sbsb.txt[5dJn43PD374ff-3OMRaJ.H2SUgypCOp][12]\r\n2017-11-08 06:14:56.231020 7f7c513ff700  5 Sync:ae41357a:data:Object:xx5:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6:11/sbsb.txt[5dJn43PD374ff-3OMRaJ.H2SUgypCOp][12]:fetch\r\n\r\nsetattr是在olh对象上执行，instance为空。\r\nput对象的olh log是在instance上，并且这两个操作并行执行了。\r\n\r\n2017-11-08 06:14:56.256769 7f7c5e3e2700 20  bucket index object: .dir.ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6.11\r\n2017-11-08 06:14:56.257584 7f7c5e3e2700 20 bucket_index_link_olh() target_obj=xx5:_:5dJn43PD374ff-3OMRaJ.H2SUgypCOp_sbsb.txt delete_marker=0 returned -125\r\n2017-11-08 06:14:56.257608 7f7c5e3e2700 20 get_obj_state: rctx=0x7f7c5e3e0790 obj=xx5:sbsb.txt state=0x7f7c534fa098 s->prefetch_data=0\r\n2017-11-08 06:14:56.258565 7f7c5e3e2700 20 get_obj_state: setting s->obj_tag to 0ke71z11swyyntmabcnlp9eqitujbrk0\r\n2017-11-08 06:14:56.258590 7f7c5e3e2700 20 bucket_index_guard_olh_op(): olh_state.olh_tag=9zlvyr2ye6r4q3uaqblrr1l9daktby39\r\n2017-11-08 06:14:56.261065 7f7c5e3e2700 20 reading from BJ.rgw.data.root:.bucket.meta.xx5:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6\r\n2017-11-08 06:14:56.261093 7f7c5e3e2700 20 get_system_obj_state: rctx=0x7f7c5e3de5f0 obj=BJ.rgw.data.root:.bucket.meta.xx5:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4164.6 state=0x7f7c534fa698 s->prefetch_data=0\r\n\r\n\r\n看来是在rgw_bucket_link_olh中出错了\r\n\r\n    const string& olh_tag = olh.get_tag();\r\n    if (op.olh_tag != olh_tag) {\r\n      if (!olh.pending_removal()) {\r\n        CLS_LOG(5, "NOTICE: op.olh_tag (%s) != olh.tag (%s)", op.olh_tag.c_str(), olh_tag.c_str());\r\n        return -ECANCELED;\r\n      }\r\n      /* if pending removal, this is a new olh instance */\r\n      olh.set_tag(op.olh_tag);\r\n    }	2017-11-08 12:28:10.805807	f
102	29	Issue	5	这里有两个地方可以修改：\r\n1，ACL在olh对象上修改是没有任何作用的，应该改为像tag一样，在obj instance上生效。\r\n  社区版已修改：\r\n    obj = rgw_obj(s->bucket, s->object);\r\n    store->set_atomic(s->obj_ctx, obj);\r\n    //if instance is empty, we should modify the latest object\r\n    op_ret = modify_obj_attr(store, s, obj, RGW_ATTR_ACL, bl);\r\n\r\n2，setattr不必修改olh id tag等。\r\n\r\n合入第一个之后问题就得到解决了。\r\n\r\n*但是要注意这点，就是setattr不应该去修改olh对象。*	2017-11-08 13:04:49.194585	f
103	31	Issue	5	社区已经修改，olh上设置acl需要设置到current version上。\r\n\r\n    obj = rgw_obj(s->bucket, s->object);\r\n    store->set_atomic(s->obj_ctx, obj);\r\n    //if instance is empty, we should modify the latest object\r\n    op_ret = modify_obj_attr(store, s, obj, RGW_ATTR_ACL, bl);	2017-11-08 13:26:51.411363	f
104	31	Issue	5	在 #29 已经合入	2017-11-08 13:27:27.536641	f
106	34	Issue	5	这问题涉及的点 不仅仅是RbdRead和RbdWrite.但是改动起来又觉得不是很有必要	2017-11-13 11:55:40.789737	f
108	38	Issue	5	陈乐  17:45:32\r\n谢锐，是第3步没同步	2017-11-15 15:16:05.158485	f
111	38	Issue	5	暂时多版本的时候的对象信息：\r\nbloom.cc\t\r\nrevision #: 3 (current)\t2017/11/16 10:39:33\t"c625679bb2a19c9d7ad9262c6de92491"\t12.37 KB\tSTANDARD\tnuser (nuser)\thqw.BWlLXEqJVWAUKCkgxn8u0XHpaaU\t\r\nrevision #: 2\t2017/11/16 10:39:09\t"c625679bb2a19c9d7ad9262c6de92491"\t12.37 KB\tSTANDARD\tnuser (nuser)\tMEOgy.4sKa-.2VKik7ccNIJDTV47cBp\t\r\nrevision #: 1\t2017/11/16 10:38:31\t"c625679bb2a19c9d7ad9262c6de92491"\t12.37 KB\tSTANDARD\tnuser (nuser)\tnull\t\r\n\r\n删除非版本的对象之后变成这样：\r\nbloom.cc\t\r\nrevision #: 4 (deleted)\t2017/11/16 10:41:13\t\t\t\t                                        nuser (nuser)\tP0VkD9aG7C14sxij-.ubGsCfvDXGaUO\t\r\nrevision #: 3 (deleted)\t2017/11/16 10:41:13\t\t\t\t                                        nuser (nuser)\tnull\t\r\nrevision #: 2\t2017/11/16 10:39:33\t"c625679bb2a19c9d7ad9262c6de92491"\t12.37 KB\tSTANDARD\tnuser (nuser)\thqw.BWlLXEqJVWAUKCkgxn8u0XHpaaU\t\r\nrevision #: 1\t2017/11/16 10:39:09\t"c625679bb2a19c9d7ad9262c6de92491"\t12.37 KB\tSTANDARD\tnuser (nuser)\tMEOgy.4sKa-.2VKik7ccNIJDTV47cBp\t\r\n\r\nslave zone：\r\nbloom.cc\t\r\nrevision #: 4 (deleted)\t2017/11/16 10:41:13\t\t\t\t                                        nuser (nuser)\tP0VkD9aG7C14sxij-.ubGsCfvDXGaUO\t\r\nrevision #: 3\t2017/11/16 10:39:33\t"c625679bb2a19c9d7ad9262c6de92491"\t12.37 KB\tSTANDARD\tnuser (nuser)\thqw.BWlLXEqJVWAUKCkgxn8u0XHpaaU\t\r\nrevision #: 2\t2017/11/16 10:39:09\t"c625679bb2a19c9d7ad9262c6de92491"\t12.37 KB\tSTANDARD\tnuser (nuser)\tMEOgy.4sKa-.2VKik7ccNIJDTV47cBp\t\r\nrevision #: 1\t2017/11/16 10:38:31\t"c625679bb2a19c9d7ad9262c6de92491"\t12.37 KB\tSTANDARD\tnuser (nuser)\tnull\t	2017-11-16 08:25:22.089992	f
116	38	Issue	5	要搞清楚多版本删除的原理，以及多版本打开关闭的逻辑处理。\r\n看这个单：http://tracker.ceph.com/issues/21210\r\n多版本suspend之后，bilog仍然是采用olh方式写的！！！ 那么set olh的逻辑又当如何呢？\r\n\r\n该patch确实能解决问题，看上去问题是在之前的同步过程中修改了olh tag，导致后续使用olh log的时候tag不匹配。\r\n\r\nWhen sync prior versions, the olh is not exsit. The slave zone will create olh itself. The olh.idtag is rand generated.\r\nThe null version's data_instance and olh is the same obj. When sync the null version's data, the olh attr is also synced to slave zone regarded as obj metadata.\r\nThus the olh.tag in olh_data_entry and the tag in olh is not the same.\r\n\r\nolh在创建的时候产生tag，所以同步对象如果把olh_tag同步过来，那么肯定跟BIOLHEntry结构中的不一致。	2017-11-20 08:21:28.169216	f
118	40	Issue	5	经验证如果没有挂起多版本这一步，就可以成功删除。\r\n\r\n挂起之后，删除olh之后变成这样：\r\nsbsb.txt\t\r\nrevision #: 4 (deleted)\t2017/11/20 14:56:04\t\t\t\tnuser (nuser)\t8wNZCuNjrjOtLaM2bJ7LfFdQFMZO9jK\t\r\nrevision #: 3 (deleted)\t2017/11/20 14:56:04\t\t\t\tnuser (nuser)\tnull\t\r\nrevision #: 2\t2017/11/20 14:55:11\t"8f14e45fceea167a5a36dedd4bea2543"\t1 bytes\tSTANDARD\tnuser (nuser)\towFJBm2mVUcITCO6suWm.TllK4vvkwr\t\r\nrevision #: 1\t2017/11/20 14:55:06\t"8f14e45fceea167a5a36dedd4bea2543"\t1 bytes\tSTANDARD\tnuser (nuser)\tx2ous5ZnUFnvhj6P4NBKUOWtWLdkRmm\t\r\n\r\n多出了null的deleted标记，且这个标记无法删除\r\n\r\n最终这个删除不掉：\r\nsbsb.txt\t\r\nrevision #: 1 (deleted)\t2017/11/20 14:56:04\t\t\t\tnuser (nuser)\tnull\t	2017-11-20 12:37:23.243348	f
258	82	Issue	5	1，面试\r\n2，转正\r\n3，方案讨论	2018-07-27 06:39:42.859881	f
259	83	Issue	5	申威编译	2018-07-27 16:19:40.465697	f
606	267	Issue	5	服务发现\r\n消息组件\r\n	2019-02-16 14:47:24.961301	f
608	269	Issue	5	今天验证没有出问题，是可以跑的。	2019-02-18 12:15:21.813263	f
609	265	Issue	5	文件命名不一样，v5版本 manifest中在perfix中加入了tag，详见prepare过程。\r\n\r\nv5版本没有任何xattr。\r\nv3版本有acl，content_type, etag，idtag，manifest， pg_ver， source_zone, x-amz-acl, x-amz-date,\r\nx-amz-meta-s3b-last-modified等\r\n	2019-02-18 13:31:33.15186	f
611	265	Issue	5		2019-02-18 15:57:12.9454	f
112	38	Issue	5	bilog类似这种：\r\n{\r\n        "op_id": "17#00000000009.528.16",\r\n        "op_tag": "000000005a0cf90bqfoaa259de496e87",\r\n        "op": "link_olh_del",\r\n        "object": "arena.cc",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 9,\r\n        "timestamp": "2017-11-16 02:33:47.829487895Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 4\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "nuser",\r\n        "owner_display_name": "nuser"\r\n    },\r\n    {\r\n        "op_id": "17#00000000010.529.3",\r\n        "op_tag": "_nCk1RGWIsJy7cnACGEYShUm6-z1yaZ1",\r\n        "op": "del",\r\n        "object": "arena.cc",\r\n        "instance": "",\r\n        "state": "pending",\r\n        "index_ver": 10,\r\n        "timestamp": "0.000000",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 0\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "17#00000000011.530.4",\r\n        "op_tag": "_nCk1RGWIsJy7cnACGEYShUm6-z1yaZ1",\r\n        "op": "del",\r\n        "object": "arena.cc",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 11,\r\n        "timestamp": "2017-11-16 02:31:45.819343031Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 356\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "17#00000000012.532.10",\r\n        "op_tag": "000000005a0cf90c4jkaa68j9ddcdh77",\r\n        "op": "link_olh_del",\r\n        "object": "arena.cc",\r\n        "instance": "Y6GbFVmsodJFHVeNwcbouRM6xj0AnHY",\r\n        "state": "complete",\r\n        "index_ver": 12,\r\n        "timestamp": "2017-11-16 02:33:47.829487895Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 4\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "nuser",\r\n        "owner_display_name": "nuser"\r\n    }	2017-11-16 08:28:25.666751	f
119	40	Issue	5	[\r\n    {\r\n        "op_id": "11#00000000001.753.2",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4771.404123",\r\n        "op": "write",\r\n        "object": "sbsb.txt",\r\n        "instance": "",\r\n        "state": "pending",\r\n        "index_ver": 1,\r\n        "timestamp": "0.000000",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 0\r\n        },\r\n        "bilog_flags": 0,\r\n        "versioned": false,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000002.754.3",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4771.404123",\r\n        "op": "write",\r\n        "object": "sbsb.txt",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 2,\r\n        "timestamp": "2017-11-20 06:54:49.941944255Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 898\r\n        },\r\n        "bilog_flags": 0,\r\n        "versioned": false,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000003.755.2",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4771.404833",\r\n        "op": "write",\r\n        "object": "sbsb.txt",\r\n        "instance": "x2ous5ZnUFnvhj6P4NBKUOWtWLdkRmm",\r\n        "state": "pending",\r\n        "index_ver": 3,\r\n        "timestamp": "0.000000",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 0\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000004.756.3",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4771.404833",\r\n        "op": "write",\r\n        "object": "sbsb.txt",\r\n        "instance": "x2ous5ZnUFnvhj6P4NBKUOWtWLdkRmm",\r\n        "state": "complete",\r\n        "index_ver": 4,\r\n        "timestamp": "2017-11-20 06:55:06.081030215Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 99721\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000005.757.10",\r\n        "op_tag": "000000005a127c4av9ncm3uqah7h6imx",\r\n        "op": "link_olh",\r\n        "object": "sbsb.txt",\r\n        "instance": "x2ous5ZnUFnvhj6P4NBKUOWtWLdkRmm",\r\n        "state": "complete",\r\n        "index_ver": 5,\r\n        "timestamp": "2017-11-20 06:55:06.081030215Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 2\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000006.759.2",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4771.404996",\r\n        "op": "write",\r\n        "object": "sbsb.txt",\r\n        "instance": "owFJBm2mVUcITCO6suWm.TllK4vvkwr",\r\n        "state": "pending",\r\n        "index_ver": 6,\r\n        "timestamp": "0.000000",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 0\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000007.760.3",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4771.404996",\r\n        "op": "write",\r\n        "object": "sbsb.txt",\r\n        "instance": "owFJBm2mVUcITCO6suWm.TllK4vvkwr",\r\n        "state": "complete",\r\n        "index_ver": 7,\r\n        "timestamp": "2017-11-20 06:55:11.234795982Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 99777\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000008.761.9",\r\n        "op_tag": "000000005a127c4f97h3vefltbp7704s",\r\n        "op": "link_olh",\r\n        "object": "sbsb.txt",\r\n        "instance": "owFJBm2mVUcITCO6suWm.TllK4vvkwr",\r\n        "state": "complete",\r\n        "index_ver": 8,\r\n        "timestamp": "2017-11-20 06:55:11.234795982Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 3\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000009.763.16",\r\n        "op_tag": "000000005a127c84vofo0u6wduiw7dw9",\r\n        "op": "link_olh_del",\r\n        "object": "sbsb.txt",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 9,\r\n        "timestamp": "2017-11-20 06:56:04.320275507Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 4\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "nuser",\r\n        "owner_display_name": "nuser"\r\n    },\r\n    {\r\n        "op_id": "11#00000000010.764.3",\r\n        "op_tag": "_2AI7BEA3BYke5gTtKVBlimvZAZ4rR7q",\r\n        "op": "del",\r\n        "object": "sbsb.txt",\r\n        "instance": "",\r\n        "state": "pending",\r\n        "index_ver": 10,\r\n        "timestamp": "0.000000",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 0\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000011.765.4",\r\n        "op_tag": "_2AI7BEA3BYke5gTtKVBlimvZAZ4rR7q",\r\n        "op": "del",\r\n        "object": "sbsb.txt",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 11,\r\n        "timestamp": "2017-11-20 06:55:11.250974962Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 904\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000012.767.10",\r\n        "op_tag": "000000005a127c84dz08gf9ysfgemhma",\r\n        "op": "link_olh_del",\r\n        "object": "sbsb.txt",\r\n        "instance": "8wNZCuNjrjOtLaM2bJ7LfFdQFMZO9jK",\r\n        "state": "complete",\r\n        "index_ver": 12,\r\n        "timestamp": "2017-11-20 06:56:04.320275507Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 4\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "nuser",\r\n        "owner_display_name": "nuser"\r\n    },\r\n    {\r\n        "op_id": "11#00000000013.769.5",\r\n        "op_tag": "000000005a127ccaaxmmnjpci1yoxh0w",\r\n        "op": "unlink_instance",\r\n        "object": "sbsb.txt",\r\n        "instance": "owFJBm2mVUcITCO6suWm.TllK4vvkwr",\r\n        "state": "complete",\r\n        "index_ver": 13,\r\n        "timestamp": "2017-11-20 06:57:14.827634744Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 5\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000014.770.2",\r\n        "op_tag": "_J9N37R7bEuXGBcMZ49zuDYue5mtIrXw",\r\n        "op": "del",\r\n        "object": "sbsb.txt",\r\n        "instance": "owFJBm2mVUcITCO6suWm.TllK4vvkwr",\r\n        "state": "pending",\r\n        "index_ver": 14,\r\n        "timestamp": "2017-11-20 06:55:11.234795982Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 99777\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000015.771.3",\r\n        "op_tag": "_J9N37R7bEuXGBcMZ49zuDYue5mtIrXw",\r\n        "op": "del",\r\n        "object": "sbsb.txt",\r\n        "instance": "owFJBm2mVUcITCO6suWm.TllK4vvkwr",\r\n        "state": "complete",\r\n        "index_ver": 15,\r\n        "timestamp": "2017-11-20 06:55:11.234795982Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 101011\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000016.773.5",\r\n        "op_tag": "000000005a127ccey04kmw663nj1dzn9",\r\n        "op": "unlink_instance",\r\n        "object": "sbsb.txt",\r\n        "instance": "x2ous5ZnUFnvhj6P4NBKUOWtWLdkRmm",\r\n        "state": "complete",\r\n        "index_ver": 16,\r\n        "timestamp": "2017-11-20 06:57:18.486806542Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 6\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000017.774.2",\r\n        "op_tag": "_KlhLeHqJDUsH1C2tyAplpXaGRZbV335",\r\n        "op": "del",\r\n        "object": "sbsb.txt",\r\n        "instance": "x2ous5ZnUFnvhj6P4NBKUOWtWLdkRmm",\r\n        "state": "pending",\r\n        "index_ver": 17,\r\n        "timestamp": "2017-11-20 06:55:06.081030215Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 99721\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000018.775.3",\r\n        "op_tag": "_KlhLeHqJDUsH1C2tyAplpXaGRZbV335",\r\n        "op": "del",\r\n        "object": "sbsb.txt",\r\n        "instance": "x2ous5ZnUFnvhj6P4NBKUOWtWLdkRmm",\r\n        "state": "complete",\r\n        "index_ver": 18,\r\n        "timestamp": "2017-11-20 06:55:06.081030215Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 101048\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "11#00000000019.777.7",\r\n        "op_tag": "000000005a127cd5utbwigvi0exred6h",\r\n        "op": "unlink_instance",\r\n        "object": "sbsb.txt",\r\n        "instance": "8wNZCuNjrjOtLaM2bJ7LfFdQFMZO9jK",\r\n        "state": "complete",\r\n        "index_ver": 19,\r\n        "timestamp": "2017-11-20 06:57:25.621603650Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 7\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    }\r\n]	2017-11-20 12:54:37.454971	f
113	38	Issue	5	先回答一个问题：这种情况下，应该是怎么样的。\r\n\r\n对于没关闭多版本的，删除就是产生一个标记，delete marker，同时产生一个新版本，也即表明最新版本是删除的。\r\nchannel.h\t\r\nrevision #: 3 (deleted)\t2017/11/16 14:30:04\t\t\t\t                                nuser (nuser)\t7eciT6VnL88Hfgak1MUvIPbpv6U0vdA\t\r\nrevision #: 2\t2017/11/16 14:29:32\t"d67a6520a7bd5f315b4330cfe44bc244"\t1.62 KB\tSTANDARD\tnuser (nuser)\tGod27gciF-G0FBfbcoeGl1rXbWGygY7\t\r\nrevision #: 1\t2017/11/16 14:29:05\t"d67a6520a7bd5f315b4330cfe44bc244"\t1.62 KB\tSTANDARD\tnuser (nuser)\tnull\t\r\n\r\n多版本无法关闭，只能挂起，挂起意味着什么呢？\r\n这个测试步骤问题更严重：\r\n1，不开启多版本，上传一个对象\r\n2，开启多版本，再次上传\r\n3，删除该对象\r\n4，挂起bucket version\r\n5，再次上传对象\r\n\r\n这时看到的现象是：\r\nmaster zone\r\nchannel.h\t\r\nrevision #: 3 (current)\t2017/11/16 14:34:56\t"d67a6520a7bd5f315b4330cfe44bc244"\t1.62 KB\tSTANDARD\tnuser (nuser)\tnull\t\r\nrevision #: 2 (deleted)\t2017/11/16 14:30:04\t\t\t\tnuser (nuser)\t7eciT6VnL88Hfgak1MUvIPbpv6U0vdA\t\r\nrevision #: 1\t2017/11/16 14:29:32\t"d67a6520a7bd5f315b4330cfe44bc244"\t1.62 KB\tSTANDARD\tnuser (nuser)\tGod27gciF-G0FBfbcoeGl1rXbWGygY7\t\r\n\r\nslave zone：\r\nchannel.h\t\r\nrevision #: 3 (deleted)\t2017/11/16 14:30:04\t\t\t\tnuser (nuser)\t7eciT6VnL88Hfgak1MUvIPbpv6U0vdA\t\r\nrevision #: 2\t2017/11/16 14:29:32\t"d67a6520a7bd5f315b4330cfe44bc244"\t1.62 KB\tSTANDARD\tnuser (nuser)\tGod27gciF-G0FBfbcoeGl1rXbWGygY7\t\r\nrevision #: 1\t2017/11/16 14:29:05\t"d67a6520a7bd5f315b4330cfe44bc244"\t1.62 KB\tSTANDARD\tnuser (nuser)\tnull\t\r\n\r\n\r\nbilog:\r\n[\r\n    {\r\n        "op_id": "54#00000000001.589.2",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4712.4757287",\r\n        "op": "write",\r\n        "object": "channel.h",\r\n        "instance": "",\r\n        "state": "pending",\r\n        "index_ver": 1,\r\n        "timestamp": "0.000000",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 0\r\n        },\r\n        "bilog_flags": 0,\r\n        "versioned": false,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "54#00000000002.590.3",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4712.4757287",\r\n        "op": "write",\r\n        "object": "channel.h",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 2,\r\n        "timestamp": "2017-11-16 06:29:05.858972802Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 213\r\n        },\r\n        "bilog_flags": 0,\r\n        "versioned": false,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "54#00000000003.591.2",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4712.4757453",\r\n        "op": "write",\r\n        "object": "channel.h",\r\n        "instance": "God27gciF-G0FBfbcoeGl1rXbWGygY7",\r\n        "state": "pending",\r\n        "index_ver": 3,\r\n        "timestamp": "0.000000",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 0\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "54#00000000004.592.3",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4712.4757453",\r\n        "op": "write",\r\n        "object": "channel.h",\r\n        "instance": "God27gciF-G0FBfbcoeGl1rXbWGygY7",\r\n        "state": "complete",\r\n        "index_ver": 4,\r\n        "timestamp": "2017-11-16 06:29:32.401551049Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 214\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "54#00000000005.593.10",\r\n        "op_tag": "000000005a0d304c6t0vm937tepi4vbz",\r\n        "op": "link_olh",\r\n        "object": "channel.h",\r\n        "instance": "God27gciF-G0FBfbcoeGl1rXbWGygY7",\r\n        "state": "complete",\r\n        "index_ver": 5,\r\n        "timestamp": "2017-11-16 06:29:32.401551049Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 2\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "54#00000000006.595.9",\r\n        "op_tag": "000000005a0d306cbc4xkf9nsknng350",\r\n        "op": "link_olh_del",\r\n        "object": "channel.h",\r\n        "instance": "7eciT6VnL88Hfgak1MUvIPbpv6U0vdA",\r\n        "state": "complete",\r\n        "index_ver": 6,\r\n        "timestamp": "2017-11-16 06:30:04.011833121Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 3\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "nuser",\r\n        "owner_display_name": "nuser"\r\n    },\r\n    {\r\n        "op_id": "54#00000000007.597.3",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4712.4757769",\r\n        "op": "write",\r\n        "object": "channel.h",\r\n        "instance": "",\r\n        "state": "pending",\r\n        "index_ver": 7,\r\n        "timestamp": "2017-11-16 06:29:05.858972802Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 213\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "54#00000000008.598.4",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4712.4757769",\r\n        "op": "write",\r\n        "object": "channel.h",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 8,\r\n        "timestamp": "2017-11-16 06:34:56.129691615Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 219\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "54#00000000009.599.14",\r\n        "op_tag": "000000005a0d31909u52r2okkbrf19yi",\r\n        "op": "link_olh",\r\n        "object": "channel.h",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 9,\r\n        "timestamp": "2017-11-16 06:34:56.129691615Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 4\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    }\r\n]	2017-11-16 12:10:57.260669	f
121	40	Issue	5	sh-4.2# for e in `cat testq.bi`; do bin/rados listomapkeys $e -p SZ.rgw.buckets.index; done\r\nver1.txt\r\nver1.txtv912iZYS-9JbNNiYVQQzRaaPXfikyAIChwls\r\nver1.txtv913imZGghn7ChutQ6Zxw9mMD0kv9fAlJQ32\r\nver1.txtv914i\r\n0_00000000001.102367.2\r\n0_00000000002.102368.3\r\n0_00000000003.102549.2\r\n0_00000000004.102550.3\r\n0_00000000005.102551.10\r\n0_00000000006.102597.2\r\n0_00000000007.102598.3\r\n0_00000000008.102599.9\r\n1000_ver1.txti\r\n1000_ver1.txtiZYS-9JbNNiYVQQzRaaPXfikyAIChwls\r\n1000_ver1.txtimZGghn7ChutQ6Zxw9mMD0kv9fAlJQ32\r\n1001_ver1.txt\r\nsh-4.2# for e in `cat testq.bi`; do bin/rados listomapkeys $e -p SZ.rgw.buckets.index; done\r\nver1.txt\r\nver1.txtv911i\r\nver1.txtv911idi8TzdrrnTx0k02GEqxpCzb9Hzsr8qR\r\nver1.txtv912iZYS-9JbNNiYVQQzRaaPXfikyAIChwls\r\nver1.txtv913imZGghn7ChutQ6Zxw9mMD0kv9fAlJQ32\r\n0_00000000001.102367.2\r\n0_00000000002.102368.3\r\n0_00000000003.102549.2\r\n0_00000000004.102550.3\r\n0_00000000005.102551.10\r\n0_00000000006.102597.2\r\n0_00000000007.102598.3\r\n0_00000000008.102599.9\r\n0_00000000009.103317.16\r\n0_00000000010.103318.3\r\n0_00000000011.103319.4\r\n0_00000000012.103321.10\r\n1000_ver1.txtid\r\n1000_ver1.txtiZYS-9JbNNiYVQQzRaaPXfikyAIChwls\r\n1000_ver1.txtidi8TzdrrnTx0k02GEqxpCzb9Hzsr8qR\r\n1000_ver1.txtimZGghn7ChutQ6Zxw9mMD0kv9fAlJQ32\r\n1001_ver1.txt\r\n\r\n区别在于suspend的bucket，会同时删除掉版本为null的对象。也就是说一次性触发了两个动作。	2017-11-20 13:07:11.2152	f
136	40	Issue	5	修改之后的才有循环同步的问题，从正常情况的日志看，在slave zone处理逻辑并不一样。\r\nslave zone是完全当作一个没有版本的对象来处理的，所以没有set_olh的bilog。\r\n为什么呢？ \r\n错，还是olh，进到函数set_olh了，并且调用cls_rgw_bucket_link_olh\r\n(gdb) p call\r\n$12 = {key = {name = "rgw_tag.h", instance = ""}, olh_tag = "gge8m6nxemcegfkot0y6ybcra8u52el2", delete_marker = false, op_tag = "000000005a158662d739hzbd20mhllyr", meta = {\r\n    category = 0 '\\000', size = 0, mtime = {__d = {__r = 0}}, etag = "", owner = "", owner_display_name = "", content_type = "", accounted_size = 0}, olh_epoch = 5, log_op = true, \r\n  bilog_flags = 0, unmod_since = {__d = {__r = 0}}, high_precision_time = false}\r\n\r\n\r\nosd执行：\r\n\r\nBreakpoint 2, rgw_bucket_link_olh (hctx=0x7f70bf7f5a38, in=<optimized out>, out=<optimized out>) at cls/rgw/cls_rgw.cc:1473\r\n1473\tin cls/rgw/cls_rgw.cc\r\n(gdb) p op\r\n$1 = {key = {name = "rgw_tag.h", instance = ""}, olh_tag = "gge8m6nxemcegfkot0y6ybcra8u52el2", delete_marker = false, op_tag = "000000005a158662d739hzbd20mhllyr", meta = {\r\n    category = 0 '\\000', size = 0, mtime = {__d = {__r = 0}}, etag = "", owner = "", owner_display_name = "", content_type = "", accounted_size = 0}, olh_epoch = 5, log_op = true, \r\n  bilog_flags = 0, unmod_since = {__d = {__r = 0}}, high_precision_time = false}\r\n(gdb) p olh\r\n$2 = {hctx = 0x7f70bf7f5a38, key = {name = "rgw_tag.h", instance = ""}, olh_data_idx = "\\200\\061\\060\\060\\061_rgw_tag.h", olh_data_entry = {key = {name = "rgw_tag.h", \r\n      instance = "zdQer7DunwEc.CZ6LVLq-4xfv.kzHSx"}, delete_marker = false, epoch = 3, pending_log = std::map with 0 elements, tag = "z933ci1gmj6818h31sxyo46oyb3xfkw8", exists = true, \r\n    pending_removal = false}, initialized = false}\r\n\r\n还有个明显的问题 就是op.olh_tag与 olh中的不一致。\r\n这就是http://tracker.ceph.com/issues/21210，又遇到了。\r\n\r\n再解决这个问题之后，社区版本就有了循环同步的问题。\r\n当然这个问题通过避免在slave zone写bilog可以避免，但是jewel版本该如何处理呢？\r\n\r\n合入http://tracker.ceph.com/issues/21743 试下看	2017-11-22 20:23:30.475185	f
137	40	Issue	5	注意测试一种情况，没有所谓的null对象，只有olh的情况。\r\n\r\nhttp://tracker.ceph.com/issues/18939 这个问题也应该关注下	2017-11-22 21:05:19.959248	f
151	41	Issue	5	slave zone同步后，null instance多出来1个。\r\n其中一个是版本1，估计是convert出来的，为啥以前没这问题呢？以前增量的时候都是从低版本过来的。\r\n而且convert只会执行一次。\r\n\r\n也就是说上来第一个对象必须从olh epoch 1开始，但是在rgw_bucket_link_olh中写入的BIVerObjEntry又是来自于olh，这样就产生了两个key。\r\n效果就相当于先写了一个普通对象，然后set_olh里面又写了一次。\r\n\r\n\r\n-static int convert_plain_entry_to_versioned(cls_method_context_t hctx, cls_rgw_obj_key& key, bool demote_current, bool instance_only)\r\n+static int convert_plain_entry_to_versioned(cls_method_context_t hctx, cls_rgw_obj_key& key, bool demote_current, bool instance_only, uint64_t epoch)\r\n {\r\n   if (!key.instance.empty()) {\r\n     return -EINVAL;\r\n@@ -1358,8 +1359,9 @@ static int convert_plain_entry_to_versioned(cls_method_context_t hctx, cls_rgw_o\r\n       CLS_LOG(0, "ERROR: read_key_entry() returned ret=%d", ret);\r\n       return ret;\r\n     }\r\n-\r\n-    entry.versioned_epoch = 1; /* converted entries are always 1 */\r\n+    if (epoch == 0)\r\n+      epoch = 1;\r\n+    entry.versioned_epoch = epoch; /* converted entries are always 1 */\r\n     entry.flags |= RGW_BUCKET_DIRENT_FLAG_VER;\r\n \r\n     if (demote_current) {\r\n@@ -1518,7 +1520,7 @@ static int rgw_bucket_link_olh(cls_method_context_t hctx, bufferlist *in, buffer\r\n   } else {\r\n     bool instance_only = (op.key.instance.empty() && op.delete_marker);\r\n     cls_rgw_obj_key key(op.key.name);\r\n-    ret = convert_plain_entry_to_versioned(hctx, key, true, instance_only);\r\n+    ret = convert_plain_entry_to_versioned(hctx, key, true, instance_only, op.olh_epoch);\r\n     if (ret < 0) {\r\n       CLS_LOG(0, "ERROR: convert_plain_entry_to_versioned ret=%d", ret);\r\n       return ret;\r\n@@ -1623,7 +1625,7 @@ static int rgw_bucket_unlink_instance(cls_method_context_t hctx, bufferlist *in,\r\n   if (!olh_found) {\r\n     bool instance_only = false;\r\n     cls_rgw_obj_key key(dest_key.name);\r\n-    ret = convert_plain_entry_to_versioned(hctx, key, true, instance_only);\r\n+    ret = convert_plain_entry_to_versioned(hctx, key, true, instance_only, 0);\r\n     if (ret < 0) {\r\n       CLS_LOG(0, "ERROR: convert_plain_entry_to_versioned ret=%d", ret);\r\n       return ret;\r\n\r\n这样修改可解决该问题。  上面删除的问题也得到解决。	2017-11-28 14:26:45.941054	f
612	269	Issue	5		2019-02-19 07:21:22.312761	f
115	39	Issue	5		2017-11-20 07:30:32.127599	f
114	38	Issue	5	2017-11-16 08:22:27.430089 7f7f4dbb4700  0 WARNING: set_req_state_err err_no=125 resorting to 500\r\n2017-11-16 08:22:27.430122 7f7f4dbb4700  3 req 1005:0.005856:s3:GET /testf/crc32c.cc:get_obj:testf/crc32c.cc :op status=0\r\n2017-11-16 08:22:27.430127 7f7f4dbb4700  3 req 1005:0.005862:s3:GET /testf/crc32c.cc:get_obj:testf/crc32c.cc :http status=500\r\n2017-11-16 08:22:27.430131 7f7f4dbb4700  2 ====== req done req=0x7f7e3c9e1e40 obj=testf/crc32c.cc op status=0 op name=get_obj http_status=500 ======\r\n2017-11-16 08:22:27.434901 7f7f937fb700  0 ERROR: exceeded max ECANCELED retries, aborting (EIO)\r\n2017-11-16 08:22:27.434931 7f7f937fb700  0 store->fetch_remote_obj() returned r=-5\r\n2017-11-16 08:22:27.435009 7f7f79fff700  5 Sync:ae41357a:data:Object:testf:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4764.1:57/crc32c.cc[6]:done, retcode=-5\r\n2017-11-16 08:22:27.435017 7f7f79fff700  0 ERROR: failed to sync object: testf:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4764.1:57/crc32c.cc\r\n2017-11-16 08:22:27.436603 7f7f79fff700  5 Sync:ae41357a:data:Object:testf:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4764.1:57/crc32c.cc[6]:finish\r\n2017-11-16 08:22:27.436616 7f7f79fff700  0 ERROR: a sync operation returned error -5\r\n2017-11-16 08:22:27.437984 7f7f79fff700  0 inc sync bucket:testf:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4764.1:57ERROR: failure in sync, backing out (sync_status=-5)\r\n2017-11-16 08:22:27.439316 7f7f79fff700  5 Sync:ae41357a:data:BucketInc:testf:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4764.1:57:finish\r\n2017-11-16 08:22:27.439335 7f7f79fff700  5 incremental sync on testf:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4764.1:57 failed, retcode=-5\r\n2017-11-16 08:22:27.439342 7f7f79fff700  5 Sync:ae41357a:data:Bucket:testf:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.4764.1:57:finish\r\n\r\n后面还有一次重试，看上去成功了。但是没产生一致的结果\r\n\r\nerr_no=125\r\n\r\n\r\n2017-11-20 03:02:57.538968 7f1264bff700  1 <cls> cls/rgw/cls_rgw.cc:1748: NOTICE: rgw_bucket_read_olh_log(): olh_tag_mismatch olh_data_entry.tag=8zena0falazw7imxcygi7uu2cy1r7dxq op.olh_tag=5bi43uiio494x2bwj38fcbypw4b79api\r\n	2017-11-16 14:20:18.722683	f
117	40	Issue	5		2017-11-20 11:55:41.271513	f
123	40	Issue	5	Breakpoint 1, RGWRados::bucket_index_link_olh (this=this@entry=0x7f057e54dc00, olh_state=..., obj_instance=..., delete_marker=delete_marker@entry=true, \r\n    op_tag="000000005a128d301irodeiyl0f6rgoq", meta=meta@entry=0x7f049ff2b5c0, olh_epoch=olh_epoch@entry=0, unmod_since=unmod_since@entry=..., \r\n    high_precision_time=high_precision_time@entry=false) at rgw/rgw_rados.cc:10046\r\n10046\tin rgw/rgw_rados.cc\r\n(gdb) bt\r\n#0  RGWRados::bucket_index_link_olh (this=this@entry=0x7f057e54dc00, olh_state=..., obj_instance=..., delete_marker=delete_marker@entry=true, op_tag="000000005a128d301irodeiyl0f6rgoq", \r\n    meta=meta@entry=0x7f049ff2b5c0, olh_epoch=olh_epoch@entry=0, unmod_since=unmod_since@entry=..., high_precision_time=high_precision_time@entry=false) at rgw/rgw_rados.cc:10046\r\n#1  0x00007f058f1f1d23 in RGWRados::set_olh (this=this@entry=0x7f057e54dc00, obj_ctx=..., bucket_info=..., target_obj=..., delete_marker=delete_marker@entry=true, \r\n    meta=meta@entry=0x7f049ff2b5c0, olh_epoch=0, unmod_since=..., high_precision_time=false) at rgw/rgw_rados.cc:10376\r\n#2  0x00007f058f214a30 in RGWRados::Object::Delete::delete_obj (this=this@entry=0x7f049ff2b940) at rgw/rgw_rados.cc:8031\r\n#3  0x00007f058f19c9d2 in RGWDeleteObj::execute (this=0x7f0574929600) at rgw/rgw_op.cc:3374\r\n#4  0x00007f058f1b4929 in process_request (store=0x7f057e54dc00, rest=0x7ffdfbcf4f90, req=req@entry=0x7f05518b9dc0, client_io=client_io@entry=0x7f049ff2c6d0, olog=0x0)\r\n    at rgw/rgw_process.cc:174\r\n#5  0x00007f0598c74cc0 in RGWFCGXProcess::handle_request (this=0x7f057e5c9b00, r=0x7f05518b9dc0) at rgw/rgw_fcgi_process.cc:121\r\n#6  0x00007f0598c76990 in RGWProcess::RGWWQ::_process (this=0x7f057e5c9db8, req=0x7f05518b9dc0) at rgw/rgw_process.h:85\r\n#7  0x00007f058f52583e in ThreadPool::worker (this=0x7f057e5c9b70, wt=0x7f0551855a60) at common/WorkQueue.cc:128\r\n#8  0x00007f058f526720 in ThreadPool::WorkThread::entry (this=<optimized out>) at common/WorkQueue.h:445\r\n#9  0x00007f058e2e8dc5 in start_thread () from /lib64/libpthread.so.0\r\n#10 0x00007f058d8f476d in clone () from /lib64/libc.so.6\r\n(gdb) c\r\nContinuing.\r\n[Switching to Thread 0x7f056bff3700 (LWP 72577)]\r\n\r\nBreakpoint 1, RGWRados::bucket_index_link_olh (this=this@entry=0x7f057e54dc00, olh_state=..., obj_instance=..., delete_marker=delete_marker@entry=true, \r\n    op_tag="000000005a128d38emfg6cky1udcs90m", meta=meta@entry=0x7f056bff0f50, olh_epoch=olh_epoch@entry=4, unmod_since=unmod_since@entry=..., \r\n    high_precision_time=high_precision_time@entry=true) at rgw/rgw_rados.cc:10046\r\n10046\tin rgw/rgw_rados.cc\r\n(gdb) bt\r\n#0  RGWRados::bucket_index_link_olh (this=this@entry=0x7f057e54dc00, olh_state=..., obj_instance=..., delete_marker=delete_marker@entry=true, op_tag="000000005a128d38emfg6cky1udcs90m", \r\n    meta=meta@entry=0x7f056bff0f50, olh_epoch=olh_epoch@entry=4, unmod_since=unmod_since@entry=..., high_precision_time=high_precision_time@entry=true) at rgw/rgw_rados.cc:10046\r\n#1  0x00007f058f1f1d23 in RGWRados::set_olh (this=this@entry=0x7f057e54dc00, obj_ctx=..., bucket_info=..., target_obj=..., delete_marker=delete_marker@entry=true, \r\n    meta=meta@entry=0x7f056bff0f50, olh_epoch=4, unmod_since=..., high_precision_time=true) at rgw/rgw_rados.cc:10376\r\n#2  0x00007f058f214a30 in RGWRados::Object::Delete::delete_obj (this=this@entry=0x7f056bff12d0) at rgw/rgw_rados.cc:8031\r\n#3  0x00007f058f0b39bd in RGWAsyncRemoveObj::_send_request (this=0x7f0411d1f580) at rgw/rgw_cr_rados.cc:637\r\n#4  0x00007f058f0afe82 in send_request (this=0x7f0411d1f580) at rgw/rgw_cr_rados.h:31\r\n#5  RGWAsyncRadosProcessor::handle_request (this=<optimized out>, req=0x7f0411d1f580) at rgw/rgw_cr_rados.cc:76\r\n#6  0x00007f058f0aff4d in RGWAsyncRadosProcessor::RGWWQ::_process (this=0x7f057e598090, req=<optimized out>, handle=...) at rgw/rgw_cr_rados.cc:36\r\n#7  0x00007f058f52583e in ThreadPool::worker (this=0x7f057e597e60, wt=0x7f057e5c1a60) at common/WorkQueue.cc:128\r\n#8  0x00007f058f526720 in ThreadPool::WorkThread::entry (this=<optimized out>) at common/WorkQueue.h:445\r\n#9  0x00007f058e2e8dc5 in start_thread () from /lib64/libpthread.so.0\r\n#10 0x00007f058d8f476d in clone () from /lib64/libc.so.6\r\n(gdb) f 1\r\n#1  0x00007f058f1f1d23 in RGWRados::set_olh (this=this@entry=0x7f057e54dc00, obj_ctx=..., bucket_info=..., target_obj=..., delete_marker=delete_marker@entry=true, \r\n    meta=meta@entry=0x7f056bff0f50, olh_epoch=4, unmod_since=..., high_precision_time=true) at rgw/rgw_rados.cc:10376\r\n10376\tin rgw/rgw_rados.cc\r\n(gdb) p target_obj\r\n$1 = (rgw_obj &) @0x7f056bff1060: {orig_obj = "ver1.txt", loc = "", object = "_:uZzLw6A-nVwsNl0ZhO9bjK0n8sUyOdm_ver1.txt", instance = "uZzLw6A-nVwsNl0ZhO9bjK0n8sUyOdm", bucket = {\r\n    tenant = "", name = "tests4", data_pool = "SZ.rgw.buckets.data", data_extra_pool = "SZ.rgw.buckets.non-ec", index_pool = "SZ.rgw.buckets.index", \r\n    marker = "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5183.1", bucket_id = "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5183.1", \r\n    oid = ".bucket.meta.tests4:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5183.1"}, ns = "", in_extra_data = false, index_hash_source = ""}\r\n(gdb) c\r\n还真在这里停留了两次，我日了。\r\n	2017-11-20 13:55:33.657169	f
120	40	Issue	5	sh-4.2# for e in `cat testo.bi`; do bin/rados listomapkeys $e -p SZ.rgw.buckets.index; done\r\nsbsb.txtv911i\r\n0_00000000001.753.2\r\n0_00000000002.754.3\r\n0_00000000003.755.2\r\n0_00000000004.756.3\r\n0_00000000005.757.10\r\n0_00000000006.759.2\r\n0_00000000007.760.3\r\n0_00000000008.761.9\r\n0_00000000009.763.16\r\n0_00000000010.764.3\r\n0_00000000011.765.4\r\n0_00000000012.767.10\r\n0_00000000013.769.5\r\n0_00000000014.770.2\r\n0_00000000015.771.3\r\n0_00000000016.773.5\r\n0_00000000017.774.2\r\n0_00000000018.775.3\r\n0_00000000019.777.7\r\n1000_sbsb.txtid\r\n\r\n删除olh之前：\r\nsh-4.2# for e in `cat testp.bi`; do bin/rados listomapkeys $e -p SZ.rgw.buckets.index; done\r\n0_00000000001.2068.2\r\n0_00000000002.2069.3\r\n0_00000000003.2070.2\r\n0_00000000004.2071.3\r\n0_00000000005.2072.10\r\n0_00000000006.2074.2\r\n0_00000000007.2075.3\r\n0_00000000008.2076.9\r\n1000_测试对象.txti\r\n1000_测试对象.txtiBaIJnvR4VUTY0RGQ6O5U3xU1Rl44rP1\r\n1000_测试对象.txtiDKmSS4b9NFOLobTk91i0mqtBKznwCAM\r\n1001_测试对象.txt\r\n测试对象.txt\r\n测试对象.txtv912iDKmSS4b9NFOLobTk91i0mqtBKznwCAM\r\n测试对象.txtv913iBaIJnvR4VUTY0RGQ6O5U3xU1Rl44rP1\r\n测试对象.txtv914i\r\n\r\nsh-4.2# for e in `cat testp.bi`; do bin/rados listomapkeys $e -p SZ.rgw.buckets.index; done\r\n0_00000000001.2068.2\r\n0_00000000002.2069.3\r\n0_00000000003.2070.2\r\n0_00000000004.2071.3\r\n0_00000000005.2072.10\r\n0_00000000006.2074.2\r\n0_00000000007.2075.3\r\n0_00000000008.2076.9\r\n0_00000000009.2078.9\r\n1000_测试对象.txti\r\n1000_测试对象.txtiBaIJnvR4VUTY0RGQ6O5U3xU1Rl44rP1\r\n1000_测试对象.txtiDKmSS4b9NFOLobTk91i0mqtBKznwCAM\r\n1000_测试对象.txtiUNbh6YIH7bsP6nxFtEp0dgn2t4S-5h6\r\n1001_测试对象.txt\r\n测试对象.txt\r\n测试对象.txtv911iUNbh6YIH7bsP6nxFtEp0dgn2t4S-5h6\r\n测试对象.txtv912iDKmSS4b9NFOLobTk91i0mqtBKznwCAM\r\n测试对象.txtv913iBaIJnvR4VUTY0RGQ6O5U3xU1Rl44rP1\r\n测试对象.txtv914i\r\n	2017-11-20 13:00:04.370578	f
122	40	Issue	5	更奇怪的现象：在我关闭slave zone的rgw之后，执行同样操作，结果是这样的：\r\nver2.txt\t\r\nrevision #: 3 (deleted)\t2017/11/20 15:46:29\t\t\t\tnuser (nuser)\tnull\t\r\nrevision #: 2\t2017/11/20 15:46:01\t"7a6f01477ea0ab4fcedecbeeb2b310e9"\t501 bytes\tSTANDARD\tnuser (nuser)\tID4Aoavr6wGDRKSLTHydkYASq0KnPjJ\t\r\nrevision #: 1\t2017/11/20 15:45:54\t"7a6f01477ea0ab4fcedecbeeb2b310e9"\t501 bytes\tSTANDARD\tnuser (nuser)\tMDl6T.i8Dz0YWCzEt520PUCjZw6S7VI\t\r\n\r\n这时delete对应的bilog:\r\n {\r\n        "op_id": "1#00000000009.110810.16",\r\n        "op_tag": "000000005a128855325xege7c4l7oej3",\r\n        "op": "link_olh_del",\r\n        "object": "ver2.txt",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 9,\r\n        "timestamp": "2017-11-20 07:46:29.131235396Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 4\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "nuser",\r\n        "owner_display_name": "nuser"\r\n    },\r\n    {\r\n        "op_id": "1#00000000010.110811.3",\r\n        "op_tag": "_k6N6HnPUobAateg0mghcsJLEuU4IgcD",\r\n        "op": "del",\r\n        "object": "ver2.txt",\r\n        "instance": "",\r\n        "state": "pending",\r\n        "index_ver": 10,\r\n        "timestamp": "0.000000",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 0\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "1#00000000011.110812.4",\r\n        "op_tag": "_k6N6HnPUobAateg0mghcsJLEuU4IgcD",\r\n        "op": "del",\r\n        "object": "ver2.txt",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 11,\r\n        "timestamp": "2017-11-20 07:46:01.432380235Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 946\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    }	2017-11-20 13:31:56.145496	f
124	40	Issue	5	正确的做法是什么呢？不应该是把null的版本干掉吧？\r\nslave zone：\r\nver1.txt\t\r\nrevision #: 4 (deleted)\t2017/11/20 16:07:12\t\t\t\tnuser (nuser)\tuZzLw6A-nVwsNl0ZhO9bjK0n8sUyOdm\t\r\nrevision #: 3\t2017/11/20 16:06:49\t"05b64c65fcc220fe52d5a9bf8fee7172"\t501 bytes\tSTANDARD\tnuser (nuser)\tCX6BiM09Aiqi3xoJfno8TODg6OyDn6i\t\r\nrevision #: 2\t2017/11/20 16:06:39\t"05b64c65fcc220fe52d5a9bf8fee7172"\t501 bytes\tSTANDARD\tnuser (nuser)\tQHXnGECXcB3YEwmCW3vy9mmeQ70cY6X\t\r\nrevision #: 1\t2017/11/20 16:06:05\t"05b64c65fcc220fe52d5a9bf8fee7172"\t501 bytes\tSTANDARD\tnuser (nuser)\tnull\t\r\n\r\n主副本在这块的执行逻辑不一样。\r\n\r\n主本bilog：\r\n{\r\n        "op_id": "46#00000000009.912.16",\r\n        "op_tag": "000000005a128d301irodeiyl0f6rgoq",\r\n        "op": "link_olh_del",\r\n        "object": "ver1.txt",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 9,\r\n        "timestamp": "2017-11-20 08:07:12.955839015Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 4\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "nuser",\r\n        "owner_display_name": "nuser"\r\n    },\r\n    {\r\n        "op_id": "46#00000000010.913.3",\r\n        "op_tag": "_mrqDuwpawNTEJjzNtF4EmEImZX1VOyc",\r\n        "op": "del",\r\n        "object": "ver1.txt",\r\n        "instance": "",\r\n        "state": "pending",\r\n        "index_ver": 10,\r\n        "timestamp": "0.000000",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 0\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "46#00000000011.914.4",\r\n        "op_tag": "_mrqDuwpawNTEJjzNtF4EmEImZX1VOyc",\r\n        "op": "del",\r\n        "object": "ver1.txt",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 11,\r\n        "timestamp": "2017-11-20 08:06:51.721181829Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 964\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "46#00000000012.916.10",\r\n        "op_tag": "000000005a128d38emfg6cky1udcs90m",\r\n        "op": "link_olh_del",\r\n        "object": "ver1.txt",\r\n        "instance": "uZzLw6A-nVwsNl0ZhO9bjK0n8sUyOdm",\r\n        "state": "complete",\r\n        "index_ver": 12,\r\n        "timestamp": "2017-11-20 08:07:12.955839015Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 4\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "nuser",\r\n        "owner_display_name": "nuser"\r\n    }\r\n最后一条bilog是从slave同步过来的	2017-11-20 14:04:56.505492	f
1598	795	Issue	5	但是思考力的根本在于找到一种理解现实的模型。然后在此模型下不断训练，就能变得更快。\r\n	2021-03-08 06:05:02.281567	f
127	40	Issue	5	还有null instance的对象是不是和olh对象的名字一摸一样？这样如何区分呢？\r\n还真不清楚，但是确实是olh和null版本共用了一个对象，而且null instance的数据并没被覆盖\r\n\r\n为什么不在写olh的时候把null version相关的bi信息给清理或者覆盖掉呢？\r\n\r\nsh-4.2# for t in `cat ./test10.bi`; do bin/rados listomapkeys $t -p BJ.rgw.buckets.index; done\r\nrgw_acl_swift.h\r\nrgw_acl_swift.hv911itWNVGC54iwG7obfdSde8aV0Tt2bMLZs\r\nrgw_acl_swift.hv912i9YUzYm-fc5Q87geRhV9psc3QBqm2UZA\r\nrgw_acl_swift.hv913iTkARIgCqHkCHzcsoIMN2yXiVAlgRI3p\r\nrgw_acl_swift.hv914i\r\n0_00000000001.73.2\r\n0_00000000002.74.3\r\n0_00000000003.75.2\r\n0_00000000004.76.3\r\n0_00000000005.77.10\r\n0_00000000006.79.2\r\n0_00000000007.80.3\r\n0_00000000008.81.9\r\n0_00000000009.83.9\r\n1000_rgw_acl_swift.hi\r\n1000_rgw_acl_swift.hi9YUzYm-fc5Q87geRhV9psc3QBqm2UZA\r\n1000_rgw_acl_swift.hiTkARIgCqHkCHzcsoIMN2yXiVAlgRI3p\r\n1000_rgw_acl_swift.hitWNVGC54iwG7obfdSde8aV0Tt2bMLZs\r\n1001_rgw_acl_swift.h\r\nsh-4.2# bin/rados ls -p BJ.rgw.buckets.data | grep "rgw_acl"\r\nae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.4_rgw_acl_swift.h\r\nae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.4__:9YUzYm-fc5Q87geRhV9psc3QBqm2UZA_rgw_acl_swift.h\r\nae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.4__:TkARIgCqHkCHzcsoIMN2yXiVAlgRI3p_rgw_acl_swift.h\r\n\r\nunlink instance到底缺了什么呢？\r\n这时null instance指向了olh的对象。\r\n\r\n在slave zone执行时，delete的参数instance是null的，但是mark version id是"null"。对象是versioned的。\r\nif (!params.marker_version_id.empty()) {\r\n        if (params.marker_version_id != "null") {\r\n          marker.set_instance(params.marker_version_id);\r\n        }\r\n      //XRWHY:so if suspend,delete will direct on null instance,but maybe the null instance is an older version.\r\n      //why ? we should only make a delete marker, otherwise, we can not rollback, or find older version.\r\n      // should see a null instance as a version too!\r\n      } else if ((params.versioning_status & BUCKET_VERSIONS_SUSPENDED) == 0) {\r\n        store->gen_rand_obj_instance_name(&marker);\r\n      }\r\n\r\n      result.version_id = marker.get_instance();\r\n      result.delete_marker = true;\r\n这样就走向了delete marker分支，但这实际上是一个unlink instance操作。\r\n\r\n有趣的是把删除标记删除掉，就相当于回滚了..删除\r\n	2017-11-21 07:40:02.978457	f
1600	610	Issue	5	动作分解和实体分解。\r\n多动作的关联性，实体之间的关联性。\r\n常见动作，常见实体	2021-03-08 06:12:49.934031	f
1601	646	Issue	5	大发力一定要力从地起，不要本末倒置。\r\n仅用末端大发力由于反作用力存在，必然会受伤。而且为了维持身体平衡，核心需花费比从地起更大的力量。\r\n冰王：我们知道鞭打发力是力从地起，从持拍脚蹬地开始一直传递到手指握拍击球完成鞭打发力，并得以将挥速增加到最大。\r\n评论：有很多人就是打球不放松，和没有掌握正确发力有关系，其实是用核心发力，却错误地使用肩膀手臂去发力。\r\nhttps://zhuanlan.zhihu.com/p/116576896\r\n还有一种瞬间发力：\r\n	2021-03-14 19:09:55.444535	f
1602	805	Issue	5		2021-03-15 06:27:55.798918	f
1603	805	Issue	5		2021-03-15 06:34:37.551754	f
1606	807	Issue	5	软件的本质还是在行为	2021-03-16 06:42:33.548067	f
1607	705	Issue	5	平衡第一，发力第二	2021-03-16 12:52:10.347183	f
1608	808	Issue	5		2021-03-16 13:05:17.531801	f
125	40	Issue	5	RGWRados::Object::Delete::delete_obj：     \r\n      //XRWHY:so if suspend,delete will direct on null instance,but maybe the null instance is an older version.\r\n      //why ? we should only make a delete marker, otherwise, we can not rollback, or find older version.\r\n      // should see a null instance as a version too!\r\n      } else if ((params.versioning_status & BUCKET_VERSIONS_SUSPENDED) == 0) {\r\n        store->gen_rand_obj_instance_name(&marker);\r\n      }\r\n关闭多版本的情况下，这里就不会在delete时产生新版本，直接把老版本给干掉了。\r\n\r\nslave zone：\r\nBreakpoint 2, RGWRados::Object::Delete::delete_obj (this=this@entry=0x7fc6d1bf22d0) at rgw/rgw_rados.cc:7993\r\n7993\trgw/rgw_rados.cc: No such file or directory.\r\n(gdb) bt\r\n#0  RGWRados::Object::Delete::delete_obj (this=this@entry=0x7fc6d1bf22d0) at rgw/rgw_rados.cc:7993\r\n#1  0x00007fc6f47839bd in RGWAsyncRemoveObj::_send_request (this=0x7fc58009ba00) at rgw/rgw_cr_rados.cc:637\r\n#2  0x00007fc6f477fe82 in send_request (this=0x7fc58009ba00) at rgw/rgw_cr_rados.h:31\r\n#3  RGWAsyncRadosProcessor::handle_request (this=<optimized out>, req=0x7fc58009ba00) at rgw/rgw_cr_rados.cc:76\r\n#4  0x00007fc6f477ff4d in RGWAsyncRadosProcessor::RGWWQ::_process (this=0x7fc6e3d95290, req=<optimized out>, handle=...) at rgw/rgw_cr_rados.cc:36\r\n#5  0x00007fc6f4bf583e in ThreadPool::worker (this=0x7fc6e3d95060, wt=0x7fc6e3daf2e0) at common/WorkQueue.cc:128\r\n#6  0x00007fc6f4bf6720 in ThreadPool::WorkThread::entry (this=<optimized out>) at common/WorkQueue.h:445\r\n#7  0x00007fc6f39b8dc5 in start_thread () from /lib64/libpthread.so.0\r\n#8  0x00007fc6f2fc476d in clone () from /lib64/libc.so.6\r\n(gdb) p params\r\n$1 = {bucket_owner = {tenant = "", id = "nuser"}, versioning_status = 2, obj_owner = {id = {tenant = "", id = "nuser"}, display_name = "nuser"}, olh_epoch = 4, marker_version_id = "", \r\n  bilog_flags = 0, remove_objs = 0x0, expiration_time = {__d = {__r = 0}}, unmod_since = {__d = {__r = 1511170925253828643}}, mtime = {__d = {__r = 1511170925253828643}}, \r\n  high_precision_time = true}\r\n\r\nversioning_status = 2 居然是2\r\n\r\nif (versioned) {\r\n    del_op.params.versioning_status = BUCKET_VERSIONED;\r\n}\r\n这里简单粗暴，显然bilog entry的\r\n"versioned": true无法表示bucket多版本是suspend状态。\r\n\r\n多版本挂起之后，写入就是之前没有启用多版本的null对象，这一点导致设计上出现了不一致。\r\n这也造成了一些混淆，当我不带version去删除时和带version null删除时处理上的混乱\r\n带null version：\r\n172.18.0.1 - - [20/Nov/2017:11:25:00 +0000] "DELETE /tests6/ver1.txt?versionId=null HTTP/1.1" 204 0 "-" "S3 Browser 6-5-9 http://s3browser.com" "-"\r\n不带任何版本的:\r\n172.18.0.1 - - [20/Nov/2017:11:27:55 +0000] "DELETE /tests6/ver1.txt HTTP/1.1" 204 0 "-" "S3 Browser 6-5-9 http://s3browser.com" "-"\r\n果然还是不一样的。\r\n\r\n*个人觉得应该把null version当作一个普通的version来看待，在delete olh时，行为还是仅仅做一个delete marker。*\r\n麻烦在于在表示一个rgw_obj时，没法区分这两种情况。\r\n\r\ns3在suspend version之后的行为也是如此，不带版本删除时，null instance被干掉了。\r\n\r\n奇葩的是suspend的bucket删除当前版本，还能rollback到上一个版本。	2017-11-20 15:16:06.929707	f
126	40	Issue	5	//} else if ((params.versioning_status & BUCKET_VERSIONS_SUSPENDED) == 0) {\r\n      } else {\r\n        assert(params.versioning_status & BUCKET_VERSIONED);\r\n        store->gen_rand_obj_instance_name(&marker);\r\n      }\r\n采用这个改法，最终删除null对象时也会产生一个marker，同步时需要注意这种情况。\r\n\r\n2017-11-20 12:01:23.945853 7fc6d27ee700  0 _send_request(): deleting obj=tests7:_:E8OcLaalAAaCoXw7RzaoT9NI2beWMVD_ver1.txt\r\n2017-11-20 12:01:23.953511 7fc6bf7ff700  0 ERROR: a sync operation returned error -2\r\n2017-11-20 12:01:23.970162 7fc6bf7ff700  0 inc sync bucket:tests7:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.1:46ERROR: failure in sync, backing out (sync_status=-2)\r\n2017-11-20 12:01:23.972665 7fc6bf7ff700  0 WARNING: skipping data log entry for missing bucket tests7:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.1:46\r\n\r\n采用该改法之后，slave zone出现上述错误。\r\n\r\n看上去像执行乱序了：\r\n2017-11-20 12:13:37.730518 7fc6bf7ff700  5 parsed entry: id=00000000011.116215.8 iter->object=get_400M.xml iter->instance= name=get_400M.xml instance= ns=\r\n2017-11-20 12:13:37.730537 7fc6bf7ff700  5 [inc sync] syncing object: tests8:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.2:36/get_400M.xml\r\n2017-11-20 12:13:37.730551 7fc6bf7ff700  5 operate(): entry->timestamp=2017-11-20 12:13:37.0.611605s\r\n2017-11-20 12:13:37.730593 7fc6bf7ff700  5 Sync:ae41357a:data:Object:tests8:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.2:36/get_400M.xml[6]:start\r\n2017-11-20 12:13:37.730605 7fc6bf7ff700  5 parsed entry: id=00000000012.116216.3 iter->object=get_400M.xml iter->instance= name=get_400M.xml instance= ns=\r\n2017-11-20 12:13:37.730612 7fc6bf7ff700  5 [inc sync] skipping object: tests8:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.2:36/get_400M.xml: non-complete operation\r\n2017-11-20 12:13:37.730616 7fc6bf7ff700  5 parsed entry: id=00000000013.116217.4 iter->object=get_400M.xml iter->instance= name=get_400M.xml instance= ns=\r\n2017-11-20 12:13:37.730620 7fc6bf7ff700  5 [inc sync] skipping object: tests8:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.2:36/get_400M.xml: squashed operation\r\n2017-11-20 12:13:37.730640 7fc6bf7ff700  5 Sync:ae41357a:data:Object:tests8:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.2:36/get_400M.xml[6]:remove\r\n2017-11-20 12:13:37.730744 7fc6d67f6700  0 _send_request(): deleting obj=tests8:get_400M.xml\r\n2017-11-20 12:13:37.730878 7fc6bf7ff700  5 add_request request http://172.18.0.130:8080/admin/log?bucket-instance=tests8%3Aae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.2%3A36&format=json&marker=00000000013.116217.4&type=bucket-index&rgwx-zonegroup=0fbaadfd-bbe6-465c-b594-122993af93f9\r\n2017-11-20 12:13:37.730960 7fc6bbffe700  5 link_request req_data=0x7fc6be1ffa80 req_data->id=6156, easy_handle=0x7fc583146000\r\n2017-11-20 12:13:37.743418 7fc6df7fd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2017-11-20 12:13:37.752565 7fc6bf7ff700  5 Sync:ae41357a:data:Object:tests8:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.2:36/get_400M.xml[6]:done\r\n2017-11-20 12:13:37.755434 7fc6bf7ff700  5 Sync:ae41357a:data:Object:tests8:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.2:36/get_400M.xml[6]:finish\r\n\r\n\r\nlink_olh_del比 remove先执行了。\r\n\r\n\r\n{\r\n        "op_id": "34#00000000009.1039.9",\r\n        "op_tag": "000000005a12ceaav7v9edwmgw99w0pv",\r\n        "op": "link_olh_del",\r\n        "object": "rgw_acl_swift.h",\r\n        "instance": "tWNVGC54iwG7obfdSde8aV0Tt2bMLZs",\r\n        "state": "complete",\r\n        "index_ver": 9,\r\n        "timestamp": "2017-11-20 12:46:34.805575147Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 4\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "nuser",\r\n        "owner_display_name": "nuser"\r\n    },\r\n\r\n上面是执行删除olh对象时的bilog，下面是仅接着执行删除version为null对象的bilog，与之前的bilog并不一样，可见instance直接影响了bilog的形成。\r\n那么在slave zone仍然能看到null version的对象，但是无法执行删除(返回-2)的根因是什么呢？\r\n    {\r\n        "op_id": "34#00000000010.1041.7",\r\n        "op_tag": "000000005a12ceb1ea0deqrt8dag2ctb",\r\n        "op": "unlink_instance",\r\n        "object": "rgw_acl_swift.h",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 10,\r\n        "timestamp": "2017-11-20 12:46:41.791979083Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 5\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "34#00000000011.1042.3",\r\n        "op_tag": "_zTFl-reak1RHQtEJzRD_pKS8HjdF6BL",\r\n        "op": "del",\r\n        "object": "rgw_acl_swift.h",\r\n        "instance": "",\r\n        "state": "pending",\r\n        "index_ver": 11,\r\n        "timestamp": "2017-11-20 12:45:19.489294844Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 5219\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "34#00000000012.1043.4",\r\n        "op_tag": "_zTFl-reak1RHQtEJzRD_pKS8HjdF6BL",\r\n        "op": "del",\r\n        "object": "rgw_acl_swift.h",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 12,\r\n        "timestamp": "2017-11-20 12:46:35.120816869Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 5228\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    }\r\n\r\n\r\n2017-11-20 12:46:41.987830 7fc6bf7ff700  5 parsed entry: id=00000000010.1041.7 iter->object=rgw_acl_swift.h iter->instance= name=rgw_acl_swift.h instance= ns=\r\n2017-11-20 12:46:41.987837 7fc6bf7ff700  5 [inc sync] syncing object: test10:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.4:34/rgw_acl_swift.h\r\n2017-11-20 12:46:41.987850 7fc6bf7ff700  5 operate(): entry->timestamp=2017-11-20 12:46:41.0.791979s\r\n2017-11-20 12:46:41.987885 7fc6bf7ff700  5 Sync:ae41357a:data:Object:test10:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.4:34/rgw_acl_swift.h[5]:start\r\n2017-11-20 12:46:41.987893 7fc6bf7ff700  5 parsed entry: id=00000000011.1042.3 iter->object=rgw_acl_swift.h iter->instance= name=rgw_acl_swift.h instance= ns=\r\n2017-11-20 12:46:41.987898 7fc6bf7ff700  5 [inc sync] skipping object: test10:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.4:34/rgw_acl_swift.h: non-complete operation\r\n2017-11-20 12:46:41.987902 7fc6bf7ff700  5 parsed entry: id=00000000012.1043.4 iter->object=rgw_acl_swift.h iter->instance= name=rgw_acl_swift.h instance= ns=\r\n2017-11-20 12:46:41.987906 7fc6bf7ff700  5 [inc sync] skipping object: test10:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.4:34/rgw_acl_swift.h: squashed operation\r\n2017-11-20 12:46:41.987952 7fc6bf7ff700  5 Sync:ae41357a:data:Object:test10:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.4:34/rgw_acl_swift.h[5]:remove\r\n2017-11-20 12:46:41.988071 7fc6d8ffb700  0 _send_request(): deleting obj=test10:rgw_acl_swift.h\r\n2017-11-20 12:46:41.988252 7fc6bf7ff700  5 add_request request http://172.18.0.130:8080/admin/log?bucket-instance=test10%3Aae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.4%3A34&format=json&marker=00000000012.1043.4&type=bucket-index&rgwx-zonegroup=0fbaadfd-bbe6-465c-b594-122993af93f9\r\n2017-11-20 12:46:41.988288 7fc6bbffe700  5 link_request req_data=0x7fc6be2d2080 req_data->id=21165, easy_handle=0x7fc5801bb000\r\n2017-11-20 12:46:41.989211 7fc6bf7ff700  5 Sync:ae41357a:data:Object:test10:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.4:34/rgw_acl_swift.h[5]:done, retcode=-2\r\n2017-11-20 12:46:41.991119 7fc6bf7ff700  0 datalog.sync-status.shard.ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.91.retry add retry entry test10:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.4:34 ret 0\r\n2017-11-20 12:46:41.993016 7fc6bf7ff700  5 Sync:ae41357a:data:Object:test10:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5186.4:34/rgw_acl_swift.h[5]:finish\r\n\r\n显然第一个同步create_delete_marker并非仅仅create_delete_marker	2017-11-20 18:11:24.611403	f
134	40	Issue	5	场景是关闭多版本上传一个对象，就会产生很多条bilog，循环产生。\r\n\r\nbilog时间规律是\r\nprepare一个时间\r\n\r\ncomplete一个时间\r\nset_olh和complete同时间。\r\n\r\n\r\n原因搞不好是这个问题\r\nhttp://tracker.ceph.com/issues/21743\r\n\r\n也就是说olh对象的mtime一直在修改，这样bilog中记录的时间与olh时间不一致。\r\nolh.mtime > bilog.olh.time\r\n这样就会不断的循环，以前有这个问题么？	2017-11-22 15:28:15.000517	f
130	40	Issue	5	新的问题：\r\n{\r\n        "op_id": "62#00000000042.9831.7",\r\n        "op_tag": "000000005a14089ei48nf693jwc6xjes",\r\n        "op": "unlink_instance",\r\n        "object": "rgw_tag.h",\r\n        "instance": "null",\r\n        "state": "complete",\r\n        "index_ver": 42,\r\n        "timestamp": "2017-11-21 11:06:06.332797486Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 3\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "62#00000000043.9832.3",\r\n        "op_tag": "_mnP6rfK-J5NQoW2Z5eU5mR3-pOhc4WZ",\r\n        "op": "del",\r\n        "object": "rgw_tag.h",\r\n        "instance": "",\r\n        "state": "pending",\r\n        "index_ver": 43,\r\n        "timestamp": "2017-11-21 11:05:41.355198827Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 6109\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "62#00000000044.9833.4",\r\n        "op_tag": "_mnP6rfK-J5NQoW2Z5eU5mR3-pOhc4WZ",\r\n        "op": "del",\r\n        "object": "rgw_tag.h",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 44,\r\n        "timestamp": "2017-11-21 11:06:06.325824432Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 6113\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n主上删除之后 bilog这样，在slave zone执行又出问题了。\r\n分析下多版本未关闭时，一个null version的删除过程。\r\n在多版本的时候，是不存在直接删除一个版本的，都是走的上述流程，有3条bilog\r\n\r\n在删除一个多版本的null instance之后：\r\nslave\r\nrgw_tag.h\t\r\nrevision #: 4 (deleted)\t2017/11/21 21:39:19\t\t\t\t ()\trl-BIj0bWGesh3BiNAQ9sKhkcndCLRz\t\r\nrevision #: 3 (deleted)\t2017/11/21 21:39:19\t\t\t\t ()\t8ZAduL8Cc2kffJgRI98wVX-WCyA1JAo\t\r\nrevision #: 2\t2017/11/21 21:38:55\t"89acfb788b24ef60d7ad87fb3b9784cd"\t1012 bytes\tSTANDARD\tnuser (nuser)\tNOxCtx3CuHqO0ad1nr4aAm-8Wmi3CIh\t\r\nrevision #: 1\t2017/11/21 21:38:49\t"89acfb788b24ef60d7ad87fb3b9784cd"\t1012 bytes\tSTANDARD\tnuser (nuser)\tHsJUW0FyCXf5IEZ3Hzd0TbM5Sfm.ft3\t	2017-11-21 16:54:17.57271	f
132	40	Issue	5	将 delete_obj中 prepare delete 的bilog 改为使用src_obj，带null之后效果更令人诧异：\r\nrgw_tag.h\t\r\nrevision #: 3\t2017/11/21 21:42:37\t"89acfb788b24ef60d7ad87fb3b9784cd"\t1012 bytes\tSTANDARD\tnuser (nuser)\tb2APVlliy3tIwC5-7NtFzTC2h.f1e-L\t\r\nrevision #: 2 (current)\t2017/11/21 21:42:37\t"89acfb788b24ef60d7ad87fb3b9784cd"\t1012 bytes\tSTANDARD\tnuser (nuser)\tCYMJkGLXiPnDB1LvVtqyG2f08vmTsvj\t\r\nrevision #: 1\t2017/11/21 21:42:33\t"89acfb788b24ef60d7ad87fb3b9784cd"\t1012 bytes\tSTANDARD\tnuser (nuser)\tIWgxPnKyV0931dMiVwJDoqkGTIKgnmP\t\r\n\r\n上传一个对象后，出现了循环同步的现象	2017-11-21 19:29:32.366813	f
135	40	Issue	5	[root@localhost ceph]# git diff src/rgw/rgw_rados.cc\r\ndiff --git a/ceph/src/rgw/rgw_rados.cc b/ceph/src/rgw/rgw_rados.cc\r\nindex 6fb346d..4ef2b32 100644\r\n--- a/ceph/src/rgw/rgw_rados.cc\r\n+++ b/ceph/src/rgw/rgw_rados.cc\r\n@@ -7054,6 +7054,10 @@ int RGWRados::fetch_remote_obj(RGWObjectCtx& obj_ctx,\r\n       JSONDecoder::decode_json("attrs", src_attrs, &jp);\r\n \r\n       src_attrs.erase(RGW_ATTR_MANIFEST); // not interested in original object layout\r\n+      src_attrs.erase(RGW_ATTR_OLH_INFO);\r\n+      src_attrs.erase(RGW_ATTR_OLH_VER);\r\n+      src_attrs.erase(RGW_ATTR_OLH_ID_TAG);\r\n+      src_attrs.erase(RGW_ATTR_OLH_PENDING_PREFIX);\r\n       if (source_zone.empty()) { /* need to preserve expiration if copy in the same zonegroup */\r\n         src_attrs.erase(RGW_ATTR_DELETE_AT);\r\n       } else {\r\n@@ -8036,7 +8040,7 @@ int RGWRados::Object::Delete::delete_obj()\r\n         return r;\r\n       }\r\n       result.delete_marker = dirent.is_delete_marker();\r\n-      r = store->unlink_obj_instance(target->get_ctx(), target->get_bucket_info(), obj, params.olh_epoch);\r\n+      r = store->unlink_obj_instance(target->get_ctx(), target->get_bucket_info(), src_obj, params.olh_epoch);\r\n       if (r < 0) {\r\n         return r;\r\n       }\r\n@@ -8122,7 +8126,7 @@ int RGWRados::Object::Delete::delete_obj()\r\n   RGWBucketInfo& bucket_info = target->get_bucket_info();\r\n \r\n   RGWRados::Bucket bop(store, bucket_info);\r\n-  RGWRados::Bucket::UpdateIndex index_op(&bop, obj, state);\r\n+  RGWRados::Bucket::UpdateIndex index_op(&bop, src_obj, state);\r\n \r\n   index_op.set_bilog_flags(params.bilog_flags);\r\n\r\n\r\n\r\n[root@localhost ceph]# git diff src/cls/rgw/cls_rgw.cc\r\ndiff --git a/ceph/src/cls/rgw/cls_rgw.cc b/ceph/src/cls/rgw/cls_rgw.cc\r\nindex 58247b5..2bde98b 100644\r\n--- a/ceph/src/cls/rgw/cls_rgw.cc\r\n+++ b/ceph/src/cls/rgw/cls_rgw.cc\r\n@@ -1624,6 +1624,8 @@ static int rgw_bucket_unlink_instance(cls_method_context_t hctx, bufferlist *in,\r\n     obj.set_epoch(1);\r\n   }\r\n \r\n+  CLS_LOG(0, "olh current epoch is %d, op olh_epoch is %d", \r\n+              olh.get_epoch(), op.olh_epoch);\r\n   if (!olh.start_modify(op.olh_epoch)) {\r\n     ret = obj.unlink_list_entry();\r\n     if (ret < 0) {\r\n[root@localhost ceph]# git diff src/rgw/rgw_cr_rados.cc\r\ndiff --git a/ceph/src/rgw/rgw_cr_rados.cc b/ceph/src/rgw/rgw_cr_rados.cc\r\nindex ac40dc6..7143b1e 100644\r\n--- a/ceph/src/rgw/rgw_cr_rados.cc\r\n+++ b/ceph/src/rgw/rgw_cr_rados.cc\r\n@@ -625,7 +625,9 @@ int RGWAsyncRemoveObj::_send_request()\r\n     del_op.params.unmod_since = timestamp;\r\n   }\r\n   if (versioned) {\r\n-    del_op.params.versioning_status = BUCKET_VERSIONED;\r\n+    del_op.params.versioning_status = bucket_info.versioning_status();\r\n+    ldout(store->ctx(), 0) << " bucket " << bucket_info.bucket.name << " key " << obj << " version status " \r\n+                                      << del_op.params.versioning_status << dendl;\r\n   }\r\n   del_op.params.olh_epoch = versioned_epoch;\r\n   del_op.params.marker_version_id = marker_version_id;\r\n	2017-11-22 18:51:27.742744	f
179	71	Issue	5	删除.git目录，否则autogen.sh过不了。\r\n\r\nceph_ver.h:\r\n#ifndef CEPH_VERSION_H\r\n#define CEPH_VERSION_H\r\n\r\n#define CEPH_GIT_VER 951609bd3033f20560230d1d3514b535cffc0fde\r\n#define CEPH_GIT_NICE_VER "eph_v10.2.10"\r\n\r\n#endif	2018-05-17 11:32:46.713775	f
180	71	Issue	5	/usr/lib/gcc/sw_64sw4-sunway-linux-gnu/5.3.0/../../../../sw_64sw4-sunway-linux-gnu/bin/ld: cls/journal/.libs/cls_journal_types.o: dtp-relative relocation against dynamic symbol _ZZ9stringifyIN3cls7journal11ClientStateEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_E2ssB5cxx11\r\n/usr/lib/gcc/sw_64sw4-sunway-linux-gnu/5.3.0/../../../../sw_64sw4-sunway-linux-gnu/bin/ld: cls/journal/.libs/cls_journal_types.o: dtp-relative relocation against dynamic symbol _ZZ9stringifyIN3cls7journal11ClientStateEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_E2ssB5cxx11\r\n/usr/lib/gcc/sw_64sw4-sunway-linux-gnu/5.3.0/../../../../sw_64sw4-sunway-linux-gnu/bin/ld: cls/journal/.libs/cls_journal_types.o: dtp-relative relocation against dynamic symbol _ZZ9stringifyIN3cls7journal11ClientStateEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_E2ssB5cxx11\r\n/usr/lib/gcc/sw_64sw4-sunway-linux-gnu/5.3.0/../../../../sw_64sw4-sunway-linux-gnu/bin/ld: final link failed: Nonrepresentable section on output\r\n\r\n有两种尝试：\r\n1.增加-fPIC\r\n2，-fvisibility-hidden\r\nhttps://stackoverflow.com/questions/3570355/c-fvisibility-hidden-fvisibility-inlines-hidden	2018-05-17 20:24:32.957491	f
183	72	Issue	5	申威编译完成，其他两项还在进行中。	2018-05-28 06:33:48.647834	f
181	71	Issue	5	./configure CXXFLAGS="-mieee" CFLAGS="-mieee"  --build=sw_64-unknown-linux-gnu --without-lttng --without-fuse --without-libatomic-ops --without-jemalloc --without-tcmalloc --without-libxfs --with-radosgw --without-cephfs --without-mds --prefix=/root/xierui/release/ \r\n\r\n这样仍然不行\r\n\r\n根因是-O2，部分文件拿出来重新编译即可。	2018-05-18 09:24:53.236042	f
184	73	Issue	5	完成TR2 审查的一些遗留事项。	2018-05-28 08:22:02.441154	f
187	73	Issue	5	使用三个zone测试auto trim。	2018-05-30 07:22:19.13984	f
188	73	Issue	5	well done!	2018-06-04 07:32:08.488409	f
191	74	Issue	5	用吹毛求疵的精神改进日志，列出多少个改进点。	2018-06-05 06:18:34.341863	f
189	74	Issue	5	bucket instance，这个instance和元数据的version是一回事么？\r\n显然不是一回事。\r\nbucket instance实际上bucket meta instance。在当前版本bucket信息分为2部分：\r\n1，bucket entry (记录了bucket name，bucket id等)\r\n2，bucket instance\r\n分离的目的是什么？\r\n\r\n根据bucket id可以找到具体的bucket instance。 bucket id仅在reshard的时候会发生变化。\r\n\r\nuser link 到某个bucket instance，但是这有什么用呢？\r\n\r\nversion tacker是给多客户端并发用的。读上来写下去，如果覆盖其他客户端写下来的就有不一致的问题。\r\n\r\n为啥UserInfo不整这个呢？\r\n\r\n	2018-06-04 09:17:08.176299	f
190	74	Issue	5	YIG并不满足我们要求，不支持usage，multisite等。\r\n\r\nmultisite设计在元数据中占了很重要的部分。另外与多版本等特性牵连。\r\nYIG是一个内部使用的系统，这与我们的目标也不一致。\r\n\r\ns3协议完整性，YIG，Minio等系统均不一定支持。\r\n\r\n\r\n	2018-06-05 06:04:03.444927	f
192	74	Issue	5	先读懂Yig代码，学习下go	2018-06-05 13:38:22.237175	f
193	71	Issue	5	替换kernel，支持xfs	2018-06-08 08:49:18.828863	f
194	75	Issue	5	V5实施计划：\r\n文件级别去重，CDP 一个人\r\n超生命周期的数据迁移+bucket跨pool，placement整改  一个人\r\n租户的Qos控制等周边 一个人\r\n性能  一个人\r\n\r\n可能需组建实施团队。\r\n1+1\r\n6个人团队其实也差不多，2运维+4研发	2018-06-14 07:13:05.259557	f
128	40	Issue	5	实施新的修改方案，slave zone也获取bucket info来执行remove_object。\r\n果然这样delete olh之后的行为在slave也是将null instance改为delete状态了。\r\n\r\n但是最后在delete这个delete_marker时 slave zone无法同步。\r\n最后一步的bilog:\r\n{\r\n        "op_id": "0#00000000018.116410.8",\r\n        "op_tag": "000000005a13bfc7ydir27j2hcqavwvs",\r\n        "op": "unlink_instance",\r\n        "object": "rgw_client_io.cc",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 18,\r\n        "timestamp": "2017-11-21 05:55:19.897362372Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 7\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    }\r\n\r\nslave zone出错信息：\r\n2017-11-21 05:55:20.051206 7f1f693ee700 20 get_obj_state: s->obj_tag was set empty\r\n2017-11-21 05:55:20.051221 7f1f693ee700 20 get_obj_state_impl: setting s->olh_tag to 2exxf5r5b386w6hcf01s64eo8gblmm5r\r\n2017-11-21 05:55:20.051258 7f1f693ee700 20 _send_request(): get_obj_state() obj=test13:rgw_client_io.cc returned ret=-2\r\n2017-11-21 05:55:20.051344 7f1f563ff700 10 multisite data sync should run between 0 - 24 now 5 = yes\r\n2017-11-21 05:55:20.051360 7f1f563ff700 20 cr:s=0x7f1e119518a0:op=0x7f1e18c84800:14RGWRemoveObjCR: operate()\r\n2017-11-21 05:55:20.051371 7f1f563ff700 20 cr:s=0x7f1e119518a0:op=0x7f1e18c84800:14RGWRemoveObjCR: operate() returned r=-2\r\n\r\n\r\n这是一个新问题，slave zone的delete marker无法删除，还有点比较奇葩，在这种情况下master zone可以删除bucket，slave zone不完全是空的，但是也可以删除。\r\n区别在于master zone执行的时候instance是"null"，而slave zone执行的时候就变成empty了\r\n\r\n\r\nint RGWRados::Object::Delete::delete_obj()\r\n{\r\n  RGWRados *store = target->get_store();\r\n  rgw_obj& src_obj = target->get_obj();\r\n  const string& instance = src_obj.key.instance;\r\n  rgw_obj obj = src_obj;\r\n\r\n  if (instance == "null") {\r\n    obj.key.instance.clear();\r\n  }\r\n\r\n罪魁祸首是这个。太乱了\r\n虽然olh和null instance共用一个对象，但是bi里面还是单独的。\r\n像1000_rgw_acl_swift.hi 就是null instance的。	2017-11-21 11:42:05.379941	f
138	40	Issue	5	还是有问题，在关闭多版本情况下，直接先删除null的instance\r\n\r\n出现了循环执行unlink instance的现象，并且对象无法再次上传成功了\r\n\r\n{\r\n        "op_id": "62#00000000388.16589.2",\r\n        "op_tag": "_ROD7trnSGrT27TNONkLLybmRDjejAVq",\r\n        "op": "del",\r\n        "object": "rgw_tag.h",\r\n        "instance": "null",\r\n        "state": "pending",\r\n        "index_ver": 388,\r\n        "timestamp": "0.000000",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 0\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "62#00000000389.16590.3",\r\n        "op_tag": "_ROD7trnSGrT27TNONkLLybmRDjejAVq",\r\n        "op": "del",\r\n        "object": "rgw_tag.h",\r\n        "instance": "null",\r\n        "state": "complete",\r\n        "index_ver": 389,\r\n        "timestamp": "2017-11-22 15:42:02.691040405Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 138991\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "62#00000000390.16592.3",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5925.5134",\r\n        "op": "write",\r\n        "object": "rgw_tag.h",\r\n        "instance": "",\r\n        "state": "pending",\r\n        "index_ver": 390,\r\n        "timestamp": "2017-11-22 15:42:02.691040405Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 138840\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "62#00000000391.16593.4",\r\n        "op_tag": "ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5925.5134",\r\n        "op": "write",\r\n        "object": "rgw_tag.h",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 391,\r\n        "timestamp": "2017-11-22 15:42:40.512816990Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 138993\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "62#00000000392.16594.14",\r\n        "op_tag": "000000005a159af0ffwiq3g51v6ftzmy",\r\n        "op": "link_olh",\r\n        "object": "rgw_tag.h",\r\n        "instance": "",\r\n        "state": "complete",\r\n        "index_ver": 392,\r\n        "timestamp": "2017-11-22 15:42:40.512816990Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 10\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    }\r\n最终bilog如上，但是看不到olh和null instance了。\r\n\r\n只剩如此了：\r\nrgw_tag.h\t\r\nrevision #: 2\t2017/11/22 23:41:17\t"89acfb788b24ef60d7ad87fb3b9784cd"\t1012 bytes\tSTANDARD\tnuser (nuser)\t4LzRLOgL3pQ.l8ofPzfjslnV.llPIDY\t\r\nrevision #: 1\t2017/11/22 23:41:11\t"89acfb788b24ef60d7ad87fb3b9784cd"\t1012 bytes\tSTANDARD\tnuser (nuser)\tThf-sv4MbTx.GgdHhOSa4SQLhgD36oN\t	2017-11-22 21:33:24.758628	f
140	42	Issue	5	某次同步失败的log\r\n2017-11-24 10:04:47.945250 7f733ffff700  0 inc sync bucket:test30:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5964.2:25ERROR: failure in sync, backing out (sync_status=-125)\r\n2017-11-24 10:04:47.948018 7f733ffff700  0 datalog.sync-status.shard.ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.114.retry add retry entry test30:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5964.2:25 ret 0\r\n2017-11-24 10:04:50.733681 7f734c7e1700  0 _send_request(): deleting obj=test30:rgw_usage.h\r\n2017-11-24 10:04:50.736663 7f733ffff700  0 ERROR: failed to sync object: test30:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5964.2:25/rgw_usage.h	2017-11-24 15:49:55.626917	f
131	40	Issue	5	解决方案：\r\n跳过这种情况？如果是del操作，并且instance是null的情况。\r\n这种必须经过unlink instance来同步。\r\n或者说del并且version是true的情况，都给干掉\r\n\r\n还有个疑问：\r\n{\r\n        "op_id": "62#00000000202.10051.5",\r\n        "op_tag": "000000005a1415a0s3qnmhfxyi4s2fxr",\r\n        "op": "unlink_instance",\r\n        "object": "rgw_tag.h",\r\n        "instance": "SBHR6PNOeCeGbI6ySeYBlV9Kk8AaCLt",\r\n        "state": "complete",\r\n        "index_ver": 202,\r\n        "timestamp": "2017-11-21 12:01:36.120037613Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 14\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "62#00000000203.10052.2",\r\n        "op_tag": "_2uOx41g3hOZB52zCOpLG7bfjRds8zTl",\r\n        "op": "del",\r\n        "object": "rgw_tag.h",\r\n        "instance": "SBHR6PNOeCeGbI6ySeYBlV9Kk8AaCLt",\r\n        "state": "pending",\r\n        "index_ver": 203,\r\n        "timestamp": "2017-11-21 11:29:12.417290614Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 132249\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "62#00000000204.10053.3",\r\n        "op_tag": "_2uOx41g3hOZB52zCOpLG7bfjRds8zTl",\r\n        "op": "del",\r\n        "object": "rgw_tag.h",\r\n        "instance": "SBHR6PNOeCeGbI6ySeYBlV9Kk8AaCLt",\r\n        "state": "complete",\r\n        "index_ver": 204,\r\n        "timestamp": "2017-11-21 11:29:12.417290614Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 132252\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    }\r\n像这种bilog，如果分2次执行，逻辑上会不会出问题呢？\r\n不会返回-2，但是同步是成功的\r\n\r\n2017-11-21 12:42:51.749610 7efcd97ff700 10 multisite data sync should run between 0 - 24 now 12 = yes\r\n2017-11-21 12:42:51.749613 7efcd97ff700 20 cr:s=0x7efcd8362b00:op=0x7efb9d690800:26RGWBucketSyncSingleEntryCRISs11rgw_obj_keyE: operate()\r\n2017-11-21 12:42:51.749619 7efcd97ff700  5 Sync:ae41357a:data:Object:test18:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5686.2:62/rgw_tag.h[23DS6dImg5npSoIwbiYyw8aDCCgLoho][0]:done, retcode=-2\r\n2017-11-21 12:42:51.749621 7efcd97ff700  6 sync object retcode= -2: test18:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5686.2:62/rgw_tag.h\r\n2017-11-21 12:42:51.749635 7efcd97ff700 20 store_marker(): updating marker marker_oid=bucket.sync-status.ae41357a-6f20-47bb-a3bd-1f0a166cd8f4:test18:ae41357a-6f20-47bb-a3bd-1f0a166cd8f4.5686.2:62 marker=00000000216.10073.3\r\n	2017-11-21 18:11:52.402218	f
133	40	Issue	5	但是过滤掉delete操作也不是一种很好的办法，因为有些是remove instance的 不是unlink instance	2017-11-21 19:30:28.681453	f
141	42	Issue	1	同样测试用例，有时候删除不成功，有时候同步写入不成功。	2017-11-24 19:49:00.642823	f
177	71	Issue	5	cd ./ceph-detect-init ; ../tools/setup-virtualenv.sh /tmp/ceph-detect-init-virtualenv ; test -d wheelhouse && export NO_INDEX=--no-index ; /tmp/ceph-detect-init-virtualenv/bin/pip install $NO_INDEX --find-links=file://$(pwd)/wheelhouse -e .\r\n../tools/setup-virtualenv.sh:行21: virtualenv: 未找到命令\r\n../tools/setup-virtualenv.sh:行22: /tmp/ceph-detect-init-virtualenv/bin/activate: 没有那个文件或目录\r\n../tools/setup-virtualenv.sh:行25: pip: 未找到命令\r\n../tools/setup-virtualenv.sh:行30: pip: 未找到命令\r\n../tools/setup-virtualenv.sh:行32: pip: 未找到命令\r\n/bin/bash: /tmp/ceph-detect-init-virtualenv/bin/pip: 没有那个文件或目录\r\nMakefile:33198: recipe for target '/tmp/ceph-detect-init-virtualenv' failed\r\n\r\n直接不编译ceph-disk, ceph-detect-init,test等	2018-05-17 09:21:40.247592	f
217	76	Issue	5	其实去重是对象级别的，我们需要有一个地方表示对象实例。要么就仍然使用head_obj表示，然后head_obj上有引用计数。\r\n\r\ntail是一个obj chain，gc的时候是整个移除的。chain上的每个obj都有引用计数。\r\n\r\nmanifest仍然不需要head_bucket和tail bucket，但是需要一个字段记录数据在哪个pool。\r\n1，移到其他pool\r\n2，修改bi\r\n3，减少源对象的引用计数\r\n这是lc迁移的逻辑。\r\n\r\n对象上有引用计数，对象全部都在lc的时候做彻底删除。\r\nlc删除：\r\n1，过期删除\r\n2，把标记删除的删除（有两种情况，一是对象覆盖，二是删除操作）\r\n删除都是调用cls_refcount_put检查是否有引用计数\r\n\r\nobject放在哪个pool，后面不仅取决于bucket，还跟存储策略有关系，不过暂时先不管。\r\nmainfest记录obj在哪个pool。	2018-06-28 12:51:13.349513	f
224	76	Issue	5	static inline void prepend_bucket_marker(rgw_bucket& bucket, const string& orig_oid, string& oid)\r\n{\r\n  //bucket所有对象的前缀\r\n  if (bucket.marker.empty() || orig_oid.empty()) {\r\n    oid = orig_oid;\r\n  } else {\r\n    oid = bucket.marker;\r\n    oid.append("_");\r\n    oid.append(orig_oid);\r\n  }\r\n}\r\n\r\nRGWObjManifest::get_implicit_location\r\nRGWObjManifest::generator::create_begin\r\n\r\n对象名字的来源。\r\n\r\nbucket marker + ns + oid（有时候是instance） + part_id + stripe.\r\n非多版本：\r\nbucket marker + oid    /  bucket marker + shadow + prefix + stipe\r\n多版本：\r\nbucket marker + instance + oid  /  bucket marker + shadow + instance + prefix + stipe\r\n\r\n统一成：\r\n对象\r\nbucket marker + ns + oid + prefix + stripe\r\n\r\nhas_manifest这个标记要好好处理\r\n	2018-07-02 12:16:46.64461	f
219	76	Issue	5	manifest中保留instance和rule即可？理论上是这样的，没有head对象了。\r\n没有head概念 这很重要，就是一个条带化的instance。\r\ncopy，rollback，重用对象的逻辑都于此相关。\r\n\r\nhead_obj概念仍然在，但是与之前不同的是 head_obj是第一个分片。并不会承担更多。	2018-06-30 07:42:00.1106	f
139	40	Issue	5	可见合入社区2个gix 再加上解决上面2问题仍然没有彻底解决问题。\r\n\r\n看来必须彻底理清楚这块才行。\r\n\r\n\r\n{\r\n        "op_id": "62#00000000378.16576.7",\r\n        "op_tag": "000000005a159aedllk2fnhnnvc6bxyx",\r\n        "op": "unlink_instance",\r\n        "object": "rgw_tag.h",\r\n        "instance": "null",\r\n        "state": "complete",\r\n        "index_ver": 378,\r\n        "timestamp": "2017-11-22 15:42:37.654742054Z",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 9\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "62#00000000379.16577.2",\r\n        "op_tag": "_YWJfdrdcIBK4YLw3v2e-cAVJWFj0YT6",\r\n        "op": "del",\r\n        "object": "rgw_tag.h",\r\n        "instance": "null",\r\n        "state": "pending",\r\n        "index_ver": 379,\r\n        "timestamp": "0.000000",\r\n        "ver": {\r\n            "pool": -1,\r\n            "epoch": 0\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n    {\r\n        "op_id": "62#00000000380.16578.3",\r\n        "op_tag": "_YWJfdrdcIBK4YLw3v2e-cAVJWFj0YT6",\r\n        "op": "del",\r\n        "object": "rgw_tag.h",\r\n        "instance": "null",\r\n        "state": "complete",\r\n        "index_ver": 380,\r\n        "timestamp": "2017-11-22 15:42:02.691040405Z",\r\n        "ver": {\r\n            "pool": 11,\r\n            "epoch": 138982\r\n        },\r\n        "bilog_flags": 1,\r\n        "versioned": true,\r\n        "owner": "",\r\n        "owner_display_name": ""\r\n    },\r\n注意unlink instance的时间。\r\n\r\n测试方法：\r\n1，开启多版本，上传对象\r\n2，挂起多版本，再次上传\r\n3，删除对象。\r\n\r\n这里不应该使用unlink instance的时间。unlink instance的bilog时间为当前时间。所以出现了循环删除的现象。\r\n\r\n这个问题的根因是null instance被干掉之后，同步逻辑去获取olh对象，并且以为olh就是null instance。\r\n其实只有在极少情况下 null instance与olh重叠。仅当olh中target指向null instance时，两者才有重叠关系。\r\n\r\n//XRCM,if do not follow olh,and instance is not empty\r\n//we should return -ENOENT\r\n\r\n仍然停不下来，还是不停delete，而且olh对象的olh.info属性确实没了。但是为啥就删不掉这个对象呢？\r\n\r\nnull instance在开启多版本或者suspend多版本的情况下，任何时候都不应该被删除，除非所有版本都被干掉。\r\n\r\n\r\n	2017-11-22 21:35:01.315969	f
129	40	Issue	5	修改后该用例可以通过测试了。\r\n主要有2个问题：\r\n1，slave zone在delete_obj时没有考虑version suspend状态，导致主从执行的delete olh逻辑不一样。该问题对于put请求同样如此，但是put请求使用了bucket info中的version\r\n  RGWPutObjProcessor_Atomic processor(obj_ctx,\r\n                                      dest_bucket_info, dest_obj.bucket, dest_obj.get_orig_obj(),\r\n                                      cct->_conf->rgw_obj_stripe_size, tag, dest_bucket_info.versioning_enabled());\r\n\r\n  只要经过olh的bilog link或unlink都是versioned，但是执行时候光看这个是不够的。\r\n  问题同样在于，如果bucket状态并不一样，严格的执行另外一个bucket的物理日志么？\r\n\r\n2，在删除null instance时，主zone执行的是unlink instance,但是由于bilog中instance被清理掉，变成empty。\r\n以目前的逻辑 rgw_bucket_unlink_instance执行时不可能看到null instance。\r\n从而使得slave zone执行delete_obj时走到set_olh分支，出现不一致。\r\n\r\n为什么写null instance没问题呢？\r\n会不会一个写到null instance，另一个写出一个新版本？\r\n写的时候没有清理写入目标的instance。 当然在多版本挂起的时候按理说不支持写null instance吧，此时null instance就是olh？\r\n\r\n2.1 这段逻辑也有问题\r\nrgw_bucket_dir_entry dirent;\r\n\r\n      //XRWHY: clear "null" instance before this?\r\n      //if do not clear, it will find 1000_xxinull? no this bi entry\r\n      //i think it is wrong here,we should not get the place holder as null instance\r\n      int r = store->bi_get_instance(obj, &dirent);\r\n      if (r < 0) {\r\n        return r;\r\n      }\r\n\r\n3，slave zone执行时，不同instance乱序执行，可能存在问题。\r\n\r\ncheck：\r\n1，slave zone同步多版本时，应该follow olh么？	2017-11-21 16:49:12.176266	f
142	29	Issue	5	修改content_type，增加http header都是走的：\r\n#0  RGWRados::Bucket::UpdateIndex::complete (this=this@entry=0x7f9225b2b520, poolid=poolid@entry=8, epoch=epoch@entry=26, size=size@entry=501, ut=..., \r\n    etag="05b64c65fcc220fe52d5a9bf8fee7172", content_type="text/txt", acl_bl=acl_bl@entry=0x7f9225b2b4d0, category=RGW_OBJ_CATEGORY_MAIN, remove_objs=0x0, op=op@entry=CLS_RGW_OP_ADD)\r\n    at rgw/rgw_rados.cc:9334\r\n#1  0x00007f92eb8bcf05 in RGWRados::Object::Write::write_meta (this=this@entry=0x7f9225b2b910, size=501, attrs=std::map with 10 elements = {...}) at rgw/rgw_rados.cc:6367\r\n#2  0x00007f92eb8bdc30 in RGWPutObjProcessor_Atomic::do_complete (this=0x7f9225b2c110, etag=..., mtime=0x7f9299dc96a0, set_mtime=..., attrs=std::map with 10 elements = {...}, delete_at=..., \r\n    if_match=0x0, if_nomatch=0x0, zones_trace=0x0) at rgw/rgw_rados.cc:2557\r\n#3  0x00007f92eb88452d in RGWPutObjProcessor::complete (this=this@entry=0x7f9225b2c110, etag="05b64c65fcc220fe52d5a9bf8fee7172", mtime=mtime@entry=0x7f9299dc96a0, set_mtime=..., \r\n    set_mtime@entry=..., attrs=std::map with 10 elements = {...}, delete_at=..., delete_at@entry=..., if_match=if_match@entry=0x0, if_nomatch=if_nomatch@entry=0x0, \r\n    zones_trace=zones_trace@entry=0x0) at rgw/rgw_rados.cc:2181\r\n#4  0x00007f92eb8b852b in RGWRados::copy_obj_data (this=this@entry=0x7f92dad4dc00, obj_ctx=..., dest_bucket_info=..., read_op=..., end=<optimized out>, dest_obj=..., src_obj=..., \r\n    max_chunk_size=4194304, mtime=0x7f9299dc96a0, set_mtime=set_mtime@entry=..., attrs=std::map with 10 elements = {...}, category=RGW_OBJ_CATEGORY_MAIN, olh_epoch=0, delete_at=..., \r\n    version_id=0x0, ptag=0x7f9225b2e580, petag=0x7f9299dc9968, err=0x7f9225b2e120) at rgw/rgw_rados.cc:7720\r\n#5  0x00007f92eb8e3f9d in RGWRados::copy_obj (this=0x7f92dad4dc00, obj_ctx=..., user_id=..., client_id=..., op_id=..., info=<optimized out>, source_zone="", dest_obj=..., src_obj=..., \r\n    dest_bucket_info=..., src_bucket_info=..., src_mtime=0x7f9299dc9698, mtime=0x7f9299dc96a0, mod_ptr=0x0, unmod_ptr=0x0, high_precision_time=false, if_match=0x0, if_nomatch=0x0, \r\n    attrs_mod=RGWRados::ATTRSMOD_REPLACE, copy_if_newer=false, attrs=std::map with 10 elements = {...}, category=RGW_OBJ_CATEGORY_MAIN, olh_epoch=0, delete_at=..., version_id=0x0, \r\n    ptag=0x7f9225b2e580, petag=0x7f9299dc9968, err=0x7f9225b2e120, progress_cb=0x7f92eb84abb0 <copy_obj_progress_cb(off_t, void*)>, progress_data=0x7f9299dc9400) at rgw/rgw_rados.cc:7526\r\n#6  0x00007f92eb856127 in RGWCopyObj::execute (this=0x7f9299dc9400) at rgw/rgw_op.cc:3653\r\n#7  0x00007f92eb87b81b in process_request (store=0x7f92dad4dc00, rest=0x7ffcf3d9f130, req=req@entry=0x7f916bc30100, client_io=client_io@entry=0x7f9225b2e6d0, olog=0x0)\r\n    at rgw/rgw_process.cc:174\r\n#8  0x00007f92f5340cd0 in RGWFCGXProcess::handle_request (this=0x7f92dadbae00, r=0x7f916bc30100) at rgw/rgw_fcgi_process.cc:121\r\n#9  0x00007f92f5342970 in RGWProcess::RGWWQ::_process (this=0x7f92dadbb0b8, req=0x7f916bc30100) at rgw/rgw_process.h:84\r\n#10 0x00007f92ebbf04be in ThreadPool::worker (this=0x7f92dadbae70, wt=0x7f92b2441e20) at common/WorkQueue.cc:128\r\n#11 0x00007f92ebbf13a0 in ThreadPool::WorkThread::entry (this=<optimized out>) at common/WorkQueue.h:445\r\n#12 0x00007f92ea9abdc5 in start_thread () from /lib64/libpthread.so.0\r\n#13 0x00007f92e9fb776d in clone () from /lib64/libc.so.6\r\n\r\n\r\n<pre><code class="cpp">\r\n\r\nRGWOp *RGWHandler_REST_Obj_S3::op_put()\r\n{\r\n  if (is_acl_op()) {\r\n    return new RGWPutACLs_ObjStore_S3;\r\n  } else if (is_tagging_op()) {\r\n    return new RGWPutObjTags_ObjStore_S3;\r\n  }\r\n  \r\n  if (s->init_state.src_bucket.empty())\r\n    return new RGWPutObj_ObjStore_S3;\r\n  else\r\n    return new RGWCopyObj_ObjStore_S3;\r\n}\r\n</code></pre>\r\n\r\nRGWPutMetadataObject 是swift用的\r\nRGWSetAttrs rgw_file 使用\r\n\r\nCors，ACL，Tag是S3走set attr的。\r\n	2017-11-25 14:18:57.120847	f
143	35	Issue	5	该问题的实际情况是master zong从slave 同步set attr失败，原因从当时日志看是set attr返回了NOT MODIFY。\r\nset attr应该处理这种情况	2017-11-25 15:20:31.646891	f
144	44	Issue	5	果然是这样：\r\nRGWPutObjProcessor_Atomic processor(obj_ctx,\r\n                                      dest_bucket_info, dest_obj.bucket, dest_obj.get_orig_obj(),\r\n                                      cct->_conf->rgw_obj_stripe_size, tag, dest_bucket_info.versioning_enabled());\r\n看最后一个参数。\r\n\r\nbucket info就是本地的，因而如果version没设置，是有可能出现这种情况的	2017-11-27 14:11:56.033174	f
146	41	Issue	5	这里有个问题，就是在另一个rgw挂掉期间，这些执行的rgw操作其根据的是当时的bucket状态。这样非常容易造成混乱。\r\n\r\nver1.txt\r\nver1.txtv913i-mYef0JLNm9RJjKoLcB446a7HwY5XKX\r\nver1.txtv914i\r\n0_00000000001.193.2\r\n0_00000000002.194.2\r\n0_00000000003.195.2\r\n0_00000000004.196.3\r\n0_00000000005.197.3\r\n0_00000000006.198.3\r\n0_00000000007.199.10\r\n1000_ver1.txti\r\n1000_ver1.txti-mYef0JLNm9RJjKoLcB446a7HwY5XKX\r\n1000_ver1.txti9GDcGQ8GIW2QwRU7D2hIiuqE0dlU9Dq\r\n1001_ver1.txt\r\n\r\n副本节点进入了这种状态：\r\nver1.txt\t\r\nrevision #: 2\t2017/11/28 9:20:47\t"05b64c65fcc220fe52d5a9bf8fee7172"\t501 bytes\tSTANDARD\tnuser (nuser)\tnull\t\r\nrevision #: 1 (current)\t2017/11/28 9:19:54\t"05b64c65fcc220fe52d5a9bf8fee7172"\t501 bytes\tSTANDARD\tnuser (nuser)\t-mYef0JLNm9RJjKoLcB446a7HwY5XKX\t\r\n\r\n还有这种状态：\r\nver2.txt\t\r\nrevision #: 3\t2017/11/28 9:27:05\t"7a6f01477ea0ab4fcedecbeeb2b310e9"\t501 bytes\tSTANDARD\tnuser (nuser)\tnull\t\r\nrevision #: 2 (current)\t2017/11/28 9:26:52\t"7a6f01477ea0ab4fcedecbeeb2b310e9"\t501 bytes\tSTANDARD\tnuser (nuser)\t9g0GBL08NZBpVoElQs9LxsV1cRZKJRw\t\r\nrevision #: 1\t2017/11/28 9:26:46\t"7a6f01477ea0ab4fcedecbeeb2b310e9"\t501 bytes\tSTANDARD\tnuser (nuser)\tklz6xfxkVRu-7CRmRt1Rfslsk6La9-J\t\r\n\r\n这些问题出现还有一个原因就是同步的乱序执行。对于同一个对象的不同instance，乱序执行是不对的。\r\n\r\n这块没必现有种原因可能是olh id tag并非每次都变。	2017-11-28 07:25:33.474512	f
150	41	Issue	5	执行上述过程后，逐个删除对象实例，出现slave zone无法删除的现象：\r\n\r\n2017-11-28 07:24:39.650630 7f98aabe1700 20 bucket_index_link_olh() target_obj=test14:_:6iEB5T2cEw0XFCcf3AS26mFjwQlivT2_ver2.txt returned -2\r\n2017-11-28 07:24:39.650648 7f98aabe1700 20 _send_request(): delete_obj() obj=test14:_:6iEB5T2cEw0XFCcf3AS26mFjwQlivT2_ver2.txt returned ret=-2\r\n2017-11-28 07:24:39.650713 7f989e3ff700 10 multisite data sync should run between 0 - 24 now 7 = yes\r\n2017-11-28 07:24:39.650726 7f989e3ff700 20 cr:s=0x7f9761d8c080:op=0x7f97618cc800:14RGWRemoveObjCR: operate()\r\n2017-11-28 07:24:39.650734 7f989e3ff700 20 cr:s=0x7f9761d8c080:op=0x7f97618cc800:14RGWRemoveObjCR: operate() returned r=-2\r\n2017-11-28 07:24:39.650740 7f989e3ff700 10 multisite data sync should run between 0 - 24 now 7 = yes\r\n2017-11-28 07:24:39.650741 7f989e3ff700 20 cr:s=0x7f9761d8c080:op=0x7f97618cc000:26RGWBucketSyncSingleEntryCRISs11rgw_obj_keyE: operate()\r\n2017-11-28 07:24:39.650745 7f989e3ff700  5 Sync:f943c167:data:Object:test14:f943c167-90d3-41f9-92d0-955fbb27eae4.4425.1:1/ver2.txt[6iEB5T2cEw0XFCcf3AS26mFjwQlivT2][0]:done, retcode=-2\r\n2017-11-28 07:24:39.650747 7f989e3ff700  6 sync object retcode= -2: test14:f943c167-90d3-41f9-92d0-955fbb27eae4.4425.1:1/ver2.txt\r\n	2017-11-28 13:14:50.559904	f
152	41	Issue	5		2017-11-28 14:50:45.659795	f
145	40	Issue	5	问题仍然没有得到解决。\r\n目前已经合入修改：\r\n1，zone trace避免循环同步\r\n2，不同步olh id/tag等\r\n3，olh 和 null共用对象，其时间不跟据olh调整\r\n4，remove使用bucket info，而不是bilog中的versioned\r\n5，delete使用src_obj，包含null instance。\r\n\r\n目前的问题是挂起时在olh上执行delete时，把null instance给删除了（这是正确的，对于挂起的bucket，olh就是null instance）.\r\n但是之后该null上的delete marker无法删除，这个行为就不对了。\r\ns3的行为是删除成功，且current version指向下一个版本。\r\n\r\n原因是带null instance执行 unlink instance，在bi_get_instance时返回-2\r\n我真不知道这种delete marker有何意义？为啥需要删除delete marker才能指向下一个版本呢？这里逻辑是什么？\r\n也许可以这么理解，那个delete marker并非是null instance的，而是上一个版本的，你删除了delete marker，自然就可以显示上一个版本了。\r\n\r\n这里怪异产生的原因是null instance的存在，null instance在version suspend的时候，与olh同消亡。\r\n\r\nrgw_bucket_dir_entry dirent;\r\n\r\n      //XRWHY: clear "null" instance before this?\r\n      //if do not clear, it will find 1000_xxinull? no this bi entry\r\n      //i think it is wrong here,we should not get the place holder as null instance\r\n      int r = store->bi_get_instance(obj, &dirent); //这里的obj不修改为src_obj,就不会有上述问题，但根因是什么？\r\n      if (r < 0) {\r\n        return r;\r\n      }\r\n      result.delete_marker = dirent.is_delete_marker();\r\n      //XRCM: unlink instance is pure op on obj instance,not olh\r\n      r = store->unlink_obj_instance(target->get_ctx(), target->get_bucket_info(), obj, params.olh_epoch);\r\n      if (r < 0) {\r\n        return r;\r\n      }\r\n      result.version_id = instance;\r\n	2017-11-27 21:08:30.692944	f
147	41	Issue	5	2017-11-28 02:54:51.650035 7f56f17f8700 10 gen olh tag, object: test12:ver2.txt tag: k0qj3pa1hhax3ztgbqql9efj6f90fumw\r\n2017-11-28 02:54:51.650092 7f56efff5700 10 gen olh tag, object: test12:ver2.txt tag: 1226b3mi8altmvy75e1epts6o60zaemw\r\n2017-11-28 02:54:51.650666 7f56efff5700 20 olh_init_modification() target_obj=test12:_:7W8-XjnNuotU6y62zWGVefYTcq8eWbi_ver2.txt delete_marker=0 returned -125\r\n果然出现了这种现象，并发执行，都去产生olh tag。	2017-11-28 08:46:58.065915	f
149	41	Issue	5	修改思路1：\r\n如果list能否逆序就比较合适，但是这样也会有很多问题。工作量也不小。\r\n\r\n修改思路2：\r\n根据状态，修改执行逻辑。如果非current，就只拷贝instance。\r\nRGW_BUCKET_DIRENT_FLAG_CURRENT 这个flag的使用。 还有一点，如果你上来直接写最近的，其实olh epoch最大，这个也影响着后面的逻辑。\r\nversioned_epoch 也就是olh epoch。\r\n所以最终执行效果是 ： 最新先执行，先link，后面的执行，但是不link，只写instance。\r\nyield {\r\n            spawn(new RGWBucketSyncSingleEntryCR<rgw_obj_key, rgw_obj_key>(sync_env, bucket_info, bs,\r\n                                                                           entry->key,\r\n                                                                           false, /* versioned, only matters for object removal */\r\n                                                                           entry->versioned_epoch, entry->mtime,\r\n                                                                           entry->owner, op, CLS_RGW_STATE_COMPLETE, entry->key, marker_tracker, zones_trace),\r\n                                                                           entry->is_latest);\r\n          }\r\n如果是latest，则同步执行。其他instance顺序则无所谓。这样还有一个作用就是仅产生一个olh_tag.\r\n但是其他执行是否存在关联顺序还要进一步分析代码	2017-11-28 12:02:06.804553	f
195	76	Issue	5	BI修改，增加需要的类型，先不做纯粹的改造。\r\n增加get操作。把属性丢到bi。\r\n\r\n本周完成读写，list流程修改，可编译通过。\r\n\r\n先调通非多版本的。\r\nput流程还没改完，明天继续修改。\r\n1，put delete list改完联调，基本功能。\r\n2，支持分片上传，copy\r\n3，支持gc\r\n4，支持多版本\r\n5，支持multipart\r\n5，支持生命周期\r\n6，list支持按修改时间查询\r\n7，结合该优化，考虑rados改进，像海航优化的不去get_object_content。\r\n\r\n计划本周完成一个可以跑的版本，即完成验证工作。	2018-06-19 12:17:32.571817	f
208	76	Issue	5	分片上传和多版本基本可以成功。\r\n可见在原有dir上面，套一个object entry的修改方法在端段时间内就能完成原型修改。\r\n但是细节的雕塑需要的时间更多。\r\n\r\n产生delete marker的逻辑中，index_ctx 没有初始化。\r\n	2018-06-23 12:19:23.083731	f
211	77	Issue	5	有一点确实存在问题，ES zone依赖于其他zone的集群，这个关系就有点乱了\r\nzone是在集群之上的。\r\n理论上es的rgw代表的是es集群的同步服务，应该依赖于es集群，而不是其他集群	2018-06-25 08:08:13.394033	f
198	76	Issue	5	多版本的对象算几个？\r\n有几个实例算几个，但是delete marker不算在内。\r\n\r\n\r\n这种级别的改造，没有测试用例真的玩不了。	2018-06-20 18:49:47.55925	f
196	76	Issue	5	do not need olh epoch now! no use. 对于副本而言就是写入一个instance。。\r\n多版本的区别焦点在于instance名字。 “null”就是非多版本，其他就是多版本。\r\n\r\n多版本的顺序关系取决于时间，以及在object entry中的顺序，object entry在新的instance产生时，总是append的。\r\n同步写入的instance根据时间排序。在时间严重不一致时，做出提示。\r\n\r\n配额本没必要实时刷新，在多版本情况下，每个版本。\r\n\r\n直接修改immutable head可以跳过first chunk。	2018-06-20 08:57:17.78574	f
200	76	Issue	5	性能，可靠性，稳定性取决于设计，而功能可以用测试来解决。	2018-06-20 18:56:55.201975	f
202	76	Issue	5	多版本list序问题。\r\n采用反转的方式处理，根据epoch反转处理。\r\n\r\nif (ret == -ENOENT) {\r\n   /* couldn't find the entry, set key value after the current object */\r\n    char buf[2] = { 0x1, 0 };\r\n    string s(buf);\r\n    *index_key  = key.name + s;\r\n    return 0;\r\n  }\r\n这里仍然有问题，如果list的marker被干掉了，原来是这么处理的？ why?	2018-06-21 09:35:14.980197	f
204	76	Issue	5	manifest相关，需改造，直接上来写head对象。	2018-06-21 15:15:48.709595	f
205	76	Issue	5	非多版本对象的put/get/delete/list都没问题了，确实简单不少。\r\n但是有不少旁路分支可能存在一些问题。比如delete带的哪些参数，unmod_since等等	2018-06-22 17:06:07.601437	f
153	41	Issue	5	测试场景：\r\n1，关闭slave rgw\r\n2，不开启多版本上传对象\r\n3，开启多版本上传对象\r\n4，启动slave rgw\r\n\r\n全量同步失败：\r\n2017-11-28 08:55:26.639873 7fe5adff4700 10 get_canon_resource(): dest=/test16/ppp.txt?versionId=null\r\n2017-11-28 08:55:26.639874 7fe5adff4700 10 generated canonical header: GET\r\n\r\n\r\nTue Nov 28 08:55:26 2017\r\n/test16/ppp.txt?versionId=null\r\n2017-11-28 08:55:26.639914 7fe5adff4700 15 generated auth header: AWS 7AF6X6C4ZGNDG6U99MQM:6sU12N2aKcdaAFK4q6Dx6Y8ZKgA=\r\n2017-11-28 08:55:26.639916 7fe5adff4700 20 RGWEnv::set(): AUTHORIZATION: AWS 7AF6X6C4ZGNDG6U99MQM:6sU12N2aKcdaAFK4q6Dx6Y8ZKgA=\r\n2017-11-28 08:55:26.639921 7fe5adff4700 20 sending request to http://172.18.0.130:8080/test16/ppp.txt?rgwx-zonegroup=a7367de0-4297-42da-860c-82eeab41d953&rgwx-prepend-metadata=a7367de0-4297-42da-860c-82eeab41d953&rgwx-sync-manifest&versionId=null\r\n2017-11-28 08:55:26.639927 7fe5adff4700  5 add_request request http://172.18.0.130:8080/test16/ppp.txt?rgwx-zonegroup=a7367de0-4297-42da-860c-82eeab41d953&rgwx-prepend-metadata=a7367de0-4297-42da-860c-82eeab41d953&rgwx-sync-manifest&versionId=null\r\n2017-11-28 08:55:26.639929 7fe5adff4700 20 register_request mgr=0x7fe59e9986a0 req_data->id=0, easy_handle=0x7fe59e9bf000\r\n2017-11-28 08:55:26.639932 7fe5adff4700  5 link_request req_data=0x7fe59e813580 req_data->id=0, easy_handle=0x7fe59e9bf000\r\n2017-11-28 08:55:26.646182 7fe5adff4700 10 receive_http_header\r\n2017-11-28 08:55:26.646199 7fe5adff4700 10 received header:HTTP/1.1 304 Not Modified\r\n\r\n看上去slave zone把olh当作null instance获取对象时间了，然而实际上null instance根本不存在。。\r\nnull instance是否存在只有在bucket index看得出来。\r\n\r\n删除null instance，底下对象会删除么？\r\n会，但是立马又会创建：\r\nrgw_obj_remove\r\n\r\n能否通过id tag来分辨对象是否是null instance？如果没有id tag，就认为不存在null instance。\r\n那是否不存在null instance（bi instance不存在），但是id tag属性还有的情况。\r\nnull instance delete marker的情况，bi instance和 id tag等都存在。但是显示上不可知null instance到底是否存在。\r\nquick.txt\t\r\nrevision #: 3 (deleted)\t2017/11/28 18:13:02\t\t\t\tnuser (nuser)\tnull\t\r\nrevision #: 2\t2017/11/28 18:12:15\t"bcbe3365e6ac95ea2c0343a2395834dd"\t3 bytes\tSTANDARD\tnuser (nuser)\tTf78hNMYtFh5Kmeve3EEvjbkg1AqVRs\t\r\nrevision #: 1\t2017/11/28 18:12:10\t"bcbe3365e6ac95ea2c0343a2395834dd"\t3 bytes\tSTANDARD\tnuser (nuser)\tpYFZ5.FiIbn2JsrB2SGUtcaI6GeXXUk\t\r\n\r\n可以理解成delete marker挂在null instance上，就像olh挂在null instance上一样\r\n\r\nget_obj_state_impl\r\n\r\n//if no ID,also no mtime\r\n  iter = s->attrset.find(RGW_ATTR_ID_TAG);\r\n  if (iter == s->attrset.end()) {\r\n    assert(s->mtime == real_time());\r\n    s->mtime = real_time();\r\n  }\r\n这个改法不好使，\r\n可以这样改：\r\nfetch_remote_obj:\r\n//maybe we get an olh, do not set pmod,otherwise we will get 304 Not Modified\r\n    if (!dest_obj.have_null_instance() || dest_state->has_manifest) {\r\n      if (!real_clock::is_zero(dest_state->mtime)) {\r\n        dest_mtime_weight.init(dest_state);\r\n        pmod = &dest_mtime_weight.mtime;\r\n      }\r\n    }\r\n\r\n但是这样结果仍然不对，null instance同步之后变成了有版本的了。\r\n因为同步的时候bucket已经是versioned了。\r\n为什么不传入null instance呢，看这个单\r\nhttp://tracker.ceph.com/issues/19599\r\n\r\n对象在全量同步时，是使用null instance的，不论是否开启多版本。\r\nso？ how to do？\r\n改为根据bucket状态当前bucket状态来决定是否设置version。\r\n如果没有多版本，就不设置null的情况，否则就设置。\r\n\r\n测试用例：\r\n1，上传null instance \r\n2，开启多版本\r\n3，启动rgw触发同步。\r\n\r\n修改：\r\nSHA-1: 8b4d3e8a798016e58d91676ce1a601e8bfb690cf\r\n\r\n* fix : 1,olh time use empty time,otherwise slave zone may use it as null instance mtime, then will not sync null instance because of olh's mtime is newer.\r\n2, set "null" instance for unlink_instance and skip del op, otherwise we can not delete null instance from un versioned bucket.\r\n3, set null instance for versioned(include suspended) bucket, otherwise fullsync will create new version for null instance.\r\n\r\nSigned-off-by: xierui <xierui@szsandstone.com>\r\n	2017-11-28 15:35:08.980596	f
155	41	Issue	5	全量同步问题汇总：\r\n1，由于并发执行，多个op均产生了olh_tag，导致其中部分操作由于olh tag不匹配而失败\r\n2，全量打乱执行顺序后，最新的对象可能是null instance，根据convert规则，其epoch是1，但实际上其epoch是最大的。\r\n3，根据时间同步，olh不应该有时间，因为olh并不同步。需要同步的是null instance，应该设置其为null instance的时间。\r\n4，slave zone执行del bilog时，如果master zone删除的是null instance，那么副本也应该是如此，否则逻辑就不一致了。\r\n同样在fullsync fetch对象的时候也应该感知是使用null instance，而不是olh\r\n5，全量同步没考虑同步delete marker	2017-12-17 12:18:54.491745	f
157	47	Issue	5	软件系统发生的持久化变更，都应该记录审计日志。\r\n而不是有可能打开，有可能关闭的日志。这样问题都无法定位。\r\n\r\n所有修改 都肉眼可见\r\n\r\n方便定位各种问题。	2017-12-29 22:51:39.44048	f
160	25	Issue	5	最终使用方案是rgw写日志到日志文件中，以一个固定格式。\r\n然后由logstash写入到es中。\r\n\r\n这个方案的好处是避免写日志影响业务，同时可以避免日志缓冲引起故障场景下日志丢失问题。	2018-01-18 07:31:20.164166	f
164	58	Issue	5	make -n看到的，但是ldd看不到\r\nldd看得到，但是执行不到（tcmalloc）\r\n\r\n同样的ceph-mon编译 -ljemalloc， osd也是如此。\r\n但是ceph-mon ldd看到依赖jemalloc，但是osd不依赖。？？？？？？？？？/？	2018-02-26 09:53:06.879664	f
167	62	Issue	5		2018-03-05 13:03:00.942672	f
168	69	Issue	5	比较奇怪的是scrub选取auth的时候，ReplicatePG为啥没对比oi里面的digest与ScrubObject的digest？	2018-04-11 08:31:07.813837	f
171	70	Issue	5	中广核的分发就是cdn（内容分发网络）。\r\n但是有点区别的是其分支站点并非仅仅是cdn的中间源，分支站点可以接受写请求。\r\n\r\n如果用户网站访问数据中心，其知道有哪些数据。但是在获取具体数据时，其直接在本中心获取数据。\r\ncdn会自动从数据中心拉取数据到分支。并且为数据设置缓存策略(简单实现可基于生命周期，写入时设置，读取时重置生命周期)。	2018-05-02 09:43:36.647171	f
170	70	Issue	5	qos，这篇文章值得一看： https://blog.csdn.net/u011364612/article/details/53608278。\r\nR，L，P 从三个维度实现Qos。 基于时间标签的算法，通过对比标签决定谁能执行。公式是重点。\r\n\r\n通过max避免预留或限流过期的问题。过期的就是过期的。\r\n标签调整问题也值得关注。\r\n\r\n用户的要求是不是用nginx的qos就能实现？ 限制ip地址的流量。	2018-05-02 08:57:30.66867	f
154	41	Issue	5	拥有一个delete marker的全量同步。\r\n测试步骤：\r\n1，关闭slave rgw\r\n2，创建bucket，上传对象\r\n3，开启多版本，再上次同一对象2次\r\n4，关闭多版本\r\n5，删除olh\r\n这时就会出现null instance是delete marker的情况。\r\n6，启动slave rgw。\r\n\r\n\r\n结果slave zone这样：\r\nquick.txt\t\r\nrevision #: 3\t2017/11/28 18:16:36\t"bcbe3365e6ac95ea2c0343a2395834dd"\t3 bytes\tSTANDARD\tnuser (nuser)\td6b2jSyFNx5jT3FrC25rf6GwAhIJAfJ\t\r\nrevision #: 2\t2017/11/28 18:16:31\t"bcbe3365e6ac95ea2c0343a2395834dd"\t3 bytes\tSTANDARD\tnuser (nuser)\t0PAbgn.9JkLbFbTYAOjWpYWzyXF5vRK\t\r\nrevision #: 1 (current)\t2017/11/28 18:16:16\t""\t0 bytes\tSTANDARD\t ()\tnull\t\r\n\r\nmaster zone也被更新成这样：\r\nquick.txt\t\r\nrevision #: 3\t2017/11/28 18:16:36\t"bcbe3365e6ac95ea2c0343a2395834dd"\t3 bytes\tSTANDARD\tnuser (nuser)\td6b2jSyFNx5jT3FrC25rf6GwAhIJAfJ\t\r\nrevision #: 2\t2017/11/28 18:16:31\t"bcbe3365e6ac95ea2c0343a2395834dd"\t3 bytes\tSTANDARD\tnuser (nuser)\t0PAbgn.9JkLbFbTYAOjWpYWzyXF5vRK\t\r\nrevision #: 1 (current)\t2017/11/28 18:16:16\t""\t0 bytes\tSTANDARD\t ()\tnull\t\r\n\r\n问题出现原因很明显，全量同步没考虑delete marker。\r\n而且这里还有一个漏洞，就是全量同步不会考虑bilog，slave zone启动全量同步，master zone与此同时也启动了全量同步。\r\n这是该操作可以同步到master zone的原因。	2017-11-28 16:10:36.948335	f
156	4	Issue	5	2017/12/28 10:38:44 [error] 29529#0: *14031976 connect() failed (111: Connection refused) while connecting to upstream, client: 10.10.200.103, server: , request: "GET /test1/?delimiter=%2F&max-keys=1000 HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "192.168.2.147:8030"\r\n2017/12/28 10:38:45 [error] 29529#0: *14031978 connect() failed (111: Connection refused) while connecting to upstream, client: 10.10.200.103, server: , request: "GET /test1/?versions= HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "192.168.2.147:8030"\r\n2017/12/28 10:38:45 [error] 29529#0: *14031980 connect() failed (111: Connection refused) while connecting to upstream, client: 10.10.200.103, server: , request: "GET /test1/?delimiter=%2F&max-keys=1000 HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "192.168.2.147:8030"\r\n2017/12/28 10:53:44 [error] 29527#0: *14040882 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 172.18.0.1, server: , request: "GET /test6/?versions HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "172.18.0.130:8080"\r\n2017/12/28 10:53:51 [error] 29527#0: *14040886 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 10.10.200.103, server: , request: "GET /test7/?delimiter=%2F&max-keys=1000 HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "192.168.2.147:8030"\r\n2017/12/28 10:55:37 [error] 29528#0: *14041436 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 10.10.200.103, server: , request: "GET /test7/?delimiter=%2F&max-keys=1000 HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "192.168.2.147:8030"\r\n2017/12/28 10:57:23 [error] 29528#0: *14041718 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 10.10.200.103, server: , request: "GET /test7/?delimiter=%2F&max-keys=1000 HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "192.168.2.147:8030"\r\n2017/12/28 10:57:40 [error] 29528#0: *14041720 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 172.18.0.1, server: , request: "GET /test7?snapshot HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "172.18.0.130:8080"\r\n2017/12/28 10:59:09 [error] 29528#0: *14042000 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 10.10.200.103, server: , request: "GET /test7/?delimiter=%2F&max-keys=1000 HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "192.168.2.147:8030"\r\n2017/12/28 11:00:25 [error] 29533#0: *14040340 upstream timed out (110: Connection timed out) while reading response header from upstream, client: 10.10.200.103, server: , request: "GET /test6/?delimiter=%2F&max-keys=1000 HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "192.168.2.147:8030"\r\n2017/12/28 11:06:16 [error] 29539#0: *14043304 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 172.18.0.1, server: , request: "GET /test7?snapshot HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "172.18.0.130:8080"\r\n2017/12/28 11:12:25 [error] 29528#0: *14043322 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 10.10.200.103, server: , request: "PUT /test6/assert.h HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "192.168.2.147:8030"\r\n2017/12/28 11:12:25 [error] 29528#0: *14043323 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 10.10.200.103, server: , request: "PUT /test6/atomic.h HTTP/1.1", upstream: "fastcgi://127.0.0.1:8090", host: "192.168.2.147:8030"\r\n	2017-12-28 08:48:23.118022	f
148	41	Issue	5	bucket list是按照对象逆序来排列的，full sync执行的结果全凭运气么？ 为什么这么说？因为并发执行，不按照olh epoch，则link的逻辑就有点乱？ 为什么乱？不是有olh epoch么？ 小的epoch就算link了，后面也会被大的epoch覆盖. *问题核心就是olh tag产生了多个吧*\r\n\r\n还有delete marker做全量同步是否有bug呢？ bug严重，连delete标记都没了。。。。\r\n开玩笑么，这块逻辑完全是缺失的。\r\n\r\n含有delete marker的instance怎么全量同步法？ 先写入instance，然后再设置delete marker？\r\n\r\n还有场景是多个对象的full sync。\r\n还有分片对象的同步，当然当作非分片处理的。	2017-11-28 09:15:50.611699	f
158	48	Issue	5	该问题一个原因是：\r\n\r\nperiod的解析都有问题，在fastcgi模式下的测试不充分。\r\n   该问题是curl使用chunked模式，nginx给fastcgi传递empty的content_length导致的，不使用chunked模式没问题。\r\n\r\n<pre><code class="cpp">\r\nint RGWRESTPostResource::aio_send(bufferlist& outbl)\r\n{\r\n  //do not use chunked\r\n  //rgw will get empty content_length,and seam it as no data.see rgw_rest_read_all_input\r\n  req.set_send_length(outbl.length());\r\n  req.set_outbl(outbl);\r\n  int ret = req.get_resource(conn->get_key(), headers, resource, mgr);\r\n  if (ret < 0) {\r\n    ldout(cct, 5) << __func__ << ": get_resource() resource=" << resource << " returned ret=" << ret << dendl;\r\n    return ret;\r\n  }\r\n\r\n  return 0;\r\n}\r\n</code></pre>\r\n\r\n增加长度部分	2018-01-16 12:19:22.284135	f
159	48	Issue	5	另外同步从一个period过度到下一个period有bug\r\n\r\n对比cursor的结果总是true的，应该对比cursor对应的epoch：\r\n<pre><code class="cpp">\r\ncurrent = sync_env->store->period_history->get_current();\r\n        if (cursor.get_epoch() == current.get_epoch()) {\r\n          next = RGWPeriodHistory::Cursor{};\r\n          if (cursor) {\r\n            ldout(cct, 10) << "RGWMetaSyncCR on current period="\r\n                << cursor.get_period().get_id() << dendl;\r\n          } else {\r\n            ldout(cct, 10) << "RGWMetaSyncCR with no period" << dendl;\r\n          }\r\n        }\r\n</code></pre>\r\n	2018-01-16 12:22:42.723433	f
161	23	Issue	5	已完成合入	2018-01-18 07:31:48.975095	f
162	50	Issue	5	完成，输出<《RGW多版本设计文档解读》一篇。\r\n但是文档输出延后了。	2018-01-19 08:27:37.272463	f
163	51	Issue	5	桶快照文档写的还可以。而且写文档过程能想到存在的缺陷。\r\n\r\n认真干事，必有收获，干好每个细节，每天进步。	2018-01-19 20:53:45.364934	f
165	59	Issue	5	可以，rgw在处理get请求时，数据也是分片发送的。\r\nheader部分和data也是分多次调用。\r\n\r\nRGWGetObj_ObjStore_S3::send_response_data\r\n会被调用多次。\r\n\r\ncurl在接收response也是如此。	2018-02-28 08:18:42.148254	f
166	60	Issue	5	在一个数据中心局部数据异常时，提供工具恢复数据。\r\n\r\n比对，然后恢复	2018-03-02 07:05:39.20448	f
169	4	Issue	5	http://blog.51cto.com/yucanghai/1713803\r\n\r\n总之，这个错误的比例升高可能表明服务器upstream处理过慢，导致用户提前关闭连接。而正常情况下有一个小比例是正常的。\r\n\r\n可能rgw 600个线程都被占满了，还有很多任务等待处理，然后最终都超时！！！	2018-04-25 08:27:09.920056	f
172	70	Issue	5	世上只有一种分布式一致性协议，paxos，其他都是变种	2018-05-02 13:55:33.602071	f
173	70	Issue	5	分析L版本增强特性，是否提前启动L版本的切换。\r\n分析增加DB层的利弊，以及工作量，人力需求。	2018-05-04 09:38:55.884286	f
174	70	Issue	5	本月还有一个任务是解读EC代码。做一次分享。\r\n\r\n另外解读rgw各个特性，为后续的改造奠定基础。\r\n\r\n把培训的专项做起来。	2018-05-07 07:21:32.5725	f
176	71	Issue	5	leveldb编译不过。	2018-05-15 14:57:23.448232	f
175	71	Issue	5	ceph 申威服务器编译\r\n\r\n./configure --without-lttng --without-fuse --without-libatomic-ops --without-jemalloc --without-tcmalloc --without-libxfs --with-radosgw --without-cephfs --prefix=/root/ceph_jewel  CXXFLAGS=-O2\r\n\r\nlibcurl缺乏\r\nlibsnappy 缺乏，默认安装的是静态库	2018-05-14 16:44:08.84056	f
178	71	Issue	5	In file included from test/journal/mock/MockJournaler.cc:4:0:\r\ntest/journal/mock/MockJournaler.h:7:25: fatal error: gmock/gmock.h: No such file or directory\r\n	2018-05-17 10:21:10.548624	f
225	76	Issue	5	multipart在bi上这样存：\r\n\r\nobj\r\n\r\nmultipart + ori obj + uploadid + partid\r\n\r\nuploadid + partid作为instance。\r\n\r\nrgw_obj这个结构体是关键。\r\n\r\n注意一点 manifest中间产生的并非rgw意义上的obj，实际上head_obj才是真正意义上的rgw obj。\r\n\r\nrados使用的hash方式与bi并不一样。\r\nbi用的是orig_obj,而rados用的是obj。manifest决定了rados对象的位置。\r\n\r\n之前在bi中multipart的key跟rados规则类似，用prefix和namespace表示。但是现在不必这样表示。\r\n\r\n\r\n	2018-07-03 07:52:40.101717	f
227	76	Issue	5	计划：\r\n1，解决multipart读写问题\r\n2，解决多版本问题，并砍掉代码。\r\n\r\ndata storage的重构又会引起架构变化，但是相对会好些。\r\n然后就可以考虑合入了。	2018-07-03 17:53:09.491589	f
182	71	Issue	5	2018-05-25 06:57:53.431517 20000034f00  0 filestore(/var/lib/ceph/data/ceph-0) mount: enabling WRITEAHEAD journal mode: checkpoint is not enabled\r\n2018-05-25 06:57:53.432216 20000034f00 -1 journal FileJournal::_open: disabling aio for non-block journal.  Use journal_force_aio to force use of aio anyway\r\n2018-05-25 06:57:53.432228 20000034f00  1 journal _open /var/lib/ceph/data/ceph-0/journal fd 18: 5368709120 bytes, block size 4096 bytes, directio = 1, aio = 0\r\n2018-05-25 06:57:53.432562 20000034f00  1 journal _open /var/lib/ceph/data/ceph-0/journal fd 18: 5368709120 bytes, block size 4096 bytes, directio = 1, aio = 0\r\n2018-05-25 06:57:53.433880 20000034f00  1 filestore(/var/lib/ceph/data/ceph-0) upgrade\r\n2018-05-25 06:57:53.434206 20000034f00 -1 osd.0 0 backend (filestore) is unable to support max object name[space] len\r\n2018-05-25 06:57:53.434222 20000034f00 -1 osd.0 0    osd max object name len = 2048\r\n2018-05-25 06:57:53.434230 20000034f00 -1 osd.0 0    osd max object namespace len = 256\r\n2018-05-25 06:57:53.434236 20000034f00 -1 osd.0 0 (63) File name too long\r\n2018-05-25 06:57:53.434761 20000034f00  1 journal close /var/lib/ceph/data/ceph-0/journal\r\n2018-05-25 06:57:53.436326 20000034f00 -1  ** ERROR: osd init failed: (63) File name too long\r\n\r\n\r\n\r\next4增加配置：\r\nosd_max_object_name_len = 256\r\nosd_max_object_namespace_len = 64	2018-05-25 12:23:54.979684	f
185	73	Issue	5	今天我什么都不干，就干一件事。-- 整理研发要搞哪些流程，大概花多少时间。项目经理要干什么,开发人员要干什么。	2018-05-28 08:23:24.707756	f
186	73	Issue	5	今天三件事：\r\n1，提交backfill\r\n2，申威编译打包\r\n3，测试auto trim	2018-05-29 06:38:42.479632	f
199	76	Issue	5	注意list操作。把多版本塞到一个key之后，如何保证顺序是一个问题。\r\n如果list marker正好落在一个key内，怎么保证下次能正常的list？	2018-06-20 18:54:59.575986	f
197	76	Issue	5	在write_meta的时候根据bucket version信息，决定是否产生instance。\r\nmultipart不必产生instance信息。也就是说使用“null”， instance。\r\n\r\n以后bilog的统计将会更加准确。使用单调递增的编号。\r\n\r\nrgw_obj结构体解析：\r\n(gdb) p head_obj\r\n$1 = {orig_obj = "assert.h", loc = "", object = "_:qnPBPm8212tJwy0F8GVmxrYgrB3HY54_assert.h", instance = "qnPBPm8212tJwy0F8GVmxrYgrB3HY54", \r\n  bucket = {tenant ...	2018-06-20 14:12:03.28255	f
201	76	Issue	5	能否使用locator作为实际instance呢？	2018-06-20 19:14:34.41153	f
203	76	Issue	5	多版本修改属性 产生新版本这种低效率的，可以考虑去重来解决。gc的时候采用check then delete，需要引用计数。\r\n但是计数放在哪里需要好好考虑。	2018-06-21 09:38:28.151627	f
206	76	Issue	5	注意同步操作总是针对某个instance的。	2018-06-22 17:07:57.939822	f
207	76	Issue	5	合并属性中的attr与meta中的信息。去重！	2018-06-23 12:09:47.235563	f
209	76	Issue	5	主要修改数据结构：\r\n#define RGW_BUCKET_DIRENT_FLAG_DELETE        0x10   /* diff from delete marker, the instance is deleted */\r\n\r\ndir entry：\r\nstring list_key;//list by epoch order\r\nmap<string, bufferlist> attrs;\r\n\r\nstruct rgw_bucket_obj_entry {\r\n  string name;\r\n  uint32_t epoch;\r\n  ceph::real_time mtime;  \r\n  vector<struct rgw_bucket_dir_entry> instances;\r\n}	2018-06-23 12:21:26.388285	f
210	77	Issue	5	如果一个人做一个特性，别人花很短时间思考的问题比他还深入。那说明什么？\r\n说明这个人的价值没发挥出来。\r\n\r\n这样的组织状态是不正常的。	2018-06-25 07:29:30.380597	f
212	77	Issue	5	可以把rgw实现砍到最精简的状态。\r\n\r\n然后当前人力可以满足。\r\n\r\n1，mos组研发思维导图，研发流程图。\r\n2，mos特性列表\r\n3，新员工基础测试list	2018-06-26 15:38:37.396449	f
213	76	Issue	5	接口标准变成了cls_obj_complete_add等操作了。\r\n\r\n这并非一次彻底的修改。	2018-06-27 14:18:19.691579	f
214	76	Issue	5	其实根据bilog的mtime基本可以确定是否需要同步对象。如果是非多版本的，可以考虑不同步。这是一个优化。\r\n\r\nrgw_bi_log_entry结构中：\r\nver成员没有作用。ver主要是产生bilog的id，这个可以在bs上顺序产生。使用index_ver即可。\r\n后面如果使用其他pool存放，需另外设计\r\n\r\ntag机制也可以干掉。\r\nolh相关的全部干掉\r\nbi编码的全部干掉\r\n\r\nlocator 改为rados_instance_name.其原含义相关代码全部干掉。\r\nversioned-epoch换成新的object_entry的epoch。\r\n\r\nmanifest这块的优化。这里可以简化，只保留必须的信息manifest结构体持久化还挺占空间的。\r\n\r\n\r\n\r\n\r\n	2018-06-28 08:08:06.206824	f
215	76	Issue	5	tombstone是干啥的？\r\n\r\nOPTION(rgw_obj_tombstone_cache_size, OPT_INT) // how many objects in tombstone cache, which is used in multi-zone sync to keep\r\n                                                    // track of removed objects' mtime\r\n\r\n从代码看确实是这个意图，现在不需要了。对象的mtime在bilog中就有。\r\n举个例子 master zone修改一个对象，slave zone在之后删除这个对象。然后slave同步master修改。但是这是不必要的，这时可判断删除动作对应的mtime 小于修改，从而不执行对应的同步。\r\n不过这玩意记录在内存，好像有缺陷。\r\n\r\n问题在于同步不一定会立即发生，如果rgw异常，或者cache满掉。那么就无法获取到mtime，是否就会执行该同步呢？\r\n\r\n*增加限制，如果dir entry对应的index_ver尚未同步，暂不删除dir entry？*	2018-06-28 08:17:31.04461	f
216	76	Issue	5	对象的tail部分是用gc来移除的，gc会检查是否有引用。\r\ncopy的时候tail是不需要copy的。\r\n\r\n这块在bi修改之后可以做得更彻底，整个obj都是可以共享的。移除全部经过gc或lc。\r\n一个有引用的对象在一些处理上会遇到问题，比如是否转移到其他pool？（在冷热的问题上，这里可以保留两份以提高其可靠性？冷热池与去重是有关联的）\r\n\r\n小文件合并时，这里存在一个问题，新obj上的引用，转移到其他pool的引用计数如何保证一致性？\r\n\r\n仍然不保证一致性，允许计数出错，对象残留。但是在删除bucket时，是不去理会引用计数的。\r\n\r\ngc这块还有obj tag。 注意gc就是专门搞对象尾巴的，没有就用不上gc。\r\n	2018-06-28 12:27:48.753642	f
221	76	Issue	5		2018-07-02 09:07:18.609368	f
222	76	Issue	5	obj-tag 不在需要了，obj tag就是为了实现原子性的。而现在通过多版本避开了rados实例的原子性问题。	2018-07-02 09:14:49.683854	f
218	76	Issue	5	obj with manifest should have tag？ why？\r\n\r\nhead_obj概念仍然需要吗？tail_object仍然要吗？\r\nmanifest最简化。manifest内部的几个类，以及其关系使用完全弄清楚。	2018-06-28 13:24:03.901227	f
229	76	Issue	5	对象的删除不应该使用lc来完成，lc是生命周期，其并不一定针对所有对象。而且所有对象的扫描效率并不好。\r\n\r\n仍然使用gc来实现。	2018-07-04 07:11:42.768864	f
1627	658	Issue	5	我有三者状态：觉者，码农，运动员。\r\n觉者，觉知别人，觉知自己，见真善美智强权财色，但灭心魔。	2021-03-21 08:40:55.07817	f
223	76	Issue	5	RGWObjManifest结构体：\r\n\r\n1，perfix\r\n在multipart时，是uploadid\r\n在atomic时，是instance\r\n\r\n所以RGWObjManifest结构体是\r\n{\r\n  rgw_bucket bucket // 对象所在bucket\r\n  string prefix;// uploadid or obj instance\r\n  uint64_t size;\r\n  map<>  rules;\r\n}\r\n\r\nover,只有这些了。	2018-07-02 09:23:07.451946	f
230	76	Issue	5	多版本下产生一个问题：就是如何实现版本删除。gc扫描整个bucket显然不合适。\r\n可以在complete的时候的返回值中携带需要删除的instance，然后丢到gc中。\r\n一致性在bi上保证。\r\n\r\n新增一个op，在非version的add，以及delete之后，增加一步获取所有delete状态的obj，丢带gc里面处理。\r\nbucket删除的时候可能存在遗漏部分对象是标记删除，但是尚未gc，存在残留。\r\n\r\n我们实际上只需记录哪些对象需要gc。添加一个已经存在的对象需要gc，这是覆盖写。delete一个对象需要gc。\r\nbi需增加一个接口，真正的clear entry。在gc成功之后执行。	2018-07-04 08:46:13.87081	f
226	76	Issue	5	multipart的meta obj比较特殊，其作为multipart upload的状态信息承载。\r\n在multipart上传成功之后会删除，其内容主体在extra pool上。其上主要存放multipart的part信息。\r\n\r\n在删除的时候其不能仅仅做delete标记，需要真正删除。\r\n\r\n为什么不在io路径上删除对象？这样会导致空间无法快速释放。如果是删除，应该立刻执行删除。\r\n先删除head，后删除对象。\r\n\r\n之前的bucket list如何过滤掉 multipart的meta和multipart的可以的呢？\r\n\r\n在list_objects 中有过滤，根据namespace。	2018-07-03 12:00:30.475755	f
231	76	Issue	5	acl和tag是在current版本上进行的，新增修改http header是用put请求，会产生新版本。	2018-07-04 09:51:35.119574	f
228	76	Issue	5	multipart问题在于 分片的key在object entry中如何表示合适？\r\n\r\n作为特殊实例？ 使用multipart flag标记？\r\n这样在current的处理上需要跳过multipart的key。\r\nlist的时候同样需要跳过。\r\n\r\n或者干脆允许key的name不一样？ multipart的对象的key名字来自于prefix。\r\n\r\nno no， multipart的key是作为单独的object entry出现的。key.name不一样	2018-07-03 18:24:22.314782	f
233	76	Issue	5	干掉snapshot特性，干掉check index(index两阶段一致性检查)，干掉olh相关的。\r\n\r\nnull instance同步与其他并无区别。都是读取数据过来同步，只不过其instance是null。	2018-07-05 12:13:54.348769	f
220	78	Issue	5	同步rgw状态无法代表zone状态，应该监控业务rgw状态。 玩积木的时候首先你得发现有哪些积木。设计评审，代码review皆是如此。\r\n\r\n1，基于时间的脆弱性\r\n\r\n2，目前协程框架下定位问题有点麻烦，如果某个cr卡住了，无法直观的看到它卡在哪里？况且cr dump偶尔还有错误\r\n\r\n[root@softbank126251002143 ceph]# bin/ceph --admin-daemon var/run/ceph/ceph-client.radosgw.default_sync.asok cr dump\r\nadmin_socket: 'ascii' codec can't decode byte 0xe6 in position 310125: ordinal not in range(128)\r\nadmin_socket: 'ascii' codec can't decode byte 0xe6 in position 310125: ordinal not in range(128)\r\n\r\n一个cr在等待哪个异步任务？\r\n\r\n3，period对于meta同步的影响，在机制上如何确保没有任何问题？ 测试中已经出现period变更之后，meta的sync info读取不到的情况。\r\n\r\n框架修改为pull方式，便于做状态管理。现在状态是分离的，要查询两个zone之间差多少数据，必须两边都是活的。\r\n\r\n4，数量差异在全量同步时也不准确。\r\n\r\n\r\n状态太他妈难看了，能否像bucket stats一样给出一组值呢。\r\n其实就是他妈一个数组\r\n[source_zone1, {1,2,....,63}]\r\n[source_zone2, {1,2,....,63}]\r\n[source_zone3, {1,2,....,63}]\r\n通过数字反应出来是否同步，以及差距多少对象同步。\r\n\r\n不同步就什么都没有\r\n	2018-07-02 07:19:23.694524	f
235	76	Issue	5	tag 和epoch的修正	2018-07-06 11:43:01.815209	f
239	79	Issue	5	defer gc的意思就是推迟删除对象，注意对象虽然删除，但是并非立即被gc清除，而是要等待一段时间（应该是避免有的客户端仍然在访问的问题）\r\nobj_tag这里其实代表了对象的实例。\r\n\r\n目前有两种实现方式：\r\n1，在write_meta中捞出需要delete的对象，注意不一定是上一个版本，这里存在并发场景。\r\n捞出来之后，根据manifest将其加入到gc中。\r\n\r\n2，send chain仅丢入一个key，由gc自己去bi中捞。这样可能对性能有点影响。\r\n\r\n此外还需要提供接口真正的删除bi entry	2018-07-11 12:19:47.102189	f
241	79	Issue	5	改造 cls_bi_get的接口，支持获取各种instance。\r\n\r\n仍然做一种比较，在instance epoch不一致的时候，让客户端操作retry。或者像以前的处理一样，当作成功。\r\n\r\n	2018-07-11 14:37:03.642995	f
238	79	Issue	5	上午搞专利\r\n3.2.1的回顾\r\n3.1.6 bug合入\r\n\r\nlicense bug合入。\r\n\r\n升级直接用工具是否可行。在同一个集群。 或者仅转换元数据?  其实NFS也可以类似玩法。\r\nmanifest是一种抽象，提供了切割能力的抽象。\r\n\r\n后面可能需要提供工具，支持写入bi的能力。\r\n	2018-07-10 06:52:53.783666	f
242	78	Issue	5	就提供一个查询命令 bucket sync status。bucket stats反应bucket最新修改	2018-07-14 09:01:04.66065	f
243	79	Issue	5	关于上双活同步时间的问题：\r\n\r\n对于非多版本请求，这个比较好说根据epoch可以判断。\r\n比如1边在同步对象A， 在同步的任务中会得到A的版本10，这时如果写入了对象11，则同步操作因为比较epoch失败而被取消。\r\n注意这是一种正常情况。\r\nepoch只能避免同时写的情况。解决gc问题。\r\n\r\n但是如果这时操作是删除对象，那么最终是否该对象仍然存在？ 这个需要根据时间来判断。\r\n\r\n\r\n删除的时候如果携带了时间，则与最新的时间对比，如果有修改，则cancel删除。\r\ndelete marker也是如此。\r\n\r\n但是ADD不一样，老版本也是有必要同步的，且同步之后不作为最新版本。\r\n举个例子两个zone各写入对象的多个版本，然后开始做全量同步，最终结果会是怎样？ 版本顺序对吗？一致吗？	2018-07-14 09:24:48.926058	f
244	79	Issue	5	set attr不涉及object和instance时间修改，也就是说不去影响对象instance的存在性。否则双活可能不同步，一边删除了，另外一边因为修改属性不去同步删除操作。	2018-07-14 09:42:58.56986	f
245	79	Issue	5	rule：\r\n1，同名instance，时间小，则不执行操作。\r\n2，非同名instance，根据时间排序。	2018-07-14 09:46:39.410994	f
246	79	Issue	5	多版本相关仍然有用例失败：\r\n1，开启多版本情况下，产生delete marker，从端不同步。	2018-07-16 13:00:28.189594	f
247	81	Issue	5	今天搞定feature列表，还有pbc。\r\n\r\n另外投入v5基础版本。\r\n\r\n周三开始投入专利交底书。	2018-07-17 07:06:14.847828	f
248	81	Issue	5	V5.1.0版本：\r\n本周完成双活模块的相关验证。\r\n解决多版本与分片上传的问题。	2018-07-17 11:45:15.590852	f
250	82	Issue	5	本周输出需求分析，以及周边规格调研。	2018-07-23 08:00:43.420039	f
249	81	Issue	5	思考如何支持异构集群，bilog是否增加字段？ dir entry是否调整？\r\n主要论证双活同步这块没有问题。 以及对后续升级的影响。	2018-07-17 14:55:34.448552	f
253	82	Issue	5	rgw_obj中的loc可作为标识对象在那个引擎的字段，同时，manifest的prefix可标识路径。\r\nManifest增加字段表明对象存储在哪种引擎中？ 还是在bi中标识更合适呢？ 这里对同步可能略为有点影响。\r\n\r\n问题在于你如何确定一个字段属于哪里？ 对象的acl表明对象的访问权限，对象的manifest表明对象如何存储。BI的作用在于定位对象，以及实现bucket list。\r\n这样理解并没什么问题。\r\n\r\nbucket list中还有一个字段是storage class，如果能运用这个字段可能恰到好处。其实生命周期转移数据也可以理解为转移到其他storage class。\r\n但是这样需要把storage class给管理起来，增加这样的一层。如果有个需求是将到期数据转移到公有云？	2018-07-24 07:03:54.299785	f
254	82	Issue	5	pool与实际底下存储之间必须得有一层抽象，以便实现bucket的data可以放入异构的pool，如果pool不支持异构，这个问题非常简单。只要在obj上调整即可。\r\n但实际上比较难。\r\n\r\nbucket是逻辑概念，pool存储实际数据。 其间的关系主要在于在bucket写入时（bi，data），需要有一个默认的pool。不然无法得知数据写入到哪里。\r\n\r\n这个问题placement可解决。从目前来说我们的主存都是rados，数据总是直接写入rados。但是我们要支持数据写到其他地方，淘汰到其他地方。\r\n\r\n得考虑到一种灵活性，比如将大对象丢到ec pool。	2018-07-24 17:28:06.673123	f
256	82	Issue	5		2018-07-26 11:59:49.612954	f
257	82	Issue	5	可以考虑在rgw_bucket上增加一个字段：NFS_pool(记录NFS挂载路径？)。然后在rgw obj中使用storage class记录其存储类型为NFS。\r\nrgw bucket可以具体对应storage class中一个pool，每种类型的storage class定义一个pool。\r\n如果想bucket对应storage class的多个pool，可以将具体pool信息转移到obj上。就这点区别。\r\n\r\nplacement并非s3的location。s3 location定义bucket在哪个zone。 placement的作为就是确定bucket的storage class下的具体pool。\r\nso，如果后续bucket只定义一个默认存储策略。则存储策略就在placement的位置，一个存储策略里面定义多个类型一样的pool。\r\n\r\nrgw bucket现在的逻辑就是直接对上pool，如果想支持其他异构的pool，可以直接扩展rgw-bucket。\r\n\r\n如果想用生命周期扩展数据 到公有云等，可建立对应的pool。没有特别的类型表示异构，就用变量名。\r\n	2018-07-26 13:05:49.571282	f
261	76	Issue	5	delete marker的处理可能略有问题，lc的时候如果当前版本是delete marker，则不必再产生新的delete marker。\r\n	2018-07-29 20:54:44.263957	f
262	84	Issue	5	专利收尾\r\n邓转正\r\n5.2.0 讨论	2018-08-02 06:30:13.526388	f
266	85	Issue	5	elasticsearch验证。	2018-08-07 17:22:46.619659	f
267	4	Issue	5	再次出现，rgw并没有很多任务处理，截取了相关的报文，nginx尝试与fastcgi接口通信，但似乎链接一直都成功。\r\n(gdb) b rgw/rgw_fcgi_process.cc:102\r\nBreakpoint 2 at 0x7f00695d9d7d: file rgw/rgw_fcgi_process.cc, line 102.\r\n(gdb) c\r\nContinuing.\r\n^C\r\nProgram received signal SIGINT, Interrupt.\r\n0x00007f005ec1870d in read () from /lib64/libpthread.so.0\r\n(gdb) b FCGX_Accept_r\r\nBreakpoint 3 at 0x7f005f02f700\r\n(gdb) c\r\nContinuing\r\n\r\n断点在这里都毫无反应，可见accept都无法接收请求了。	2018-08-07 17:24:22.368658	f
264	88	Issue	5	pg分裂不是特别好计算到底到达多少对象分裂。\r\n有点奇怪的是对象的hash并不具备离散性。\r\n\r\n这个可能并非是完全hash，而是根据对象名字的反转。通常文件名不一样，而后缀一样。\r\n所以pg放对象时是根据hash的末尾开始选择目录的。\r\n\r\n而我们性能测试的时候，文件名前缀一样，没有后缀。所以出现根据hash的尾部选择目录，对象集中在一些目录的现象。\r\n\r\n	2018-08-07 11:41:53.026933	f
270	88	Issue	5	使用预分裂的方式。	2018-08-08 08:10:55.992327	f
274	4	Issue	5	停掉rgw或rgw端口不对，nginx返回值都是502.\r\ngdb rgw卡住，nginx返回值是499.\r\n\r\n当时的情况是nginx发送了请求，但是fastcgi接收包失败。	2018-08-09 14:40:39.595985	f
278	4	Issue	5	syn_recv   net.core.somaxconn 太小。导致请求溢出？\r\n\r\n但是性能测试环境的请求不是更多吗？是因为执行时间的差异吗？\r\n\r\n性能环境上 TIME_WAIT状态的连接高达2万多。	2018-08-13 11:37:38.206255	f
282	91	Issue	5	也就是说在读取数据的size小于预读时，direct和非direct性能是接近的。\r\n\r\nRaid卡是另一个影响因素，低端RAID卡像H710可能不支持直通。\r\n通过Raid命名可查看是否直通，直通模式下Raid信息中不包含对应的磁盘信息。	2018-08-15 09:07:57.868916	f
285	90	Issue	5	分析v5.1.0的问题。	2018-08-16 13:39:22.59014	f
286	39	Issue	5	bucket index规模增加也许也是性能下降的一大原因。 omap规模增大，leveldb性能下降。\r\n\r\n最终的架构也许还是小文件合并，bi放在单独的ssd osd上以提升各方面的性能。\r\n\r\nrados cls提供空间管理能力，每个bucket index上分配1万个rados对象，然后bucket对象映射到rados对象上。	2018-08-16 14:04:45.280371	f
288	91	Issue	5	还有可以调整的是调度算法。如果认定队列中请求太少，可在上端增加压力。\r\nrgw cache对于小块读性能影响非常大。	2018-08-17 11:46:10.246283	f
260	76	Issue	5	mtime，slave use bilog time to check wether new or old. no need try get remote obj.\r\nmtime 表示的是创建时间，bilog中记录的时间即为修改时间，是否同步对比bilog时间和本地state即可。\r\n\r\n前端操作除非无法知道instance，否则都应该传入instance。\r\ndelete_obj有两种情况，一种是多版本下不带版本删除，就是delete marker。\r\n另外一种就是删除实际的instance。非多版本下就是删除null。\r\n\r\n在s3上实际操作，修改tag和acl对象的上次修改时间均不会变。\r\n问题的核心是否会产生新版本，对象需要根据版本有序（我们这是根据时间有序），则规则如下：\r\n如果一个操作在多版本下会产生新的版本，则其会变更修改时间，否则不会。\r\n\r\n保留mtime作为对象创建时间，set_attr 额外使用一个时间，如果时间小于当前attr时间则不执行对应操作。\r\n测试方法：断开同步，分别设置acl，测试最终是否一致。\r\n	2018-07-29 20:01:53.331161	f
263	85	Issue	5	务必将双活等引入到自动化测试中。	2018-08-06 07:18:25.13106	f
265	86	Issue	5	monitor在集群大时单独部署，可减少操作系统压力对monitor的影响。\r\n当内存不够时，所有进程都会收到影响。通信异常等各种问题。\r\n\r\n	2018-08-07 12:15:10.060809	f
268	88	Issue	5		2018-08-08 06:44:28.56406	f
280	39	Issue	5	一种方案是支持bucket开启小文件合并。直接在io路径上做文件合并，每个rgw使用各自的文件。\r\n前期可考虑不支持gc，对象转移或删除的时候更新引用计数，计数为0，则删除文件。\r\n\r\n在rgw bi上产生对应的key。这个key的作用就是gc。否则可以让rgw对象直接对应到rados对象。\r\n	2018-08-13 18:11:54.498838	f
269	89	Issue	5	3，看来海量小文件合并仍然有必要。SSD仍然无法很好的解决海量小文件的问题。这问题主要在分裂上。\r\n能否：1，将pg分裂发散到各个时间段？ 2，提前预分裂？\r\n\r\n\r\n10，NFS的性能也是一个大问题。	2018-08-08 07:43:41.370913	f
271	89	Issue	5	11, apache httpd服务无法正常停止，导致系统内存撑爆	2018-08-09 11:24:50.937236	f
272	4	Issue	5	问题，gdb调试卡太久，对accept调用有影响吗？ 499是accept出问题了么？\r\n网络在什么情况下出现状态问题呢？\r\n\r\ntcp的应答是自动发出的吗？卡住程序对这个有影响吗？\r\n\r\ngdb卡住时间长的假设是错误的，实际在卡住程序很久之后。仍然可以恢复。那究竟是什么影响了呢？	2018-08-09 12:39:19.034553	f
273	4	Issue	5	the RTT is negative?\r\nRetransmision  PSH,ACK	2018-08-09 13:28:22.852145	f
275	88	Issue	5	采用预分裂方式，目前看性能是相对平稳的。\r\n但是\r\n1，目录深度应该可以优化\r\n2，对象名长度应该想办法缩短。	2018-08-10 07:02:56.766239	f
276	78	Issue	5	还有一个非常大的缺陷是：\r\n全量同步并没有跳过哪些对象就是自己写入的对象。对象应该有首选归属地。\r\n全量同步的bilog中同样应该记录归属地，试想B从C全量同步，同步到A zone的对象m，如果bilog中不记录。A与B增量同步，仍然会同步对象m。\r\n\r\n多活的情况实际更加复杂，非数据所属zone仍然存在重复执行的情况，所以这一问题在多活中普遍存在。	2018-08-10 12:26:43.20677	f
277	4	Issue	5	[root@localhost engine]# netstat -anp | grep 1230\r\ntcp      129      0 0.0.0.0:1230            0.0.0.0:*               LISTEN      25822/radosgw       \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48164         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48165         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48133         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48413         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49091         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49006         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48030         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49015         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48840         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48086         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49034         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48332         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49052         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48654         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48954         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:47988         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48577         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48852         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48777         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48264         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48073         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48950         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48547         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48256         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48019         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48821         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48163         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49109         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48412         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49123         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48822         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48867         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48897         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48942         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48904         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48937         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48885         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48609         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48354         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48761         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48246         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48035         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48414         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48949         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48446         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48029         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49422         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49320         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48220         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48919         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48930         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48221         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48350         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48024         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:47908         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48094         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48093         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:47907         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:47811         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48036         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48477         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49116         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48570         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:47768         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48537         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48406         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48625         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48111         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48351         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48129         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48321         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49063         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49051         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48395         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48010         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48846         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48653         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49111         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48509         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48067         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48920         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49168         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:49094         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:48324         SYN_RECV    -                   \r\ntcp        0      1 127.0.0.1:49072         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0    905 127.0.0.1:48010         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5073 127.0.0.1:48220         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49229         127.0.0.1:1230          SYN_SENT    15835/nginx: worker \r\ntcp        0      1 127.0.0.1:49070         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   5049 127.0.0.1:47815         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5065 127.0.0.1:47228         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   1256 127.0.0.1:48351         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48858         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0   5065 127.0.0.1:47983         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48864         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0   5065 127.0.0.1:47202         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49081         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49087         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49100         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   1257 127.0.0.1:47768         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0    912 127.0.0.1:48035         127.0.0.1:1230          ESTABLISHED 15829/nginx: worker \r\ntcp        0      1 127.0.0.1:49074         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   5049 127.0.0.1:48609         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48553         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0   1257 127.0.0.1:47077         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49065         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   5064 127.0.0.1:48897         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0   1256 127.0.0.1:48133         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0   5049 127.0.0.1:48413         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0    904 127.0.0.1:49422         127.0.0.1:1230          ESTABLISHED 15835/nginx: worker \r\ntcp        0      1 127.0.0.1:48857         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0      1 127.0.0.1:48150         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49067         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0    904 127.0.0.1:48093         127.0.0.1:1230          ESTABLISHED 15829/nginx: worker \r\ntcp        0   5401 127.0.0.1:47183         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49106         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0    904 127.0.0.1:48653         127.0.0.1:1230          ESTABLISHED 15858/nginx: worker \r\ntcp        0      1 127.0.0.1:48556         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0    872 127.0.0.1:48332         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0   5065 127.0.0.1:47122         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   1257 127.0.0.1:47624         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48939         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0    905 127.0.0.1:47085         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48449         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   1257 127.0.0.1:47811         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48941         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   5048 127.0.0.1:49091         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0   1256 127.0.0.1:48030         127.0.0.1:1230          ESTABLISHED 15829/nginx: worker \r\ntcp        0      1 127.0.0.1:48209         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48878         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48543         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49080         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49090         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48559         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0   1256 127.0.0.1:48406         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0   5064 127.0.0.1:48867         127.0.0.1:1230          ESTABLISHED 15858/nginx: worker \r\ntcp        0    904 127.0.0.1:48777         127.0.0.1:1230          ESTABLISHED 15858/nginx: worker \r\ntcp        0      1 127.0.0.1:48234         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49092         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48039         127.0.0.1:1230          SYN_SENT    15829/nginx: worker \r\ntcp        0    912 127.0.0.1:48577         127.0.0.1:1230          ESTABLISHED 15858/nginx: worker \r\ntcp        0   1256 127.0.0.1:48073         127.0.0.1:1230          ESTABLISHED 15829/nginx: worker \r\ntcp        0      1 127.0.0.1:48893         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   5065 127.0.0.1:47194         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5048 127.0.0.1:49111         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48153         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48544         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   5065 127.0.0.1:47799         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5064 127.0.0.1:48885         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48561         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0      1 127.0.0.1:48166         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0    904 127.0.0.1:48024         127.0.0.1:1230          ESTABLISHED 15829/nginx: worker \r\ntcp     5065      0 127.0.0.1:1230          127.0.0.1:54940         CLOSE_WAIT  -                   \r\ntcp        0   5065 127.0.0.1:47968         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49054         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48889         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   5064 127.0.0.1:48937         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49096         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49064         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0    904 127.0.0.1:48654         127.0.0.1:1230          ESTABLISHED 15858/nginx: worker \r\ntcp        0      1 127.0.0.1:48926         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   5065 127.0.0.1:47798         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   1256 127.0.0.1:48246         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0    904 127.0.0.1:48221         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0   1256 127.0.0.1:48822         127.0.0.1:1230          ESTABLISHED 15858/nginx: worker \r\ntcp        0      1 127.0.0.1:48447         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48034         127.0.0.1:1230          SYN_SENT    15829/nginx: worker \r\ntcp        0   5065 127.0.0.1:47943         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5065 127.0.0.1:48163         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48648         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0   5064 127.0.0.1:49052         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0   5048 127.0.0.1:48919         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48546         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   5041 127.0.0.1:48625         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49105         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   5049 127.0.0.1:48264         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49093         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48856         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0    912 127.0.0.1:48846         127.0.0.1:1230          ESTABLISHED 15858/nginx: worker \r\ntcp        0   5064 127.0.0.1:48949         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48552         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0      1 127.0.0.1:49088         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48879         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   5064 127.0.0.1:49051         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49132         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0    904 127.0.0.1:48821         127.0.0.1:1230          ESTABLISHED 15858/nginx: worker \r\ntcp        0   5064 127.0.0.1:48942         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0   5065 127.0.0.1:48129         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5064 127.0.0.1:48920         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48938         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49084         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   5049 127.0.0.1:47907         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49154         127.0.0.1:1230          SYN_SENT    15835/nginx: worker \r\ntcp        0   6024 127.0.0.1:48321         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0    912 127.0.0.1:48354         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48224         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49169         127.0.0.1:1230          SYN_SENT    15835/nginx: worker \r\ntcp        0      1 127.0.0.1:48887         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49152         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49095         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48031         127.0.0.1:1230          SYN_SENT    15829/nginx: worker \r\ntcp        0      1 127.0.0.1:49108         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   5065 127.0.0.1:47823         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49181         127.0.0.1:1230          SYN_SENT    15835/nginx: worker \r\ntcp        0   5065 127.0.0.1:47193         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp     5065      0 127.0.0.1:1230          127.0.0.1:54947         CLOSE_WAIT  -                   \r\ntcp        0      1 127.0.0.1:48557         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0   5049 127.0.0.1:48412         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49076         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48943         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48033         127.0.0.1:1230          SYN_SENT    15829/nginx: worker \r\ntcp        0    905 127.0.0.1:47260         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0    905 127.0.0.1:47179         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0    904 127.0.0.1:49006         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49103         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48874         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49104         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48558         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0   1248 127.0.0.1:48094         127.0.0.1:1230          ESTABLISHED 15829/nginx: worker \r\ntcp        0      1 127.0.0.1:49071         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   5065 127.0.0.1:47227         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0    904 127.0.0.1:48547         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48853         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp     5065      0 127.0.0.1:1230          127.0.0.1:54934         CLOSE_WAIT  -                   \r\ntcp        0   5049 127.0.0.1:47809         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5041 127.0.0.1:48414         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49055         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0    904 127.0.0.1:48761         127.0.0.1:1230          ESTABLISHED 15858/nginx: worker \r\ntcp        0      1 127.0.0.1:49117         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   5065 127.0.0.1:47988         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48235         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48172         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49079         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49082         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp      905      0 127.0.0.1:1230          127.0.0.1:55001         CLOSE_WAIT  -                   \r\ntcp        0      1 127.0.0.1:49086         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49110         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   5049 127.0.0.1:47833         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48886         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49069         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   1257 127.0.0.1:47392         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48173         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48038         127.0.0.1:1230          SYN_SENT    15829/nginx: worker \r\ntcp        0      1 127.0.0.1:49470         127.0.0.1:1230          SYN_SENT    15835/nginx: worker \r\ntcp        0   5049 127.0.0.1:48537         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48944         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48890         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   1249 127.0.0.1:47622         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5065 127.0.0.1:47819         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48859         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0   5064 127.0.0.1:49116         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0   1256 127.0.0.1:49320         127.0.0.1:1230          ESTABLISHED 15835/nginx: worker \r\ntcp        0      1 127.0.0.1:48223         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48032         127.0.0.1:1230          SYN_SENT    15829/nginx: worker \r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:55524         ESTABLISHED 25822/radosgw       \r\ntcp        0      1 127.0.0.1:48185         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49066         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48877         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49085         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48212         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49101         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   5065 127.0.0.1:48111         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   4993 127.0.0.1:47175         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0    912 127.0.0.1:48350         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0   5049 127.0.0.1:48570         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49077         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49173         127.0.0.1:1230          SYN_SENT    15835/nginx: worker \r\ntcp        0      1 127.0.0.1:48860         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0   5048 127.0.0.1:49109         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49068         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49133         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49009         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0    905 127.0.0.1:47671         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48591         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0   5065 127.0.0.1:47740         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5057 127.0.0.1:47942         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49136         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   5049 127.0.0.1:48477         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0    904 127.0.0.1:48840         127.0.0.1:1230          ESTABLISHED 15858/nginx: worker \r\ntcp        0      1 127.0.0.1:48863         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0      1 127.0.0.1:49089         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   5065 127.0.0.1:47253         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5065 127.0.0.1:47741         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48873         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48562         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0      1 127.0.0.1:48854         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0   1257 127.0.0.1:47391         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5065 127.0.0.1:47350         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48233         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   5065 127.0.0.1:47831         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   1256 127.0.0.1:48446         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0    913 127.0.0.1:47675         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48861         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0      1 127.0.0.1:49078         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   1257 127.0.0.1:47623         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5064 127.0.0.1:48950         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0    905 127.0.0.1:48019         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5065 127.0.0.1:47201         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48542         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0    904 127.0.0.1:49015         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49261         127.0.0.1:1230          SYN_SENT    15835/nginx: worker \r\ntcp        0      1 127.0.0.1:48040         127.0.0.1:1230          SYN_SENT    15829/nginx: worker \r\ntcp        0      1 127.0.0.1:48940         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49341         127.0.0.1:1230          SYN_SENT    15835/nginx: worker \r\ntcp        0      1 127.0.0.1:49075         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:49429         127.0.0.1:1230          SYN_SENT    15835/nginx: worker \r\ntcp        0    905 127.0.0.1:47731         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5064 127.0.0.1:49063         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48869         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0      1 127.0.0.1:49097         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   5048 127.0.0.1:49094         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0   5065 127.0.0.1:47977         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   1257 127.0.0.1:47835         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5057 127.0.0.1:47251         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48186         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48169         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49083         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0    904 127.0.0.1:48852         127.0.0.1:1230          ESTABLISHED 15858/nginx: worker \r\ntcp        0   5049 127.0.0.1:48256         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48560         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0    904 127.0.0.1:48029         127.0.0.1:1230          ESTABLISHED 15829/nginx: worker \r\ntcp        0   5049 127.0.0.1:48509         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0    904 127.0.0.1:48165         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp     5049      0 127.0.0.1:1230          127.0.0.1:54941         CLOSE_WAIT  -                   \r\ntcp        0      1 127.0.0.1:49073         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48855         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0    904 127.0.0.1:49034         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48037         127.0.0.1:1230          SYN_SENT    15829/nginx: worker \r\ntcp        0   1248 127.0.0.1:48904         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0   5065 127.0.0.1:48164         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   1256 127.0.0.1:48067         127.0.0.1:1230          ESTABLISHED 15829/nginx: worker \r\ntcp        0      1 127.0.0.1:48217         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48168         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49256         127.0.0.1:1230          SYN_SENT    15835/nginx: worker \r\ntcp        0      1 127.0.0.1:49118         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48862         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0   5064 127.0.0.1:49123         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48396         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   1256 127.0.0.1:48086         127.0.0.1:1230          ESTABLISHED 15829/nginx: worker \r\ntcp        0      1 127.0.0.1:49151         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0    904 127.0.0.1:48036         127.0.0.1:1230          ESTABLISHED 15829/nginx: worker \r\ntcp        0      1 127.0.0.1:49102         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49099         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0    912 127.0.0.1:48930         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0    913 127.0.0.1:47677         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49056         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0    905 127.0.0.1:47688         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp     5065      0 127.0.0.1:1230          127.0.0.1:54939         CLOSE_WAIT  -                   \r\ntcp        0   1257 127.0.0.1:47330         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5049 127.0.0.1:47908         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49153         127.0.0.1:1230          SYN_SENT    15835/nginx: worker \r\ntcp        0      1 127.0.0.1:49057         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48210         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   6024 127.0.0.1:48324         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49035         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0   1256 127.0.0.1:49168         127.0.0.1:1230          ESTABLISHED 15835/nginx: worker \r\ntcp        0      1 127.0.0.1:49058         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0    905 127.0.0.1:47676         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0    905 127.0.0.1:47674         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:49107         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:48948         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp     5049      0 127.0.0.1:1230          127.0.0.1:54904         CLOSE_WAIT  -                   \r\ntcp        0    904 127.0.0.1:48395         127.0.0.1:1230          ESTABLISHED 15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49053         127.0.0.1:1230          SYN_SENT    15857/nginx: worker \r\ntcp        0      1 127.0.0.1:48143         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0      1 127.0.0.1:49098         127.0.0.1:1230          SYN_SENT    15839/nginx: worker \r\ntcp        0   1257 127.0.0.1:47874         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0   5072 127.0.0.1:48954         127.0.0.1:1230          ESTABLISHED 15857/nginx: worker \r\ntcp        0   5065 127.0.0.1:47744         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48868         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0      1 127.0.0.1:48770         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0   5065 127.0.0.1:47739         127.0.0.1:1230          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:48866         127.0.0.1:1230          SYN_SENT    15858/nginx: worker \r\ntcp        0    905 127.0.0.1:47670         127.0.0.1:1230          FIN_WAIT1   - 	2018-08-13 06:53:15.970429	f
283	91	Issue	5	7200卷磁盘，在osd上随机读写1MB，带宽只有30M左右。avgrq-sz只能到256，到不了512. why？\r\n	2018-08-15 13:20:24.810908	f
279	4	Issue	5	[root@localhost ceph]# netstat -anp | grep 1230 | grep "59825"\r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:59825         SYN_RECV    -                   \r\ntcp        0   1256 127.0.0.1:59825         127.0.0.1:1230          ESTABLISHED 15833/nginx: worker \r\n[root@localhost ceph]# netstat -anp | grep 1230 | grep "59825"\r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:59825         SYN_RECV    -                   \r\ntcp        0   1256 127.0.0.1:59825         127.0.0.1:1230          ESTABLISHED 15833/nginx: worker \r\n[root@localhost ceph]# netstat -anp | grep 1230 | grep "59825"\r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:59825         SYN_RECV    -                   \r\ntcp        0   1257 127.0.0.1:59825         127.0.0.1:1230          FIN_WAIT1   -                   \r\n[root@localhost ceph]# netstat -anp | grep 1230 | grep "59825"\r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:59825         SYN_RECV    -                   \r\ntcp        0   1257 127.0.0.1:59825         127.0.0.1:1230          FIN_WAIT1   -                   \r\n[root@localhost ceph]# netstat -anp | grep 1230 | grep "59825"\r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:59825         SYN_RECV    -                   \r\ntcp        0   1257 127.0.0.1:59825         127.0.0.1:1230          FIN_WAIT1   -                   \r\n[root@localhost ceph]# netstat -anp | grep 1230 | grep "59825"\r\ntcp        0      0 127.0.0.1:1230          127.0.0.1:59825         SYN_RECV    -                   \r\ntcp        0   1257 127.0.0.1:59825         127.0.0.1:1230          FIN_WAIT1   -                   \r\n[root@localhost ceph]# netstat -anp | grep 1230 | grep "59825"\r\ntcp        0   1257 127.0.0.1:59825         127.0.0.1:1230          FIN_WAIT1   -                   \r\n[root@localhost ceph]# netstat -anp | grep 1230 | grep "59825"\r\ntcp        0   1257 127.0.0.1:59825         127.0.0.1:1230          FIN_WAIT1   -                   \r\n[root@localhost ceph]# netstat -anp | grep 1230 | grep "59825"\r\ntcp        0   1257 127.0.0.1:59825         127.0.0.1:1230          FIN_WAIT1   - \r\n\r\n从其状态也可见是服务端出了问题。服务端无法进入ESTABLISHED状态。\r\n\r\nhttps://www.cnblogs.com/leezhxing/p/5329786.html\r\n但是为什么RECV_Q一直是129呢？\r\n\r\n<pre>\r\n[root@localhost ceph]# ss -lnt\r\nState       Recv-Q Send-Q                      Local Address:Port                                     Peer Address:Port              \r\nLISTEN      0      100                                     *:6665                                                *:*                  \r\nLISTEN      0      50                                      *:6601                                                *:*                  \r\nLISTEN      0      5                               127.0.0.1:6666                                                *:*                  \r\nLISTEN      0      50                                      *:6602                                                *:*                  \r\nLISTEN      0      50                                      *:6603                                                *:*                  \r\nLISTEN      129    128                                     *:1230                                                *:*   \r\n</pre>	2018-08-13 11:42:05.228825	f
281	39	Issue	5	使用小文件合并，可以解决filestore分裂问题，xfs文件系统元数据过多问题。\r\n同时还能实现顺序写优化，降低bcache引入而引起的风险(还有一个ssd坏了大量osd异常的问题)\r\n\r\nbcache可以感知元数据，但是无法感知目录，文件数量增多之后，仍然可能有目录被淘汰。	2018-08-14 06:53:00.25958	f
308	95	Issue	5	1,解决es sync不到的问题\r\n2，解决分片上传meta对象仍然存在的问题\r\n3，bucket和user一致性问题，bucket，bucket instance，user。 出现非常莫名的bucket不存在了，但是instance在，且还link在user上，况且是没有执行删除bucket的情况下。\r\n没有删除bucket，估计是同步出现一致性问题。 删除bucket那就是删除操作本身也出现一致性问题。\r\n问题都是bucket信息没了，并非bucket instance key对应的bucket info信息没了。	2018-09-01 05:53:53.196374	f
309	95	Issue	5	4，gc list问题是因为加入gc使用instance不具备唯一性。应该使用manifest中的prefix。\r\n另外对象删除如果依赖gc，也没必要必须等多久删除，当然这样有奇效（就是防止误删除）\r\n\r\n多数据中心数据缓存也可以利用该机制来处理，对于那些不在本地存数据的bucket，或者数据不在本地的对象，使用gc来管理其淘汰策略。	2018-09-02 10:55:48.999112	f
310	95	Issue	5	奇怪的是配置了nginx支持长连接之后，rgw波动就好了很多。性能也变得稳定了，看来nginx这里可能是波动的瓶颈\r\n\r\nkeepalive_timeout  180;\r\nkeepalive_requests 8192;	2018-09-04 15:32:30.925198	f
311	96	Issue	5	继续改进rgw日志，v5.2.0 增加同步带宽的监视。\r\n强调时间，效率	2018-09-05 07:00:16.635654	f
313	96	Issue	5	如何进行大对象空间管理。\r\nfreelist。 \r\n\r\n可提供bucket的强力删除手段，把index和rados对象都给删除掉。\r\n\r\n这个特性与到期数据转移可能存在一些冲突。小文件还转移吗？代价有点高。\r\n\r\nbucket针对每个pool都有hash空间也是可以的。BI上记录对象被映射到哪个rados object。\r\n\r\n顺序存放的问题在于写入冲突非常剧烈，对性能影响比较大。\r\nhash的问题在于难以控制每个桶的对象，且扩展不方便。	2018-09-06 07:45:27.597197	f
314	96	Issue	5	帮忙修复5.2.0的问题等。\r\n\r\n修改性能统计的时间精度	2018-09-07 14:46:42.909837	f
315	97	Issue	5	完成5.1.0的发布。\r\n1，遗留问题处理。\r\n2，兼容性问题处理。单个zone升级兼容，以及多个zone的升级兼容。\r\nrados的兼容。 rgw升级验证。\r\n\r\nNAS pool写入，全量同步的时候传入storage class，增量的时候可利用特殊的op来标记bilog	2018-09-10 07:06:41.997057	f
316	97	Issue	5	综合优化：\r\n1，osd进程挂掉之后，在数据量大时，需要很长时间才up\r\n2，恢复优先对peering速度有影响\r\n3，恢复qos控制不精准。	2018-09-11 09:33:05.816317	f
317	97	Issue	5	1,完成摘要式的ceph与s3标准接口对比\r\n2，梳理产品规格，完善产品手册。\r\n3，修复qos的bug。	2018-09-12 07:09:26.945881	f
284	91	Issue	5	https://www.kernel.org/doc/Documentation/block/queue-sysfs.txt\r\nqueue参数\r\n\r\nhttps://blog.csdn.net/wangww631/article/details/78798637\r\n\r\nmax_segments (RO)\r\n-----------------\r\nMaximum number of segments of the device.\r\n\r\nmax_segment_size (RO)\r\n---------------------\r\nMaximum segment size of the device.\r\n\r\n这两参数主要是影响io下发情况，一个segment即一个内存片段。iov方式写入时，最大请求大小就是\r\nmax_segments*max_segment_size， 显然通常可能达不到。\r\n\r\n\r\nmax_hw_sectors_kb (RO)\r\n----------------------\r\nThis is the maximum number of kilobytes supported in a single data transfer.这个是硬限制，通常是256kb\r\n\r\nmax_integrity_segments (RO)\r\n---------------------------\r\nWhen read, this file shows the max limit of integrity segments as\r\nset by block layer which a hardware controller can handle.\r\n\r\nmax_sectors_kb (RW)\r\n-------------------\r\nThis is the maximum number of kilobytes that the block layer will allow\r\nfor a filesystem request. Must be smaller than or equal to the maximum\r\nsize allowed by the hardware.\r\n\r\nnr_requests (RW)\r\n----------------\r\nThis controls how many requests may be allocated in the block layer for\r\nread or write requests. Note that the total allocated number may be twice\r\nthis amount, since it applies only to reads or writes (not the accumulated\r\nsum).\r\n\r\nTo avoid priority inversion through request starvation, a request\r\nqueue maintains a separate request pool per each cgroup when\r\nCONFIG_BLK_CGROUP is enabled, and this parameter applies to each such\r\nper-block-cgroup request pool.  IOW, if there are N block cgroups,\r\neach request queue may have up to N request pools, each independently\r\nregulated by nr_requests.\r\n\r\n小请求时，这个参数非常重要，队列深度不够则合并减少，整体性能也会下降。 可对比avgqu-sz来分析\r\n	2018-08-15 14:11:28.084483	f
287	39	Issue	5	用SSD缓存inode并没解决inode过多的问题。	2018-08-16 15:00:38.587427	f
290	90	Issue	5	协助支持烽火性能测试\r\n协助分析海量小文件性能问题，修改目录层次，并调整对象的hash放置。目前性能仍然在测试阶段，达到3亿之后的稳定性有明显提升。\r\n提供Admin API接口支持查询bucket是否同步。	2018-08-17 16:11:13.528667	f
291	92	Issue	5	scrub的问题还没那么好改，其实这不仅是scrub的问题。凡是list可能都有问题。\r\n不过还好rgw不会调用rados的list功能。\r\n\r\nhash与reverse nibble的关系是反转的。\r\n这里的主要问题在于list是按字符序的，但是index认为自己是反序的。\r\n这里index的顺序和nibble一致，	2018-08-20 18:47:26.738492	f
292	92	Issue	5	考虑整个多数据中心方案。应用如何感知数据位置？	2018-08-22 06:58:16.094814	f
293	92	Issue	5	解决双活在bucket全量同步阶段的问题 cd#246	2018-08-22 07:01:12.112784	f
294	92	Issue	5	FileStore的hash index遍历算法：\r\n	2018-08-22 10:25:54.371639	f
295	92	Issue	5	scrub能扫描到所有对象有一个前提：\r\nhash_prefixes的排序与cmp_bitwise的排序一致。\r\n但是hash_prefixes是用的hash反序，与bitwise用bit反序顺序必然不一定一致。	2018-08-22 13:58:27.953328	f
296	92	Issue	5	解决问题#240，#218	2018-08-24 07:35:04.340089	f
297	95	Issue	5	解决分片上传统计的bug	2018-08-27 09:04:06.686401	f
298	95	Issue	5	验证perf版本是否有问题。\r\n可能是因为rgw在线创建pool过慢导致meta同步出现问题。	2018-08-27 12:00:57.864021	f
299	4	Issue	5	附件，不一定有多少个已建立连接	2018-08-27 15:33:19.300798	f
300	4	Issue	5	奇怪的是当把其他同步rgw关闭，netstat 查看大部分与此rgw相关连接也进入CLOSE_WAIT状态，ss -lt仍然看到Recv-Q 129,似乎无法释放。	2018-08-27 15:46:21.749632	f
301	95	Issue	5	日志和分片上传问题解决。\r\n但是499问题根因仍然没找到，为什么撑爆了恢复不了呢？ filestore分裂仍然有问题，可能恢复和pool删除场景都有问题。	2018-08-27 18:50:57.685517	f
302	95	Issue	5	1,中广核数据分发方案\r\n2，filestore分裂方案	2018-08-28 13:27:33.432297	f
303	93	Issue	5	还有一种排序是目录排序，这是三位一体的。这三者必须保持一致，否则可能无法扫描到所有对象。\r\n\r\n请参考get_path_contents函数，其中有根据目录排序的逻辑	2018-08-28 15:33:39.262307	f
304	93	Issue	5	common/Mutex.cc: 113: FAILED assert(r == 0)\r\n\r\n mos version v5.1.0-54-g42a2ebc (42a2ebc4965ff3ab1c12135387cfcb96554c8f83)\r\n 1: (ceph::__ceph_assert_fail(char const*, char const*, int, char const*)+0x8b) [0x7f198cdd92eb]\r\n 2: (Mutex::Lock(bool)+0x19c) [0x7f198cd89fdc]\r\n 3: (std::_Sp_counted_deleter<FDCache::FD*, SharedLRU<ghobject_t, FDCache::FD, ghobject_t::BitwiseComparator, std::hash<ghobject_t> >::Cleanup, std::allocator<int>, (__gnu_cxx::_Lock_policy)2>::_M_dispose()+0x28) [0x7f198cad67a8]\r\n 4: (std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release()+0x39) [0x7f198c74cec9]\r\n 5: (FileStore::lfn_unlink(coll_t const&, ghobject_t const&, SequencerPosition const&, bool)+0x33f) [0x7f198cab3a6f]\r\n 6: (FileStore::_remove(coll_t const&, ghobject_t const&, SequencerPosition const&)+0x6f) [0x7f198cab42ff]\r\n 7: (FileStore::_do_transaction(ObjectStore::Transaction&, unsigned long, int, ThreadPool::TPHandle*)+0x1e72) [0x7f198cac7b92]\r\n 8: (FileStore::_do_transactions(std::vector<ObjectStore::Transaction, std::allocator<ObjectStore::Transaction> >&, unsigned long, ThreadPool::TPHandle*)+0x3b) [0x7f198cacb3fb]\r\n\r\n\r\n已知在pg创建时，重启osd会挂掉\r\n删除pool，pg会挂掉	2018-08-28 21:59:53.219662	f
305	93	Issue	5	会不会是部分对象的hash前面全部都是0，导致的。\r\n\r\n确实像是这种原因，修改之后就可以删除pool了。	2018-08-28 22:07:01.301899	f
307	93	Issue	5	合入5.1.0版本，支持配置目录层次，默认2层。	2018-08-29 00:12:09.733251	f
306	93	Issue	5	调整算法，根据hash来计算目录，只是前面三层仅为一层目录而已。其他地方无需任何修改\r\n这种算法有个限制，就是pg的hash值需要为16的倍数，也就是hash要单独占一个字符，否则对象分布并不在预期内。\r\n比如说4个pg，只占了2字符。 那么hash值尾数为1，5，9，13都会落在这个pg。但是根据规则可能只创建了DIR_1.\r\n\r\n当然这提前可以计算。就是把剩余位数补齐之后，计算所有数对于当前pg总数求模的值\r\n\r\n另外如果仅两层目录搞预分裂也是非常快的。\r\n\r\n	2018-08-28 23:28:37.006996	f
312	96	Issue	5	性能可以做到以5s为粒度几乎不波动。 cosbench统计周期也是5s	2018-09-05 13:47:41.96519	f
318	97	Issue	5	1,同步不跑的bug\r\n2，qos的bug\r\n3，合入gc tag处理的问题	2018-09-13 06:47:23.100955	f
320	98	Issue	5	海量小文件方案:\r\n设置bucket的rados shard数量。\r\n比如默认按5000万对象算，100个小文件合并为一个大文件。10kb~500kb文件，rados对象就是1M~50MB。\r\n总文件数50万。\r\n\r\n可支持动态修改。rados shard。但是之前的对象不会挪位置。这样虽然rados对象大小不一致，但是关系不大。\r\n\r\n对于不存在删除场景的bucket，可以使用其他方式处理。	2018-09-17 17:12:59.155963	f
322	98	Issue	5	在技术栈上，TiKV符合mos对于分布式kv系统的要求。下决心攻克这个堡垒。\r\n\r\n1，支持事务\r\n2，range数据分布，以支持高效的数据查询。\r\n3，增量恢复，解决bi以rados object粒度恢复以及scrub的问题。\r\n\r\n现在的mos无法作为一个大规模产品，bucket的限制，以及查询的限制都严重制约了其使用场景。\r\n	2018-09-17 17:23:21.828922	f
323	98	Issue	5	解决qos bug，以及simple messager死循环bug\r\n\r\n提交cdp相关修改。在多版本的情况下，也记录bilog，并且将bilog trim的时间调整为默认30天。\r\n优化修改leveldb配置，sst文件大小与 write_buffer_size也有关系。将其默认值调整为64MB\r\n	2018-09-19 09:45:34.354972	f
324	98	Issue	5	编写性能分析工具，可以按照非常方便的查看每个osd的请求数量以及延时情况等。	2018-09-21 07:47:22.319864	f
327	111	Issue	5	linux下，通过调整内核参数解决，\r\nvim /etc/sysctl.conf\r\n编辑文件，加入以下内容：\r\nnet.ipv4.tcp_syncookies = 1\r\nnet.ipv4.tcp_tw_reuse = 1\r\nnet.ipv4.tcp_tw_recycle = 1\r\nnet.ipv4.tcp_fin_timeout = 30\r\n然后执行 /sbin/sysctl -p 让参数生效。\r\n\r\n这样可以避免出现该错误\r\n\r\n*让time_wait状态的进行重用，这对于高并发连接的服务器是必须设置的*。	2018-10-08 12:04:18.234183	f
329	110	Issue	5	6，net.ipv4.tcp_tw_reuse = 1 解决端口被使用完的问题	2018-10-08 15:10:07.056232	f
335	109	Issue	5	焦虑多是因为风险\r\n风险是因为自己太弱	2018-10-09 19:08:30.22552	f
336	89	Issue	5	刷新：\r\n1，BI使用rados pool存储时的规模限制。\r\n   可以考虑使用db来存储bi，以及realm，zone，bucket，user等元数据。\r\n\r\n2，bucket自动跨pool，对业务不感知\r\n\r\n3，框架调整，实现与rados的解耦。\r\n   一方面可以利用rados的进步，另外根据对象存储，可实现自定义的backend。\r\n   比如在bluestore的基础上，各种砍除，剪裁。\r\n4，实现小文件的合并（看怎么实现，可能对于rados而言就存在覆盖写了）\r\n\r\n5，双活优化\r\n可以考虑将meta的同步改为同步方式，以避免period的变化对meta同步实现的影响。\r\n不过要考虑zone失效的情况。	2018-10-11 13:00:59.983637	f
337	103	Issue	5	1，确定自己是真有兴趣的，校验标准是自己平时会想它么，就像恋爱一样，吸引着你吗？\r\n2，搞清楚大体框架，沙盘，理清其本质，解决的核心问题。\r\n3，反复演练，让自己练出思维惯性。	2018-10-12 12:40:07.598284	f
339	118	Issue	5	当一个人本身有良好的习惯，比较容易通过学习或其他方式获得成功时，目标不是一个大问题。\r\n\r\n对于迷路很久的人，需要打破现有状态是需要精神力量支持的，因为他们还没看到正向循环，还没感受到合理的方式本身会让生活更好更有趣。	2018-10-12 14:33:39.755934	f
341	115	Issue	5	https://blog.csdn.net/smstong/article/details/42193177	2018-10-12 20:51:18.957093	f
343	115	Issue	5	wchar_t 存在的意义是什么？表示unicode编码的字符串？\r\n其意义在于不论用何用方式保存源文件，其字符串编码都是唯一确定的，不用考虑字符串编码格式问题。\r\n*一个宽字符可以表示任何系统所能认识的字符* （包括中文等）\r\n通常我们并不关心这个问题，因为一般源文件保存格式与终端输出格式是一致的。但是如果你想程序既能在windows上运行（默认gbk编码），也能在linux上运行（默认utf8编码）。则必须注意输出的编码格式了。或者你把大陆的gbk编码拿到台湾的big5下，不使用wchar_t 也是搞不定的。这是因为不同编码格式下存储方式不一致，而wchar_t 定义了不依赖于系统编码的格式。\r\n\r\n\r\nhttp://www.cppblog.com/lf426/archive/2010/06/25/118707.html	2018-10-12 21:34:23.377889	f
328	110	Issue	5	3,检查5.1.0是否有修改需同步到5.2.0\r\n4,es 6.x版本不支持在一个index下面使用多个type了，之前我们多个数据中心使用不同type区分的使用方式需要修改.\r\n5,修改版本命名规范	2018-10-08 13:42:18.946577	f
330	108	Issue	1		2018-10-08 19:31:31.284943	f
331	112	Issue	1		2018-10-08 19:34:03.002459	f
332	112	Issue	1	一方面并未完全限制死。另外如果内地企业卖往国外的产品产生的外汇收入不流入国内(海外结算)，而国内需使用美元购买必需品，长期下去外汇必然不断减少。\r\n\r\n在国内信用下降时，他国商人如果不能直接兑换外汇，就会换成商品转移出去。这时股市会大降。信心流失，而物价则会上涨。	2018-10-08 19:48:06.721426	f
333	113	Issue	1	你要理解钱的本质是什么？ 是信用。是信用推动了M2的发展。但当信用出现危机时，这些钱就回从到原始的地方。\r\n最终社会流动性降低，资产价格下降。价格是供需决定的，货币流动减少则供应减少。	2018-10-09 05:56:33.830474	f
334	114	Issue	5	人生也是因为有了认真，有了坚实不虚的每一天才那么多彩	2018-10-09 19:05:49.023883	f
338	118	Issue	5	也许难以统一人的精神动机，有的人是因为恐惧，有的是因为虚荣，有的是因为憎恨，压迫算么？孤独？信仰？神灵？榜样？斗争（斗争的动力是什么）？\r\n\r\n理性的认知：因为这种充满精神力量的，有目标感的生活是更好的方式。俗人以为慵懒，满足自己欲望是更好的。\r\n\r\n但是感性在其中起着怎样的作用呢？理性如何解释人如何能产生崇高的理想，坚定的目标？这也是我起初认为爱和兴趣，好奇心是精神力量的源头。像牛顿，爱因斯坦这种科学家，破解未解之谜。当然名誉也是一种动力，获得赞美也是动力。\r\n\r\n也许对于一些人而言。因兴趣而为，伴随榜样的力量，赞誉的推动加上天赋就足以达到别人无法企及的水平。\r\n	2018-10-12 14:08:06.965639	f
345	115	Issue	5	通过xfs从windows传中文文本文件，在linux上文件名和内容均无法识别。\r\n系统默认编码绝对了内容的存放方式，也决定了部分终端对输出的处理方式。\r\n除非部分终端进行转码处理。\r\n\r\nwchar_t 可以解决这种跨平台问题，在运行时，根据环境决定输出使用什么编码。	2018-10-13 11:47:01.628016	f
340	115	Issue	5	几乎所有编码都是兼容ASCII的，所以对于字符串而言，使用\\0结束都不是问题。\r\n软件如果内部不进行转码，在string中存储了就是对应编码的2进制形式，这时使用其他方式解码很可能就是乱码。\r\n\r\n比如你保存一个文本文件，其使用gbk编码。 如果你使用notepad++ 使用ansi编码，utf8编码查看都不是中文字符。\r\n\r\nANSI 编码\r\nD0B6D0B0  卸邪\r\n\r\nUTF8编码\r\nD0B6D0B0  жа\r\n\r\n中文BIG5编码：\r\nD0B6D0B0  笢\r\n\r\n中文 GB2312编码\r\nD0B6D0B0  中\r\n\r\n实际上文件二进制内容是完全一样的。\r\n\r\n问题来了：\r\n1，程序怎么知道输入法给自己的是什么编码呢？ \r\n2，显示器又怎么知道给出的待输出二进制是什么编码呢？\r\n对于输入法而言，它会把你的输入按照系统编码进行转码，然后传给程序。\r\n对于显示器而言，\r\n3，修改系统默认编码会有什么影响？ 比如上述文本，在utf8下输入中文“中”，对应的二进制肯定会发生变化。\r\n对于应用程序而言，读取不同编码格式，显示的时候需要怎么处理呢？\r\n4，wchar和编码显示有何关系？\r\n\r\n	2018-10-12 18:53:03.388774	f
346	115	Issue	5	https://www.quora.com/Why-doesnt-Microsoft-use-UTF-8-on-Windows-10\r\n这篇文章提及，windows内部使用的是utf-16编码，但是code page是什么意思呢？linux也有code page的概念么？\r\n\r\nhttps://zh.wikipedia.org/wiki/代码页\r\n\r\n内码页就是显示器设置的，你给显示器的二进制，显示器怎么显示就取决于内码页。\r\n可以转换内码页，但是不知道能否有函数指定某个字符使用什么内码页显示。\r\n\r\nwindows内部使用的编码跟内码页没关系。你可以使用各种方式来保存文件。但显示的时候需处理	2018-10-13 12:40:45.121404	f
342	115	Issue	5	输入使用的系统默认的编码格式，就是说在文本编辑器中使用的编码格式是固定的。\r\n如果你想把gbk的编码转为utf8的，需要自行处理。\r\n\r\n输出终端有自己默认的编码格式，如果你给出的字符不是对应格式的，则无法正确显示。\r\nwindows窗口应该也有指定的字符编码。比如cmd窗口 chcp 65001 就是utf8编码\r\n\r\n显示器是不管编码的，输出终端管编码。显示器只是根据终端驱动给出的字库进行显示。不过有一点终端根据二进制编码找字库，这一步对于不同的编码是否也不一样呢？\r\n终端知道编码和二进制值，只要字库提供各种编码对应的字库就可以了。\r\n\r\n所以如果你输入是gbk编码，在程序中你需要转为unicode编码，再然后可以根据unicode编码转化为big5编码，从而在默认big5编码的终端上显示出来。\r\n	2018-10-12 21:11:32.469814	f
344	115	Issue	5	当我在一个ansi类型的txt文件 和 在一个utf类型的txt文件中各写入同样字符时，最终保存的二进制内容不一样。\r\n这个不一样是谁做的呢？ 输入到记事本的时候，记事本根据文件编码类型进行了转换么？ 应该是这样的。	2018-10-12 22:02:20.958082	f
347	121	Issue	5	还有一种解决方案是创建对象时分裂，但是这样开始性能很慢，不利于测试。	2018-10-16 09:46:07.327316	f
348	121	Issue	5	pg_num  320\r\n\r\nhex: 140\r\n\r\nseed + 320\r\nseed: 1  001  141 281 3C1 501 641 781 8C1 A01 B41 C81 DC1 F01 \r\n \r\n给出一个函数，计算hash值情况，然后创建pg。 可提供参数，允许pool支持提前创建，这样可加快实际执行速度。\r\n参数限制预创建的目录总数，这样就基本可以控制一个pool的对象总数。\r\n\r\n1，首先根据pg_num计算出总的深度\r\npg_num 4096，则其深度为4，在原有基础上+2，也就是深度为6.\r\n\r\n2，循环计算6层目录\r\nseed： 000001 001001 002001 003001 004001\r\n\r\n\r\n依赖还是要充足，分析清楚pg到底是如何分裂的。\r\n比如求模大于pg_num求模,则split_bits为 p-1，否则为p\r\n\r\n假设pg_num从100，扩充到150，哪些pg需要分裂呢？ childpg的计算。\r\n\r\n102增加到104，split 的pg分别是 21.26，21.27\r\n\r\n26：0010 0110   66：0110 0110\r\n27：0010 0111   67：0110 0111\r\n\r\n为啥不是0000 0110呢？ 为什么不是2和3呢？\r\n\r\n2 | 0100 0000 < 0110 0100\r\n2 | 1000 0000 > 0110 1000\r\n\r\n所以2被干掉了。请参考函数is_split,找到符合>= old_pg_num && < pg_num,且seed计算后仍然为本seed的数值，作为child pgs。\r\n\r\n也就是说分裂的seed满足这样的条件：其二进制的低位与parent是一致的。\r\n\r\n这样就好办了。对于26，只需创建如下目录：\r\n\r\n6\r\n2 6 E\r\n就可以满足分裂要求了。要么在本层不会分裂，就会进入下一层。\r\n\r\n参考函数col_split_level\r\n转移就是把path的hash值符合child seed且大于原inbits的转移出来。\r\n所以上述就算有6/3目录，也不符合转移的条件。\r\n\r\npg分裂是根据二进制数值来计算的，pg seed是根据十进制计算的。	2018-10-16 16:09:50.413146	f
349	120	Issue	5	解决filestore目录预分裂在pg split时的bug。	2018-10-18 07:11:08.048266	f
350	121	Issue	1	问题原因分析：\r\npg分裂时计算方式，如pg 1.26，当新建pg数量大于102时，则其会分裂出1.66.\r\n也就是说是在高位扩展的方式实现pg的分裂的。\r\n0010 0110 (26)  第一次扩展就是 0110 0110 (66)\r\n\r\n这也是为什么filestore需要将数据根据hash反序存放，其目的就是达到在pg分裂时仅move目录即可。\r\n\r\n上次修改pg分裂打破了该规则，导致数据根本没法正常转移到分裂的pg。因而出现了\r\n1，在当前pg下的对象hash在新的osdmap下已经不属于该pg了，hash check失败\r\n2，根据新的osdmap，定位之前创建的对象，如果对象在新的pg就无法找到对应的对象\r\n等问题。\r\n\r\n解决方案：\r\n\r\n仍然使用预分裂的方式，避免在后期转移大量文件。\r\n目前结构按hash组织，避免打破上述规则。\r\n\r\n比如23.1A1，预分裂后目录结构为：\r\n1\r\nA\r\n0 1 ...F \r\n\r\n假设某次分裂出23.3A1， 则只需转移数据 1/A/3 目录即可，其他数据仍然留在当前pg。\r\n	2018-10-18 07:54:42.542507	f
351	121	Issue	1	实际上数据也是按照二进制放的，参考函数 ceph_stable_mod.\r\n假设pg_num是140，按10进制计算，位数为140(8C)的对象应该放入pg.0\r\n但是按照二进制算 8C 1000 1100 按照函数ceph_stable_mod算，应该放入pg.C.\r\n也就是说ceph使用的是二进制求模运算。	2018-10-18 17:33:28.265453	f
355	127	Issue	1	在切换到下一个period时，重置marker位置。但是重置可能失败。\r\n应该在marker中记录同步位置，参考社区修改：574ff5f5df62a0a1e9a8ff7e4a87cd65cc952d7e	2018-10-20 09:44:24.239268	f
358	133	Issue	5	私有云的缺点：\r\n1，资源整合弱\r\n2，技术实力弱\r\n3，运维效率底下	2018-10-23 09:39:23.799489	f
360	134	Issue	5	NoQ.beoYENxSW_860 [writefull 0~4194048] v233'6003 uv6003 ondisk = 0) v7 ==== 223+0+0 (2953448851 0 0) 0x7f0c3ac73300 con 0x7f0c520c1600\r\n    -4> 2018-10-24 14:26:54.363392 7f0c3c1fb700  1 -- 192.168.13.120:0/4184383355 <== osd.2 192.168.13.119:6800/47746 14980 ==== osd_op_reply(187355 8a333bb8-7fb4-4bfe-840d-490f87f2502b.40647.37__shadow_myobjects8418.BVNAk9fihrpnTH2xW8IFnOIK9JcSPbn_1076 [writefull 0~4194048] v233'5972 uv5972 ondisk = 0) v7 ==== 224+0+0 (3079957286 0 0) 0x7f0c37473600 con 0x7f0c520c1a80\r\n    -3> 2018-10-24 14:26:54.374741 7f0c38afc700  1 -- 192.168.13.120:0/4184383355 <== osd.7 192.168.13.120:6804/47448 11860 ==== osd_op_reply(187380 8a333bb8-7fb4-4bfe-840d-490f87f2502b.40647.37__shadow_myobjects8494.0-neB8QEGmQ3MvjH2MX5ys0HfAnCkwC_964 [writefull 0~4194048] v233'5834 uv5834 ondisk = 0) v7 ==== 223+0+0 (1919885020 0 0) 0x7f0c33073600 con 0x7f0c520c2080\r\n    -2> 2018-10-24 14:26:54.374935 7f0c527fd700  1 -- 192.168.13.120:0/3752582948 <== osd.13 192.168.13.118:6812/47074 188 ==== osd_op_reply(188 realms.1bfb4d43-57f9-461f-ba11-8779cd840e21.control [watch ping cookie 139691342021376] v0'0 uv1 ondisk = 0) v7 ==== 171+0+0 (1674671842 0 0) 0x7f0b91015300 con 0x7f0c6cc3c700\r\n    -1> 2018-10-24 14:26:54.383316 7f0c3c1fb700  1 -- 192.168.13.120:0/4184383355 <== osd.2 192.168.13.119:6800/47746 14981 ==== osd_op_reply(187401 8a333bb8-7fb4-4bfe-840d-490f87f2502b.40647.37__shadow_myobjects8418.BVNAk9fihrpnTH2xW8IFnOIK9JcSPbn_1076 [write 4194048~256] v233'5973 uv5973 ondisk = 0) v7 ==== 224+0+0 (458386884 0 0) 0x7f0c37473600 con 0x7f0c520c1a80\r\n\r\n\r\n为啥不是一次性写入4MB？	2018-10-24 14:59:28.279043	f
363	134	Issue	5	从代码分析，当chunk size与stripe size相等的时候，不可能出现覆盖写的情况。	2018-10-25 19:16:48.278968	f
365	137	Issue	5	政治与人际关系\r\n政治与权力\r\n政治与斗争\r\n\r\n政是政策？ 治是治理？	2018-10-26 06:34:32.221484	f
368	134	Issue	5	xfs在频繁创建文件，删除文件之后形成的空洞也是个大问题。	2018-10-27 07:52:33.905798	f
369	140	Issue	5	流程:研发在feature合入之后，自发现问题单也需提单，但不必转给测试。特性或重要bugfix需review，review记录到版本svn。	2018-10-30 08:50:11.376526	f
372	140	Issue	5	貌似delete obj bypass gc也有问题	2018-10-30 18:17:42.136213	f
404	150	Issue	5	2018-11-09 21:16:51.425939 7fb37fbff700  4 rgw realm watcher: Disconnected watch on realms.8527beb0-c88c-4b34-9cd8-fe7eae7ca6a5.control\r\n2018-11-09 21:16:56.897957 7fb4eb3fe700 -1 RGWWatcher::handle_error cookie 140415140703360 err (107) Transport endpoint is not connected\r\n2018-11-09 21:16:56.898023 7fb4eb3fe700  2 removed watcher, disabling cache\r\n2018-11-09 21:16:59.284277 7fb4eb3fe700 -1 RGWWatcher::handle_error cookie 140415140704256 err (107) Transport endpoint is not connected\r\n2018-11-09 21:17:02.796462 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:17:06.565509 7fb4eb3fe700 -1 RGWWatcher::handle_error cookie 140415140699776 err (107) Transport endpoint is not connected\r\n2018-11-09 21:17:10.045663 7fb4eb3fe700 -1 RGWWatcher::handle_error cookie 140415140701568 err (107) Transport endpoint is not connected\r\n2018-11-09 21:17:12.388277 7fb4eb3fe700 -1 RGWWatcher::handle_error cookie 140415140700672 err (107) Transport endpoint is not connected\r\n2018-11-09 21:17:18.315045 7fb4eb3fe700 -1 RGWWatcher::handle_error cookie 140415140702464 err (107) Transport endpoint is not connected\r\n2018-11-09 21:17:24.796573 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:17:27.189282 7fb4eb3fe700 -1 RGWWatcher::handle_error cookie 140415140698880 err (107) Transport endpoint is not connected\r\n2018-11-09 21:17:27.190580 7fb4eb3fe700 -1 RGWWatcher::handle_error cookie 140415140697984 err (107) Transport endpoint is not connected\r\n2018-11-09 21:17:46.796697 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:18:08.796818 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:18:30.796926 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:18:52.797028 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:18:53.792040 7fb37fbff700  4 rgw realm watcher: Disconnected watch on realms.8527beb0-c88c-4b34-9cd8-fe7eae7ca6a5.control\r\n2018-11-09 21:18:56.984523 7fb4da7ff700  0 ERROR: register_watch() returned ret=-110\r\n2018-11-09 21:19:14.797137 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:19:36.797241 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:19:58.797350 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:20:20.797458 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:20:42.797564 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:21:04.797674 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:21:26.797779 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:21:48.797886 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:21:59.883048 7fb4eb3fe700 -1 RGWWatcher::handle_error cookie 140415140701568 err (107) Transport endpoint is not connected\r\n2018-11-09 21:22:10.797989 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:22:32.798082 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:22:54.798188 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:23:16.798288 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:23:38.798400 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:24:00.798521 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:24:22.798626 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:24:44.798732 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:25:06.798847 7fb4e5bfd700  2 RGWDataChangesLog::ChangesRenewThread: start\r\n2018-11-09 21:25:12.519799 7fb4eb3fe700 -1 RGWWatcher::handle_error cookie 140415140697984 err (107) Transport endpoint is not connected\r\n	2018-11-10 14:45:35.167165	f
398	148	Issue	5	1，情绪，情感本身应该作为理性的一部分，大脑存在的非理性部分也是既定事实\r\n2，连结与银行存款的比喻很贴切。\r\n3，情绪，水桶的比喻也非常贴切。	2018-11-05 17:10:36.350764	f
403	141	Issue	5	1，文档\r\n2，问题单继续处理	2018-11-09 07:08:27.036826	f
406	162	Issue	6		2018-11-14 03:37:30.129135	f
412	148	Issue	6	【要点1】“联结-断裂-重新联结”.在亲密的关系中，我们要做的不是绝对避免断裂，而是在断裂后努力重建联结，父母要主动与孩子重建联结。\r\n\r\n【要点2】父母与孩子之间良好的亲子关系就像一条“隐形脐带”，为孩子源源不断地输送了心理营养，使孩子拥有足够的安全感。\r\n\r\n【要点3】孩子说“妈妈，你走开”，真是想法却是“我想让你知道，此刻我很难过”。此时的孩子是在用“气话”和“哭闹”来表达自己糟糕的心情和感受。\r\n\r\n【要点4】当孩子出现三种负情绪：生气/愤怒，害怕/恐惧，伤心/悲伤，这是孩子的情绪水桶满了，当孩子在父母理解接纳的情况下大哭一场之后，他的情绪自然会恢复平静。\r\n\r\n【7个小游戏】\r\n# 爱的香香\r\n# 爱抱宝贝的机器人\r\n# 遥控器游戏\r\n# 枕头大战\r\n# 爱的帐篷\r\n# 爱的暗号\r\n# 小猫上树\r\n\r\n\r\n	2018-11-14 04:18:07.144087	f
501	4	Issue	5	从抓包的结果看：\r\ntcp请求可以进入半连接状态，即server可成功收到SYNC并发送ACK。\r\n但是server全连接队列满了，recv-q 129, 无法进入accept连接。\r\n\r\n问题的根因还在于accept为啥没有取走任何连接？	2018-12-18 13:46:22.268282	f
502	4	Issue	5		2018-12-18 13:47:14.772045	f
517	4	Issue	5	https://stackoverflow.com/questions/27395496/socet-recv-hangs-when-server-crashes\r\n\r\nread可能在极端情况下卡死，但是select在这种情况下同样获取不到数据，但是可定义超时时间，从而服务端可主动关闭。	2018-12-24 18:59:14.655066	f
518	4	Issue	5		2018-12-24 19:17:33.138122	f
352	121	Issue	1	参考get_split_bits函数：\r\nsplit_bits的含义就是从此之后在左边以二进制扩展1的数据都属于本pg。\r\n对于pg_num 1111 1010 (250)\r\n\r\npg 1011 1010 的split_bits就是8\r\npg 0111 1011 的split_bits就是7	2018-10-18 17:58:00.164931	f
353	121	Issue	1	还有一个问题，revise bit用来干啥的？	2018-10-19 07:43:08.184308	f
443	171	Issue	5	multipart在对象ESIXT的时候改变head对象名，这样不合适吧，在分片上传失败的情况下，这些head对象岂不是无法找到。\r\n\r\n不过这问题可能只会导致head残留，但是abort和complete multipart都没问题，应该都是根据meta对象的属性记录来遍历的。\r\nmeta bi存在的意义似乎只在于quota统计。	2018-11-17 16:06:53.016782	f
354	127	Issue	1	es zone全量同步实质上做完了，但是就是没有输出 done over all的日志。\r\n\r\nes返回了大量429错误，这里可能需要做下流控。控制每秒发出的请求数量。\r\n\r\n如何控制es不返回429？ fullsync位置因为错误无法更新。但是既然最终同步成功，那fullsync位置还是有机会往后走的？否则怎么会同步成功呢？\r\n\r\n这问题并非必现，有时可以进入正常的增量同步状态(incremental)	2018-10-19 20:39:13.387683	f
356	130	Issue	1	多故障域，一个故障域不可用影响其他故障域问题。\r\n\r\n对于集群元数据，可以建立跨越故障域的元数据故障域。就像mon一样。\r\n建议在此类场景下，每个环境使用一个独立的SSD或小盘建立元数据集群。\r\n\r\n可靠性是相对的。	2018-10-22 11:30:09.254359	f
357	133	Issue	5	另外把计算资源比喻水电是非常不合适的，在没水的情况下，实际上我们是可以去超市买水的。\r\n\r\n但是存储的数据不是可以买来的，你可以买硬件，但是买不来数据。	2018-10-23 08:55:23.453279	f
359	134	Issue	5	分析频繁删除场景下的性能。kworker占用大量cpu。	2018-10-24 14:49:35.55343	f
361	135	Issue	5	https://bean-li.github.io/disk-cache-policy/\r\n\r\n\r\n可以看到Disk Cache Policy 是 Disk’s Default 。这个default值可以分成以下情况：\r\n\r\nFor virtual disks containing SATA disks ， Enabled\r\n\r\nFor virtual disks containing SAS disks ， Disabled\r\n\r\n可以通过如下命令将Disk Cache Policy的值改成 Disable	2018-10-25 12:58:37.24758	f
362	134	Issue	5	rgw超时自杀，但是rados op超时这种情况应该排除。以免影响其他故障域。	2018-10-25 16:03:36.32275	f
366	137	Issue	5	在总体上讲，政治是上层建筑领域中各种权力主体维护自身利益的特定行为以及由此结成的特定关系。\r\n\r\n马克思认为，“政治是经济的最集中的表现”，“政治就是各阶级之间的斗争”，“政治就是参与国家事务，给国家定方向，确定国家活动的形式、任务和内容”，“政治权力不过是一个阶级用以压迫另一个阶级的有组织的暴力”。\r\n\r\n西方的政治学家为政治下过许多定义，例如：\r\n①认为政治是国家的活动，是治理国家，是夺取或保存权力的行为。\r\n②认为政治是权力斗争，是人际关系中的权力现象。\r\n③认为政治是人们在安排公共事务中表达个人意志和利益的一种活动，政治的目标是制定政策，也就是处理公共事务。\r\n④认为政治是制定和执行政策的过程。\r\n⑤认为政治是一种社会的利益关系，是对社会价值的权威性分配。\r\n⑥一群人借以控制另外一群人的按照权力组织的关系和安排。\r\n⑦“政治”是指规则制定、维系或修正（即以和平的方式讨论）的特定方式。	2018-10-26 06:37:25.272679	f
367	138	Issue	5	约几个人开怀畅谈？ 让人展现自己。\r\n聊天不需要总是特别理性，人际交往更多的是情感倾诉之类的。 我貌似很少做情感倾诉。内向的人多理性。\r\n\r\n5，让自己变成一个有情商的人？ 什么是情商？\r\n6，如何寻找聊天话题，以不至于把天聊死？	2018-10-26 07:06:04.889774	f
371	140	Issue	5	在多版本产生delete marker的情况下，如果是null版本，应该做删除rados对象的操作。	2018-10-30 18:00:26.04397	f
373	140	Issue	5	把ceph master的所有multisite的问题单分析一遍	2018-10-30 18:32:41.531916	f
370	140	Issue	5	写与删除并发场景下可能有点问题，因为我们流程是：\r\n1，get\r\n2，change bi\r\n3，delete\r\n\r\n这个过程中，bi可能发送变化。可以考虑使用epoch等来发现这种问题。\r\n如果第二步失败，说明出现了冲突情况。 这是对于put操作可执行撤销。\r\n对于delete操作可直接取消操作。\r\n\r\ndelete也有问题，假设delete与put并发，最后执行的是delete，则put的版本可能就残留了。这时应该撤销delete操作。	2018-10-30 17:45:39.601636	f
446	107	Issue	5	知道什么是合适的是人的一个分界点\r\n理解何等规模的系统运作，看清事物本质是另一个分界点\r\n理解人性的善与恶，恶的强烈与善的坚韧\r\n看懂事物的发展变化是另一个分界点	2018-11-18 07:30:27.929936	f
450	175	Issue	5	研究双活模块，增加对cr的动态检测，如果是异常情况（没阻塞，但是就是不跑），同步rgw可异常退出。	2018-11-24 15:25:00.344906	f
452	175	Issue	5	日志上也可增强，输出当前执行的cr执行历史	2018-11-27 09:49:57.095586	f
460	182	Issue	6	课程列表\r\n第1课：全脑早教概述，掌握大脑的设计图\r\n第2课：拿到打开大脑的钥匙\r\n第3课：语言能力\r\n第4课：理解能力\r\n第5课：表达能力\r\n第6课：数学启蒙\r\n第7课：思考能力\r\n第8课：质疑能力\r\n第9课：情商能力\r\n第10课：社交能力\r\n第11课：自控力\r\n第12课：专注力\r\n第13课：记忆力\r\n第14课：计划力&整理能力\r\n第15课：感知力\r\n第16课：观察力\r\n第17课：想象力&创造力	2018-11-28 13:47:35.732125	f
462	183	Issue	5	前端增加判断，如果队列满，则accept请求，但是直接给客户端返错。\r\n\r\n改法：\r\n在dequeue超时的情况下，使用临时request先accept，然后直接fcgi finish。抛弃请求。	2018-11-28 14:30:57.129624	f
463	139	Issue	5	1，每个模块都需要人深入了解，每个特性设计都需要仔细review，每个bug都需要深入review和测试。\r\n否则，架构慢慢腐化，bug越来越深。\r\n\r\n2，自动化测试绝非可选项。兵马未动，粮草先行。自动化测试就是应该在开发之前进行规划的。\r\n\r\n3，review看什么？ 一方面软件的特性犹如一张网，看一滴水下去影响了哪些线。从架构上，从与其他特性的交织上，从dfx特性上，从代码实现上。各种层面去review。\r\n\r\n4，风险控制与运维报告	2018-12-01 08:05:28.292962	f
464	149	Issue	5	分层，去状态化。 微服务架构。	2018-12-01 09:37:12.600947	f
465	184	Issue	5	最近杀球明显好很多，杀球平一般是退的不够或挥拍太慢。\r\n前场准备时拍子应该提前准备好。\r\n手臂手腕放松，随时准备挥拍击球。\r\n\r\n姿势不标准，重心不稳则失误多。所以业余的速度跟专业的差很远。专业发力基本功好，打完一拍之后重心各方面调整好。\r\n不够放松则速度无法提升，容易失误。\r\n专业双打杀球好多不侧身的，杀完双脚是水平站位。	2018-12-01 16:23:08.153376	f
451	175	Issue	5	wait_for_child是主动调用的，可阻塞parent\r\ninterval_wait 就是协程睡眠了。\r\nsleep 是主动等待唤醒，比如生产者和消费者模型中，没事干时就会sleep。\r\n\r\nio block比较常见点，在wait或流控的时候都会使用该标记。\r\n\r\n断言：如果协程不在调度范围，那么其应该处于阻塞状态。\r\n\r\ncontext_stacks包含所有stack， scheduled-stacks包含所有可调度的stack。	2018-11-27 09:05:20.397049	f
422	171	Issue	5	http://tracker.ceph.com/issues/20861\r\n客户端调用多次multipart complete，具体为什么导致问题还得分析。\r\n\r\ngc在后端删除，必须确保rgw不会写入重复的对象。否则gc可能把覆盖写入的正常rados对象给删除了。\r\n\r\n还有断言multipart时，原始对象不存在或orig_size == 0显然是不合适的,multipart可能出现重试的情况，这时bi可能有重复的key。\r\n\r\n复现该问题：\r\n不对，错误需要注入在bi写失败上，这样在老版本才会把对象加入gc。\r\n\r\n注意以前版本如果发现完全一样的多版本对象，是会改变对象名字，重新写的。因而也不存在覆盖写的情况！！！！\r\n所以这块暂时无需调整，但是在析构函数中删除对象这块是需处理的。\r\n详细请参考RGWPutObj的重试代码	2018-11-16 15:57:06.768074	f
397	141	Issue	5	计划周一周二完成bug修复，周三可以check文档，过评审。	2018-11-05 07:00:11.50388	f
399	149	Issue	5	软件架构发展：CS BS SOA MSA \r\nhttps://gitbook.cn/books/5a8d689decd7eb74c19ba962/index.html\r\n\r\n<pre><code class="text">\r\n库是工具箱。\r\n\r\n框架是一套通用的解决方案。\r\n\r\n架构是高度抽象的需求，是系统中的不变量。\r\n\r\n平台是所有可能做的事的集合。\r\n</code></pre>\r\n	2018-11-06 18:47:28.698485	f
400	149	Issue	5	例如ceph rgw架构。\r\n\r\n数据处理是广义上的，不仅是处理图片等。还有比如查询某个前缀的对象个数。对象名包含某个字符的个数等。\r\n或者在某段时间内，某个bucket写入的对象个数等\r\n\r\n所以使用一个强大的DB是非常需要的。数据处理定义专门的rest接口。	2018-11-07 08:06:21.398655	f
401	149	Issue	5		2018-11-07 08:10:04.322823	f
402	149	Issue	5	软件架构需要对齐: 1,公司战略，软件的发展方向。 2，人力匹配\r\n架构有点没法一步到位，是逐步改进优化的。\r\n当然如果能思考清除未来5年趋势，你可以设计5年架构规划	2018-11-09 06:45:09.392476	f
405	148	Issue	6		2018-11-14 03:32:48.358539	f
415	157	Issue	5	任务1：完善规格限制，补充acl，user quota部分，同时可分享相关知识。	2018-11-14 09:36:30.859039	f
417	167	Issue	5	initiatives ：方案，倡议	2018-11-15 16:25:30.13536	f
419	169	Issue	5	https://linux.cn/article-9535-1.html  \r\n通过S3A支持hadoop大数据	2018-11-15 17:55:37.503554	f
421	171	Issue	5	在非分片上传大对象的时候，一个请求处理大量数据，可能每个rados请求没超过120s超时，但是请求整体超过600s，rgw挂掉\r\n\r\n应该reset timer。	2018-11-16 14:53:19.317292	f
423	172	Issue	6		2018-11-16 16:11:59.098537	f
424	146	Issue	6	美丽不是一件小事\r\n美丽是让所有人都见证你将自己的美好活出来的大事	2018-11-16 18:26:02.325876	f
454	178	Issue	6	【要点1】\r\n情绪脑vs理智脑--情绪脑也叫本能系统，它负责产生快乐、愤怒、恐惧等情绪，这一类情绪有助于我们回避危险、适应环境。\r\n理智脑是人类特有的大脑结构，主管理性思考、分析与控制。\r\n\r\n【要点2】\r\n负情绪vs内分泌--情绪会引起内分泌系统的相应变化，这里先讲负情绪对内分泌的影响。\r\n大量研究发现，如果负情绪不能及时平静下来，那么持续的负情绪就会造成内分泌系统产生与压力相关的荷尔蒙，而如果过多的压力荷尔蒙在大脑中停留时间过长，就会形成有害的大脑化学环境，影响大脑的健康发育。\r\n\r\n【要点3】\r\n正情绪vs负情绪--2015年哈佛大学儿童发展中心一份研究报告指出，健康的情绪管理，不是没有负情绪，而是在负情绪的同时，拥有平衡的、甚至更多的正情绪。\r\n因此，我们除了帮助孩子应对负情绪外，也需要重视不断加强正情绪。\r\n\r\n【要点4】\r\n1、养育着作为“外部调节器”，为孩子起到两个作用：\r\na.调节并减缓负情绪\r\nb.激发正情绪\r\n2、怎样发挥“外部调节器”功能？\r\n第一步，大人主动支持，主动提供有效的安慰。\r\n第二步，引导孩子认识情绪。\r\n第三步，通过理解还在的语言，帮助孩子引入理智脑。\r\n	2018-11-28 09:05:18.660977	f
509	4	Issue	5	通过lsof -i -a -p 命令查看，发现连接只剩单边的，rgw到nginx。\r\n\r\n另外一端已经关闭。\r\n问题：\r\n1，对端关闭的时候，read不会返回错误吗？\r\n2，对端关闭的情况下，本端为啥长时间不关闭？ 从netstat看也看到有数据需发送。send-q为空	2018-12-22 13:36:53.197008	f
444	171	Issue	5	http://tracker.ceph.com/issues/11749  这问题不可忽略，还是得解决。\r\n\r\n由于multipart通过对象名检查是否冲突的机制仍然存在，所以仍然需要后删除head对象，先删除其他对象。\r\ngc不会对该机制造成影响，因为gc的对象在没删除的时候，multipart仍然可检测到该对象。\r\n\r\n且采用gc机制该问题自然解决了，因为对象没有立即删除。不过最安全的还是后删除head。gc可后增加head对象。\r\n\r\n不过这机制真他妈复杂，软件中的统一模型，设计非常重要。 社区rgw已然腐烂。\r\n	2018-11-17 16:16:26.116705	f
447	173	Issue	5	合适的点怎么把握：良知？独立与互赖。	2018-11-18 07:35:26.533116	f
448	171	Issue	5	在写bi超时之后，可能出现这种现象，即对象的bi存在，但是数据体应该超时出错给gc掉了。\r\n以前失败只会是bi写冲突，现在还有超时，所以出现了对象大量残留。	2018-11-18 07:59:41.351286	f
449	4	Issue	5	测试方法，gdb卡住rgw一段时间，或在rgw处理中增加sleep，观察多久rgw能恢复。\r\n或者把队列搞的非常浅，tcp接收队列也搞的非常浅，观察在其满时的现象。	2018-11-22 08:44:06.759992	f
510	103	Issue	5	先从认知上理解事物，了解其本质和运转机理，为什么而存在等。\r\n\r\n其次采用分治方法，将复杂事物划分为各个部分，然后就是解决具体的每个问题了。	2018-12-23 20:55:38.635695	f
516	4	Issue	5		2018-12-24 18:56:13.202681	f
522	4	Issue	5	关于iptbales tcp-flag的解释https://serverfault.com/questions/375423/tcp-flags-in-iptables-whats-the-difference-between-rst-syn-and-rst-and-syn-rst\r\n\r\n--tcp-flag FIN,ACK FIN,ACK用于拦截FIN包	2018-12-25 17:42:23.47972	f
523	4	Issue	5	accept的socket是否会继承listen的socket，不一定，所以最好还是额外设置下	2018-12-26 08:49:33.004095	f
527	214	Issue	5	持戒护念，一日三省，以中庸之道，达至臻境界。依存有度，能看世间真情(情况的情)。\r\n	2018-12-28 06:59:39.731567	f
413	161	Issue	6	【要点1】自信与掌控感--自信是一种“我能行，我能客服阻力、做成我想做的事”的感觉，或者成为“掌控感”。孩子的健康成长不能缺少掌控感，掌控感是自信的基本要素。因此，要建立孩子的自信心，就要在日常生活中尽量保护孩子的掌控感\r\n\r\n【要点2】“抱”与“推”--在孩子退缩时先“抱一抱”他（肢体抚慰与言语安慰），让孩子知道我们会及时保护他，孩子确定自己是安全的，他才能主动探索外面的世界，并在内心逐渐形成自信心。\r\n\r\n【7个小游戏】\r\n# 情绪雕像-父母形容自己的内心从变弱到变强的过程，让孩子感同身受。\r\n# 超级力量-父母把自己的鼓励与支持化作孩子能听懂的语言，让孩子看到。\r\n# 一指禅-让孩子充分体验掌控感\r\n# 冲关夺宝-释放紧张情绪，让孩子找回掌控感（控制自己的情绪）\r\n# 宝宝抱抱-让孩子在开心的玩耍过程中通过控制大人，感受到自己的力量。\r\n# 人体播放器-孩子按哪里，父母就发出搞笑的声音，既增加亲密，又增加乐趣。\r\n# 斗牛-鼓励孩子充分展示自己的力量，并最终战胜大人。\r\n\r\n  	2018-11-14 04:29:42.073206	f
414	162	Issue	6	【要点1】孩子们的恐惧感来自于对现实事务的恐惧和想像中的恐。这些恐惧大多数是暂时的，随着年龄的成长会自然消失。\r\n\r\n【要点2】恐惧有益--恐惧或害怕，使我们每个人与身俱来的一项本能，是一项重要的生存保障。\r\n\r\n【要点3】可预期性--对于即将在孩子生活中出现的新事物，我们可以带孩子先去看一看，摸一摸，了解与认识，从不熟悉到慢慢熟悉。\r\n\r\n【要点4】支持性保护--父母一方面理解和接纳孩子的害怕情绪，以此来保护孩子的心里感受；另一方面，对于不得不经历的挑战，不完全逃避，找适合自己孩子的方式，一点点去适应。\r\n\r\n【5个小游戏】\r\n# 抓床下的鳄鱼--带着孩子把想象中的恐惧“外化”并“具体化”，用重视的态度、轻松的游戏，化解孩子内心的恐惧情绪。\r\n# “弟弟别怕，姐姐保护你”--角色互换，现实中“强大”的成人，在游戏里化身“弱小”的弟弟，化解孩子因为害怕而产生的羞愧感和无助感，也让孩子通过“保护弱小”的游戏心生新的勇气。作重要的是，大人滑稽的慌张动作，给孩子带来欢乐，让“害怕”变成好玩的事\r\n# 表情包-让容易精湛、敏感的还在得到充分的放松。\r\n# 压路机-增加亲子之间的亲密和信任，同时又增加一些小刺激的欢乐游戏。\r\n# 坦克大战--让孩子充分展现力量，在笑声中获得满满的成就感。\r\n\r\n\r\n\r\n\r\n\r\n	2018-11-14 04:42:47.378839	f
416	164	Issue	5	同时使用ACL、Bucket Policy\r\n如果ACL和Bucket Policy同时使用， 则ACL对某个账户的授权结果allow，可以被Bucket Policy的显示 Deny覆盖。\r\n\r\n如果Bucket Policy和IAM Policy同时使用，同样遵循explicit deny>allow>default deny的规则。\r\n\r\n\r\nacl不支持 explicit deny，acl只能配置允许访问，不能显示的拒绝访问。\r\npolicy支持	2018-11-14 12:15:12.036927	f
418	168	Issue	5	<pre>\r\nFusionStorage，9000 和UDS的区别\r\nfusionstorage设计是面对云数据中心未来的存储服务而设计的，他有几个要点:\r\n1,    适配云化环境，有良好的扩展伸缩能力\r\n2， 适配未来云化环境下的自动资源分发以及资源管理需求。\r\n3， 由于企业的云数据中心主要承载企业业务，因此对性能时延也有一定的要求，所以fusionstorage设计采用了支持IB组网，支持SSD cache加速等提高性能的设计。\r\n4， 数据需要有强一致性，任何时刻的数据必须保证一致性以及可靠性。（为了性能fusionstorage采用多副本跨界点分布等方式来保证数据可靠性）UDS的设计是面对对象存储的需求，他的特点就是要求容量非常大，价格低，高并发，但是时延要求不高（基于互联网传输），最后他要直面个人用户而不仅仅是企业用户，所以并发量非常大。\r\nOceanStor 9000的目标是面对高性能计算，大吞吐量的数据处理，大数据处理等企业存储需求。\r\n</pre>	2018-11-15 16:51:42.215688	f
420	171	Issue	5	显然通过挂掉服务的方式来检查死锁或避免过载都是不合适的。\r\nrgw应该要有过载保护。	2018-11-16 14:52:37.195359	f
425	146	Issue	6	美好的形象不仅仅是美丽那么简单，\r\n它需要对自己的热爱和欣赏，\r\n它需要融合你的过去、现在和梦想，\r\n它需要心灵的纯净和心态的从容，\r\n还需要品味的提升和修养，\r\n它是身心灵的和谐，\r\n它是表达出最美好的你自己......	2018-11-16 18:29:23.832502	f
429	146	Issue	6	胡冬寅十月读书（15-20）\r\n\r\n书名：《成就最美好的自己》\r\n\r\n  摘录（请让我知道一个真实的你-气质定位）：\r\n气质定位就是让见到你的人能够清晰地接收到由你自己散发出来的、关于你是一个怎样的人的美好信息，这个信息的传递既适合你要见到的人，也适合你自己的表达能力，它会让你自在而又自信，并且激发见到你的人对你的尊敬和喜爱。所以，气质定位里有对不同场景的定位描述，但他们都是你-真实而又美好的你，一个最好的你！\r\n做一个有气质的人需要-真实、有美感、表里如一、在家在外如一。气质绝非面具，是从里到外散发出来的韵致。\r\n气质不是一蹴而就的，有气质的人能够自省，对自己有要求才有进步，一生都不放松。\r\n\r\n感悟心得：做到有气质，不是为了达到某种目的而展现出来的姿态，需要接受自己真实的模样，并对自己有要求，不断进步，深入灵魂。	2018-11-16 21:09:00.821766	f
426	146	Issue	6	胡冬寅十月读书（1-7）\r\n\r\n书名：《成就最美好的自己》\r\n\r\n  摘录1：玛亚对美的理解极其深刻，她能够透视美在个人身上的存在，她懂得找寻个人的美，并且将那久被遗忘、躲在角落的美引发出来。\r\n\r\n感悟心得1：以前的自己因着藏在心底的自卑，觉得自己不美，麦姐和Joy便是将我那久被遗忘、躲在角落的美引发出来的人，让我切身感受到自己美好的样子，也让我对美有了不同于以前的理解。每个人都是独特的，都有着自己最美好的状态，当我们对待美的理解变化了，也就能够更好的发现自己、接纳自己。\r\n\r\n  摘录2（写在前面的话）：美丽不是一件小事，美丽是让所有人都见证你将自己的美好活出来的大事。我们的形象，以及我们对待自己形象的态度真的就是我们人生的写照。什么是优雅？优雅是打不败的状态，是随时随地都能持守的美好。一个最好的你，看起来应该是在所有场合都衣着举止得体，都是被尊重、被喜爱的！\r\n\r\n感悟心得2：认真的对待自己的形象，衣着举止得体，展现出随时随地都能持守的美好，将自己的美好活出来，这是我正在乃至终身需要去修炼的功课。	2018-11-16 18:30:19.319994	f
485	199	Issue	5	培养兴趣的起初可能是通过 好奇心，成就感，价值认同等方式来的。\r\n随着不断的深入，可能慢慢不需要别人的鼓励与肯定了，自己逐步窥探其中门径，逐步体会领域，创新变化的乐趣。	2018-12-05 07:57:41.261328	f
513	4	Issue	5	https://blog.csdn.net/dog250/article/details/81697403\r\n\r\n这篇文章讲述了可能一段处于fin-wait-1，另一端establish的情况。tcp假连接。	2018-12-24 18:53:17.005106	f
428	146	Issue	6	书名：《成就最美好的自己》\r\n\r\n  摘录（请让我知道一个真实的你-风格测试）：\r\n人人都想拥有自己独特的风格，风格由你的身、心组成，只是隐而未现，你不能发现，是因为你对自己的了解、接受、表达都还不足够。\r\n打开自己的心扉，坦言自己喜欢的一切以及惧怕的一切，因为你的风格一定是丰富的组合，而不是单一、一成不变的单调形象。你会发现一个新的我，一个完整的自我。没有自我的人，不会有风格。梳理内心是形象设计的第一步。\r\n要记住，寻找自我风格是为了自身的建设和完整，不是为了虚荣。你将得到的风格是属于你个人的，自在的，你才能驾驭的游刃有余。\r\n\r\n感悟心得：\r\n寻找风格是一个寻找自我的过程，观察自己的事业、生活、婚姻、学习成长，感知自己的快乐、痛苦、幸福等情绪，梳理自己的内心，了解原本的自己以及自我的需求，坦然接纳真实的自我，进而会更加有力量去进行自身的建设和完善，展现出独一无二的自己。	2018-11-16 21:08:22.456587	f
431	146	Issue	6	胡冬寅十月读书（33-48）\r\n\r\n书名：《成就最美好的自己》\r\n\r\n  摘录（体型-无论你是纤、婷端、端、盈，都应学会欣赏自己）：\r\n  我发现她冷暖两色都可以驾驭，她喜欢穿黑白两色相间的几何图案的裙子，典型的冬季型，使她看起来很power，很利落清洁，与她的直短发相得益彰，也将她的知性衬托的很到位；但是，她也穿大地色的服饰，她穿起典型秋季型咖啡色的卡丁衫来，显得特别温柔、文雅......我明白这些都是因为她有发自内心的爱和喜乐。她的身心都散发着人们称之为自信的气质，使她的言行举止充满了得体的悠然，也使她的体形和丰盈的内心浑然一体，成为一种美妙的承载。我清楚，那并非一般人认为的自信，因为自信的焦点还是在自己身上，但是信心是一种更大的恩赐。\r\n  感恩、爱、不嫉妒、喜乐，这就是你必须学习操练具备的。不论是谁，只要你爱美、希望自己美，它们会组成你美丽的信心。\r\n\r\n感悟心得：不论自己的体形是纤、婷、端、盈，我们都必须学习感恩、爱、不嫉妒、喜乐，不断操练，最终具备，成长为一个拥有信心的美丽女人。	2018-11-16 21:10:06.410132	f
430	146	Issue	6	胡冬寅十月读书（21-32）\r\n\r\n书名：《成就最美好的自己》\r\n\r\n  摘录（体型-无论你是纤、婷端、端、盈，都应学会欣赏自己）：\r\n《风中的杰奎琳》是一副摄影名作，我深深地照片中的杰奎琳吸引。吸引我的是她在不经意的回首中那份信心，她挺拔的身姿和摆动的胳膊出奇地美丽，尽管胸部小的像个刚发育的孩子，却充满了独特的性感，这性感源于对生命的接受和欣赏......倘若还存留一丝自己造的厌憎和不满，就无法拥有这份美丽。\r\n女人，尽管都爱美，但少有人能够为自己的生命感恩，这个起点的缺乏，会使她们一生对美的追求都有偏离。\r\n\r\n感悟心得：魅力的完全绽放，需要自我接纳，心怀感恩；当我学会欣赏自己原本的样子，不再与自己为敌，油然而生一种自在而又舒坦的感觉，这便是生命的奇妙，学会欣赏，美就在心中生根发芽，终有一天长成大树。	2018-11-16 21:09:29.772045	f
432	146	Issue	6	胡冬寅十月读书（49-62）\r\n\r\n书名：《成就最美好的自己》\r\n\r\n  摘录（色彩-你能驾驭的颜色比你知道的还多）：       \r\n  颜色与人的关系绝不只是与肤色合适与否的问题，颜色与人的真正关系是内心、性格和气质的关系。\r\n  颜色会因为性情、年龄、环境、事由、时间段、款式、材质、使用部位等不同而改变它与人之间的关系，将这些考虑进去后，你会发现你以为不能用的颜色原来可以如此好看，你的选择原来可以如此广阔而又微妙。。。\r\n\r\n感悟心得：了解自我的色彩是为了更好的运用色彩，而不是为了把自己框定在一个既定的范围，当我们深层次理解色彩与人的关系，颜色也可以丰富在我们身上进行表达，而不在是限制。	2018-11-16 21:11:11.848944	f
433	146	Issue	6	胡冬寅十月读书（63-68））\r\n\r\n书名：《成就最美好的自己》\r\n\r\n  摘录（妆容-护肤：一堂专属于你的皮肤保养课）：\r\n  肤色，均匀光洁很重要，学会护养，学会真正实用的个人化妆术，是很享受很快乐的事，也是女性的一种修养，它能培养你从容细致的女性特质。\r\n  很多人问我有没有最简便的、最省时间的皮肤保养方法？我说：没有！世界上从来没有一样美好的事物是无需付出代价的。美丽属于愿意为美丽付出代价的女人，这代价中最重要的就是时间，因为这象征着坚持，坚持才能持守终身的美丽。     \r\n\r\n感悟心得：护肤，贵在坚持，就像吃饭刷牙一样，需要内化成为一种习惯，然而这种习惯的养成并不容易，需要投入时间和精力，我们一旦坚持，时间会将最好的结果回馈给我们。	2018-11-16 21:11:48.083867	f
434	146	Issue	6	胡冬寅十月读书（69-74）\r\n\r\n书名：《成就最美好的自己》\r\n\r\n  摘录（妆容-美妆：把修养和信心描画在脸上）：\r\n  一张化过妆的脸，给自己和给他人的感觉都会更加安心。你只要试过就会明白那种安心的感觉，你不必为自己脸上的任何瑕疵担忧他人的看法，观者也不必为你脸上裸呈的瑕疵付出怜悯、安慰的义务。你的妆容甚至代表你的涵养，代表你将自己的隐私管理得当。\r\n\r\n感悟心得:精致的妆容如同干净整洁的房间带给我的感觉，会让我安心自在。每天为自己画个精致的妆，心情愉悦的拥抱生活和工作！	2018-11-16 21:12:19.533979	f
435	146	Issue	6	胡冬寅十月读书（75-84）\r\n\r\n书名：《成就最美好的自己》\r\n\r\n  摘录（管理你的衣橱-整理衣橱前先要明白的事情）：\r\n衣橱整理可以发现一个人在犯些什么错误，错误就是你购买收藏了多少不适合自己的衣物，你保留了多少已经无法穿着旧物，当然其中也包括“新的旧衣服”\r\n不穿的衣服是每个女人都要付出的学费，这笔学费付过之后，才能获得有魅力的、有生命力的衣橱。\r\n衣橱整理，是一个祝福，是帮助你结束不该再犯的错误，并且找回原本就该属于你的美丽。\r\n如果你想买一件便宜衣服，它必须看起来很贵。如果你想买一件很贵的衣服，它必须物有所值。\r\n\r\n\r\n感悟心得：衣橱就如我们的身体，当觉得那里出了问题时，需要给衣橱来个专业的诊断，找对病症，对症下药的去“医治”，结束我们曾经犯错误的方式，然后一点点的去建设属于我们怦然心动的衣橱。	2018-11-16 21:13:27.570433	f
436	146	Issue	6	胡冬寅十一月读书（85-91）\r\n\r\n书名：《成就最美好的自己》\r\n\r\n管理你的衣橱-衣橱里的经典收藏（经典款式：衣橱主干）\r\n\r\n  摘录：\r\n打开你的衣橱，你最需要的会是什么？是随手拿出来穿都不会出错的衣服。\r\n你是否拥有最适合你的衣橱主干，有一个最好的检验方法就是：第一，你的每种经典基本款完全可以互相搭配。第二，你的主干衣橱会使你出席任何场合时（不知道其他人怎么穿，不知道场面到底有多大）显得优雅得体，并且使你感到自在，还使得他人对你微笑。\r\n\r\n感悟心得：建立属于自己风格的衣橱主干，每个早晨都不再手忙脚乱，穿衣变成一件简单且高效的事情，那将是一种美好而幸福的体验	2018-11-16 21:14:14.809847	f
437	146	Issue	6	胡冬寅十一月读书（91-95）\r\n\r\n书名：《成就最美好的自己》\r\n\r\n管理你的衣橱-衣橱里的经典收藏（礼服和晚装：衣橱光芒）\r\n\r\n  摘录：\r\n当人们看到你的光芒时，不会有一丝想要模仿的意念，因为那就是你的，不可替代，唯有你能够驾驭！这才是该属于你的惊艳之作。\r\n最适合的颜色+最适合的特殊面料+最精到的裁剪+最具独特气质的风格语言=你的个人光芒\r\n\r\n感悟心得：找到属于自己的惊艳之作，散发出属于自己的光芒，嗯，一定能够有那么一件衣服在等着自己去发现，充满期待~	2018-11-16 21:14:46.096251	f
438	171	Issue	5	multipart不一样主要在于其操作分为多个且是客户端发起的，客户端可能发出完全重复请求。\r\n非multipart对象残留可以通过丢入gc的方式处理掉。但是multipart如果对象名完全一样，丢入gc处理不合适。\r\n\r\n在前端读取manifest，然后在rgw合并成一个manifest，这些都没原子性保护。	2018-11-17 07:49:35.332356	f
439	171	Issue	5	目前multipart中间的part是跟版本没关系的。只有最后完成时有版本号。支持重复执行，加上版本号看看。	2018-11-17 08:11:01.125596	f
440	171	Issue	5	multipart的分片head对象名字应该通过get_part函数获取，目前能正确，纯属巧合。	2018-11-17 08:37:45.633789	f
441	171	Issue	5	在两个地方注入测试：\r\n1，在put完成 wait_pending_front中测试，观察对象总数和rados对象是否残留\r\n2，在bi写入注入失败，看对象数量和rados对象是否残留	2018-11-17 13:47:57.329457	f
442	171	Issue	5	还发现一个问题：以前分片上传 分片第一个对象总是使用obj名称定位，这样总会定位到第一个对象？\r\n\r\n不对， index_hash_source就是给bs用的，其他对象就算赋值了也没关系，不会使用。	2018-11-17 15:06:32.78793	f
489	165	Issue	5	有些任务可以交由其他人来push完成。\r\n组织也许只有一个leader + 几个成员。但是有些任务可交给其他成员负责，否则所有事情一个人trace会力不从心。\r\n\r\n比如近期把培训任务交给天伟负责感觉就好很多。	2018-12-06 14:08:57.842512	f
455	172	Issue	6	【要点1】\r\n*分离焦虑在所难免。*分离焦虑始于一岁左右，但在幼儿园阶段表现的尤为明显，因为幼儿园期间孩子第一次真正走出家庭、步入新环境，我们也希望孩子能够顺利地度过这个阶段。\r\n*没有任何养育方法能让孩子的亲子分离过程轻松简单。*\r\n因此我们要正确预测到：还在在跟我们分别的时候，一定会大哭；面对孩子大哭的时候，我们自己也很可能产生负情绪，如烦躁（这孩子怎么这么不懂事，跟你说了妈妈一会儿就回来）或者内疚（宝宝好可怜，妈妈对不起你）。\r\n*我们要想帮助孩子，那么首先要处理好自己内心的情绪。*\r\n\r\n【要点2】\r\n*虽有分离，亦有重逢。*要想帮孩子适应分离，就必须让孩子在完整的过程中获得完整的体验：完整的过程是既有分离又有重逢，那么相应的完整体验就是分离是的难过，和重逢时的快乐。\r\n*因此，我们不能只关注如何跟孩子分离，还必须话心思、花精力来跟孩子快乐重逢。*\r\n\r\n【要点3】\r\n*重逢时，重联结与掌控感--重点来谈幼儿园阶段孩子的“藏猫猫”游戏。*\r\n很多专业人士认为，藏猫猫游戏中所包含的元素，跟“分离与重逢”的生活主题直接相关。孩子藏猫猫的过程中，其实一遍又一遍地体验“我藏起来了，爸爸妈妈找不到我；我出来了，爸爸妈妈找到我了”这样的过程。\r\n这个游戏不仅直接涉及到“分离与重逢”这个重要主题，而且孩子是具备掌控力的乙方--在这个游戏中，由孩子控制“分离与重逢”的节奏。这对于孩子获得心理平衡由着重要的意义。\r\n\r\n	2018-11-28 09:29:24.69731	f
456	178	Issue	6		2018-11-28 11:15:34.680677	f
457	148	Issue	6		2018-11-28 11:16:08.420295	f
458	161	Issue	6		2018-11-28 11:16:46.404963	f
459	162	Issue	6		2018-11-28 11:32:13.751752	f
461	182	Issue	6	左右脑\r\n左脑：严谨的老学究\r\n\r\n全脑启蒙要点之一：\r\n先对右脑“投其所好”，在引导孩子使用左脑	2018-11-28 14:26:16.408737	f
470	149	Issue	5	zone元数据实际上只与同步rgw有关系。可以分离出来。	2018-12-01 18:58:27.37356	f
472	149	Issue	5	架构有点不得不考虑的是随着云化的不断增强，新的软件产品可能是云平台的一部分。\r\n软件厂商应该可以快速的接入到云平台。以利用平台统一的管理和运维。	2018-12-01 19:19:23.621843	f
473	185	Issue	5	1，力都是从脚到核心，到肩部，大臂，小臂，手。以及连接关节。\r\n2，如果需要最大的挥速，最好把每部分都加速起来。当一节完成加速时，其他节都是放松的。但是能借到速度，击打完球后即可收回，发力高效干净利落。不要过度发力，发力距离也不必过长。过度发力通常意味着不够放松，不放松加速效果必然不好。\r\n3，击球点，每次都应该是差不多的。\r\n4，显然不起跳的高远球侧身也不必那么多，不然不是扭腿么。需要侧身的球通常都是要起跳的，整个身体有一个扭转。	2018-12-02 12:50:25.109504	f
475	165	Issue	5	任务管理，还有重要方面就是工作遗漏，比如要出版本了，再去执行社区bugfix同步显然是不合适的。\r\n	2018-12-03 07:10:15.340783	f
488	200	Issue	5	一个zone对应一个集群？\r\n不是这样的，zone的概念是区域，一个区域理论上可以有多个集群。\r\n\r\n但是rgw的placement对应的是pool。必然与集群耦合。\r\n这中间少了一层集群。\r\n\r\n在rgw的配置项中，应该有个列表，zone名称，对应的集群列表。\r\n\r\nzonegroup是一组有同步关系的zone，不同zonegroup没同步关系。\r\n\r\n\r\n公有云一般试用方式是选择区域。但是区域内怎么部署上层不感知。\r\n\r\n在multisite设计中每个rgw角色对等的，所以社区定义zone概念就是rgw instance的集合。但是我们实际用的时候是分离的，zone的信息中只看到了同步rgw。\r\n\r\n按照当前的思路走下去，业务根本不必感知zone，业务rgw与zone关联变弱。\r\n那么如何支持将bucket创建在指定zone呢？\r\n\r\nzone元数据同步这块能够改进？\r\n是否搞成同步执行模式，在同步rgw挂掉的时候，找到master先完成元数据同步？\r\n\r\n长期来看，必须支持自己的sdk，我们可以保持与s3兼容，但是有些地方可能不得不扩展。比如像区域定义这些。私有云客户如何灵活使用多站点？\r\n\r\n支持单个对象的存储类型，Amazon如何控制单个对象的存储类型？\r\n\r\n我目前感觉，如果不充分熟悉s3，并结合我们产品的最终形态考量。\r\n仅仅是剥离librgw的接口抽象这工作将难以进行。\r\n对象存储的概念都是来源于s3，设计上无法脱离。\r\n\r\n其实我们的目标是剥离出强依赖librados的部分作为librgw。\r\n在切换版本之后，我们仍然可以工作，而且只需编译rgw相关部分。\r\n可独立出包。\r\n\r\n抽离rgw与rados强关联部分为librgw_rados，使得在切换rados版本时，只需升级librgw_rados即可。librgw_rados模块由rados引擎组统一维护.\r\n\r\nrgw可考虑使用静态编译，编成独立程序。\r\n现在比较难搞的是cls这块，只有切换DB，重新设计rgw元数据才好解决。	2018-12-06 12:25:44.099952	f
480	197	Issue	5	做精品，需要有切入点，这切入点通常是技术变革，新的论文，新的技术推出的时候。这时创业公司存在机会从一点很强做到单品很强。\r\n\r\n做生态必须得有内容，有数据，否则不具备粘性。像亚马逊，阿里和腾讯是生态的杰出代表。 百度从形态上还是一个单品。苹果是那极端的例子，苹果是生态和产品一手抓的。\r\n\r\n巨大的变革，指数级别的增长，新生的生态，燃爆的技术点。是这个时代的明星。\r\n\r\n\r\n	2018-12-04 13:09:59.443697	f
482	198	Issue	5	例子：\r\n目标机器：目标-计划-执行-优化\r\n堆积知识：一个知识点，一个问题，一步一步走下去。\r\n软件稳定的方法：不断补充的自动化测试	2018-12-04 13:16:31.891795	f
479	186	Issue	5	技术竞争力\r\n1，难点技术\r\n\r\n多数据中心\r\n海量小文件\r\nbucket支持海量数据\r\n无感扩容\r\n数据检索\r\n\r\n2，交付能力\r\n架构松耦合具备良好扩展性，快速集成能力\r\n自动化测试覆盖，软件版本快速稳定\r\n\r\n3，基础能力\r\n存储基本功能\r\n性能提升（升级rados）\r\n\r\n4，差异化定位\r\n  定位市场，出于对市场差异的认知，确定产品差异技术点.比如华为手机定位的变化。\r\n  \r\n5，进入门槛\r\n  进入门槛一方面是资质类的，另一些是由于先入完成了圈地导致的。\r\n  先入企业掌握了数据，引导了用户认知，导致其他对手难以进入。不过2B产品在这面与2C产品可能不太一样。	2018-12-04 12:45:51.382752	f
483	186	Issue	5	国毅提出的想法是做行业生态，结合上游企业，做行业解决方案。	2018-12-04 15:46:47.828873	f
484	186	Issue	5	最终结果可能是大而不强，技术平平。\r\n\r\n公司策略如果是通过业务扩展来获取融资，与通过技术创新获取融资是不一样的。\r\n从目前情况来看我们可能难以在技术创新上得以发展，最终业务玩的好可能就是宏杉的情况。\r\n了解宏杉和深信服，如果没有革新，也许他们就是我们的未来。	2018-12-04 15:47:13.851809	f
486	199	Issue	5	羽毛球我喜欢研究发力，但羽毛球还有很多其他方面，装备，场地，赛事，人物，技术流派，策略等。\r\n软件我喜欢研究架构，但是软件还有开发，测试，语言，平台，工程，项目管理，产品，行业等等。\r\n\r\n想成专业人士，那就不仅是看电影精彩的部分，还得搞清拍摄过程各种细节。\r\n\r\n每个环节其实都可以很有趣，不要限制自己于固定环节。	2018-12-05 08:29:01.942178	f
487	149	Issue	5	*架构设计需要有整体格局* 不能搞盲人摸象式的设计	2018-12-06 11:39:30.034726	f
490	195	Issue	5	rgw committer要求：\r\n1，责任心和认真细致的精神\r\n2，掌握rgw大部分模块原理及实现\r\n3，设计并实现至少一个rgw重要功能\r\n4，掌握公司编程规范\r\n5，掌握提交要求(涉及文档，提交规范，测试规范等)	2018-12-06 14:13:20.516925	f
491	207	Issue	5	第一点的补充：虽然前中场发力可能没手臂打开的过程，但是最终效果手臂还是打开的。所以挥拍举拍的空间仍然要有。\r\n保持身体的平衡。	2018-12-08 21:02:49.649326	f
494	209	Issue	5	在objecter增加注入测试，验证watch/notify超时情况下。最终rgw是否能够更新period。\r\n观察是否reload	2018-12-13 14:43:38.509542	f
498	4	Issue	5	请求在nginx未阻塞，如何证明？\r\n\r\ncurl请求在100多s之后仍然能结束，返回502错误。\r\n重启nginx，超时现象仍然不会消失。\r\n看来唯有重启rgw才能拯救了。\r\n\r\nnginx停了一个晚上 rgw都没恢复。\r\n\r\n从2个角度分析问题：\r\n1，read系统调用什么情况下会一直卡住\r\n2，从网络协议上排查是否存在这种可能性	2018-12-17 16:19:37.120649	f
514	4	Issue	5		2018-12-24 18:55:30.844873	f
515	4	Issue	5		2018-12-24 18:55:48.71135	f
466	184	Issue	5	移动三要素：\r\n1，启动步\r\n2，节奏，前场步伐快，杀球回动快，高远回动慢等，要有这种节奏意识。\r\n3，步伐搭配，第一步小，最后一步大。利用击球力量来回动，反弹第一步。\r\n\r\n手上功夫：\r\n1，松握紧打\r\n2，长甩短抖\r\n       逐节发力，其实大臂用不了多少力。大臂运动到位，小臂手腕甩起来。\r\n3，正侧反背\r\n4，肘在上方\r\n体会甩，啪啪的感觉。\r\n5，慢甩试试\r\n\r\n反手功夫：\r\n转换握拍\r\n侧身\r\n迅速回动\r\n抬肘\r\n\r\n节奏：\r\n高远慢回，杀球和网前快速准备\r\n对方出球，我发小跳启动\r\n借势回第一步。\r\n预判球线路，在自己步伐最快到达的地方击球\r\n\r\n有了启动步和侧身，步伐明显上升一个层次。打球有了一种节奏感。\r\n\r\n策略\r\n\r\n新问题：\r\n挥拍太慢，有些球来不及打。导致不流畅。错过最佳击球点。身前球有时候举拍太慢\r\n步伐上接靠边杀球要用跨步，拍子伸直了打。\r\n羽毛球就是玩节奏，步伐手法与球速的完美匹配，移动到合适的地方，协调的完成击球。\r\n\r\n有时候步伐沉重不是步伐问题，是身体疲惫，无法调动状态。\r\n\r\n挥拍过程中肩膀和手都是刚性的，蹬地加速收腹加速肩膀，光这个速度算上球拍应该足以把球打到中场。这时小臂还是折叠状态，此时打开小臂进一步加速，最后握紧完成传递。\r\n\r\n问题：引拍的目的是为了加大进程，让拍在大臂固定时有一个速度，很简单你不引拍试下球拍加速不起来，实际击球点在上方夹角80左右。\r\n\r\n问题2:你试下不蹬地，跳不起来。如果你只用小腿，一会就累的不行。步伐的发力主要在髋部和核心力量上。	2018-12-01 16:23:34.693671	f
467	184	Issue	5	高远和杀球本周终于有点感觉了，放松手腕。不必提前太多引拍，否则中间得减速。小臂内旋，手腕抓紧。杀球与高远类似，因为击球点不一样，手臂打直的点不一样，杀球更靠前，所以杀球的引拍可以比高远小点\r\n\r\n羽毛球发力的核心就是松紧松，想像整个人都舒展，手臂完全放松，加速击球瞬间紧，然后又松的过程，简直爽爆了。\r\n\r\n整个手臂放松\r\n不同的角度打开手臂\r\n回环引拍\r\n狂练吧\r\n\r\n所有球的击球都是干净利落的，准备姿势是协调动作的，击球瞬间停顿，也就是闪腕，可以让球出去速度很快且不容易出界，短促击球初速度快且没有加速度。\r\n\r\n抖腕闪腕并非指手腕发力，手腕是放松的，实际是大臂小臂拉动手腕，手指抓紧的过程。\r\n\r\n回环引拍是一个过程，不要先引到一半，尤其是平抽挡，先拉好则击球方向已经确定。\r\n\r\n	2018-12-01 16:23:47.620071	f
468	184	Issue	5	反手拇指顶压力不够，可能是展腕练习太少，手指无力。\r\n曲指发力和拳握是一回事吗？感受拍面形变是什么感觉\r\n\r\n反手的核心在于手臂是展开运动，想借助手臂力量，则手臂运动方向要注意。与正手一样，正手手臂不升值则力量来源于小臂旋转和抖腕的力量。在击球瞬间手臂是完全打开的。\r\n\r\n手臂是垂直打开的，不是水平运动\r\n\r\n准备姿势重心在双脚，注意准备握拍总是在同一高度，在转身架拍或下蹲架拍时，基本不用调整则拍就在正确位置。\r\n\r\n如何好球都是良好架拍开始的，架拍合适了说明步伐到位了，并且完成了全身的发力的准备。没有步伐就没有发力就是这个道理。为什么状态不好，腿跑不动时必然球打不好就是这道理。\r\n\r\n架拍除了高远的侧身，反手的转身，还有前场的弓箭步，中场的下蹲等。看别人打球看的是什么，是因果。\r\n\r\n发力总是大端带动小端，但是技术难点在小端。在甩动的最后环节，甩到位之后停住，小端要握紧屏住。发力时全身的平衡也非常重要。\r\n\r\n高远击球瞬间除了内旋还有手腕外展，变成拳握，以便更好的握紧球拍发力以及收拍，看林丹，傅海峰等杀球慢动作便知。\r\n\r\n还有网前球正反手统一使用斜面握拍更好发力。其实每个点击球握拍都有点区别，反手上方网前大拇指顶宽面好发力。但是侧面和下方顶宽面不好发力\r\n\r\n发力细节的掌握，其他就是练了。\r\n\r\n宁可打不到球，也要按标准做动作，这点非常重要，不要总是用错误方式弥补前面的错误。\r\n	2018-12-01 16:24:03.5366	f
469	149	Issue	5	将MOS产品分为业务类模块和接口类模块，业务类模块包括：RGW主业务模块，后端处理模块、同步处理模块、后处理模块。这几个模块仍使用J版本的框架进行编写、实现和编译。即将这几个模块作为一个独立的产品进行编译和打包。这样一来，变化最大的业务类模块可以后续一直独立在J版本的框架上独立发展，跟社区完全没有关系。 要达到这一目标，需要用第三方DB把目前用到的rados的cls模块给剥离出来，这个是最终的一道门槛。\r\n\r\n\r\n\r\n接口类模块，即librgw.so，这个动态库主要完成了RGW业务与RADOS之间进行交互逻辑的封装，它跟随社区版本进行升级。由于只提供了对接rados的处理，所以后续跟随社区rados升级是很容易的事情。该动态库需要跟引擎平台（引擎平台跟随ceph大版本升级）一起编译，是引擎平台的代码的一部分。librgw.so跟MOS业务类模块之间只通过头文件进行感知，通过动态链接的方式进行调用。	2018-12-01 18:55:10.908476	f
471	149	Issue	5	考虑点：\r\n1，有状态，无状态\r\n2，有cache，无cache\r\n3，CAP\r\n4，share nothing， share storage\r\n5，performance sensible	2018-12-01 19:02:49.985926	f
474	186	Issue	5	开发自测框架也要搞起来，另外软件内部的打桩测试，以及各种手段应该加入，确保所有出现的问题都可以使用用例覆盖。\r\n所有调用底层模块的函数都应该可以模拟。\r\n\r\n为什么自验证流于形式，难以全面？笨马战法。战略正确，有确切的方法不断前进。\r\n自验做不起来一个原因就是没有好的框架来做这个事。\r\n\r\n代码review做不起来，是因为分工，安排上存在问题。\r\n核心员工可留作开发核心特性，review方案和代码。\r\n中层员工完成中等特性设计，代码开发\r\n初级员工完成特性优化，bugfix等。\r\n	2018-12-02 14:13:50.936038	f
476	194	Issue	5	checklist：\r\n1，需求说明\r\n2，原理，模块设计\r\n3，使用文档\r\n4，规格\r\n5，命令参数\r\n6，review\r\n7，计划点，检查点，任务详细计划。	2018-12-03 12:38:14.918886	f
477	195	Issue	5	项目经理职责：\r\n1，跟踪项目任务，推动项目进展\r\n2，确定项目变更，确认各种是否合规，了解项目风险。	2018-12-03 12:45:34.835705	f
478	196	Issue	5	项目经理应该有个任务表，任务应该做到不遗漏，可跟踪可执行。\r\n1 根据目标列举所有任务\r\n\r\n2 完成任务分配，人与任务的匹配\r\n\r\n3 确定每个任务的执行标准，每个任务做完善\r\n软件开发每个环节的任务，需求分析，方案设计，代码开发，review，测试，文档等。\r\n不求面面俱到，但是每步做到位才是最快的方式。\r\n\r\n4 跟踪进度风险，时间，协调解决难题	2018-12-04 06:17:19.184877	f
481	129	Issue	5	建立测试用例，自动化测试，这一个笨方法。	2018-12-04 13:12:10.89551	f
564	214	Issue	5	看风云变幻，听潮起潮落。\r\n不同层次的人看到的世界不一样，大脑中运行的程序逻辑不一样。	2019-01-14 06:55:09.66683	f
492	208	Issue	5	2018-12-11 16:16:19.543752 7f5d32377700  5  reset timeout for put obj testobj5221\r\n2018-12-11 16:17:52.987317 7f5d32377700  1 throttle(objecter_ops 0x7f5dcbd95268) get throttle timeout\r\n2018-12-11 16:17:52.987499 7f5d32377700  0 ERROR: write_meta complete failed -110\r\n2018-12-11 16:17:52.987585 7f5d32377700  3 NOTE: put failed, add gc obj test3:testobj5221.G8IEZwyBlY6kIS42sbYcN2Tazj7-3hu\r\n\r\n2018-12-11 16:18:20.535090 7f5d32377700  3 req 1246:120.992756:s3:PUT /test3/testobj5221:put_obj:test3/testobj5221null :completing\r\n2018-12-11 16:18:20.535401 7f5d32377700  3 req 1246:120.993067:s3:PUT /test3/testobj5221:put_obj:test3/testobj5221null :op status=-110\r\n2018-12-11 16:18:20.535424 7f5d32377700  3 req 1246:120.993090:s3:PUT /test3/testobj5221:put_obj:test3/testobj5221null :http status=408\r\n2018-12-11 16:18:20.535453 7f5d32377700  2 ====== req done req=0x7f5c50ca01a0 obj=test3/testobj5221null op status=-110 op name=put_obj http_status=408 ======\r\n2018-12-11 16:18:20.535772 7f5d32377700  1 heartbeat_map reset_timeout 'RGWProcess::m_tp thread 0x7f5d32377700' had timed out after 120\r\n2018-12-11 16:18:20.535804 7f5d32377700  1 heartbeat_map reset_timeout 'RGWProcess::m_tp thread 0x7f5d32377700' had suicide timed out after 120\r\n\r\n\r\n#7  0x00007f5dde223ff5 in ceph::HeartbeatMap::_check (this=0x7f5dcbc4b160, h=0x7f5c68850040, who=0x7f5dde5e33ce "reset_timeout", now=1544516300) at common/HeartbeatMap.cc:86\r\n#8  0x00007f5dde2241f3 in ceph::HeartbeatMap::reset_timeout (this=0x7f5dcbc4b160, h=0x7f5c68850040, grace=60, suicide_grace=0) at common/HeartbeatMap.cc:96\r\n#9  0x00007f5dde3dd586 in ThreadPool::worker (this=0x7f5dcbc25070, wt=0x7f5da1037d60) at common/WorkQueue.cc:148\r\n\r\n在程序运行慢的时候仍然会出现。reset 超时之后，仍然有几步get state，修改bi等。\r\n	2018-12-11 15:39:03.556738	f
493	200	Issue	5	还有一个思路就是让rgw使用rados的c接口，rados不暴漏除接口之外的其他common类。\r\n社区版本rgw下面增加了service，这里也可关注下。\r\nrgw工程做相应调整。	2018-12-12 13:26:32.731375	f
495	4	Issue	5	Thread 683 (Thread 0x7f0622bfc700 (LWP 4889)):\r\n#0  0x00007f06625dd7fd in read () from /lib64/libpthread.so.0\r\n#1  0x00007f06629f5ba9 in OS_Read () from /var/lib/ceph/lib/libfcgi.so.0\r\n#2  0x00007f06629f4193 in ?? () from /var/lib/ceph/lib/libfcgi.so.0\r\n#3  0x00007f06629f4757 in FCGX_Accept_r () from /var/lib/ceph/lib/libfcgi.so.0\r\n#4  0x00007f066cfd6287 in RGWFCGXProcess::run (this=0x7f0652825a00) at rgw/rgw_fcgi_process.cc:110\r\n#5  0x00007f066cfe8dee in RGWProcessControlThread::entry (this=<optimized out>) at rgw/rgw_process.h:270\r\n#6  0x00007f06625d6e25 in start_thread () from /lib64/libpthread.so.0\r\n#7  0x00007f0661bdebad in clone () from /lib64/libc.so.6	2018-12-17 09:11:26.062187	f
496	4	Issue	5	[root@localhost ceph]# netstat -anp | grep 1233\r\ntcp      129      0 0.0.0.0:1233            0.0.0.0:*               LISTEN      4670/radosgw        \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55624         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55792         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56732         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56212         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56158         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56316         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56364         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56368         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55798         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56318         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55864         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56600         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56536         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56384         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55932         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55866         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55788         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56370         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55818         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55860         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55808         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55626         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56752         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55810         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55562         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56530         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55962         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55894         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55976         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56304         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56584         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55630         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55980         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56344         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56534         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56346         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56532         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56540         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56270         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55934         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55942         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55790         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55344         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55814         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55312         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56302         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55282         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55816         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55856         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55796         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55628         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56338         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56266         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56262         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55806         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55958         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56762         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56306         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55858         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56838         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55944         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56528         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56068         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56878         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56222         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55448         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56264         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55606         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55940         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56854         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56268         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55974         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:55634         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56836         SYN_RECV    -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:56586         SYN_RECV    -                   \r\ntcp        0   1265 127.0.0.1:55626         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0   1264 127.0.0.1:55980         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0   1264 127.0.0.1:56318         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55854         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56560         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp      921      0 127.0.0.1:1233          127.0.0.1:59726         CLOSE_WAIT  -                   \r\ntcp        0    920 127.0.0.1:56264         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp      921      0 127.0.0.1:1233          127.0.0.1:59714         CLOSE_WAIT  -                   \r\ntcp        0    913 127.0.0.1:54864         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    920 127.0.0.1:56838         127.0.0.1:1233          ESTABLISHED 45709/nginx: worker \r\ntcp        0   1264 127.0.0.1:56600         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56664         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56166         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    921 127.0.0.1:55346         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56356         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56676         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56650         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56170         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56354         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1265 127.0.0.1:55162         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56314         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    920 127.0.0.1:56854         127.0.0.1:1233          ESTABLISHED 45709/nginx: worker \r\ntcp        0   1265 127.0.0.1:55170         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56144         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp      921      0 127.0.0.1:1233          127.0.0.1:59708         CLOSE_WAIT  -                   \r\ntcp        0    921 127.0.0.1:55630         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp      921      0 127.0.0.1:1233          127.0.0.1:59712         CLOSE_WAIT  -                   \r\ntcp        0   1264 127.0.0.1:56836         127.0.0.1:1233          ESTABLISHED 45709/nginx: worker \r\ntcp      921      0 127.0.0.1:1233          127.0.0.1:60094         CLOSE_WAIT  -                   \r\ntcp        0      1 127.0.0.1:55800         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0    920 127.0.0.1:55810         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp     1265      0 127.0.0.1:1233          127.0.0.1:60148         CLOSE_WAIT  -                   \r\ntcp        0   1264 127.0.0.1:55974         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0   1264 127.0.0.1:56270         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56020         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp     1265      0 127.0.0.1:1233          127.0.0.1:60144         CLOSE_WAIT  -                   \r\ntcp        0    920 127.0.0.1:56384         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0   1265 127.0.0.1:55160         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56626         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56016         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56742         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56632         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55986         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55802         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56162         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56024         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    921 127.0.0.1:55342         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0   1264 127.0.0.1:56262         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0   1265 127.0.0.1:54858         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:55852         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:55836         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0    921 127.0.0.1:55236         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    921 127.0.0.1:55080         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56012         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    921 127.0.0.1:55098         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    921 127.0.0.1:55606         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56358         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56348         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    577 127.0.0.1:56316         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    921 127.0.0.1:55136         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56604         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1264 127.0.0.1:55816         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0      1 127.0.0.1:55824         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56782         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1264 127.0.0.1:55866         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0   1264 127.0.0.1:56752         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56146         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1264 127.0.0.1:56346         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0   1265 127.0.0.1:55268         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0   1264 127.0.0.1:56158         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0    920 127.0.0.1:55856         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0    920 127.0.0.1:56534         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0    600 127.0.0.1:54856         127.0.0.1:1233          ESTABLISHED 45699/nginx: worker \r\ntcp        0      1 127.0.0.1:56776         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55964         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56546         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1264 127.0.0.1:55858         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0    920 127.0.0.1:56212         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56352         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    920 127.0.0.1:55944         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56004         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56000         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56656         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    920 127.0.0.1:55976         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55848         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56616         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1265 127.0.0.1:55282         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56772         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56164         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1265 127.0.0.1:54928         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56738         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1265 127.0.0.1:54574         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    600 127.0.0.1:55894         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0    920 127.0.0.1:56732         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56662         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56362         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56640         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    921 127.0.0.1:54866         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    921 127.0.0.1:54576         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0   1264 127.0.0.1:55958         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0    921 127.0.0.1:54686         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0   1264 127.0.0.1:55940         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56602         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56734         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56360         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56636         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    921 127.0.0.1:55422         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56668         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56630         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56160         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56740         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55804         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:55992         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55846         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:55862         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56880         127.0.0.1:1233          SYN_SENT    45709/nginx: worker \r\ntcp        0   1264 127.0.0.1:55792         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0    920 127.0.0.1:56344         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp     1265      0 127.0.0.1:1233          127.0.0.1:60142         CLOSE_WAIT  -                   \r\ntcp        0      1 127.0.0.1:56008         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55998         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1264 127.0.0.1:56306         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56658         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56736         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    920 127.0.0.1:56370         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55828         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56142         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1264 127.0.0.1:56304         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56002         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    920 127.0.0.1:55790         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56778         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    921 127.0.0.1:55240         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56624         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56310         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56672         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    920 127.0.0.1:56364         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56748         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56646         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1265 127.0.0.1:55338         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    921 127.0.0.1:54684         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      0 127.0.0.1:1233          127.0.0.1:60190         ESTABLISHED 4670/radosgw        \r\ntcp        0      1 127.0.0.1:56638         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1264 127.0.0.1:56586         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0    577 127.0.0.1:55788         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    920 127.0.0.1:55864         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0      1 127.0.0.1:55996         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56312         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55832         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:55982         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    920 127.0.0.1:56532         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55838         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56674         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56654         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56014         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    920 127.0.0.1:55798         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0   1265 127.0.0.1:55300         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56018         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55990         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55840         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56784         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56350         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1265 127.0.0.1:55278         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp     1265      0 127.0.0.1:1233          127.0.0.1:59718         CLOSE_WAIT  -                   \r\ntcp        0      1 127.0.0.1:56148         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56168         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    920 127.0.0.1:55860         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp      921      0 127.0.0.1:1233          127.0.0.1:59514         CLOSE_WAIT  -                   \r\ntcp        0   1264 127.0.0.1:56762         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56542         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56620         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    921 127.0.0.1:55424         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    920 127.0.0.1:56530         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55842         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0   1265 127.0.0.1:55298         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0   1264 127.0.0.1:56302         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56642         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    921 127.0.0.1:55628         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:55960         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    913 127.0.0.1:55624         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56320         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55844         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56780         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    921 127.0.0.1:54932         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    921 127.0.0.1:55296         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56800         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    600 127.0.0.1:55096         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0   1264 127.0.0.1:56584         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56744         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp     1265      0 127.0.0.1:1233          127.0.0.1:60146         CLOSE_WAIT  -                   \r\ntcp        0      1 127.0.0.1:55820         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56610         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    600 127.0.0.1:56338         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56666         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    920 127.0.0.1:56540         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0    920 127.0.0.1:56266         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55984         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55834         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0   1265 127.0.0.1:54360         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    881 127.0.0.1:56068         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:55794         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56628         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1265 127.0.0.1:54976         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    921 127.0.0.1:55312         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    921 127.0.0.1:54930         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    920 127.0.0.1:55932         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0   1264 127.0.0.1:55942         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56612         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    921 127.0.0.1:55304         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56652         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1264 127.0.0.1:55808         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0   1264 127.0.0.1:56368         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56644         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    920 127.0.0.1:55796         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0    920 127.0.0.1:56268         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0    920 127.0.0.1:55934         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56606         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55850         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0   1264 127.0.0.1:56222         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0    921 127.0.0.1:55164         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp      921      0 127.0.0.1:1233          127.0.0.1:59710         CLOSE_WAIT  -                   \r\ntcp        0      1 127.0.0.1:56010         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55994         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56022         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55830         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp     1265      0 127.0.0.1:1233          127.0.0.1:59690         CLOSE_WAIT  -                   \r\ntcp        0   1265 127.0.0.1:54502         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    600 127.0.0.1:55334         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0   1265 127.0.0.1:55344         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0   1265 127.0.0.1:55448         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56308         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56678         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp     1265      0 127.0.0.1:1233          127.0.0.1:60072         CLOSE_WAIT  -                   \r\ntcp        0    921 127.0.0.1:55302         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    921 127.0.0.1:55526         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    921 127.0.0.1:55228         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0   1264 127.0.0.1:56536         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker \r\ntcp        0   1264 127.0.0.1:55814         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56026         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56648         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp     1265      0 127.0.0.1:1233          127.0.0.1:59944         CLOSE_WAIT  -                   \r\ntcp        0    881 127.0.0.1:55294         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56786         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55826         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56618         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0   1265 127.0.0.1:55562         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    921 127.0.0.1:55340         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56634         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp     1265      0 127.0.0.1:1233          127.0.0.1:59700         CLOSE_WAIT  -                   \r\ntcp        0    921 127.0.0.1:55238         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0   1265 127.0.0.1:55604         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56750         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56746         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56660         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp      921      0 127.0.0.1:1233          127.0.0.1:60092         CLOSE_WAIT  -                   \r\ntcp        0   1265 127.0.0.1:55634         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    921 127.0.0.1:55336         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0      1 127.0.0.1:56670         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56006         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56608         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56804         127.0.0.1:1233          SYN_SENT    45709/nginx: worker \r\ntcp        0      1 127.0.0.1:56774         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp      921      0 127.0.0.1:1233          127.0.0.1:59716         CLOSE_WAIT  -                   \r\ntcp        0   1264 127.0.0.1:55818         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56806         127.0.0.1:1233          SYN_SENT    45709/nginx: worker \r\ntcp        0      1 127.0.0.1:56802         127.0.0.1:1233          SYN_SENT    45709/nginx: worker \r\ntcp        0    577 127.0.0.1:56528         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    577 127.0.0.1:54830         127.0.0.1:1233          FIN_WAIT1   -                   \r\ntcp        0    920 127.0.0.1:55806         127.0.0.1:1233          ESTABLISHED 45716/nginx: worker \r\ntcp      921      0 127.0.0.1:1233          127.0.0.1:59354         CLOSE_WAIT  -                   \r\ntcp        0      1 127.0.0.1:56614         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55822         127.0.0.1:1233          SYN_SENT    45716/nginx: worker \r\ntcp        0      1 127.0.0.1:56562         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:56544         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp      913      0 127.0.0.1:1233          127.0.0.1:59698         CLOSE_WAIT  -                   \r\ntcp        0      1 127.0.0.1:55946         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0      1 127.0.0.1:55988         127.0.0.1:1233          SYN_SENT    45702/nginx: worker \r\ntcp        0    600 127.0.0.1:56878         127.0.0.1:1233          ESTABLISHED 45709/nginx: worker \r\ntcp        0    920 127.0.0.1:55962         127.0.0.1:1233          ESTABLISHED 45702/nginx: worker	2018-12-17 09:11:41.566922	f
497	4	Issue	5	nginx error log:\r\n\r\n2018/12/14 17:59:38 [error] 13641#0: *377504589 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.12.179, server: , request: "GET / HTTP/1.1", upstream: "fastcgi://127.0.0.1:1233", host: "192.168.12.179:8080"\r\n2018/12/14 18:01:03 [error] 13636#0: *377504641 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.12.179, server: , request: "GET / HTTP/1.1", upstream: "fastcgi://127.0.0.1:1233", host: "192.168.12.179:8080"\r\n2018/12/14 18:01:21 [error] 13634#0: *377504956 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.12.179, server: , request: "GET / HTTP/1.1", upstream: "fastcgi://127.0.0.1:1233", host: "192.168.12.179:8080"\r\n2018/12/14 18:02:47 [error] 13636#0: *377505330 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.12.179, server: , request: "GET / HTTP/1.1", upstream: "fastcgi://127.0.0.1:1233", host: "192.168.12.179:8080"\r\n2018/12/14 18:03:34 [error] 13631#0: *377505618 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.12.179, server: , request: "GET / HTTP/1.1", upstream: "fastcgi://127.0.0.1:1233", host: "192.168.12.179:8080"\r\n2018/12/14 18:04:33 [error] 13631#0: *377505936 recv() failed (104: Connection reset by peer) while reading response header from upstream, client: 192.168.12.179, server: , request: "GET / HTTP/1.1", upstream: "fastcgi://127.0.0.1:1233", host: "192.168.12.179:8080"\r\n	2018-12-17 11:56:57.632263	f
499	135	Issue	5	近线SAS和SATA默认cache都是打开的，按下面说法主要是很大的性能提升。\r\n\r\n\r\nRE: PERC 9 and 'disk cache policy'\r\nIf I use OpenManage to create a RAID6 virtual disk using the wizard in advanced mode the default for "Disk Cache Policy" is Enabled.\r\nThat sounds normal. As you noted previously, the default is to disable disk cache for SAS drives. The drive you are using is not a SAS drive, it is a Near Line SAS drive.\r\n\r\nEnabling or disabling disk cache on a SATA or near line SAS spindle drive can have very noticeable performance impacts due to the slow access times. The performance difference is not as noticeable on SAS drives which typically have much faster access times. SATA and near line SAS drives for our servers are usually 7200 RPM. Supported SAS drives are generally 10k RPM or faster.\r\n\r\nYou should notice a performance increase by enabling disk cache. You can make the determination whether or not the performance increase/decrease of enabling/disabling disk cache is worth increased/decreased risk to your data.\r\n\r\nThanks\r\n\r\nDaniel Mysinger\r\nDell EMC, Enterprise Engineer	2018-12-18 10:29:37.723471	f
500	135	Issue	5	NL-SAS是采用了SAS的磁盘接口和SATA的盘体的综合体。SAS是Serial Attach SCSI（串行SCSI），SATA是串行ATA。\r\n\r\nSAS 向下兼容SATA，SCSI硬盘一般在10Krpm 或15krpm ，而ATA硬盘在7.2Krpm 左右。最初的SAS 1.0标准提供了300MB/s，当前已经推出的SAS 2.0规范中，速度已经提高到了600MB/s.SAS被期望最终能够达到1200MB/S。	2018-12-18 10:32:43.196716	f
503	4	Issue	5	模拟测试很长时间才accept一次，队列虽然经常是满的，但是仍然有变化。最终还是会慢慢降下来	2018-12-18 14:23:31.845668	f
504	4	Issue	5		2018-12-18 18:19:58.728088	f
505	4	Issue	5	在正常的fcgi accept路径上不accept，增加sleep 1，会出现使用tmp句柄一直出于read状态的现象。且tcpdump现象与499出错时类似\r\n\r\n另外再做一个尝试，正常就用tmp来accept，看是否存在问题。\r\n	2018-12-18 19:52:32.829027	f
506	4	Issue	5	卡住并不一定因为队列满了，实际队列没满的时候也可能出现。\r\n而且一旦出现这种情况就会卡住，很难退出。\r\n\r\n尝试重复init，以及减少fcgi_finish_r都没用。\r\n\r\n问题并非必现，但是概率还是非常高的。\r\n\r\n下一步计划：编译fcgi来定位	2018-12-20 19:29:12.124248	f
507	211	Issue	5	目前MOS 数据管理系统设计中并非基于多站点，只能各自登陆站点，查看用户在一个zone内的使用情况	2018-12-21 07:17:33.338988	f
508	211	Issue	5	S3及各种存储功能\r\n多站点\r\n多故障域\r\n多版本\r\n异构存储\r\n数据检索\r\n数据处理\r\nQos	2018-12-21 07:21:47.742984	f
511	213	Issue	5		2018-12-23 21:06:41.435874	f
512	214	Issue	5	头条的视频还停留在分享阶段。观看效果以及分析方面都不深入。\r\n\r\n可以考虑做一款专业偏向的视频网站。或者武侠类VR游戏。	2018-12-23 21:48:45.029522	f
519	4	Issue	5	加大tcp连接队列来解决该问题可能不现实。\r\n\r\n这个问题的原因到底是：\r\n1，tcp连接丢在队列太长时间没处理(因为后端慢，那么需定位后端问题，这里可增加日志辅助定位)\r\n2，tcp连接没法成功处理，因为队列已满\r\n\r\n如果是2，那么加大队列可解决问题。如果是1则仍然有问题。\r\n这2种原因肯定是都有的，如果1没问题，那就不存在2.\r\n所以解决可以从2方面着手。\r\n\r\n明天按正常方案验证:\r\n1,正常接收请求，但是调整接收请求的速度使得可能让tcp队列满而hang， usleep(1)\r\n2，增大接收队列，观察是否可解决该问题。\r\n\r\n	2018-12-24 19:38:09.922472	f
520	4	Issue	5	Tcp keepalive设置：https://hengyunabc.github.io/why-we-need-heartbeat/	2018-12-25 07:07:34.511434	f
521	4	Issue	5		2018-12-25 12:38:46.63948	f
524	4	Issue	5	该问题最终通过设置tcp keepalive解决，但更好的办法应该是服务器在应用层有超时机制。	2018-12-27 11:28:01.597349	f
525	215	Issue	5		2018-12-27 11:51:58.270878	f
533	218	Issue	5	https://www.jianshu.com/p/cccfb481d548	2018-12-30 13:37:00.061026	f
538	149	Issue	5	架构还必须考虑的是版本变迁计划，升级，水平扩展。	2019-01-02 06:33:15.249773	f
542	215	Issue	5	能否考虑将现有的小文件合并运行于当前的pool，这样可保持兼容性。\r\n另外通过合并转移到其他pool，也可以解决扩容如何使用的问题。	2019-01-05 13:48:21.411691	f
529	216	Issue	5	估计要在v6版本了。此时框架也基本成型。rgw依赖三类接口，分别可用不同组件来实现。\r\n服务分离。除了三类接口外。\r\nrgw本身也需要分层：业务处理层， 存储中间层(封装gc如何在存储层实现，提供接口等)， 存储底层。 \r\n\r\n年初规划，年底放出测试。基本节奏。	2018-12-29 09:13:51.162003	f
544	224	Issue	5	多个人，犹如一个人一样。一台并行执行的机器。\r\n捅刀子是为了发现问题。\r\n坚持效率\r\n\r\n开哪些会？解决哪些问题？\r\n\r\n1，周例会\r\n对齐整体进展情况，每个人汇报工作。其他人给出评价，主要是捅刀子。\r\n\r\n2，晨会\r\n晨会一方面中期发现风险，尽早调整。一是方案上的风险，一是进度上的风险。\r\n另外临时出现的问题，以及idea的沟通\r\n\r\n3，技术探讨会\r\n\r\n讲究效率，如何讲究效率\r\n拒绝人生攻击\r\n维持持续的酸痛感。\r\n	2019-01-06 08:27:20.171971	f
545	225	Issue	5	我主要保留角色：\r\n2，3，6 \r\n\r\n1给梁\r\n4给廖\r\n5给黎忠\r\n\r\n因时间关系，我确实没他们做得好。	2019-01-06 20:46:11.316259	f
548	227	Issue	5	经常有听见下属抱怨上级：“你不信任我！你要是信任我就应该不要来管我，放手让我去干！把这事全交给我去干。。。。”\r\n\r\n　　其实，信和任是两个不同的词。信是相信，但任是委任。相信一个人但未必会委任一个人去做一件事。就像我们相信诸葛亮有非凡的才华，但不会委任他给你当开刀手术医生一样。\r\n\r\n　　同样，委任一个人一件事，也不能完全不顾不问的等待结果。那是非常错误的。作为领导的职责就是要确保事情有结果和部属有成长！分配工作后不闻不问是领导人的失职。检查工作进展，完善工作方法和信不信任没有关系。\r\n\r\n　　“用人不疑，疑人不用”是较低水平的管理方法，是种无奈！而“用人要疑，疑人要用”才是更高境界！	2019-01-06 21:38:53.99845	f
550	133	Issue	5	为什么有公交车，的士，高铁了。我们还要买私家车？ 私有云需做出高端和差异化。	2019-01-06 21:52:08.098759	f
552	224	Issue	5	周例会\r\n1，气氛不活跃，只是在同步信息。\r\n2，未来一周的任务安排\r\n3，同步项目信息，一些POC信息，公司信息\r\n4，周例会主持人机制，其他人发言太少\r\n5，写周报，了解其他组近期计划。没有统一任何跟踪\r\n6，周一下午开？开会之前刷新任务进度，利用好禅道工具\r\n7，没有紧迫感，项目延期，任务延期严重。\r\n8，周例会内容，哪些固定议题，哪些临时议题。提前发会议通知，确定议程。讨论小组之间任务，过下任务。\r\n9，会议结论没有按时发布。\r\n\r\n晨会：\r\n1，没定期召开。\r\n2，晨会没有充分暴露问题。---问题尽量通过更详细的设计来解决\r\n3，进度与问题两个方面的内容，有意识的捅刀子\r\n\r\n评审会：\r\n1，大方案TMG更早介入\r\n2，缺乏版本评审计划\r\n3，设计文档模板不是很好\r\n4，review人员需提前review，提出意见，意见需记录下来\r\n5，POC特性也要评审，也需慎重对待\r\n\r\n专题会：\r\n1，开得太少，没有识别出来关键问题，如何及时发起\r\n2，结论做的不够好，需要会议纪要	2019-01-07 14:16:43.349045	f
553	225	Issue	5	目前职责：\r\n1，项目整体管理\r\n2，架构看护以及改进\r\n3，重大bugfix\r\n4，人员招聘，培训	2019-01-08 08:24:21.868699	f
554	216	Issue	5	而且最好能提供+n操作，就是在原来的value上做运算，而不是只set value。\r\n	2019-01-08 08:38:23.406778	f
555	230	Issue	5	原则：\r\n1，能在rgw层实现的功能，不要在cls去实现。	2019-01-10 07:21:05.589848	f
558	216	Issue	5	基于通用key-value接口来实现元数据管理，并由此推演其他模块是否能正确运行。\r\n重写rgw代码：\r\n1，前端s3解析与执行模块。\r\n2，后端异步处理模块（实际执行的也是s3逻辑，gc等）\r\n   通用模型，可提供遍历，计算，处理，转移，删除等后端操作。但是只需遍历一次。\r\n\r\n3，双活同步管理模块\r\n   采用push模式，方便监控管理，简化代码逻辑。\r\n\r\n4，公共存储接口层\r\n   易于拓展，充分解耦。	2019-01-11 07:17:45.36892	f
561	232	Issue	5		2019-01-11 07:55:34.386879	f
539	215	Issue	5	pg预分裂导致pg creating过程变慢，在原故障域内创建大量pg的pool。可能导致集群大量请求卡住，无法使用。\r\nrgw metadata修改发给master执行，同步采用异步方式，并且OM没有等待所有节点同步完成。造成om对操作结果的误判。	2019-01-03 14:40:31.499451	f
565	215	Issue	5	store_marker也有缺陷，该cr被返回之后，实际执行的顺序是不确定的。可能导致rados存储的marker并非最新，但是内存里面又是最新的。\r\n把watch/notify关闭之后，也许对这里有帮助。	2019-01-15 07:44:21.215021	f
596	262	Issue	5	每个个体知识面要求都非常高。\r\n既要懂社交，管理，做事，还得会观察，甄别。\r\n\r\n很多人看不到因而无话可说，但是看得到的人可能都是话题。比如吃饭，聊文化，聊过往都是可以聊的，都可以了解一个人。	2019-02-12 10:33:14.487451	f
597	263	Issue	5	要理解中国企业管理，就得深入了解中国人。中国文化。\r\n文化是怎么形成的？ 	2019-02-12 14:16:35.226776	f
598	216	Issue	5		2019-02-15 09:41:30.39026	f
600	216	Issue	5	就算使用backfill方式仍然无法解决osd节点重启引起的io中断问题。只要一个bs对象在恢复，整体业务就被中断。	2019-02-15 09:45:51.508895	f
601	260	Issue	5	经阅读代码确定，在mon处理boot消息时，没有延迟osd up的机制。	2019-02-15 12:06:06.536701	f
540	122	Issue	5	分治，合理划分人和事。\r\n另外就是强力的trace，确保目标机器的作用。\r\n\r\n思考的广度，以及对于问题重要性的理解。	2019-01-04 09:40:25.773036	f
526	211	Issue	5	一个realm对应多个zonegroup，一个zonegroup对应多个zone\r\n一个zone对应一个集群，如果有多个集群，可使用多个zone。\r\n一个集群内有多个故障域，呈现出不同的pool。\r\nbucket物理上属于zone，归属上属于user。\r\nuser和bucket在zonegroup内唯一。\r\n\r\nzone只定义资源关系，并不关心资源如何使用。zone的新增和删除理论上不影响业务rgw。\r\n而zone状态变更之后，同步rgw可以重启以加载。\r\n\r\n-placement概念可保留，placement是真正决定如何使用集群的。-\r\n\r\nbucket的index后面会增加一个meta，其中可记录每个bs的range等信息，另外还可以加个信息，就是bs存在哪个pool。\r\nbucket默认会选取一个index pool，选取多个data pool。理论上可支持index pool变更。\r\n\r\n对于pool可以做不同抽象，pool可以是rados的pool，也可以是其他的pool，如nas，公有云，光盘存储。\r\n对于这点似乎没有问题， pool就是资源存放的容器。\r\n\r\n有个概念storage_class,其实对应的就是一类pool。可以根据pool的type划分storage class。\r\n\r\n资源还有另一种方式抽象，就是站点。可利用多站点来保留多份数据。\r\npool也是跨站点的。通过站点和pool来支持数据流转。区别在于pool方式元数据我们仍然保留。\r\n站点方式元数据在不同站点各有一份。\r\n\r\n\r\n\r\n\r\n	2018-12-27 15:04:40.68545	f
528	211	Issue	5	定义一个多站点框架，其实不论对象存储还是块存储都需要。而且可以抽象出来，其实逻辑是接近的。\r\n外部只要注入一个log entry，提供fullsync接口，以及处理log entry的接口即可。\r\n\r\n框架要求：\r\n1，支持Qos\r\n2，支持站点单向同步，双向同步\r\n3，需要同步的资源，自行注册\r\n4，支持站点添加，删除，选举等等\r\n5，提供接口查询当前站点信息等\r\n6，提供同步接口\r\n\r\n\r\nMongoShake rotter等开源产品.\r\n\r\n这里有点比较复杂的是meta和data之间存在依赖关系。\r\n如果支持同步方式，可较好处理这一问题。而且有些操作需考虑一致性问题。\r\n理论上是否支持在一个zone删除一个bucket，但是另一个zone保留？	2018-12-28 07:24:50.366833	f
530	216	Issue	5	只有kv接口，如何玩转bucket index。尤其是后续考虑支持range方式。\r\n配额的统计肯定得分开。\r\n\r\n框架还一个局限就是同步按照bs。这些bs对象的遍历，这样对于支持range方式的bi不是很合适。\r\n设计range分裂。同步的单位是bucket。这并不影响同步效率。\r\n\r\n正好元数据格式调整。\r\nV6：\r\npool抽象，支持storage class\r\nrgw与rados解耦，抽离接口\r\nbucket index支持海量数据\r\n\r\n	2018-12-29 12:30:47.146556	f
531	216	Issue	5	基于多版本机制，使得设计保持一致性。在list输出结果时做特殊处理。gc定期清理删除的版本，或者多出的版本。\r\n\r\nput操作步骤：\r\n1，写入数据\r\n2，写入bilog\r\n3，写入bi (key:obj_instance)  instance：reverse time + random\r\n4，cache写入配额变更\r\n5，写入datalog\r\n\r\ndelete：\r\n1，写入bilog\r\n2，写入bi（delete marker），同步时需检查对端是否有delete marker\r\n3，cache更新配额\r\n4，写入datalog	2018-12-29 13:51:52.749029	f
532	217	Issue	5	http://network.51cto.com/art/201409/450885.htm	2018-12-30 13:26:07.181131	f
534	219	Issue	5	linux signal：用于进程间通知。需要注意\r\n1，信号处理函数应该可重入\r\n2，阻塞式系统调用在被信号中断时会返回，应用需处理该错误。\r\n\r\n\r\n应用程序该如何使用信号？\r\n应用程序捕获信号通常为了优雅的退出，或采用某些特殊行为（哪些？）\r\n所以问题变为：哪些场景下程序需正常按步骤退出？\r\n进程在操作系统申请的资源都会被系统释放，但是有些不一定。比如使用第三方的资源，如共享内存，如rgw使用rados的锁。\r\n打开的文件，socket都会被系统关闭。\r\n	2018-12-31 14:27:21.041835	f
535	219	Issue	5		2018-12-31 15:26:13.426559	f
537	216	Issue	5	rados omap接口支持cmp，在比较失败的时候撤销操作。支持多个key操作。 \r\n这样range split的算法就可以实现了。在发现range变更时，返回错误，加载range配置。\r\n如果正在split中，则新增的key需额外计录，以方便汇入split的key	2019-01-02 06:21:47.767856	f
536	221	Issue	5	面试失误总结：\r\n1，因为人力不够，或给的钱不够，找勉强凑合的。\r\n2，没有考察人实际的工作量和难度。造成对能力的错误认识。\r\n3，没有很好的考察德行。\r\n\r\n经验：面试这块，要尽量避免招到能力一般但是其他方面奇葩的人。这种人不稳定。	2018-12-31 22:39:07.972888	f
541	215	Issue	5	还有两个老的：\r\n1，扩容场景\r\n2，单bucket海量文件场景\r\n3，海量小文件场景(已经在优化)\r\n4，在线升级(rgw无状态，只有元数据部分影响升级，但元数据上可保持兼容，metadata，bi各种元数据模块要设计好)，服务可在线增加。	2019-01-05 12:46:55.793295	f
556	230	Issue	5	场景1：在非多版本删除时，增加后端任务。将超过x天的残留bi给清除掉。\r\n\r\n合适做法应该是根据同步位置来清理，根据bilog及其实例，识别删除操作，然后理清delete flag的key	2019-01-10 09:45:51.328878	f
546	225	Issue	5		2019-01-06 21:22:34.388917	f
547	227	Issue	5	什么叫从“做事用人”到“用人做事”？做事用人是事情已经想清楚了，找一个合适的人来干。相信很多人还在这个阶段。越往后走，会接触到“用人做事”，这事儿怎么干你也没搞清楚，你根本不是这方面的专家，但要找到最有可能把这个事情想清楚和做出来的人，让他来带一个合适的组织。	2019-01-06 21:30:57.18792	f
549	227	Issue	5	确定合适的战略，找牛逼的人。	2019-01-06 21:47:27.781796	f
551	228	Issue	5	工作划分：例会，晨会转移出去。	2019-01-07 09:01:55.70096	f
557	216	Issue	5	在多个rgw并发时，如何根据先后顺序，实现冲突检查。mtime字段可作为比较，尤其是将mtime作为key之后。\r\n\r\n尤其是非多版本下的处理	2019-01-10 17:45:00.061687	f
559	227	Issue	5	了解人：\r\n1，了解一个人的价值观，是否开放进取，是否因循守旧。对于合作是什么态度。\r\n2，如何看待自己可能存在的思维漏洞，能否经常自省，如何完善自己的逻辑机器。\r\n3，能否看到别人的长处，善于合作。\r\n4，是否内心足够强大\r\n\r\n去伪：\r\n1，是否纸上谈兵，思路很好，但从未执行过\r\n2，是否面面俱到，但浮于表面。	2019-01-11 07:44:20.494019	f
560	232	Issue	5		2019-01-11 07:53:08.692752	f
562	191	Issue	5	双打三板斧：\r\n封网，分球，杀点	2019-01-11 10:19:36.022811	f
563	190	Issue	5	握拍位置不仅取决于前后场，而取决于身体与球的距离。\r\n后场的近身球也可以采用高位握拍	2019-01-11 10:21:23.154184	f
566	215	Issue	5	placement变更引起rgw reload，导致业务中断的解决方案\r\n\r\n如何看待placement：placement是storage_class之上的一层，根据业务灵活的配置zone的空间使用。使得用户可自定义bucket元数据，数据，冷数据等具体storage_class分别使用怎样的策略存放。\r\n\r\n调整：\r\n1，将placement信息放在zone param中，zonegroup无需placement信息。\r\n不同的zone可自行决定如何放置数据。这样是合理的，实际上我们不同zone之间数据存在差异，可自行安排数据放置策略。且支持在线修改placement。\r\n\r\n（解决bucket在不同zone之间要求使用同样placement的问题，目前没有做zone之间的placement管理）\r\n\r\n2，支持user default placement，这样placement可对用户透明，用户甚至不必感知placement的存在。\r\n3，在placement信息变更时，不必更新realm period，也不必执行reload操作，避免引起业务中断。\r\n\r\n	2019-01-15 09:01:59.116801	f
567	216	Issue	5	可分析下TiKv以及cockroachdb如何实现range split。\r\n\r\n引入DB也没关系，但是kv接口层仍然需要。 逻辑层也仍然需要。	2019-01-15 13:34:35.816995	f
571	216	Issue	5	1，解决bi问题\r\n2，改进写入模型，支持批量写入。\r\n能否将小文件合并做到IO路径上？写入时合并，后台支持gc。现在的IO模型支持起来可能有点麻烦。\r\n或分配一个rados对象做追加写。\r\n\r\n一个bucket实例共用一个对象。每次使用前分配一下空间，然后写入。问题主要在于一致性。\r\n一个对象写入时，分配了空间，但是写失败了。\r\n\r\n这里搞不好真不适合使用数据库，数据库的操作比如在key里面修改value的局部，但是并发冲突的时候，其实我们希望的是操作A基于操作B的结果来修改。	2019-01-17 06:57:41.539155	f
572	215	Issue	5	海量小文件问题 （梁欣鑫）\r\n免归档 （归档有哪些要求，归档策略）（按年按文件类型，压缩归档，冷存储，公有云）(马四)\r\n免备份 （备份策略，备份隔离，备份域(故障域)，过期拷贝？）(马四)\r\n降低二级存储的成本（去重，压缩，冷池休眠）(马四)\r\n大容量支持（10PB规模如何支持）（多集群，多故障域）（谢锐）\r\nTF对接性能问题 （延迟敏感性应用）\r\n\r\n内部：\r\n多站点 （马四，刘一阳）\r\n解耦 （谢锐）\r\nbucket海量数据 （不排序/优化bs性能？）（谢锐）\r\n数据处理 （马四，刘一阳）\r\nES检索 （马四）	2019-01-18 04:11:50.147303	f
568	216	Issue	5	rados接口不支持+/-运算。如何实现数量统计？还有多rgw下如何为bilog编号？\r\n\r\n还有一种玩法就是支持多集群，rgw元数据沿用当前方案。 但是数据全部放到新的pool上。只封装读写接口给rgw。\r\n元数据采用SSD集群。在目前的代码上支持range的index。搞不好修修补补还能玩。\r\n\r\n说白了就是把ceph加cls当作数据库来玩了。\r\n\r\n其实这种框架与原计划并不冲突。至少迈出了第一步。rgw在pool管理上需独立出来。\r\n并且将rgw原先的meta一堆乱七八糟的pool都汇总。\r\n	2019-01-15 14:11:15.473987	f
588	253	Issue	5	大规模下如何保障可用性？ 对象存储设计成可用性优先是非常合适的。以便应层出不穷的故障。\r\n大规模下的性能分析？\r\n大规模下的问题跟踪，风险发现？\r\n对于大规模分布式系统，这种有复杂度的。系统内部的可见性尤为重要。\r\n\r\n离线修复数据。	2019-01-30 11:48:06.291777	f
569	216	Issue	5	方案x：\r\n在线分裂，支持将前部x万数据抽取分裂。\r\n0，设置原range, pre_split\r\n1，批量读取x万key\r\n2，批量写入到new range\r\n3，刷新range列表\r\n4，设置原range，complete split，刷新统计信息。\r\n在split期间可在原range读取，但是不能写入。\r\n\r\n批量导入的key不记录bilog。\r\n有个问题，像小文件合并的方案其实有个假定：bucket shard不会分裂。\r\n	2019-01-16 07:20:31.847885	f
570	215	Issue	5	分发与汇聚：\r\nbucket上保留有源站点信息，同时也有同步到哪些站点的信息。\r\n\r\n通过这些信息，可以在站点之间实现自动数据拉取与回源。	2019-01-16 08:38:22.605939	f
573	215	Issue	5	\r\nbucket海量数据\r\nbucket可扩展（支持跨pool，灵活使用）\r\n多站点\r\n多版本（做数据保护）\r\n\r\n归档策略\r\n可扩展\r\n\r\n海量小文件问题 （梁欣鑫）\r\n免归档 （归档有哪些要求，归档策略）（按年按文件类型，压缩归档，冷存储，公有云）(马四)\r\n免备份 （备份策略，备份隔离，备份域(故障域)，过期拷贝？）(马四)\r\n降低二级存储的成本（去重，压缩，冷池休眠）(马四)\r\n大容量支持（10PB规模如何支持）（多集群，多故障域）（谢锐）\r\n方案1：使用站点来扩展\r\n  1，限制站点规模，比如一个站点规模正好在5PB。\r\n  2，每个站点各自建业务rgw\r\n  3，每个站点对应一个集群。\r\n方案2：使用多集群扩展\r\n  1，rgw支持多集群，一个站点对应多个集群\r\n方案3：使用多故障域扩展\r\n  1，rgw支持多故障域\r\n  \r\nTF对接性能问题 （延迟敏感性应用）\r\n\r\n内部：\r\n多站点 （马四，刘一阳）\r\n解耦 （谢锐）\r\n方案1：将rgw对rados接口依赖进行封装。使得后续可使用其他系统进行替代。\r\n       难度在于如果统一为kv接口，不提供cls后端逻辑，则业务层实现需进行大调整。\r\n\t   或提供通用的后端kv逻辑，以减轻前端保障数据一致性的压力。\r\n\t   \r\n方案2：数据pool使用统一平台，元数据先使用当前版本顶上。\r\n       要求rgw支持多集群\r\n\t   缺点：rgw元数据部分没解耦。\r\n\t   \r\n方案3：重新抽象接口，元数据选用其他分布式kv数据库。\r\n       \r\n\r\nbucket海量数据 （不排序/优化bs性能？）（谢锐）\r\n方案1：提供不排序的list接口，不支持目录功能。\r\n       bs接口建议调用rest admin接口，尽量从cache获取信息。\r\n\t   \r\n\t   shard的问题主要在于扩展性。当bucket数据规模增大之后，shard无法在线增加。\r\n\t   支持hash shard分裂？如何做二次定位。\r\n\t   \r\n方案2：元数据基于其他分布式kv系统\r\n方案3：在rados cls基础上改造，支持range index？\r\n方案4：将ceph改造为kv系统，支持局部恢复。oid对应于表的分片。\r\n\t   \r\n数据处理 （马四，刘一阳）\r\nES检索 （马四）\r\n\r\n	2019-01-18 06:52:01.244566	f
574	154	Issue	5	1，降低硬件耦合，SSD故障不会影响到所有相关的HDD\r\n2，使用大文件，恢复和scrub等速度更快\r\n3，在POC测试时更加灵活(目前bcache使用并未缓存数据)\r\n\r\n4，filestore预分裂，创建pg太慢，对其他pool造成影响。\r\n	2019-01-18 11:26:34.966665	f
575	215	Issue	5	1，优化gc效率，支持快速的数据删除。\r\n  rados能否提供batch delete接口？\r\n2，恢复Qos\r\n	2019-01-21 07:25:00.968826	f
445	107	Issue	5	积木思考法（理清系统的组织架构）：拆分系统每个组件，以独立与关联的方式分解系统。\r\n人体层次组织思维	2018-11-18 07:24:22.22783	f
576	103	Issue	5	案例学习也是非常重要的部分\r\n学习是在*重构*与*延展*自己的知识。	2019-01-21 20:53:09.973148	f
577	216	Issue	5	在rados提供的接口与bi之间增加一层index，用于扩展支持range index。以支持list请求比较多的场景。\r\n\r\n当然采用专业的数据库也许是更长远之计。凡是皆有利弊，当然还需深入分析。	2019-01-21 21:06:42.84203	f
578	215	Issue	5	1，v5架构所有对象丢入gc不是很合适，且默认gc shard很少，删除大量对象时gc压力非常大。\r\n2，uage，notify等shard也太少，不利于不同osd分担\r\n3，最好将元数据独立故障域。\r\n4，同步和后端rgw没必要使用rgw cache，尤其是同步rgw，同步状态刷新非常快。\r\n5，quota-thread并非每个rgw都需要，只有业务rgw是需要。\r\n	2019-01-25 13:11:31.42012	f
580	137	Issue	5	政治，权力，控制，人心，帮派。\r\n李斯为何在与赵高的斗争中败下阵来？\r\n项羽为何失败？\r\n\r\n政治的逻辑与核心是什么？	2019-01-27 21:16:12.126223	f
581	137	Issue	5	民主制在哪些情况下合适？\r\n如何与初级员工？中层，以及高层打交道。	2019-01-27 21:17:06.672627	f
582	251	Issue	5	心理上要有打多拍的准备，这样就总是放松的迎接下一回合。快速放松就能快速准备好下一回合。	2019-01-27 22:04:27.808166	f
583	251	Issue	5	http://bbs.badmintoncn.com/thread-395619-2-1.html	2019-01-27 22:07:01.541031	f
584	239	Issue	5	为什么动作要规范，因为受限于人体特征，动作是有限制的。\r\n比如击球，有些动作就非常别扭。	2019-01-27 22:09:42.600213	f
585	254	Issue	5	软件实现功能这没啥可说的。\r\n但是软件的成败并非完全取决于功能，尤其是软件变大变复杂之后。\r\n考虑几个问题：\r\n1，软件如何扩展？\r\n2，软件如何升级？\r\n3，软件的风险如何控制？\r\n3.1 如何快速定位问题\r\n3.2 如何快速恢复\r\n4，软件的鲁棒性怎样？	2019-01-28 08:34:11.945328	f
586	255	Issue	5		2019-01-28 08:43:55.787924	f
587	256	Issue	5	这个还是有风险的，如果pg无法计算一些interval，那有些修改将被忽视。\r\n甚至可能无法完成恢复。	2019-01-30 09:44:26.065725	f
579	215	Issue	5	1，http的Date可在nginx和rgw日志中输出，方便定位问题。\r\n2，后端rgw可以部署在任意服务器上，并且最好支持服务发现。以方便业务rgw调用服务。	2019-01-25 13:12:02.69985	f
589	260	Issue	5	tell osd在线修改参数，能否tell osd重启\r\n能否批量修改配置\r\n\r\n\r\n问题：\r\n大量osdmap把系统盘空间撑爆	2019-02-08 11:39:38.38705	f
591	259	Issue	5	对象存储有一点非常适合于分布式，就是系统出现异常时，几乎不会影响新对象的写入。\r\n而块存储，因为其空间分配的分散性影响非常大。	2019-02-08 12:57:50.127773	f
590	260	Issue	5	mark osd lost +  osd_find_best_info_ignore_history_les\r\n舍弃数据修复。\r\n\r\npg层面可支持舍弃部分数据。而不是坏了一点就把整个抛弃的设计思路。\r\n\r\n系统是向前发展和生长的。记忆也会丢失。但我们仍然能追寻蛛丝脉络。\r\n\r\n老的链接逐步断开，新的连接在快速的建立。\r\n	2019-02-08 12:46:14.237208	f
592	260	Issue	5	monitor key数量正常，但是占用几十G空间。使用mon_compact_on_start可恢复。	2019-02-08 19:00:46.450686	f
602	260	Issue	5	时间不一致 对于rgw的影响是真正后写的对象，可能成为历史版本。但是不会出现两个zone版本顺序不一样的问题。	2019-02-15 12:34:20.423089	f
593	133	Issue	5	数据才是核心，很自然的一点。我们会把核心数据放在私有云上，而非核心数据放在公有云上。\r\n对企业而言什么是核心数据？规律，结论，客户信息，企业机器运转的核心数据。 \r\n而生产过程数据，量大且价值低，可放在公有云上。\r\n\r\n私有云的核心是数据的绝对安全可靠。非常高的可用性以及稳定性。\r\n\r\n把公有云与私有云的关系，对比为餐馆吃饭与家里请厨师做饭是不合适的。\r\n数据是企业的命根，而吃饭显然在当下不具备这个特点。	2019-02-10 23:03:04.41117	f
594	255	Issue	5	马云需要直接管理上万人么，不，他可能只需管理10来个人。	2019-02-12 10:12:39.929956	f
595	138	Issue	5	每个人都有其苦恼，也有其欢乐，有其生长环境的痛。朋友是交心的。如果同时有相近的价值观，就可能成为至交。\r\n有人麻木，有人没看到人心。这些人还停留在做事阶段。\r\n\r\n做事也分很多阶段，无法克己的人，就没法走出原生环境的伤。这些伤在非高知，优渥，开明的家庭里都是存在的。\r\n	2019-02-12 10:19:33.400805	f
599	216	Issue	5	对于非多版本的bucket支持indexes模式。这样就算bucket shard不多，仍然可支持海量数据。\r\n而且这种模式的价值应该还是比较明显的。	2019-02-15 09:44:34.398102	f
603	265	Issue	5	方案1：\r\n1，先提供工具将V3的bi，结合head object在新的pool中产生V5的BI\r\n重点是1，验证manifest。 2，产生合适的manifest。\r\n\r\n2，停止rgw，等待工具处理完近期写入的新对象。然后将原index pool rename为index_bk,\r\n将新的pool rename为index pool。\r\n3，升级rgw和osd等到V5版本\r\n4，启动服务。	2019-02-16 09:04:53.20044	f
623	279	Issue	5	如果ClientIP与VIP相同，则RS无法完成数据包发送，因根据转发规则，其转发给lo。\r\n所以DS无法作为系统的客户端。	2019-02-23 09:12:17.661491	f
605	271	Issue	5	避免循环同步仍然是需要实现的。\r\n可以使用其他语言实现，同步只是其中一个服务。\r\n\r\n重点要搞清楚元数据那块，是否存在风险。\r\n\r\n如何切换zone的角色。	2019-02-16 14:43:48.201119	f
610	265	Issue	5	再验证一个地方，将v5的manifest prefix中的版本去掉。并且修改rados对象名字，看能否正常读取数据。\r\n这里验证没有问题。	2019-02-18 15:45:14.909043	f
607	268	Issue	5	损坏的osd有33，91，115， 155， 165\r\n其中165报错为 Corruption： checksum mismatch\r\n其他报错为 Corruption：bad record length\r\n对应的host为：node.(num % 15 + 3).\r\n因为第0的节点编号是node3.\r\n\r\nnode6, node4, node13, node8, node3\r\n	2019-02-18 09:24:51.162899	f
616	276	Issue	5	https://mp.weixin.qq.com/s/8QdKMhvyeDnv_Vv8LnBgJw\r\n\r\n加入pg中文社区	2019-02-20 09:02:09.252205	f
617	268	Issue	5	系统日志中未见leveldb明显错误	2019-02-20 14:27:21.86108	f
619	279	Issue	5	<pre><code class="text">\r\n在分析数据包流向前，需要厘清一个容易产生疑惑的要点：在VS/DR模式下，TCP连接是客户端和RS之间建立的，\r\nDirector只是负责改造、转发建立TCP连接时的数据包给后端RealServer；当TCP连接建立完成后，\r\n就有了客户端和服务端(RS)的概念，这时客户端将直接和RS进行数据通信，而Director已经退出舞台，\r\n不再负责改造、转发请求数据包，直到关闭连接时。也就是说，Director改造、\r\n转发的数据包只有客户端发送的和tcp连接建立、关闭相关的syn、ack和fin包，\r\n其它数据包和它无关(网络状况良好的情况下，共转发syn+ack、fin+ack共4个包)。\r\n可以想象，这样的Director相比NAT模式，性能高的不是一点点。\r\n</code></pre>\r\n\r\n这个如何做到？Client发送数据的目标地址总是VIP，如何透过DS？\r\n难道路由器还可以保持单次会话的状态？\r\n	2019-02-21 19:34:22.23693	f
620	271	Issue	5	IDEA：搞一个分布式的raft元数据同步模块。实现元数据的同步。\r\n元数据操作都丢给该同步模块。彻底解决元数据的一致性问题。	2019-02-22 13:56:24.376366	f
622	279	Issue	5	DS发给RMAC的包，由于其目标IP为VIP。因而RMAC网卡会转发该数据包。在RS上其转发是给本地的lo网卡（VIP配置在lo网卡上的情况）。 lo网卡处理完数据之后发给源MAC(这里是RMAC)。数据包再经由RMAC网卡发出去。\r\n\r\n这里RMAC的作用有点像路由器。根据上述流程可推断：如果nginx只监听RIP，则无法正常处理消息。	2019-02-23 09:09:53.78936	f
625	271	Issue	5	另外真正大规模是需要考虑同城多站，以及非同城情况的。\r\n高可靠情况下。同城多站之间存在容灾关系。公有云没有暴漏这层情况。\r\n\r\n这块需求还是摸摸，一个区域内站点怎么管理的。	2019-02-23 14:59:31.818577	f
626	281	Issue	5	8个incomplete，确认下bi对应的pool。	2019-02-24 15:28:20.871634	f
629	240	Issue	5	1，测试框架先行\r\n没有好用的测试框架，研发的bug用例就不能立即补充，bug也没法充分自验证。\r\n2，每个bug都应该有对应的用例\r\n3，如果系统需要测试随机碰撞发现问题，说明很多地方不在控制范围内。应该采用更透明方式测试。\r\n4，测试是渗透于架构与开发过程中的。\r\n5，大特性分迭代交付\r\n6，谁开发谁维护，模块特性解耦，任务解耦。\r\n7，平台与业务关注点与变化周期都不一样，应该采用分离策略。\r\n8，设计review相当于对设计进行测试，验证其是否合适，可行。\r\n9，代码review相当于初步的白盒测试。\r\n10，采用服务模型，可以按服务来解耦。\r\n11，设计应该综合考虑测试，运维，监控，升级，性能，可靠性，可用性，一致性，扩展性，功能，人力安排等等。不要随意假设，忽略一些小部件。	2019-02-26 07:03:53.500046	f
630	216	Issue	5	1，rados提供kv接口，在此kv基础上实现多站点元数据一致性保障，可在此基础上实现raft。\r\n好处是该服务可以无状态化。坏处是性能可能受影响。单独实现的话需考虑如何通知到，以避免使用rados的\r\nwatch/notify接口。 etcd都帮搞定了。\r\n\r\n2，同步代码，同步状态管理。zone配置仍然放在本地。zone给哪些zone同步也在本地配置。zone有哪些placement都属于zone固有信息。而且这些信息不必缓存，直接在后端获取。可避免使用rados watch/notify机制\r\n\r\n3，s3服务。s3服务是独立的，她与同步的关系仅在于datalog与bilog。\r\n\r\n4，后端服务，能够看到客户端看不到的变量，以辅助管理\r\n\r\n\r\n	2019-02-26 15:17:24.920043	f
631	216	Issue	5	etcd至少要做到孤立节点可读。否则多数据中心网络异常后，s3服务可能受到影响。\r\n\r\n同时如果把奇节点丢在其中一个数据中心。则需有机制强行恢复。\r\n比如在目标站点拉起一个节点，从而可形成多数派。\r\n\r\n	2019-02-27 14:52:18.094191	f
720	348	Issue	5	真相可能掌握在更有权力和资本的人手中，他们让机器运行算法以获得更好的信息，进而改变了当下。 \r\n弱势群体的机会在于运用廉价的数据，更好的算法得到更好的结果。 这就是当下社会情况。\r\n\r\n如果没法操控好机器，就可能被其他人取代，但这模式不会变。弱势群体利用更好的算法，更差的机器才能颠覆。	2019-04-24 09:31:28.437139	f
613	214	Issue	5	如果把人简化点比喻成软件。\r\n身体就是硬件\r\n心智观念认知就是操作系统\r\n技能经验就是服务软件。\r\n\r\n一个人要达成目标，尤其是需要多人完成的目标。是需要具备不少能力的。\r\n我们可以通过人达成的成就来反推。\r\n\r\n1，空有认知，没有身体力行，无法验证。\r\n2，身体如高配的跑车，然而不运行起来也没用，\r\n心智认知最明显的就是对于时间和情绪控制方面。\r\n操作系统可能还不错，但是在空转。\r\n3，还有硬件牛逼，操作系统飞快的。但是不跑服务，无法展示其他人以价值。\r\n这种是潜力股，但是能否发挥出来有风险。	2019-02-19 10:00:11.972777	f
614	240	Issue	5	任何系统都可能存在bug。重要的是问题可以不断收敛。\r\n\r\n自动化测试就是解决这个问题的呆办法。没有这个复杂系统都玩不起来。\r\n而且系统设计之初就应该为测试，升级，监控，运维留好后路。合理的抽象与模块划分。否则等着的就是今夜无眠。	2019-02-19 12:34:32.97667	f
615	268	Issue	5	1,osd db什么时候出现异常的。\r\n从日志无法分析出来，日志中都没有Corruption信息，这个信息是打印在屏幕上的。\r\n\r\n<pre><code class="text">\r\n2019-01-29 11:01:14.809009 7f9633f2c900  1 journal _open /var/lib/ceph/data/ceph-91/journal fd 4: 5368709120 bytes, block size 4096 bytes, directio = 0, aio = 0\r\n2019-01-29 11:01:14.809036 7f9633f2c900  1 journal close /var/lib/ceph/data/ceph-91/journal\r\n2019-01-29 11:01:14.809054 7f9633f2c900  0 probe_block_device_fsid /var/lib/ceph/data/ceph-91/journal is filestore, 173ad517-b782-45ca-a5ed-d5437b23e37f\r\n2019-02-05 09:46:25.652868 7f837e147900  0 SandStone MOS V5.2.1 (6421a98067919427dba833a42dde26151dc61cfb), process ceph-osd, pid 9791\r\n2019-02-05 09:46:25.676240 7f837e147900  0 filestore(/var/lib/ceph/data/ceph-91) backend generic (magic 0x58465342)\r\n2019-02-05 09:46:25.676637 7f837e147900  0 genericfilestorebackend(/var/lib/ceph/data/ceph-91) detect_features: FIEMAP ioctl is disabled via 'filestore fiemap' config option\r\n2019-02-05 09:46:25.676643 7f837e147900  0 genericfilestorebackend(/var/lib/ceph/data/ceph-91) detect_features: SEEK_DATA/SEEK_HOLE is disabled via 'filestore seek data hole' config option\r\n2019-02-05 09:46:25.676661 7f837e147900  0 genericfilestorebackend(/var/lib/ceph/data/ceph-91) detect_features: splice is supported\r\n2019-02-05 09:46:25.903040 7f837e147900  0 genericfilestorebackend(/var/lib/ceph/data/ceph-91) detect_features: syncfs(2) syscall fully supported (by glibc and kernel)\r\n2019-02-05 09:46:25.904898 7f837e147900 -1 filestore(/var/lib/ceph/data/ceph-91) Error initializing leveldb : Corruption: bad record length\r\n</code></pre>\r\n\r\n可能情况是这些osd一直hang在那里，中间输出的超短启动日志是om调用ceph-osd  get fsid产生的。\r\n\r\n问题是当时osd到底是hang住了，还是om没有尝试拉起呢？\r\n可以确定的是这十多天osd没有启动过，没有走到mount加载filestore过程。\r\n\r\n可以确定的现象是所有这些osd所在host都出现了内存不够的问题。\r\n	2019-02-20 07:10:41.503892	f
618	216	Issue	5	1，支持pool概念抽象\r\n2，使用placement来灵活配置pool的使用，存储策略\r\n3，支持数据流转的抽象（同步，备份，归档都是将数据从一个bucket实例转移到另一个bucket实例）\r\n流转的Qos，监控，压缩都是通用的。\r\n4，元数据分离\r\n5，多站点的元数据同步\r\n\r\nrgw工程依赖问题，在解耦之后可能仍然无法解决，common部分难以剥离。\r\n最彻底的方式就是重新实现rgw。	2019-02-21 10:33:48.011067	f
628	283	Issue	5	大型网站的域名访问是如何做负载分担的？\r\n分析阿里云的sdk看看	2019-02-25 10:38:20.982317	f
621	271	Issue	5	多版本频繁修改system对象需修改。\r\n\r\n关闭同步rgw的cache不合适，会导致元数据更新无法同步给业务rgw。\r\n这里将同步rgw使用system object的地方做修改。从而减少watch/notify的发出。\r\n\r\n这里遗留一个问题：目前同步状态在内存中没有cache，每次bs同步都得读取bs当前同步状态。\r\n后续设计新同步模型的时候需考虑这点。	2019-02-22 16:58:19.512567	f
634	240	Issue	5	设计对于测试的考量：https://segmentfault.com/a/1190000007866223	2019-03-01 14:12:33.190209	f
624	271	Issue	5	未来的同步框架。可考虑做分离式设计。元数据做成同步模式的。业务rgw 作为follow。\r\n\r\n而数据同步跟普通的数据读写并无差异，就是根据binlog来同步。只是需检查依赖的元数据是否已经同步。\r\n实现这个框架。\r\n\r\n	2019-02-23 12:34:37.467171	f
627	283	Issue	5	12.2 HTTP重定向\r\n\r\nWeb服务器可通过Http响应头信息中的Location标记来返回一个新的URL，浏览器自动去访问这个新的URL。\r\n\r\n实现：可以通过Web应用程序代码实现你想到的调度策略，如可根据请求的URL的不同来进行合理的过滤和转移。\r\n\r\nhttps://www.zhihu.com/question/22610352\r\n\r\n不过这种与endpoint管理不一样。	2019-02-25 10:31:19.991725	f
637	221	Issue	5	1，是否健康\r\n2，是否柔软，谦逊\r\n3，是否坚定，触之不动\r\n4，是否快乐。\r\n\r\n跟定输入，验证输出。面试就是x/y = f(x),重点就是f。\r\n\r\n就像一个不倒翁一样。你不推它，是感知不到的。	2019-03-03 22:04:46.519077	f
639	280	Issue	5	在日常交流中，融入思考与情感。如何做到时刻在当下？君子如何好人，看到别人的兴趣，保持好奇心。唯有热爱，让人保持热忱。	2019-03-03 23:22:07.291639	f
641	294	Issue	5		2019-03-05 07:51:48.868359	f
642	215	Issue	5	placement与pool作为资源管理的抽象，应该作为独立层次管理。\r\nbucket是数据集合的抽象，是逻辑单位。placement的定位就是bucket使用pool的管理方式。	2019-03-05 12:21:51.210662	f
643	155	Issue	5	Martin Fowler\r\n\r\nOne of the differences between building\r\narchitecture and software architecture is\r\nthat a lot of decisions about a building\r\nare hard to change. It is hard to go back\r\nand change your basement, though it is\r\npossible.\r\nThere is no theoretical reason that anything is hard to change about software.\r\nIf you pick any one aspect of software\r\nthen you can make it easy to change,\r\nbut we don’t know how to make everything easy to change. Making something\r\neasy to change makes the overall system\r\na little more complex, and making\r\neverything easy to change makes the entire system very complex. Complexity is\r\nwhat makes software hard to change.\r\nThat, and duplication.\r\n\r\nSoftware is not limited by physics, like\r\nbuildings are. It is limited by imagination, by design, by organization. In\r\nshort, it is limited by properties of people, not by properties of the world. “We\r\nhave met the enemy, and he is us.”	2019-03-05 13:00:54.807084	f
645	214	Issue	5	好的生活不是躺尸，而是尝遍乐趣，积极享受，同时也好好休整。\r\n就像打羽毛球一样，你不是站在那里，漫不经心，那样的生活不会有意思，也没法调整好自己。\r\n你要认真的打球，赢了能兴高采烈。输了也能坦然面对。重要的是你在经历这一切，与朋友一共成长与体验。\r\n\r\n能克服自己的心魔，跨越自我意识障碍。\r\n同时看到自己的思维盲区，积极与同样认真有趣的人合作。	2019-03-06 19:25:17.980727	f
632	287	Issue	5	1，查看几张网卡。\r\nlspci | grep -i eth\r\n<pre><code class="text">\r\n01:00.0 Ethernet controller: Broadcom Limited NetXtreme BCM5720 Gigabit Ethernet PCIe\r\n01:00.1 Ethernet controller: Broadcom Limited NetXtreme BCM5720 Gigabit Ethernet PCIe\r\n02:00.0 Ethernet controller: Broadcom Limited NetXtreme BCM5720 Gigabit Ethernet PCIe\r\n02:00.1 Ethernet controller: Broadcom Limited NetXtreme BCM5720 Gigabit Ethernet PCIe\r\n04:00.0 Ethernet controller: Intel Corporation 82598EB 10-Gigabit AF Dual Port Network Connection (rev 01)\r\n04:00.1 Ethernet controller: Intel Corporation 82598EB 10-Gigabit AF Dual Port Network Connection (rev 01)\r\n</code></pre>\r\n\r\n或cat /proc/net/dev\r\n<pre><code class="text">\r\nnter-|   Receive                                                |  Transmit\r\n face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\r\n  eth0: 2209785591 26605292    0 117493    0     0          0   5223710 569323943 1725958    0    0    0     0       0          0\r\n  eth1:    1690      10    0    0    0     0          0        10     2742      31    0    0    0     0       0          0\r\n  eth2:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\r\n  eth3:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\r\n  eth4:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0\r\n  eth5: 3440060985213 3794627140    0 117420    0     0          0     12166 10756198412767 8245868156    0    0    0     0       0          0\r\n    lo: 3170789494359 776063107    0    0    0     0          0         0 3170789494359 776063107    0    0    0     0       0          0\r\n</code></pre>\r\n\r\n	2019-02-28 10:29:07.413913	f
633	287	Issue	5	如果一个网卡上配置多个ip，会在/etc/sysconfig/network-script/下面创建多个ifcfg配置文件。\r\n且device使用的不是eth0， 而是eth0:21 这种形式。\r\n\r\n另外ip addr命令看到的不是物理状态。通过配置ifcfg，然后ifup是可以将其显示状态改为up的。	2019-03-01 07:28:15.426074	f
638	221	Issue	5	1，认知\r\n保守与否，价值观怎样，可以问时事。\r\n\r\n2，目标\r\n结合结论，来看一个人的能力。\r\n\r\n3，情感\r\n可以聊加班，以及一些其他事情来点火。不点火放不出怪兽。\r\n\r\n另外可以看看：\r\n经验与能力	2019-03-03 22:11:20.175929	f
640	293	Issue	5	晚上也有系统给我产生价值。就像构建一个机器人给自己赚钱一样。想想都激动。	2019-03-05 07:35:11.921991	f
644	155	Issue	5	事物复杂是因为其存在依赖与关联。有些关联很密切，有些比较稀松。\r\n软件就是用函数表达这种关联。 相关的一些函数组成模块，相关的服务组成进程。\r\n\r\n除了研究执行体之外，软件最多的都是涉及交互，互斥，数据共享。 对于状态的处理有cache，与非cache模式，有状态与无状态之别。\r\n数据有share或者not share的模型。	2019-03-05 13:08:00.363449	f
635	290	Issue	5	工程产品需要考虑各种实际场景，考虑人性，业务，考虑事务发展的趋势与阶段。考虑成本，同时还有选择，谨慎的运用权力。	2019-03-03 21:45:07.498795	f
646	222	Issue	5	缺点：\r\n1，做事缺乏计划，主动性不够\r\n2，执行推动力弱\r\n3，责任心缺乏\r\n4，细节考虑不够\r\n5，偏忧虑型风格\r\n\r\n优点：\r\n1，有框架思维能力，能从基本上确立制度。\r\n2，有开放创新能力，可以想出一些Idea	2019-03-07 10:05:03.904285	f
647	227	Issue	5	1，采用严要求，以及有点小痛感的压力，给于其时间调整，不行就滚蛋\r\n2，找有兴趣有能力的人，且有德之人(依道而行谓之德)，给于高工资。	2019-03-07 10:08:52.538132	f
649	240	Issue	5	张瑞关于设计的观点：\r\n1，元数据是核心，精简元数据设计\r\n2，理解设计需解决的问题所处的层次，带来的产品亮点，未来架构演进之后设计是否报废，设计就是要做精品的路子\r\n3，实现方案有很多种，关键是理解清楚问题，以及考虑方案的额外增益\r\n4，保持特性的弹性，配置化，可在线配置》离线配置\r\n5，细节不可随便遗漏：应用场景分析，端到端的IO流程，异常场景，关键算法，资源占用等都得考虑。\r\n\r\n张瑞在细节与周全上还是考虑的比较多的。	2019-03-07 13:11:22.042111	f
651	107	Issue	5	原则：\r\n1，如果你毫无计划的在做一件事，说明你缺乏这方面的系统思维，机器尚未建立起来。	2019-03-07 13:16:24.20492	f
652	216	Issue	5	解决rgw bi恢复卡住业务，以及bucket list慢的思路。\r\n方案X：\r\n将bi独立成服务。\r\n支持配置多组bi服务，但是一个bucket只落在其中一个。\r\nbi服务的逻辑是采用批量写入key到一个rados对象（对，同一时间只写一个rados对象）。\r\n在内存中维持level 0的rados bi对象。当然如果内存足够，其他level也是可以加载到内存的。\r\n\r\n当然也可以每个bucket搞N个shard，然后写到1万数据，就启动合并。并切换一组。\r\n\r\n一方面由于L0的key写入量在一段时间范围内，不需要全量恢复所有key\r\n另外后端合并后写入到新的rados obj。而不去修改还有的rados obj。 \r\n然后通过内存加速index。\r\n\r\n还有一种思路，ceph支持range index。\r\n\r\n\r\n\r\n	2019-03-07 16:18:17.585398	f
650	240	Issue	5	软件开发有大技术点：设计，代码编写，测试，review，解bug等专项技能。\r\n\r\n设计关乎认知否？of course，对系统的认知理解，从不同层次看待问题设计是不一样的。	2019-03-07 13:13:25.950595	f
653	299	Issue	5	高压之下，如烈日炎炎。要知道避暑。 吃吃西瓜？\r\n夜幕降临，要能安歇。为来日做好准备。\r\n\r\n忧思过度，嫉妒，纵欲，暴躁，愤怒这些情绪就像雾霾，沙尘暴，冰雨等灾害天气。伤害的是自己和身边的人。\r\n\r\n积极应对，才能从容每一天。不让自己在烈日下烤死，或者在外乡流浪。 外乡真有那么好么，尤其是自己并未发生改变的时候。老人说先在家里做好事情，再出去	2019-03-08 08:22:08.589407	f
656	296	Issue	5	与客户聊产品功能体验\r\n与投资者聊产品远景，发展规划\r\n与员工聊技术\r\n与供应商聊对其需求，价格。	2019-03-08 11:51:36.653883	f
667	313	Issue	6	本月共有4个假期时间，其中1个小长假，3个正常周末\r\n# 4月5日-4月7日：清明/叁物园亲子活动/房间已预订共14人（姐姐家3人、二哥家3人、自己家4人、二嫂同事家4人）/计划4月5日早上出发，4月6日下午返深\r\n# 4月13日-4月14日：周六在家打扫除/周日安排各自社交活动\r\n# 4月20日-4月21日：周六带谢震去周边公园玩耍/周日阅读思考写作休息\r\n# 4月27日-4月28日：周六链接一个人/周日安排第一次家庭会议\r\n	2019-03-18 08:15:55.498657	f
721	350	Issue	5		2019-04-25 06:45:05.692857	f
2152	1026	Issue	5	设计模式可以说是为架构服务的，架构定义了实体关系，系统的基本路径。\r\n设计模式则处理了实体变化时，如何仍然维持架构不腐烂的问题。	2022-10-16 20:12:24.220751	f
2153	942	Issue	5		2022-10-16 20:18:16.290564	f
655	290	Issue	5	科学研究的是 z(x) = y(x) + a(x) + b(x) + ... + k \r\n当然一切结函数，工程本身也被研究。\r\n\r\n工程关心的是：\r\n1，y(x)各个子函数具体实现方案，基于计算，存储，网络资源等更好无误的实现。\r\n2，参数优化，根据当前条件，参数调整到哪种程度。\r\n3，如何监控，运维。\r\n4，成本与时间。	2019-03-08 09:33:19.419415	f
658	39	Issue	5	又走回在线合并的思路。\r\n离线合并代价太高，且gc问题对于对象存储可能不严重。在线合并更合适。\r\n\r\n并且可以根据bs来分配大对象，在IO路径上将请求也做合并，包括数据请求与bi的请求。	2019-03-08 14:32:27.45799	f
660	298	Issue	5	如果不考虑ACL，其实写可以优化，多版本写入的读可以优化掉。\r\n\r\n或者做垂直优化，让user或user的bucket跟rgw服务建立关系。然后针对user/bucket加载元数据，读操作也会受益。性能刚刚的。\r\n\r\n像头条这种写少读多的场景更为合适，不过经过cdn之后，也许其读写也是相近的。\r\n接口不受严格限制之后，好处与坏处同样明显。像阿里oss这种提供域名服务的，万一挂了该如何处理。	2019-03-08 14:51:09.17245	f
654	299	Issue	5	就像打羽毛球一样，除了击球一刹那，平时都在有条不紊，放松的安排工作与调整。\r\n\r\n原则：\r\n1，正常情况下，人应该是放松且开心的。\r\n2，犹豫不决，问题困扰的情况下，人仍然可以放松平静，因为改进提升自己的机会来了。这与积极思考并无矛盾，而且心态稳定有利于思考。	2019-03-08 09:27:21.181148	f
659	298	Issue	5	是可以考虑只缓存必要字段到数据库或ES，从而实现快速list，以及按照prefix查找，全文检索等的。\r\n\r\n比如文件名，创建时间，ETG，大小，TAG等，这些加起来不会超过100字节的话，可加载到内存中加速读取。\r\n	2019-03-08 14:47:52.232726	f
657	298	Issue	5	1，支持复杂查询，高频查询。\r\n2，解决海量小文件问题\r\n3，解决bi恢复卡住业务的问题。\r\n   精简元数据，实际上可以做到非常小的。\r\n4，支持接入多家公有云。\r\n5，优化IO模型，更方便支持小文件优化写入\r\n6，多版本必须开启，去掉ACL。从而减少写入放大，减少写入时读操作。\r\n7，bs以及一些元数据可考虑策略cache，从而减少读请求。\r\n8，垂直优化空间还是非常大的。	2019-03-08 11:53:20.306327	f
662	302	Issue	5	1，动机\r\n  解决计算机资料阅读的困难\r\n  解决英语邮件沟通以及听讲座的问题\r\n2，计划\r\n  按照每年一个版本\r\n  2019：解决英语读写问题\r\n  2020：解决英语听说交流问题\r\n  \r\n3，执行\r\n  指导思想：建立体系，学以致用\r\n  读写问题：\r\n  1，词汇量问题，按照通常说法，词汇量达到2-3万就非常不错了。这阶段目标假设是常用1万单词。\r\n我现在的单词量估计3k左右。需要每天记20个单词，一年可达标。\r\n  2，语法问题，这个记忆量不大，应该可完成。\r\n  体系：就是建立好词根，单词的关联关系。 语法规则集。\r\n	2019-03-09 15:53:22.472878	f
663	303	Issue	5	1，词根含义存在变化衍生的情况\r\n2，在专业领域词根可能不一样。\r\n比如sol与heli， anim与bi	2019-03-12 10:22:29.52602	f
664	298	Issue	5	还有在小文件写入上，可以通过合并写入，有望极大提升性能	2019-03-12 12:48:04.791428	f
661	280	Issue	5	完成英语与数学学习的思路整理，建立起日常生活工作与英语，数学的联系。\r\n完成数据库基础知识巩固\r\n建立更加完善的产品体系思维，提升打造产品的综合能力。\r\n\r\n用数学的方式思考问题，用英语扩展视野。最终我的目标是能科学，严谨的研究问题，得出规律和结论。not 直觉。\r\n当然直觉与经验很重要，但我们需要抓紧本质并且严谨，利用公开的数据和研究成功。\r\n\r\n\r\n	2019-03-09 15:15:06.05778	f
665	163	Issue	5	分布式系统的短板分析。\r\n延时与吞吐量多角度分析\r\n并发冲突。性能跟踪以及统计。统计每个io的延时。	2019-03-15 16:50:42.513945	f
666	154	Issue	5	目前考虑在线合并方案。\r\n有几个问题：1，EC pool不支持overwrite。因而针对ec pool的情况，可能还是得使用tier的方式。\r\n2，bi的cache可以使用osd在filestore cache，既可以加速bucket list性能，也可以加快bi对象的恢复。\r\n3，大对象gc可以把同osd的合并做offload，利用clonerange等rados接口。\r\n4，还有一个必须优化的就是元数据规模，这个也是2的前提。\r\n\r\n顺序写，offload等性能优化手段。减少网络交互以及IO次数	2019-03-15 16:56:05.115983	f
668	314	Issue	6	一、自己定下这个2020年完成职业转型的目标后，我就在思考我该从哪里入手呢？\r\n首先我想到的是，弄清楚这个问题，我可能需要一些专业的知识，专业的工具，专业的人，再加上自己思考和选择。\r\n\r\n二、我究竟该通过什么方式去了解这些专业的知识、专业的工具，如果去接触到这些专业的人呢？\r\n* 网上查询，然后自己学习，可能会花费我大量的时间，容易中途放弃\r\n* 报名一些课程，通过集中式学习，然后用于分析自己，也许是一条不错的路径\r\n* 我身边有没有这样的专业人士，通过他们提供一些前期免费的服务，我先微信问问吧\r\n\r\n三、那种方式操作起来最简单，我先行动起来？\r\n* 第一种对我来说有点难度，不容易出结果，同时容易中途放弃；\r\n* 第二种花费太多的金钱，可能试错成本会很高，不适合轻易做决定；\r\n* 第三种最容易有反馈结果，也就是发条微信的时间，简单易行，就从这个方式开始吧	2019-03-18 08:50:56.768734	f
672	315	Issue	6		2019-03-18 11:59:55.042963	f
674	254	Issue	5	软件工程研究的核心问题是：如何在生命周期内有质量，有效率的适应环境变化。	2019-03-23 14:41:02.687317	f
669	314	Issue	6	思考完这些问题后，我梳理了深圳圈的所有人，选定了小章鱼先进行了解，理由如下：\r\n* 小章鱼上过职业规划生涯的相关专业课程\r\n* 小章鱼是一个自带能量的人，她身上有我所欣赏的能力\r\n* 小章鱼个人的职业发展比较成功\r\n\r\n2019年2月28日微信进行了沟通，咨询咨询职业生涯规划课程内容\r\n\r\n2019年3月1日进行了回复：\r\n一、解答生涯规划的课程，小章鱼上了新精英课程，详细情况如下：\r\n# 基础班：都要上，基础的工具、逻辑，基本知识等\r\n# 咨询实践班（咨询方向）：针对未来做咨询方向的人，把在基础班学到的知识，在实际的咨询中进行利用、演练，写咨询报告等\r\n# 企业版权课（培训方向）：企业做对接，怎么用职业生涯规划里面的工具，帮助企业中不同阶段的员工渡过解决他们不同阶段的问题\r\n**结论：如果不是未来想要从事这个方向的话，上职业生涯规划课程成本太大没有必要，可以找到付费或公益的职业规划师，找到相应的答案，解决自己的问题即可*\r\n二、通过初步微信沟通，小章鱼答应可以先了解一下我的情况，再帮我推荐相应的职业生涯规划师做进一步的咨询\r\n* 小章鱼建议面聊后，初步了解情况，看能否答疑解惑\r\n* 根据初步的了解再定向推荐职业生涯规划师\r\n*初步约定下周见面了解 \r\n\r\n\r\n2019年3月4日发送“咨询信息收纳表给我”\r\n\r\n2019年3月5日约定见面时间3月6日中午\r\n\r\n2016年3月6日早上反馈“咨询信息收纳表”给小章鱼\r\n\r\n2019年3月6日中午如约见面\r\n\r\n\r\n\r\n	2019-03-18 09:32:26.191999	f
670	315	Issue	6	时间：2小时（2019年3月6日12:00-14:00）\r\n地点：南山科技园醉翁亭\r\n内容：职业生涯规划咨询\r\n人物：胡冬寅、张雨晨（小章鱼）\r\n需要准备的资料：咨询信息收纳表\r\n谈话框架如下：\r\n简单讲述职业生涯规划的流程-通过做职业生涯规划毕业案例导致自己对职业生涯产生担忧-自己如何利用职业生涯规划里面的工具帮自己解决自己的职业规划-简单了解我的情况-表示如果有需要可以推荐相关职业规划咨询师给我-抛出自己的保险营销团队招合伙人的橄榄枝-告知可以参加相关的活动进行了解\r\n\r\n\r\n\r\n	2019-03-18 10:37:28.453257	f
671	315	Issue	6	我从中得到的资讯和收获\r\n一、关于职业生涯规划，包含了以下方面的问题（需要弄清楚自己究竟是属于哪个方面的疑惑）：\r\n职业选择与定位\r\n职场适应\r\n职业能力探索\r\n职业决策\r\n职业方向重定向\r\n职业倦怠\r\n职业晋升\r\n跳槽\r\n职业人际关系处理\r\n职场压力面对\r\n工作与生活平衡\r\n生涯愿景与生涯平衡\r\n\r\n二、职业转型的口诀\r\n转岗不转行\r\n转行不转岗\r\n探索的步骤依是向上看、向内看、向左右看、向外面看\r\n向上看即从该职位的上升渠道看有没有可能（比如会计往上是主管会计-总账会计-财务总理-财务总监）\r\n向内看即从专业知识领域的通道有没有可能（比如会计会计从业资格证-初级会计师-中级会计师-高级会计师-注册税务师-注册会计师-国际注册会计师）\r\n向左右看即看同一行业的其他岗位是否有合适的（比如培训岗等）\r\n如果再没有合适的才向外看，向其他行业和其他岗位探索，但往往会比较累\r\n\r\n三、看一个行业是否符合自己可以通过人事网书四个方面去一步步验证\r\n人：可以约该行业该公司最优秀的人出来，了解他的想法和工作状态\r\n事：通过查看关于该公司负面评价来了解\r\n网：通过官方网站去了解该公司的相关产品\r\n书：通过书本的系统知识来判断\r\n\r\n四、通过小章鱼的分享有以下几点的收获\r\n对于自己从事的岗位不管喜欢与否，都有做好的能力\r\n女人到了35岁，男人到了40岁，都会遇到家庭与事业平衡的问题，如果能够提前规避，就不至于面临两难的选择\r\n从大的层面来说一个人的信仰和善心也会对一个人的事业产生重要的影响\r\n主动链接身边的人，帮助人和被帮助都是一种幸运\r\n有工具有方法然后就是去行动，如果不行动，什么都没有\r\n对保险行业有了更多的认识，也提供了进一步了解的可能性\r\n\r\n	2019-03-18 11:51:54.148905	f
673	212	Issue	5	计算机的本质就是逻辑，此外还有信息部分。其中信息表示部分就是数据结构，而逻辑部分就是算法。\r\n计算机与数学一脉相承。 所以数学能运用的地方，计算机都能用到。\r\n\r\n计算机与数学的区别在于信息部分，信息包含了两部分：存储与传输。\r\n\r\n计算机：计算 + 信息\r\n信息：存储 + 网络\r\n\r\n\r\n而涉及事物的地方，就与相关的专业发生关系。 如工程，社交，人体设计，美工等等。这些都是交叉学科了。	2019-03-21 20:49:12.680532	f
675	244	Issue	5	问题分类：\r\n1，补\r\n2，找，探索发现类问题\r\n3，编，开放型创新型问题\r\n\r\n探索分析法\r\n分治	2019-03-23 15:13:51.151381	f
676	303	Issue	5	英语单词的发展就是不断组合创新的过程。\r\n通常词根组成必须考虑的要素：发音，拼写(像形)，含义衍生。音，形，义三位一体。\r\n比如辅音和元音的组合使用。符合发音习惯。几乎每个语言都如此。\r\n\r\n	2019-03-24 08:37:29.139776	f
679	302	Issue	5	学英语就是一个典型例子，记住的东西总是会忘。人总是习惯做好一些准备，然后开始一些事情。\r\n而现实通常是来不及的，有了一定基础了，just do it。	2019-03-24 14:25:35.797862	f
678	272	Issue	5	人对于数据的运用还处在很初期的阶段， 每个人都需要一个随身导师。\r\n\r\n要么用脑，要么用体力。关键是体力有些问题还解决不了	2019-03-24 14:09:23.630098	f
684	323	Issue	5	产品的本质就是解决客户的问题，提升客户的综合能力。\r\n工程的本质就是如何在有限资源下最大效率，质量的完成产品	2019-03-25 23:37:26.719905	f
685	324	Issue	5	顺丰可以支持整池扩容。\r\n\r\n总结一下对于产品而言，你看重什么，你觉得问题是什么真的至关重要。有些特性真的没那么重要，真正打攻坚战就看出来了。	2019-03-26 13:56:40.221008	f
686	326	Issue	6	胡冬寅的时间安排\r\n3月30日\r\n# 6:00-8:30学习跑步洗漱早餐 \r\n# 8:30-9:30陪谢震\r\n# 9:30-18:00陪购\r\n# 18:00-21:00吃晚餐陪谢震哄睡\r\n# 21:00-22:00跑步洗漱\r\n# 22:00-23:00梳理自己的疑问，看看周日去看房和约人需要弄清楚哪些方面的问题并文字话记录下来\r\n	2019-03-29 07:29:09.269981	f
687	326	Issue	6	3月31日\r\n# 6:00-9:00学习跑步洗漱早餐打扫卫生洗衣服\r\n# 9:00-18:00看装修带谢震出去玩，查看晚上见面有哪些地方方便\r\n# 18:00-20:00约见红花姐姐\r\n# 20:00-21:00陪谢震\r\n# 21:00-22:00跑步洗漱\r\n# 22:00-23:00学习及讨论下周活动及安排\r\n	2019-03-29 07:34:52.955316	f
689	163	Issue	5	插曲一：Profiler 是如何工作的？\r\n\r\nProfiler 会启动你的程序，然后通过配置操作系统，来定期中断程序，然后进行采样。比如发送 SIGPROF 信号给被分析的进程，这样进程就会被暂停，然后切换到 Profiler 中进行分析。Profiler 则取得被分析的程序的每个线程的当前位置等信息进行统计，然后恢复程序继续执行。\r\n\r\n这个用来做静态模块分析。\r\n但是动态的，请求类型汇总，请求延时跟踪得另外做。\r\n也就是说能够得到所有输入下的性能图。	2019-03-29 13:05:11.358646	f
690	116	Issue	5	最好单独给nginx tmp挂一个分区。避免将操作系统盘撑满。	2019-03-30 12:56:48.284958	f
691	326	Issue	6	周末活动安排总结\r\n已完成活动：陪购、带谢震出去玩、约见红花姐\r\n未完成活动：看装修、大扫除、学习和跑步以及知识整理及梳理\r\n\r\n后期活动安排需注意：\r\n# 如果是外出类型的活动，一般时间不好控制，当天避免安排两件活动，专心做好一件事情即可\r\n# 关于讨论的主题我们需要提前思考和事后总结，避免晚上思考太多而推迟睡眠，影响第二天的安排\r\n# 生活中我们要怀着一颗慢下来的心态，专注于我们自己生活的每一个片段，每一分每秒都是我们自己的生活\r\n# 重要的事情按照自己既定的节奏来，一步一个脚印做好重要但不紧急的事情\r\n\r\n	2019-04-01 12:55:11.526864	f
723	355	Issue	5	beas的假设：1，对于启迪场景，数据资源是企业的核心资源，数据的使用必须受控且有偿。因而统一存储并非常态。\r\n            2，即便对于单一数据源场景，beas作为中间件也能发挥其价值。beas的核心价值在于加速查询分析，其后可能延申到智能查询。	2019-04-25 17:00:06.52191	f
724	358	Issue	5	程序员应该学会用数学知识来描述其算法。\r\n用架构知识描述其设计\r\n用工程描述其实现	2019-04-26 06:58:12.976285	f
728	356	Issue	5	Access Schema： X Y N\r\nConstraint Index： x y  count\r\n\r\nN = Max(count(Y) group by X)\r\ncount = count(x,y) group by (x,y)\r\n\r\n也就是说N是表示对于一个具体x，y最多存在多少种情况。\r\ncount是对于具体的x，y。 实际上有多少条记录。\r\n	2019-04-26 15:06:05.09006	f
648	221	Issue	5	硬件篇\r\n1，观察人的身形，精神面貌，眼神\r\n2，你有哪些业余兴趣爱好？如何锻炼身体？\r\n3，逻辑思维能力\r\n\r\n操作系统\r\n管理：\r\n1，你怎样管理你的时间？\r\n2，你一般如何调整心态？\r\n3，你觉得生活哪些方面有压力，会对哪些事情焦虑？\r\n4，如果你负责一件事情，一般会如何做？（管理与执行）\r\n5，是否足够坚韧，克服困难。\r\n6，是否具备逻辑，科学严谨。\r\n\r\n自我认知：\r\n1，你认为你有哪些优点与缺点？ \r\n   有人马虎但积极，有人细心但是苛求，有人框架思维细节不够，有人擅长规划但不能执行，有人热情但情绪化，有人勇敢尝试有人固执保守。\r\n   有人有责任心，有人开放，有爱。有人宣称自己有爱，缺无责任心，有人宣称自己开放，却不思进去。有人说自己科学严谨，但做事并不细心认真。\r\n   有人热衷抱怨不思改进。\r\n\r\n   这里主要看能否认清自己，以及是否有逻辑。\r\n\r\n2，你的人生偶像是谁？\r\n\r\n升级更新：\r\n1，数学，英语基础 （与研究能力有关系，这个通常通过毕业学校可以看出基本）\r\n2，业余时间提升自己的方法？\r\n\r\n\r\n服务能力篇（看看他的产品逻辑是否完善）：\r\n1，你热爱什么工作？之前做的比较有成就感的事情是什么？\r\n2，描述你做成了哪些有一定难度的事？难在哪里？\r\n3，认识行业关键能力，工程能力， 需求分析，设计，代码编写， review，测试方法\r\n4，对于每个小部件是否有研究。练习程度是否够？\r\n5，建议都给一个开放式的编程题做。\r\n6，专业基础知识，计算，存储，网络，工具组件等\r\n\r\n外交综合篇 (看稳定性，延展性如何)\r\n1，来公司的诉求与动机是什么？\r\n2，考虑工作的出发点，行业/平台/薪资/领导风格\r\n3, 家庭情况，已婚/单身/小孩，生活压力怎样，另一半做什么？\r\n4，一般多久会与朋友聊聊天？（交往面等）\r\n\r\n对人的诊断。	2019-03-07 10:25:16.630307	f
693	272	Issue	5	通过计算，解决问题。\r\n计算与思考是与造物主(如果存在的话)最亲近的方式。	2019-04-04 20:51:07.06618	f
677	272	Issue	5	我相信爱，包容，开放，虚心\r\n我相信梦想，同时也接受现实\r\n我相信我可以改变，以拥有创造与精神的力量。\r\n\r\n如果能爱别人，那么就能接受别人，包容别人，看到别人遭受的痛苦，同时也能指出更好的路。\r\n\r\n那些震撼人心的，美妙的人和事才是最为宝贵的。\r\n消除工作中重复的部分，让自己享受美妙的生活。\r\n\r\n我们对于自己严格要求也是因为爱，我们热爱自己的事业，就像自己的孩子一样。我们以身作则，并能真正的享受这一切。\r\n我们在从事怎样的行业，我们在辅助别人少走弯路。让企业正确的决策，使其发挥更大的社会价值。安静的死亡与有序的重生。\r\n\r\n我帮人修复其逻辑机器，如果其还没逻辑机器，我可以给它建议。就像医生医人，我们医心，人心和企业的心。\r\n我需经过刻苦而积极的思考，只能做到这些吧	2019-03-24 13:57:01.723681	f
680	302	Issue	5	不要去专门学习工具，你要做的是理解工具的精髓，能解决什么问题。 在实际使用中理解它，掌握它，改进它。\r\n重要的是建立联系，运用起来。	2019-03-24 14:37:38.073171	f
681	103	Issue	5	不要去学习一个工具。我记不住这些东西。我可以告诉你我的理解。\r\n工具需要的是一个使用手册，查多了就自然缓存了。	2019-03-24 14:44:28.495524	f
682	321	Issue	5		2019-03-24 19:24:58.972114	f
683	323	Issue	5	找到目标客户，定义好解决的问题，以科学严谨的方式提供产品。\r\n\r\nor\r\n\r\n定义好解决的问题，寻找客户\r\n\r\n这两种方式是同源的，核心都是解决客户的问题，一个是从自己内部出发，一个是从外部出发	2019-03-25 23:35:53.024524	f
688	163	Issue	5	如果将程序看为复合函数。性能分析有2个维度：\r\n1，横向，可以了解在某一个场景下，每个模块的时间占用情况。\r\n2，纵向，分析某一个输入下，函数的一次运行，每个关键函数的执行时间消耗。（相当于延时分析）\r\n\r\n尤其是针对异常性能的纵向分析，可以了解系统发生了哪些奇异事件。\r\n\r\n性能的奇异事件，应该也是监控的一部分。	2019-03-29 12:04:32.564567	f
692	103	Issue	5	学习从热爱与明确目标开始的。打羽毛球就是其中典型。包括学习计算机知识。以前都做了很多年，但是没啥长进。\r\n有了热爱，有了目标，就会有目标机器，就开始总结原则，规律。并加以锻炼，然后水平才获得较大提升。	2019-04-03 07:08:06.781485	f
695	272	Issue	5	我对一切触及本质的问题都比较感兴趣，终究是因为我想了解复杂系统的运转规律。\r\n政经法，文史哲，古今人与事。\r\n对于建立系统，以及优化系统也充满兴趣。	2019-04-04 21:57:58.806734	f
698	280	Issue	5	提升3倍方法: 精力管理*时间管理*效率。\r\n\r\n这里提升指的是达到目标的能力。	2019-04-07 06:41:50.498672	f
700	332	Issue	5	共识算法与数据同步算法确实不一样。共识算法的基础是对等角色。而数据同步算法其角色不必对等。	2019-04-09 15:01:39.408918	f
701	334	Issue	5	深度思考，而不是浮在表面上的，搜搜问题，检查下基本代码逻辑等。这些是具体工作。\r\n\r\n深度思考是要想清楚一些核心基本问题。理清整体脉络。是用来改进机器的。而不是运转机器的。	2019-04-09 16:25:46.256886	f
694	293	Issue	5	另外系统可以有一个强大的仿真方法。比如针对某个输入或一组输入。我们通过记录每个函数的返回值。可以通过特定方式注入，然后模拟出来在该系列输入下，软件的行为。由此问题基本上是必现的。\r\n\r\n还有些模块可能具备累计效应，运行N多天才累计出问题。能否搞个时间模拟器，10分钟模拟出一天的效果。\r\n\r\n性能波动分析与疑难bug定位是消耗时间最多的地方。得有一个黑匣子(比如用数据库实现)，来分析系统的疑难问题。\r\n运用切片编程技术，实现黑匣子	2019-04-04 21:21:21.37795	f
696	329	Issue	5	三杰和陈平确实挺有意思。情商高的人洞悉人性，善于扑捉人情变化。阴谋搞短期战术，阳谋搞长期战略。\r\n\r\nhttps://www.zhihu.com/question/20764782，这里面提及的萧何有点意思，刘邦越败越强。\r\n\r\n刘邦 政治外交权术用人都玩的比较6，且利益分配搞得不错。	2019-04-04 23:06:55.732699	f
697	329	Issue	5	关于男女：https://www.douban.com/note/154731196/	2019-04-04 23:08:28.387731	f
699	215	Issue	5	1，如果在meta同步尚未完成的情况下，切换master会导致bucket始终无法同步。原因可能是触发bucket同步之后，其向新的master，也就是自己同步。这样必然同步失败。\r\n2，在一端删除bucket时，另一站点的数据没法正常删除。	2019-04-09 07:47:28.498816	f
702	216	Issue	5	最近思路;分2层，第一层仍然使用hash。第二层使用range index（或hash index加内存排序)。第二层放在一个rados对象+多个附属对象上。\r\n附属对象的作用是降低恢复成本。同时使用range方式。附属对象还可以缩小查找范围。\r\n\r\n用cls和附属对象实现一个range index。可定义每个index比如1万个key。	2019-04-15 08:35:34.796068	f
703	21	Issue	5	[root@wade3hao74b2 ceph]# xfs_db -r -c "sb 0" -c "p" -c "freesp -s " /dev/sdd\r\n\r\n   from      to extents  blocks    pct\r\n      1       1    2004    2004   0.01\r\n      2       3     507    1297   0.01\r\n      4       7    1020    5474   0.02\r\n      8      15    4020   51071   0.20\r\n     16      31 1124566 25807052  99.77\r\n\r\n比如这种情况\r\n[root@wade3hao74b2 ceph]# xfs_info /dev/sdd\r\nmeta-data=/dev/sdd               isize=2048   agcount=4, agsize=15262412 blks\r\n         =                       sectsz=512   attr=2, projid32bit=1\r\n         =                       crc=0        finobt=0\r\ndata     =                       bsize=4096   blocks=61049646, imaxpct=25\r\n         =                       sunit=0      swidth=0 blks\r\nnaming   =version 2              bsize=4096   ascii-ci=0 ftype=0\r\nlog      =internal               bsize=4096   blocks=29809, version=2\r\n         =                       sectsz=512   sunit=0 blks, lazy-count=1\r\nrealtime =none                   extsz=4096   blocks=0, rtextents=0\r\n\r\ninode是2048，64个inodesize就是32个block。上述磁盘没有连续的32个block了。因而无法分配inode。报空间不够的错误。	2019-04-15 08:50:08.677897	f
704	336	Issue	5		2019-04-15 14:07:56.791527	f
705	336	Issue	5		2019-04-15 14:08:26.870096	f
706	240	Issue	5	机器：\r\n为何存在，目的是什么？\r\n是否合适？\r\n适用场景？\r\n优缺点分析，核心缺陷？\r\n在哪些情况下发生变化？\r\n涉及哪些外部交互？\r\n故障场景？\r\n是否会升级?\r\n出问题如何分析？	2019-04-15 14:24:43.591964	f
707	274	Issue	5	数据挖掘就是人提供了算法，参数。现有计算机系统基本都是这种模型的。\r\nAI是提供了通用基础算法，然后利用输入，输出训练具体算法。这就是学习。\r\n	2019-04-16 12:24:30.771947	f
709	341	Issue	5	beas将metadata，constraint index，sampling的数据在本地化存储。\r\n利用这些数据可生成查询计划。	2019-04-22 12:52:55.022819	f
710	341	Issue	5	目前看不到核心重点，以及难点在哪里?\r\n\r\n查询引擎如何高效的使用索引数据？\r\n现在的查询引擎如何运用采样或索引数据，来制定查询计划？\r\n以后是否需支持分布式？TiDB的计算架构？整体的存储计算架构。	2019-04-22 13:07:06.909384	f
711	341	Issue	5	需求：\r\n索引数据是怎样存储的？\r\nmetadata如何存储，是建同样的表么？如何区分不同库的不同表？\r\n采样数据是什么样的？怎么存储？\r\n字段可在线增加么？索引字段变更？\r\n\r\n	2019-04-22 13:11:13.25566	f
712	340	Issue	5	win10-ubuntu: xierui/xierui\r\npostgresql: xierui/Anew***422	2019-04-22 14:33:28.860757	f
714	342	Issue	5	R={x | x不属于x }，然后现在问R是否属于R。如果R不属于R，那么根据定义，R属于R；如果R属于R，那么根据定义，R不属于R。\r\n\r\n| 后面可理解为一种关系: x不属于x 对应于 x不属于自己理发的人	2019-04-23 10:41:18.587824	f
715	341	Issue	5	1，整体模块架构\r\n2，整体进程架构，以及交互\r\n3，配置管理\r\n4，日志管理\r\n5，系统内部状态监控\r\n6，cache设计\r\n7，元数据存储，索引，数据存储结构\r\n8，内部管理\r\n9，通信模块\r\n10，核心算法\r\n11.工具	2019-04-23 13:48:20.901958	f
716	341	Issue	5	我也认为对象数据库是一个失败的尝试：\r\nhttps://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E5%BA%93	2019-04-23 14:10:25.375228	f
717	341	Issue	5	BgWriter和WalWriter工作模式都有点奇怪，在其异常时，postgres进程又能自行做这些工作。\r\nPGarch比较好理解，通过保存全量的wal日志来追踪所有的数据修改，然后实现任意时间点的数据恢复。	2019-04-23 15:01:52.311819	f
708	280	Issue	5	我相信每个人都有无限潜能\r\n我相信每个人都可以过得更好\r\n\r\nso：\r\n我选择乐观，而不是悲观\r\n我选择开放，而不是封闭\r\n我选择按计划自律生活，而不是随心所欲\r\n我选择接收现实并着手改变，而不是防御\r\n我选择有趣，而不是boring\r\n\r\n世界是逻辑的，以目标逻辑机器的方式运作自己的系统。\r\n人生是一种旅途，体验各种感觉。\r\n没有所谓的价值与对错，只有适合当下的选择。生存或死亡都是选择。但不能南辕北辙。\r\n\r\n3.0版本，个人角色是高级软件工程师。把4台机器运转好。\r\n3.0版本，我想重构自己的思维模式，从数学基础来思考问题，而不是从一个形式到另一个形式的关联分析与归纳。\r\n明确算法理论与工程实现。算法理论是经骨，工程实现是皮肉。	2019-04-21 14:54:32.678506	f
718	346	Issue	5	牛顿和莱布尼茨的时代真是牛逼。微积分和数理逻辑的起源都在那个时候。符号化，证明是这一切的根源。哲学促进了科学的发展。\r\n\r\n而欧洲那时候需要数学也是因为资本主义的发展需要。。。	2019-04-24 06:48:56.206361	f
289	39	Issue	5	有一点不明白的是为什么filestore放置的时候，采用hash的反序？ \r\nhash根据取模运算之后，hash的后几位决定了在那个pg，在pg内部后几位是非常接近的。为什么还要反序呢？\r\n这样岂不是会加深目录层次？\r\n\r\n反序是为了方便pg分裂，pg分裂的时候需根据hash来分割对象。	2018-08-17 15:25:06.242833	f
719	347	Issue	5	比如面试时，我想知道一个人的交通信息，一个人的犯罪信息。提交的代码量，参与项目的情况。 最终得到一个值是否通过面试。\r\n\r\n这就是一套算法。	2019-04-24 09:23:39.658886	f
770	359	Issue	5		2019-05-07 09:18:33.949761	f
740	359	Issue	5	Schema使用例子：\r\n存在一张学生日志记录表，其中日志中有日期，天气，作者，事件等信息。\r\n另外还有一张表记录了某个学生请假的情况，有学生，请假，日期。\r\n\r\n现在想分析学生请假与下雨的关系。\r\n这样可使用schema：日期->天气\r\n学生日志记录表可抽取 日期|天气的子表。其记录数量远小于学生日志记录表。\r\n\r\n由此说来存在子表通常更可能出现在表设计没有充分分解的情况。如果将日志记录表拆开。\r\n日期，作者，事件\r\n日期，天气\r\n这样就不存在问题。	2019-04-28 12:11:31.220642	f
713	342	Issue	5	第一次数学危机起源于根号2，结束于无理数的定义。\r\n第二次数学危机是关于无限分割空间和时间的。实际上我们知道对2无线分割，比如1+1/2+1/4 好像可以无限加下去，应该是个无穷大的数。然后实际上不可能超过2.\r\n第二次数据危机的解决与级数和微积分相关。\r\nhttps://zh.wikipedia.org/wiki/%E6%9E%81%E9%99%90_(%E6%95%B0%E5%AD%A6)\r\n\r\n第三次数据危机\r\nhttps://baike.baidu.com/item/ZF%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F\r\n\r\n我没理解罗素悖论的本质。一个难题是如何将现实中的问题抽象的逻辑问题？\r\n\r\n罗素悖论的逻辑描述：（？？？怎么抽象的）\r\n如果存在一个集合A={x | x∉ A }，那么A∈A是否成立？如果它成立，那么x∈A，不满足A的特征性质。如果它不成立，A就满足了特征性质。\r\n\r\nhttps://baike.baidu.com/item/ZF%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F\r\n(8)正则公理：也叫基础公理。所有集都是良基集。说明一个集合的元素都具有最小性质，例如，不允许出现x属于x的情况。\r\n准确的定义：“对任意非空集合x，x至少有一元素y使x∩y为空集。”\r\n以上8条公理组成了ZF公理系统，再加上选择公理，则组成了ZFC公理系统。\r\n\r\n这里理解吧，如果性质定义了一个集合。朴素集合论认为元素要么属于集合，要么不属于集合。\r\n罗素悖论的意思是存在性质，使得一个元素既无法属于集合，也没法不属于集合。 就是说性质描述可能存在矛盾。\r\n\r\n那么这个矛盾一定是自己导致的吗？ 自我相关导致的？\r\n\r\n\r\n<pre><code class="text">\r\n理发师悖论可以表达成集合论的形式，就是罗素悖论。R={x | x不属于x }，然后现在问R是否属于R。\r\n如果R不属于R，那么根据定义，R属于R；如果R属于R，那么根据定义，R不属于R。基于这两种不同的数学哲学基础，\r\n面对悖论问题时，可以得出很不相同的分析方式和解决方式。一百年前出现罗素悖论的时候，\r\n数学家们普通接受“发现”的数学哲学观点，当数学出现悖论的时候，就觉得天塌下来了：我的上帝，\r\n是不是客观真理出问题了，或者上帝旨意出问题了？如果是以维氏“发明”的数学哲学观点，\r\n就觉得没有什么大不了的，根本不是客观真理出问题了，而是数学家主观观念出问题了。数学家构造的规则矛盾了，\r\n在矛盾的地方再构造一个新规则就是了。举个例子，就像一开始根据乘法来定义除法a/b=c iff a=b*c，就会得出0/0=2=3这样的矛盾。\r\n怎么解决这里的矛盾呢？难道要取消所有的除法？当然不是了，只需要在矛盾的地方重新定义一下：0不能作除数。瞧，问题就解决了。\r\n\r\n作者：庄朝晖\r\n链接：https://www.zhihu.com/question/20511488/answer/128130551\r\n来源：知乎\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n</code></pre>\r\n\r\n	2019-04-23 07:00:36.45853	f
722	353	Issue	5		2019-04-25 09:27:07.899128	f
725	359	Issue	5		2019-04-26 08:47:07.111387	f
726	361	Issue	5	SysCache很简单就是一个数组，定长的。\r\nVFS时一个LRU链表，用来管理VfdCache。\r\nRelCache是用hash表来存的。因为变化少，且不必排序。\r\n共享缓存区采用hash加freelist来管理\r\n本地缓冲池也采用hash管理，利用文件块信息来创建和管理。	2019-04-26 09:00:00.414462	f
727	360	Issue	5	比如一个问题，我在内存中缓存了schema，但是在另外一个pg实例中删除了。可能导致查询计划无效。这时pg是返回错误吗？还是修改查询计划？\r\n\r\ncache的作用在于减少查询，如果要加表锁，实际操作仍然需在下面执行的。	2019-04-26 09:12:04.353944	f
729	355	Issue	5	Executor要考虑迭代算子\r\n基于结果的缓存，物化视图，从而对于后续查询可以优化。 比如查询a>1,与后续查询a>2， 就存在重用情况。	2019-04-26 15:08:09.253913	f
743	366	Issue	5		2019-04-28 14:09:55.226877	f
731	359	Issue	5	目前bounded query是只考虑等值条件的。实际上bounded query是思想就是index，只是这个index可能不那么显而易见。 其实有一个合适的DBA，识别出索引就可以解决这个问题。\r\n自动索引技术。\r\n\r\nno，等值是在传递条件。但bounded本身是索引。而且Access Schema如何跨table还是一个复杂的问题。\r\n\r\nc1->c2,c2->c3. 可以推导出c1->c3.\r\n\r\n等值条件对于bound，就是范围是有影响的。即便不是等值条件，Schema也有其存在价值。	2019-04-27 09:04:47.209947	f
732	356	Issue	5	在同一个表传递schema的时候存在放大的情况是指\r\nc1=1，c1->c2,c2->c3 求笛卡尔积，则最终结果还得使用c1=1来约束，否则就存在放大的情况。	2019-04-27 11:59:05.290744	f
734	359	Issue	5	实际上AccessSchema就是大表中存在的一个小表。而且这个表上应该建index。所谓constraint index其实就是小表的内容。\r\n对于beas而言，甚至可以把常用的表即便没有AccessSchema拉取到本地。而AccessSchema本身就是一个小表。\r\n\r\n这样就比较好举例了，比如在日志中收集每天的天气信息。这样就可以形成一个小表。	2019-04-28 06:40:52.429021	f
735	76	Issue	5	总结：在该次重构中，存在2个大问题。\r\n1，重构机会难得，但是未能做彻底，虽然有时间上的约束，但是考虑不全面才是根因。\r\n比如元数据规模缩减，多站点重构，关于bucket跨pool的抽象处理等\r\n\r\n2，未考虑由此带来的安装，升级，以及性能上的深刻影响。\r\n这点就显得在工程上不是很专业了。一个大的改动如果不深入分析每个地方的影响显然是不合适的。	2019-04-28 07:30:40.822788	f
736	240	Issue	5	当对当前工程改动或设计子模块时，理应从各种维度去分析，而不是像哲学思考一样快刀斩乱麻，还得考虑各个相关部分如何做。（请参考BI改造任务的总结）。\r\n所以实际上事情还是非常多的。而且得对现在系统有非常深入的理解。\r\n\r\n模块拆分与特性树：欧博与yy让我见识到对单个任务“分解与合作”的玩法。我之前更喜欢由每个人持续完成一个任务，但是这样一方面任务太大，一个人可能难以完成且缺乏讨论。\r\n\r\n工程有趣在于其考虑实用性，效率，以及可发展性等等涉及人与资源方面的考量。而科学更侧重问题的解决算法。	2019-04-28 07:41:53.638802	f
737	359	Issue	5	1，AccessSchema相当于子表，这样理解则可以看AccessSchema看成一种特别的RelSchema，而ConstraintIndex其实就AccessSchema的内容。\r\n  这样可以整体将其看成一张表。\r\n2，AccessSchema上可能需要建立X上的索引，方便查找。\r\n3，主键到其他字段存在Schema，PrimaryKey→Y, 1,而PrimayKey本身有索引。\r\n4，C1->C2,C2→C3,在什么情况下考虑提前生成C1→C3,自动过程还是手动。\r\n5，对于频繁访问的某个表，对于beas也可以加载以获取加速。\r\n6，AccessSchema的访问统计，自动淘汰	2019-04-28 07:54:12.602087	f
745	122	Issue	5	还有非常重要的是：任务划分，另外团队中是否有人掉队也是需考虑的。\r\n任务划分有时候需独立，但重大任务需要协作，并做内部分工，且需要更多人参与讨论。\r\n\r\n管理需发挥集体智慧。\r\n\r\n当一个任务中，有人在理解执行上掉队了，可能就无法发挥很好的价值。这是作为leader需要关注的。\r\n\r\n现实情况人不合适，完不成任务就干掉，换其他人 不一定很合适。\r\n尤其是团队内部，要区分其可能跟上与完全没法胜任的情况。	2019-04-28 14:19:36.417911	f
748	367	Issue	5	beas的执行框架，日志系统，以及后续延展有更大的空间，否则你穿上pg的架子，最终受其影响必然很大。	2019-04-29 07:19:56.663317	f
746	364	Issue	5	1，buffer与事务并发控制的锁有何关系？\r\n  没有关系，锁是通过LockTag定位的，锁存储与记录没任何关系。 这是pg单实例运行决定的。\r\n\r\n2，脏buffer是整体写回么\r\n  这个估计是的。不过通常空间分配是追加的，除非空洞情况。这也有vacuum来处理。\r\n\r\n3，如何通知buffer失效。\r\n不存在，buffer本身就在共享内存中。本地缓冲区仅用于本地临时可见的表。\r\n\r\n4，为什么关闭表需写回脏页？放在后面由WalWriter写回不行么？WalWriter挂掉的情况？\r\n\r\n5，进程挂掉时，如何保证所有状态的正常清理，如锁，buffer的pin，lock	2019-04-28 14:24:45.023461	f
749	367	Issue	5	把beas丢到其他框架，需考虑其框架是否满足pg的发展要求。\r\n而自定义beas框架，同样也需搞清楚beas需要的架构是什么？\r\n\r\n在其他框架上做，实现上阻碍：\r\n1，不改动pg函数，而是新增函数。显然做不到，至少得在原来逻辑上加不同分支吧\r\n2，要在pg内注册大量的勾子与新增定义。而将pg定义为子模块，则实现一个wrapper层就可以了。\r\n\r\n感觉将beas包pg，这样修改的侵入式应该更低，也更可控。\r\n1，线程模型，执行模型可控\r\n2，调度过程可控	2019-04-29 07:45:02.265066	f
773	373	Issue	5	是否存在在beas中使用pg中特定的MemoryContext来分配内存的情况\r\n是否存在在beas中创建pg的新的MemoryContext情况？\r\n\r\n应该都不存在。	2019-05-07 18:25:10.498289	f
1429	658	Issue	5	在我想做的领域我就是最强的那个人，why？ 因为我既敢于冒险，也敢于面对现实，既能运用感性的力量，也能运用理性的力量。\r\n我就是天生的领路人，开拓者。	2020-09-23 21:10:30.321741	f
730	359	Issue	5	索引存在的关系：\r\n\r\n显式关系：\r\nX->常量  N\r\nX->Y     N\r\nX1->X2   N (同一个表)\r\n\r\n隐式关系：\r\nX1->X2\r\nX->Y,Y->Z => X->Z\r\n\r\n操作：\r\n1，查找从表A字段x出发到表B存在关系\r\n2，从表A出发到表B存在的关系（约束：表A的查询需在B之前）\r\n\r\n举例：\r\n1，直接查找 \r\nC1->B2. 查找C1，B3 where C1=1 and C1=B2\r\n\r\n2，根据表内的隐式关系\r\nC2->B2, 查找C1，B3 where C1=1 and C3=B2\r\n可利用C1->C2，C2->B2的关系, Fetch B时使用C2->B2?\r\n不这个逻辑是错误的，Schema的含义就是constraint index，要使用index必须有等值条件。\r\n\r\n我们是通过等值条件来搜索索引。这点不论有没constraint index都是一样的。（我们的目标就是看是否所有的等值条件都有索引） （*其实非等值条件也是可以考虑的*）\r\n\r\n\r\n \r\n	2019-04-27 07:54:12.186091	f
733	356	Issue	5	存在主键的情况，主键对于其他列都是以1 bounded的。\r\nconstraint index实际上是表，而非索引。	2019-04-27 13:45:26.655018	f
761	373	Issue	5	pg内存管理分析：\r\npg内存被memcontext接管，可以定义一个模块。定义初始化函数注入函数指针。这样可间接使用pg的内存管理机制。\r\npg有palloc，repalloc，pfree等函数。 也可注入jemalloc函数等。以中间件的方式使用内存。\r\n\r\n*内存管理主要2问题：\r\n1，如何在并发，多核，以及不同使用场景(分配的大小，以及分配释放的特征)等情况下高效的管理内存\r\n2，如何避免内存泄漏*\r\n\r\n高效率的分配，以及内存泄漏检测jemalloc和tcmalloc都有现成的。\r\n有种场景是可以利用利用率来换取内存分配速度。比如常见的freelist内存池管理。	2019-05-05 07:23:26.546895	f
738	361	Issue	5	SysCache缓存了所有系统表元组，其中每个表的元组在内存中为CatCache结构管理。\r\n系统表本身是用cachedesc结构来描述的，存在静态数组cacheinfo中，CatCahce中的Cat可能是Cataog的简写。\r\nSysCache中的具体元组不是一次性加载的，随着系统运行加载。\r\n\r\nCatCache是用hash组织其中的元组的，同一个桶内用双向链表组织。\r\nCatCache中的元组结构体为CatCTup。\r\n\r\n查找：CatCache中的元组，其hash值可以从最多4个key组合计算而来。\r\n\r\nRelCache的管理更为简单，因为其变化更少。直接根据oid Hash查找即可。\r\n\r\n*Cache的同步都是在事务完成之后进行的，有个问题，如果其他postgres用到了对应的数据，是否都需要在加锁成功(假设资源先被其他事务占据)之后刷新Cache？*\r\n\r\n这个是有处理的，参考AcceptInvalidationMessages调用的地方就明白了	2019-04-28 08:56:46.924991	f
739	361	Issue	5		2019-04-28 09:07:33.351868	f
741	359	Issue	5	根据beas面临的io特征，考虑AccessSchema，以及索引的组织。 更夸张点，AccessSchema是否可以其他方式存储。而非pg的数据组织方式。\r\nAccessSchema是否采用全内存组织？	2019-04-28 12:36:01.840401	f
742	355	Issue	5	beas是做到pg内，还是pg外？ 如果算子类本身就是pg的扩展，那么是否需要抽象成与pg无关，这似乎不是很有必要。\r\n虽然号称解耦，但逻辑上本身就有耦合性。	2019-04-28 13:54:11.938912	f
744	357	Issue	5	这是一个很大的问题，其实之前在华为工作就有这点，每个人的信息量不一样，当我们不具备或不去收集需要进行决策的信息时，我们就没法深入讨论，也就没法跟着团队一同往前走。\r\n最终效果可能就变成了只能做些局部功能。	2019-04-28 14:14:51.278163	f
747	368	Issue	5		2019-04-28 15:06:23.082001	f
752	115	Issue	5	例子1：\r\nLinux上vim保存文件默认使用utf8，编译时指定使用GB2312 ，则输出为乱码：\r\n[root@iZwz9h8nr0sr6y7lz3hih4Z c_code]# gcc -o test test.c -fexec-charset=GB2312 \r\n[root@iZwz9h8nr0sr6y7lz3hih4Z c_code]# ./test\r\nא¹򯜚\r\n\r\n	2019-04-29 14:59:32.905424	f
753	280	Issue	5	成为一个真正的程序员（Coder），而不是码农。	2019-04-29 15:04:14.489883	f
756	375	Issue	5		2019-05-04 04:36:29.613162	f
758	375	Issue	5		2019-05-04 04:39:11.151195	f
763	378	Issue	5		2019-05-05 16:52:09.001205	f
760	373	Issue	5	内存管理：\r\n1，每次执行做一次内存分配，还是所有内存都初始化分配好？\r\n是否考虑采用jemalloc？似乎没必要，目前是单进程模型。\r\n\r\nmysql内存管理分析\r\n\r\n2，对于后续的内存加速这块，对于内存分配的要求。\r\n这个应该是必须的，内存用来加速分析应该是典型场景了。但是对于pg，这个是不是得搞共享内存了。\r\n\r\nredis内存管理分析。\r\n\r\n\r\n	2019-05-05 06:53:21.016394	f
765	370	Issue	5	E8. 蕴含等值式 \r\n理解：很重要的逻辑等价式，证明可以通过真值表验证。\r\n\r\nE8. A→B╞╡¬A∨B \r\n\r\n\r\nE17.等价等值式II \r\n理解：如果两个命题等价：要么这两个命题都成立，要么这两个命题都不成立。\r\n\r\nE17. A↔B╞╡(A∧B)∨(¬A∧¬B)\r\n\r\n	2019-05-06 19:58:11.226519	f
767	353	Issue	5	可以看到的是，如果仅通过形式系统本身的公理 \\ 规则，是很难（或者说不可能）在有限的步骤内判定一个命题公式是否是该形式系统内的定理的；PC 系统也是如此。而同构的方式可以很好的解决这个问题。 PC 系统本身也具有自己的同构系统：真值函数运算系统。因此，判定 PC 系统中的命题公式是否为定理就非常简单了：我们只需要用真值表判断命题公式对应的真值函数是否是重言式，就可以判断该命题公式是否是 PC 中的定理。 而利用真值表计算代替使用PC系统自身元素推演，就像是利用数论解决MIU系统的难题一样，有一个最大的优势：前者的计算都是可以在有限步骤内完成的。\r\n\r\nMIU那个神奇的例子，居然通过数字化310，可证明MU不属于符号系统MIU。	2019-05-06 20:10:10.730279	f
750	359	Issue	5	1，通过Admin Tool/PGSql发起CreateAccessConstraint的DDL命令\r\n2，Parser解析CreateAccessConstraint命令\r\n3，执行CreateAccessConstraint命令\r\n  3.1 检验AccessConstraint对应的表和字段合法性\r\n  3.2 在AccessSchema系统表中存储AccessConstraint\r\n  3.3 创建ConstraintIndex表，并在其上建立基于X（X可能是多列）的索引，并用源表数据填充其内容\r\n  3.4 更新AccessSchemaCache\r\n4，返回DDL执行结果\r\n\r\n待确定：\r\n1，AccessConstraint支持跨表，跨库（暂不支持）\r\n2，C1->C2,C2→C3,在什么情况下考虑提前生成C1→C3,自动过程还是手动。（最小系统先不考虑）\r\n3，对于频繁访问的某个表，对于beas也可以加载以获取加速。（最小系统先不考虑）\r\n4，AccessSchema的访问统计，自动淘汰。（最小系统先不考虑）\r\n\r\n子功能拆分：\r\n1，支持创建Access Schema命令\r\n涉及模块：Parser，Utility， Command，Catelog， Cache\r\n输入：SQL字符串\r\n输出：执行结果\r\n任务描述：\r\n解析SQL字符串\r\n CreateAccessSchema的执行，包括语义合法性检查，创建ConstraintIndex表，以及索引等。\r\n AccessSchemaCache的更新\r\n异常场景：\r\nSQL命令格式错误，返回错误\r\nSQL命令内容错误，如表或字段非法等，返回错误\r\n技术点：\r\n    ConstraintIndex内容加载的时机，以及状态管理。\r\n\r\n2，查询某个表或表字段（可能多个），是否存在对应的AccessSchema\r\n涉及模块：AccessSchemaCache，Catelog\r\n输入：表，字段\r\n输出：对应的AccessConstraint描述符列表\r\n任务描述：\r\n     1，从AccessSchemaCache中找出相关表的所有存在的AccessSchema\r\n     2，找出某个字段存在的AccessSchema\r\n异常场景：\r\n技术点：\r\n   组织方式\r\n\r\n3，提供接口，支持向ConstraintIndex中插入或删除数据\r\n涉及模块：DML\r\n输入：SQL\r\n输出：执行结果\r\n任务描述：\r\n     1，在数据变化时，根据变化情况更新ConstaintIndex。\r\n技术点：\r\n    这里源表的update，需根据old tuple/new tuple一起刷新ConstraintIndex	2019-04-29 14:05:09.504529	f
751	373	Issue	5	1，字符编码问题\r\n2，字符串提供的功能，比如搜索？查找，判断是否为数字，转换等等\r\n3，内存管理考虑的重点是减少内存拷贝且安全的使用？	2019-04-29 14:40:29.265288	f
754	368	Issue	5	https://www.toutiao.com/a6672612422768919054/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1556530757&app=news_article&utm_source=weixin&utm_medium=toutiao_ios&req_id=2019042917391601002905119484405E5&group_id=6672612422768919054\r\n\r\n一些比较形象的比喻	2019-04-29 15:30:06.608038	f
771	373	Issue	1	内存管理：\r\nbeas的内存使用存在两种情况，1是beas内使用，pg释放。2是beas使用，beas释放。\r\n原则上在beas内可释放的内存，不能延迟到pg释放。\r\n\r\n因而这里有两种MemAllocator，一种是PgAllocator，另一种是BeasAllocator。\r\n在调用内存管理接口时，根据需要传入不同的Allocator。\r\n\r\nbeas内存管理不做类pg上下文管理，pg调用beas函数之前需切换好上下文。\r\n\r\n需考虑共享内存的情况，比如在多个beas实例共享，同步数据等。\r\n\r\n字符串：\r\nSds将内存分配从字符串中剥离出来。封装字符串结构，除了封装字符串的特定优化操作外，\r\n其他字符串函数面向C字符串，从而避免使用时需额外从char *转换到Sds。	2019-05-07 14:50:49.704577	f
755	345	Issue	5	1：A = {y为自己 | Q(y) } 给自己理发的人。\r\n2：Q(x) = x不属于A\r\n\r\n从这个定义看本身就蕴含矛盾。\r\n如果理发师M属于A，则Q(x)为真，M不应该属于A。\r\n如果从2出发，理发师M不属于A。Q(x)为真，则可推出理发师M属于A。\r\n从理发师角度出发上述可描述为：\r\n1：A = {x | Q(x)} \r\n2: Q(x) = x不属于A\r\n这是给自己理发的人的精确描述，假设岛上所有人均可能是理发师。\r\nA就是描述所有给自己理发的人。Q(x)描述的命题为给x理发。\r\n理发师的描述为：\r\nA = { x | 存在y，满足Q(y) }，理发师至少给某个人理发，可以是自己也可以是别人。\r\n给自己理发的人：\r\nB = {x | Q(x)} \r\nB属于A	2019-05-02 19:07:01.980005	f
757	375	Issue	5		2019-05-04 04:37:57.415766	f
759	372	Issue	5	2，提前半小时准备入睡，所以最晚时间是10：30\r\n3，不要过度运动，过度饮食，否则长期无法恢复。\r\n4，不要在家里安排个人学习，家里可安排交流类，放假期间可安排交际等等。	2019-05-05 06:36:08.71394	f
768	346	Issue	5	数理逻辑，形式逻辑是其他一切，包括集合论的基础，凡是涉及符号系统，以及证明类。都与数理逻辑有关系。\r\n所以数理逻辑是离散数学的第一章	2019-05-06 20:22:52.515745	f
762	373	Issue	5	这个c的字符串库应该可以满足要求：\r\nhttps://github.com/antirez/sds\r\n调研清楚，看是否满足要求，这里涉及一次类型转换。\r\n\r\n*动态字符串，主要解决char*没有记录字符串长度引起的低效，以及越界问题。*\r\nhttps://stackoverflow.com/questions/4688041/good-c-string-library\r\n好像sds比bstring更受欢迎，基本确定就基于sds了。	2019-05-05 09:14:26.401778	f
764	373	Issue	5	在使用pg过程中，内存分配在使用上存在哪些坑。\r\nMemoryContext释放也有讲究，有的是reset，有的内存是直接释放的。意外情况具体指什么呢？ pg出错跳转有何特别？\r\n\r\n梳理清理事务执行期间相关的MemoryContext。\r\n\r\nfree之后自动将指针置为空。增加内存泄漏的自动检测？\r\n\r\n议题：\r\n1，有没必要设计内存泄露检测机制\r\n2，有没必要设计打桩，以验证程序在内存不足时的行为。\r\n3, pg内存分配\r\n  pg的内存接口在palloc.h中，其中使用palloc与MemoryContextAlloc的都有\r\n  而MemmoryContext的管理主要在memutils.h中\r\n\r\n4，一种内存分配方式够用么？是否提供多种抽象？有default，但是也可以没有？\r\n5，短期内存的分配与使用。\r\n  常用内存分配算法有堆内存分配，伙伴算法，slab算法\r\n6，内存对齐\r\n7，在没有额外支持情况下，仅仅靠对malloc接口封装，可能难以支持内存池管理的扩展需求，\r\n还是这些扩展需求放到上层来实现。	2019-05-05 17:17:28.112476	f
772	366	Issue	1	目前看工作量过大，主要是pg无法作为独立的库，其中有大量的全局变量等。	2019-05-07 14:56:02.809029	f
769	359	Issue	5	按照最新讨论AccessSchema不能存为\r\nX，Y， count。  还要包含X，Y对应的tupleid。否则在没Cover住的情况下，其他列获取效率就比较低了。\r\n这时存在4种扫描方式：\r\n1，全表扫描\r\n2，利用条件，下推做全表扫描（比如仅有条件a=1）\r\n3，利用原表的索引（a上建立了索引）\r\n4，利用tupleid（这是最高效的方式，因此需记录tupleid）\r\n\r\n那么问题来了，X，Y对应的tupleid有多个，如何存储于检索，另外如何在表存在多个schema时，避免冗余存储？\r\n\r\n另外一个问题是跨表跨库的AccessSchema.\r\nR1(w,x),R2(w,y)\r\nAccessSchema存储为（W，X，Y，R1_tpuleids，R2_tupeids, count）,这样count不是针对x，y。如果在x，y上执行count，需额外执行一次计数操作。\r\n\r\n	2019-05-07 08:58:55.525271	f
804	398	Issue	5	https://segmentfault.com/a/1190000008949574\r\n\r\nextern关键词，可以扩大声明的作用范围。\r\n也可以把extern加在变量定义前面，但这没什么卵用。默认就是extern的。\r\nextern "C" 中的extern显然也没什么卵用，这是一个固定用法，告诉编译器用C方式编译代码。	2019-05-14 15:15:19.854608	f
806	397	Issue	5	宏定义：编译期间替换。\r\n\r\n宏定义做符号替换，不会实际运算。\r\n预编译的宏是需在编译期间就确定的，比如struct A##x，如果x是变量就没法编译通过。	2019-05-14 18:26:38.360529	f
807	371	Issue	5	数学通过符号抽象，通过演绎证明，等价转换去理解复杂事务。	2019-05-14 18:35:30.859089	f
1430	545	Issue	5	该系统在其他系统之上引入了什么特性，其最明显的差异点是什么。\r\n要哪些求解方式，哪些解本质上是等价的。\r\n如何用数学语言来描述问题，从而找到问题的本质	2020-09-23 21:14:35.737735	f
774	373	Issue	5	问题1：根据内部使用与外部使用分2套接口函数，还是统一使用一套接口函数？\r\n问题2：是否需要提供Reset等接口？如何看待宿主与beas关系？\r\n  对于beas而言，需要的部分是内存分配。宿主需要有最终释放内存的能力。\r\n  增加Reset接口是对这种能力的一种约束。\r\n  问题2.1 PG是如何管理内存的，在何时reset。怎么切换MemoryContext？什么情况下提前释放MemoryContext。\r\n问题3：context，尤其是具体类型的context，是由宿主来管理的。beas提供的是算法，而数据的主体在宿主中。\r\n比如CurMemoryAllocator这种显然不合适，greenplum可能没这个概念。然后对接greenplum相关分配内存都得修改？\r\n只能让宿主提供具体实现。\r\n  \r\n  问题3.1，如果beas需要根据需求，将不同的内存挂在具有不同生命周期的MemoryContext上，则必须感知不同的MemoryContext。\r\n而问题是在不同系统中，不同的管理方式对应的MemoryContext是不一样的。\r\n           一种解决方法是增加约束：beas只能在当前上下文分配外部的内存。\r\n           二是beas根据自身需要，不得已情况下定义不同类型的宿主Allocator，让宿主决定如何具体实现。	2019-05-08 15:15:24.23602	f
775	369	Issue	5	模式与实现分离，不要随意为了实现而变更设计，这样就会犯理论上的错误。\r\n\r\n给问题一个明确的定义，甚至一个理论上的定义。然后再按层次分解问题。	2019-05-08 15:27:02.433122	f
811	402	Issue	5		2019-05-16 08:19:51.748535	f
813	402	Issue	5	安全函数是否需考虑 拷贝或cat的源与目的存在内存重叠的情况\r\nbstring的拷贝也是用memcpy实现的，要不要考虑memmove的场景。	2019-05-16 09:37:25.459067	f
779	384	Issue	5	BSP，Hadoop，Spark，Orca，GreenPlum，Flink，Calcite，NLP(自然语言->SQL)\r\n\r\nRedshift（也是基于pg，提供行存和列存等等），GreenPlum 数仓产品\r\n\r\nHive，HAWQ， SparkSql\r\n\r\nGreenPlumDB缩写为GPDB	2019-05-09 17:49:06.649144	f
782	384	Issue	5	https://db-engines.com/en/ranking\r\n\r\n数据库产品真实五花八门。\r\n\r\n即便是同一种类型的也有很多款	2019-05-09 20:11:35.652805	f
783	373	Issue	5	不修改sds，新增将一段内存转换为sds的接口。原先sds跟内存相关的接口屏蔽掉。\r\nsds是一个结构体。当然也是一个char *，sds使用时当作char *完全没问题。唯一需注意的是释放的时候。\r\n\r\n如果sds之外，提供一组字符串安全操作的函数。	2019-05-10 06:55:14.593076	f
786	386	Issue	5	在Constraint Index中存储tid/rowid主要是解决数据变更时，刷新CI的问题？\r\n另外存储tid/rowid可提供一种新的数据检索方式。	2019-05-11 03:56:18.568084	f
788	373	Issue	5	cmMalloc需要换个名字，可参考tcmalloc，jemalloc。\r\n\r\n要不叫hb，host-based，意思是这个内存是在宿主上管理的。	2019-05-13 06:45:03.940915	f
792	390	Issue	5		2019-05-13 08:03:44.247709	f
794	392	Issue	5	例如\r\n\r\n<pre><code class="cpp">\r\n#define BSTRING_VAR(T, s) struct BString#T *sh = (void *)(s);\r\nstatic inline size_t bstringLen(const BString s)\r\n{\r\n    db_uint8 type = (db_uint8)(s[0]);\r\n\tswitch (type)\r\n\t{\r\n\t    case BSTRING_TYPE_8:\r\n\t    {\r\n\t\t\tBSTRING_VAR(8,s);\r\n\t\t\treturn sh->len;\r\n\t    }\r\n\t\tcase BSTRING_TYPE_16:\r\n\t    {\r\n\t\t\tBSTRING_VAR(16,s);\r\n\t\t\treturn sh->len;\r\n\t    }\r\n\t\tcase BSTRING_TYPE_32:\r\n\t    {\r\n\t\t\tBSTRING_VAR(32,s);\r\n\t\t\treturn sh->len;\r\n\t    }\r\n\t\tcase BSTRING_TYPE_64:\r\n\t    {\r\n\t\t\tBSTRING_VAR(64,s);\r\n\t\t\treturn sh->len;\r\n\t    }\r\n\t\t\r\n\t}\r\n\t\r\n    return 0;    \r\n}\r\n</code></pre>\r\n\r\n没法写成：\r\n\r\n<pre><code class="cpp">\r\n    db_uint8 type = 8 * (1 << (db_uint8)(s[0]));\r\n    BSTRING_VAR(type, s);\r\n    return sh->len;\r\n</code></pre>\r\n\r\n\r\n	2019-05-13 13:15:26.282445	f
797	394	Issue	6	    这次活动姐姐、文萁还有谢锐，以及妈妈们都积极参与进来了，首先得对她们表示感谢！\r\n    完成好过完美，以前的自己总是迟迟不开始，总觉得一切准备的不够完美，如今在慢慢克服这一心理坎，凡事给自己一个期限，到了期限不管准备成什么样子，就先去执行，事情总是在行动的过程中一步步完善起来的。\r\n    这是一个好的开头，珍惜我们还住在一起，还有这样的便利表达自己想法的时候，尽可能的把真实的自己展现给家人，用行动告诉家人我已经长大，她们可以放心了，告诉她们不管在怎样的环境中，我都有能力把自己过好！\r\n	2019-05-14 12:40:42.819711	f
799	395	Issue	6		2019-05-14 12:45:21.89503	f
802	393	Issue	5	Merge commit \r\nA merge commit is created for every merge, and merging is allowed as long as there are no conflicts. \r\n\r\nMerge commit with semi-linear history \r\nA merge commit is created for every merge, but merging is only allowed if fast-forward merge is possible. This way you could make sure that if this merge request would build, after merging to target branch it would also build. \r\nWhen fast-forward merge is not possible, the user is given the option to rebase. \r\n\r\n根因在这里，第一种只要没冲突就可以合入，第二种每次都得rebase。	2019-05-14 14:39:29.20171	f
809	396	Issue	6	2019年5月14日\r\n最近几天谢震有些微烧，但观察精神状态还好，持续留意他的状态吧，希望这种状态最近能够好转\r\n现在的他，已经能听懂我说的很多话，比如把苹果扔在地上，我让他捡起来，不吃的苹果可以放在桌上，他会照做\r\n乐于晚上跟我在房间打会球，会很开心地笑，模仿我的各种打球动作\r\n只要我说看书，他一定是很感兴趣的，小脑袋里面不知道紫想些什么，会很认真的指着书上的物品，嗯嗯呀呀的发着音，虽然我并不知道他实际想要表达的是什么，但我在用心的回应着他，用我理解的方式在告诉他妈妈眼中看到的世界。\r\n\r\n他有着他的小脾气，会表达着他的各种想法，这个阶段的他正在全然的吸收着这个世界带给他的一切，慢慢地他会有跟多的自我意识，希望他能够喜欢这个全新的世界	2019-05-15 12:54:25.01727	f
814	393	Issue	5	https://www.lefer.cn/posts/42401/\r\n\r\n当然基于原始仓库的master拉分支比自己仓库的master分支更好。	2019-05-17 11:40:30.478204	f
817	362	Issue	5	XLOG是redo日志，但是pg让人需要地方记录整个事务块的状态，以便在异常时，考虑整个事务的回滚等操作。CLOG就是干这个的。	2019-05-17 15:56:29.616758	f
818	403	Issue	5		2019-05-17 16:10:31.536589	f
820	322	Issue	5	1，正手不会发力\r\n2，正手能发力，都不够放松和伸展，球速不快\r\n3，正手发力非常好，反手能打主动球\r\n4，正手发力无可挑剔，可以回各种被动球。步伐完全能跟上。 反手可以打被动球。	2019-05-18 20:32:49.772494	f
823	405	Issue	5		2019-05-20 08:20:30.825176	f
821	404	Issue	5	pg或其他系统当前使用的存储架构。\r\n细节，每个字段的长度，极端场景。\r\nx到y的数量就是1的情况。但是x存在大量重复。还有情况是x不存在重复。\r\n\r\n\r\n	2019-05-20 07:03:29.398995	f
1477	582	Issue	5		2020-11-02 08:01:23.285847	f
1479	705	Issue	5	杀球是往前送身体的，高球是往上推的。只有会执行打点技术，才有战术可言。	2020-11-03 11:40:47.153571	f
776	369	Issue	5	问题1：根据内部使用与外部使用分2套接口函数，还是统一使用一套接口函数？\r\n问题2：是否需要提供Reset等接口？如何看待宿主与beas关系？\r\n  对于beas而言，需要的部分是内存分配。宿主需要有最终释放内存的能力。\r\n  增加Reset接口是对这种能力的一种约束。\r\n  问题2.1 PG是如何管理内存的，在何时reset。怎么切换MemoryContext？什么情况下提前释放MemoryContext。\r\n问题3：context，尤其是具体类型的context，是由宿主来管理的。beas提供的是算法，而数据的主体在宿主中。\r\n比如CurMemoryAllocator这种显然不合适，greenplum可能没这个概念。然后对接greenplum相关分配内存都得修改？\r\n只能让宿主提供具体实现。\r\n  \r\n  问题3.1，如果beas需要根据需求，将不同的内存挂在具有不同生命周期的MemoryContext上，则必须感知不同的MemoryContext。\r\n而问题是在不同系统中，不同的管理方式对应的MemoryContext是不一样的。\r\n           一种解决方法是增加约束：beas只能在当前上下文分配外部的内存。\r\n           二是beas根据自身需要，不得已情况下定义不同类型的宿主Allocator，让宿主决定如何具体实现。除了当前上下文，可能\r\n 还需要一个常驻内存的。\r\n\r\n问题4，共享内存管理，beas自身会涉及管理共享内存吗？如果涉及，需额外设计一套共享内存管理机制。从逻辑上说共享内存分配可以与堆\r\n上的内存分配独立开。	2019-05-08 15:44:06.637243	f
777	382	Issue	5	改变下视角：将内存按照生命周期与使用方式来分类。\r\nMemTypeLocal ->  beas内使用且beas能控制其释放。\r\nMemTypeRequest -> 跟具体某次执行相关，beas作为中间件时执行主体不在beas，则由外部实现。beas无法完全控制其释放。\r\nMemTypeProcess -> 进程全局存在的，beas作为中间件时，进程主体不在beas，则由外部实现。beas无法完全控制其释放。\r\nMemTypeInstance -> 跨进程的，如共享内存。如无需对pg可见，可在beas内分配与释放。\r\n\r\n分类确实可以让我们可以更清楚的看问题。\r\n变量的生命周期其实也不能作为接口使用的参考，beas内的变量其生命周期也可能是request级别的，而非函数级别，当然这样用非常危险。另外Process级别的实际用的也是Local。\r\n如果将其本质描述为“由调用者管理内存的内存使用方式”。 调用者并不定是outer，也可能边界发生变化而转为inner。	2019-05-09 11:57:52.666624	f
778	385	Issue	5	测试点1：sdsnewlen原来计算ReqType时不包含头部长度，现在包含了。	2019-05-09 16:40:32.885929	f
780	384	Issue	5	<pre><code class="text">\r\n然后，我们来看看为什么要ETL？\r\n    在我看来，有两个原因。\r\n    一：性能  将需要分析的数据从OLTP中抽离出来，使分析和事务处理不冲突。咦？这不是数据仓库的效果吗？是了，\r\n数据仓库，大多数情况下，也就是通过ETL工具来生成地。\r\n    二：控制  用户可以完全控制从OLTP中抽离出来的数据，拥有了数据，也就拥有了一切。\r\n    嗯，OLAP分析，数据挖掘等等等……。\r\n--------------------- \r\n作者：tiger119 \r\n来源：CSDN \r\n原文：https://blog.csdn.net/tiger119/article/details/1482555 \r\n版权声明：本文为博主原创文章，转载请附上博文链接！\r\n</code></pre>\r\n	2019-05-09 19:54:29.439685	f
784	384	Issue	5	数据领域无外乎两个问题：1，存储形态。 2，计算形态。\r\n\r\n数据分布	2019-05-11 03:45:28.593997	f
785	386	Issue	5	如果X->Y只有N种，但是TID到X只有一种，那Constraint Index的规模也是非常大的。	2019-05-11 03:49:56.133595	f
787	387	Issue	5	2，为什么使用状态机模型，而不是功能机？或者其他描述？\r\n3，在最初最简单的时候，图灵是如何看到其图灵机定义的巨大意义的？也即为什么他会认为机器计算方向的前途？	2019-05-12 20:00:07.228294	f
790	382	Issue	5		2019-05-13 06:56:13.296376	f
789	373	Issue	5	sds可能不满足我们的要求，sds返回的是字符串位置，这要求释放的一方必须调用sds的释放方式。\r\n而beas的内存管理存在多种形式。把sds当作void *来看待。把sds当作char*看待，你仍然无法直接用c字符串函数处理。因为需要修改头部。\r\n\r\nsds基于常用字符串接口之上再做一层封装。	2019-05-13 06:53:42.162241	f
791	390	Issue	5		2019-05-13 08:01:13.473417	f
793	390	Issue	5		2019-05-13 08:07:01.083237	f
795	394	Issue	6		2019-05-14 12:18:47.062171	f
796	394	Issue	6	看到身边有人在持续举行家庭会议这件事情，触动了我，也和家人表达了类似的想法，但迟迟都未行动\r\n由于在讨论中姐姐和文萁出现了对抗的情绪，我灵机一动，想到了下午凑在一起举行一次家庭活动吧，叫做择日不如撞日，初衷是想借母亲节这一话题，缓解文萁和姐姐的情绪对抗，也给自己一个机会表达一下对自己母亲的感谢。\r\n平日里，习惯于把感情埋藏在心里的我们，有些心里话还真不知道怎么去表达，没有机会我们要创造机会，正所谓自己想要什么就去种什么样的种子吧，我也希望自己和母亲能够彼此心里敞亮，而不是各自有各自的心结，我希望她在余生里面都能够平和喜乐地生活，享受属于自己的幸福。\r\n	2019-05-14 12:35:03.779043	f
798	394	Issue	6		2019-05-14 12:44:25.412943	f
800	326	Issue	6		2019-05-14 12:47:02.752196	f
801	182	Issue	6		2019-05-14 12:55:36.393854	f
803	397	Issue	5	 inline 关键字实际上仅是 *建议内联并不强制内联*\r\n gcc中O0优化时是不内联的，即使是O2以上，如果该函数被作为函数指针赋值，那么他也不会内联，也必须产生函数实体，以获得该函数地址。经测试c文件中的仅inline函数即使Os优化也不内联，因为没有static，编译认他是全局的，因此像普通函数一样编译了，本c文件也一样通过 bl inline_func 这样的方式调用，不像网上别人说的，本c会内联，其他c文件则通过bl inline_func 方式。加入static 后则内联了。（Os优化等级测试）\r\n    *所以在头文件中用inline时务必加入static*，否则当inline不内联时就和普通函数在头文件中定义一样，当多个c文件包含时就会重定义。所以加入static代码健壮性高，如果都内联了实际效果上是一样的。（gcc下验证过O0级别includes.h中仅定义inline的函数，编译失败，Os编译成功）\r\n--------------------- \r\n作者：求知君 \r\n来源：CSDN \r\n原文：https://blog.csdn.net/huanghui167/article/details/41346663 \r\n版权声明：本文为博主原创文章，转载请附上博文链接！	2019-05-14 14:55:29.279468	f
805	399	Issue	5		2019-05-14 15:24:17.94711	f
808	402	Issue	5	C11 标准的安全函数在glibc是不支持的，有人实现了对应版本https://github.com/rurban/safeclib\r\ngcc默认的C标准目前还是C89/C90的。\r\n\r\n\r\nLinux / glibc维护者拒绝添加安全功能，认为您应该保持字符串的长度并使用memcpy。感觉这想法是对的，字符串其本质就是内存片段。	2019-05-15 12:40:16.448363	f
810	402	Issue	5	strncpy也是不安全的 \r\nhttps://blog.csdn.net/gexiaobaohelloworld/article/details/27567673	2019-05-15 12:58:58.068265	f
812	402	Issue	5	C的内存操作函数就是一坨屎，各种没有参数检查，以及越界检查	2019-05-16 08:20:30.292039	f
815	362	Issue	5	一组包围在 BEGIN 和 COMMIT 语句中间的语句有时候被称做事务块\r\n每个 SQL 语句当做在一个被执行的事务来看待	2019-05-17 15:30:32.103585	f
816	362	Issue	5	隔离级别:\r\n1,脏读，读到未提交的数据\r\n2，不可重复读，在一个事务内，多次读取记录的内容不一致\r\n3，幻读，一个事务内，多次读取，记录条数不一样，出现了新删除与插入记录。	2019-05-17 15:36:54.629111	f
819	368	Issue	5	1.1 接球准备时，身体放松，压低重心。\r\n1.2 抬起脚跟，或小跳调整，伸展身体，架拍并放松手臂手腕。\r\n    自己应该能感受到自己的发力形态。\r\n1.3 根据对方站位，调整发力方向与力度\r\n\r\n站位原则：\r\n1，根据对方击球地点，双打时如果一前一后。则偏向补充己方进攻球员的前方。\r\n2，积极补位，尤其是己方进攻时\r\n3，进攻与防守的轮转。\r\n4，网前站位应该压低身体，随时准备扑球。\r\n\r\n业务选手一般不太会调整自己的站位，以及准备动作，当对方球速快时，就会进入不会打球的状态。	2019-05-18 20:30:29.561016	f
827	404	Issue	5	Mysql binlog是一种逻辑复制方式，基于innodb的redo日志可实现物理复制，但这并非mysq官方复制方式。有其他团队做这个\r\nhttps://www.jianshu.com/p/68e3a4e5ef8a	2019-05-21 13:24:31.210732	f
828	406	Issue	5	还是ubuntu的包管理牛逼，轻轻松松找到合适的源	2019-05-21 14:33:18.533263	f
824	404	Issue	5	问题的关键点是如何在众多的tuples中找到某个更新的tuple，并将其删除。如何数量众多，不至于全部加载。组织方式。\r\n不查找，或以追加方式。因为平时并无查找需求（lsm-tree查找不快，但是扫描应该没问题）。\r\n访问模式：\r\n1，扫描，全读\r\n2，插入，删除\r\n\r\ntupleid基本是定长存储，这是其中一个特征。\r\n\r\ntupleid有两个作用：\r\n1，根据其刷新ac\r\n2，提供tid的索引能力	2019-05-20 12:42:35.149842	f
830	406	Issue	5	1，继续分析下二进制结构\r\n2，binlog机制缺陷分析\r\n3，innodb redo日志格式分析，pg xlog分析。	2019-05-21 18:43:17.288594	f
852	425	Issue	5	pg 逻辑复制的全量同步过程描述：\r\nhttps://juejin.im/entry/5a77f70f5188257a604971dc	2019-05-27 20:58:14.978286	f
858	436	Issue	5	要了解正则表达式的原理，需要先了解一些计算机语言文法的基础知识。\r\n\r\n一个文法可以用一个四元来定义，G = {Vt，Vn，S，P}\r\n\r\n其中Vt是一个非空有限的符号集合，它的每个元素成为终结符号。Vn也是一个非空有限的符号集合，它的每个元素称为非终结符号，并且Vt∩Vn=Φ。S∈Vn，称为文法G的开始符号。P是一个非空有限集合，它的元素称为产生式。所谓产生式，其形式为α→β，α称为产生式的左部，β称为产生式的右部，符号“→”表示“定义为”，并且α、β∈(Vt∪Vn)*，α≠ε，即α、β是由终结符和非终结符组成的符号串。开始符S必须至少在某一产生式的左部出现一次。\r\n\r\n文法可推导的语言标记为L(G)。	2019-06-02 20:00:31.611062	f
859	438	Issue	5	索引不支持同步删除，通过vacuum来删除。因而am没提供单个删除命令。\r\n\r\n理解bitmap scan：\r\nhttp://francs3.blog.163.com/blog/static/405767272011665227181/\r\n1，如果过滤数据需多重处理\r\n2，如果过滤的数据量占比很大\r\n这时bitmap scan优于seq scan和index scan。\r\n\r\n传统的index在insert的时候也是需要scan位置的，scan有两种形式，找到（match）与找到起始位置。\r\nac的区别在于找到时，运用count++。找不到时使用count=1.	2019-06-04 12:22:19.044624	f
825	404	Issue	5	PG的ha实现方式，删除，更新操作如何同步？\r\n还有情况是Y变了，但是T不变的情况？ 数据库一定会为更新操作生成新的tid么？\r\n列式存储，去掉重复列。\r\n内存结构也得考虑用hash查找，否则怎么找？\r\n\r\n逻辑流复制：\r\n<pre><code class="text">\r\n逻辑流复制利用索引的方式优化传输数据的效率，它们可以按表为单位定制。大致分为三种情况:\r\n\r\n如果修改的表有 primary key, 则表的变化的逻辑数据只会包括该表变化的列和pk列数据，如果 pk 列被修改，则还会输出老的 pk 列数据。\r\n如果修改的表没有 primary key，则可以使用 alter table 指定一个 REPLICA index，同时需要这个索引列为非空，其产生的效果和 1 相同。\r\n如果修改的表不满足上面的两个条件，而又要做同步，可以使用 alter table 设置这个表的 REPLICA IDENTITY 为 FULL。于是系统在表修改时会记录修改行的所有列，不会做任何的优化。\r\n很明显，给对应的表设置 PK 或指定索引，在数据同步时效率更高。我们可以安需定制同步策略。在实现功能的过程中需要考虑这部分变化。\r\n</code></pre>\r\n\r\n所以记录的不一定是tid。但可能确实需要一个唯一确定的，要么就是全列。\r\n	2019-05-20 15:16:15.326848	f
829	406	Issue	5		2019-05-21 15:14:07.922248	f
832	408	Issue	6	设计师在装修过程中可能会做哪些工作：\r\n量房拍照，收集信息\r\n协助梳理居住需求，讨论生活场景\r\n根据实际情况，确定设计构想的前瞻度\r\n与委托人配合，对各种方案思路的可行性进行验证\r\n根据双方确定的平面布置方案，进行深化设计\r\n协助控制预算，协助挑选施工方与供应商\r\n确定设计方案，列出采买清单，协助安排施工、采买、安装的时间节点\r\n开工后与施工方保持沟通，及时协商解决意外方案变动和偶发状况\r\n协助进行家具电器、灯具光源、补充配件的安装调试，以及参与其他约定的工作事项	2019-05-22 04:15:51.641498	f
834	408	Issue	6	我们需要一个什么样的家\r\n先了解一下自己的生活习惯是有很必要的。看看这些习惯当中， 哪些是因为条件所限， 被迫潜移默化形成的， 哪些是因为自己觉舒服自在而长久保持的。这无疑也是一项非常有意义的工作。\r\n\r\n有哪些习惯的需求\r\n胡冬寅：\r\n\r\n\r\n谢锐：\r\n\r\n\r\n谢震：\r\n 	2019-05-22 04:32:20.170853	f
826	404	Issue	5	binlog的具体格式，在mysql不同版本的实现。\r\nhttps://dev.mysql.com/doc/internals/en/rows-event.html\r\n这篇介绍了大体格式，但是具体操作类型的日志没细说。另外旧记录如何表示也没说明\r\n\r\nhttps://blog.csdn.net/yanzongshuai/article/details/79686867\r\n此文介绍了insert/update/delete事件的binlog数据格式。\r\n*参考此文章，以及binlog -H可以详细分析数据格式*\r\nheader\r\nfor(row events)\r\nfooter\r\n\r\n问题：\r\n1，binlog中是通过where条件来表示update和delete影响的列么？\r\n<pre><code class="text">\r\nUPDATE_ROWS_EVENT不仅包含行修改后的值，也包括修改前的值；DELETE_ROWS_EVENT仅仅记录删除行的主键值。\r\n</code></pre>\r\n这个描述是啥意思？update不记录相关行的主键么？ delete不是用where条件来记录的？\r\n\r\nhttps://dzone.com/articles/identifying-useful-info-mysql\r\n看这篇文章，应该是用where条件表示的，但是每列的值都有。\r\n那么我们怎么知道哪个是主键呢？	2019-05-21 07:28:56.583369	f
831	408	Issue	6	室内设计，必须是基于真实需求，从现实条件的制约中去组合调配设计要素，并最终做出权衡取舍\r\n我们可以用温度、气味、触觉来评判居家环境，必要的时候，我们甚至可以假装自己是失聪者，用触觉、嗅觉、听觉、皮肤感觉来感受居室空间的动线情况、声音分布、空气流通、物品摆放、以及用身体的移动来感受动线走向\r\n\r\n花点时间了解一下自己的生活习惯，看看这些习惯中，哪些是因为条件所限，被迫潜移默化形成到的，哪些是因为自己觉得舒服自在而长久保持的\r\n装修过程中，你需要投入多少资金预算和时间精力，有相当一部分因素，在你选房买房的阶段就已经决定了\r\n楼位和户型朝向\r\n是否有外墙保温层\r\n入户门品质\r\n窗户是中空玻璃平开窗（包括内开内倒窗）还是单层玻璃推拉窗\r\n晴天正午阳光直射区域及有效直射的时长\r\n以上会影响到家中夏季空调耗电读书、冬季供暖期室内实际温度，房间的落灰层度、客厅和卧室隔离户外噪音的情况，从而在不经意间影响到实际生活品质\r\n\r\n装修的主要工序：\r\n拆除清运\r\n水电管线改造及完工确认\r\n墙体新砌及坑洞补平\r\n防水施工及闭水试验\r\n瓷砖铺贴及地面找平\r\n石膏板吊顶及轻质隔墙施工、其他现场木作\r\n墙面基层处理\r\n室内门及门套的现场制作或厂家定制\r\n柜体制作或厂家定制（包括橱柜）\r\n喷刷墙漆\r\n厨卫及阳台吊顶（除石膏板吊顶外的其他做法）\r\n安装室内门\r\n铺贴壁纸壁布\r\n铺设地板与踢脚线\r\n安装合金推拉门\r\n安装开关面板\r\n安装定制家具和相关电器设施\r\n调试安装灯具光源\r\n安装卫浴洁具\r\n安装窗帘轨道及窗帘布\r\n其他定制采购部件的协调安装等\r\n添置其他软装陈设及花卉绿植\r\n\r\n入住预算：指最终入职之前的最大入住预算，这不仅包括自购的基础建材、建材辅料、装饰建材。还包括水、电、网、气、风、暖设施，成品家具及配套产品、定制家具和其他定制产品、普通家用电器、只能家具硬件、五金配件、卫浴洁具、开关面板和灯具电料、软装陈设等，以及施工安装费用、设计费、灯具和洁具安装费用、物业押金和其他杂费等\r\n\r\n也就是说，在设定预算时，需要把乔迁之前的所有费用都先考虑进去，得到一个现阶段能拿得出的预算的最	2019-05-22 04:15:11.818283	f
833	409	Issue	6	厨房：\r\n厨余垃圾处理器\r\n洗碗机\r\n五门冰箱\r\n厨房冷霸\r\n\r\n\r\n卫生间：\r\n洗衣机\r\n浴霸或者暖风机\r\n马桶旁边的高压水龙头\r\n\r\n客厅或者卧室：\r\n空调\r\n\r\n	2019-05-22 04:19:22.504797	f
844	386	Issue	5	AccessSchema 可以看成x，y，rowid的三维空间在x，y上的投影。投影使用(x,y，count,tids）来表示。判断x，y是否可建立ac的一个判定方式就是x，y的重复度。\r\ny，x，无穷大 与 x，y，无穷大。 这两种情况都无法缩小数据规模。 \r\nx，y，1 缩小的能力取决于x或y中的一个。\r\n\r\n提前提取的AccessSchema就相当于我们在原始数据上的经验，0\r\n \r\n 在万维世界中，涉及人类活动的部分维度数据空间可能非常小，这是缩小数据规模的核心思想。分析通常做的事情可能就是分析不同维度的关联性。\r\n\r\n这引申出一个问题：数据分析，到底在分析啥？\r\n\r\n数据库的表，只是把事物（通常是人）的多维信息统一表示了。\r\n\r\n实x->m, p->y. 与x->m没有本质区别。比如使用条件x=1 and m = t2.p，这时运用x到m的schema，同时根据等值关系传递可用于access schema的优化。\r\n对于跨表的情况，单独x->y建立不了联系。这就是一个笛卡儿积。但是如果x，m  p，y 且m和p语义相等。则可建立起关系，这相当于提前运用了条件。\r\n建立xm->py的AccessSchema。这样做是有意义的，因为x->m可能无法缩小数据规模。 	2019-05-26 10:28:54.671822	f
846	426	Issue	5	如果将世界以万维矩阵存储下来。人类以及自然活动的轨迹就是这个矩阵中打通的关系。这些关系有的表现为线性，有的表现为树状，有的是图状。\r\n如果这世界是一个旋转矩阵，那么人对因果，规律的认知都是基于过往经验的总结。	2019-05-26 14:12:27.808645	f
835	404	Issue	5	明确一点：\r\n1，redo日志如何记录，在x，y，主键/rowid变更场景时，beas如何处理这些情况\r\n1.1，在update其他列时，rowid或主键是否未变更？尤其是对于pg这种多版本的。\r\n1.2，update y时，x在redo是否体现，rowid如何体现？\r\n1.3，redo日志记录的是主键还是rowid？\r\n2，mysql原生版本是否能基于redo日志复制？是否存在问题？\r\n3，能否采用多层次的树来组织x->y->rowid/主键，并且搜索时基本是基于x，y的	2019-05-22 06:35:52.948492	f
836	404	Issue	5	https://juejin.im/entry/5ba0a254e51d450e735e4a1f\r\n这篇文章介绍了大体框架。	2019-05-22 07:50:16.349222	f
845	386	Issue	5	如果将x，y，tuple看成x，y关于实体rowid(实际上是主键)的投影。那么xm->py就是x，y基于实体m|p 的投影。p与m实体是等价的。\r\nx，y，tupleid    x，y，m。或表示为 x = Ft(y)或 x = Fm(y)。\r\n\r\n还有一种看待该问题的方式：\r\n1，t到x，y的投影\r\nx，y本身并无关系。但t在x，在y上的投影空间都有限。x->y有界。x因条件而有界。\r\n\r\n这地方有个因为，既然x有界，则x->t有界。 t到y则也有界。那么x->y也应该有界。\r\n这种方式存储就跟索引类似了，建立x->t的索引即可。 有了t自然就有了y。\r\n\r\n第三种理解：基于重复度。以及查询条件来自动创建投影。比如x，y均有重复度。且经常利用x或y作为查询条件。\r\n即可根据x，y，t建立子表来加速查询。\r\n\r\nAccessSchema的索引都是去重的，即同一个x不会存多个。\r\n	2019-05-26 12:54:03.977822	f
837	404	Issue	5	mysql物理复制可能要求主备数据库完全一致，并且redo日志中需记录逻辑page才能实现。\r\n\r\n1，mysql的redo是记录整条记录修改的，保护所有列\r\n2，mysql的redo是不含old value的，需通过undo获取。\r\n2.1 delete的undo会记录old value么\r\n3，delete操作记录的是物理信息，即每个page-offset对应的row被删除了。\r\n3.1 是否非叶子部分也会发生变更。	2019-05-22 09:08:54.758911	f
838	404	Issue	5	该方案不可能基于物理复制，所以还是考虑逻辑复制吧。\r\npg在10版本之后才支持逻辑复制。	2019-05-23 06:27:32.265762	f
839	423	Issue	5	1，如何调整wal级别\r\n2，pyhical日志的实现\r\n3，logic日志的实现\r\n4，不同级别的日志记录区别以及代价\r\n5，logic full 是否可行	2019-05-23 15:02:48.406183	f
840	423	Issue	5	XLogInsertRecord分析该函数	2019-05-23 16:30:22.006516	f
841	390	Issue	5	知识除了问题，还有结构，结构不断细化，结构本身就包含知识。执行路径，执行与反馈。\r\n结构包含不同层次，并且可以无限展开。	2019-05-23 20:35:39.980011	f
842	400	Issue	5	常见典型问题：\r\n1，击球后脚步未根据下一个球调整好\r\n2，仓促下打了半场球，发力过程不完整\r\n3，反手被动回球不到位	2019-05-25 06:18:34.668109	f
843	425	Issue	5	物理复制：基于存储管理系统实现的复制\r\n逻辑复制：基于数据库的逻辑变更进行复制，不关心存储细节。	2019-05-25 12:42:51.308528	f
849	425	Issue	5	Mysql复制技术	2019-05-26 14:34:28.160804	f
850	425	Issue	5	PostgreSql复制技术	2019-05-26 14:34:40.930815	f
1481	533	Issue	5	要理解模块接口的重要性，作为开发核心之一的沟通，其重要性体现的一个点就是接口。\r\n为什么单元测试要提前设计，只有这样模块才能清晰起来，才有明确的组织结构。	2020-11-06 13:29:30.815088	f
848	425	Issue	5	Oracle复制技术：\r\n\r\nadvanced replication：\r\nhttps://docs.oracle.com/cd/E11882_01/server.112/e10706.pdf\r\n\r\nstream replication（逻辑复制）：\r\nhttps://www.oracle.com/technetwork/database/twp-streams-replication-11gr1-130056.pdf	2019-05-26 14:34:18.152096	f
1482	708	Issue	5		2020-11-15 04:37:19.501622	f
1487	659	Issue	5	自己颠球都能发现，发力时：\r\n1，小臂手腕刚开始要放松，且后倒。\r\n2，击球瞬间握紧，呈刚体，否则反弹力都被手掌吸收。\r\n3，需要很大挥拍吗？不需要，尤其非后场球。\r\n\r\n反手难在于放松，有了此发力基础，在加上动作与线路练习就应该能成\r\n	2020-11-29 04:42:39.580357	f
1489	711	Issue	5		2020-12-02 06:33:36.780764	f
847	425	Issue	5	*复制的分类*\r\n\r\nwiki：\r\nReplication in computing involves sharing information so as to ensure consistency between redundant resources, such as software or hardware components, to improve reliability, fault-tolerance, or accessibility.\r\n\r\n复制可以按不同方式划分，由于我们这里主要关注的是数据模型，因而我们考虑根据复制内容来划分的方式。\r\n按这种方式大类可分为物理复制与逻辑复制。\r\n\r\nhttps://www.cnblogs.com/songyuejie/p/4743299.html\r\n远程服务器将获取数据的二进制格式，而不是通过SQL。\r\n\r\nhttp://www.postgres.cn/docs/10/logical-replication.html\r\n逻辑复制是根据复制标识（通常是主键）复制数据对象及其更改的一种方法。 我们使用术语逻辑与物理复制相比，它使用确切的块地址和逐字节复制。\r\n\r\n定义:\r\n物理复制是基于数据物理存储结构实现的复制。数据存储结构并不感知数据的语义。\r\n逻辑复制是基于数据的逻辑结构的复制。逻辑结构在数据库中是指表，记录等信息。\r\n\r\n通过上述定义我们可以看到逻辑复制与物理复制是在系统的不同层次实现的。\r\n逻辑复制在物理复制之上，因而它具备物理复制不具备的一些特点：\r\n1，实现不同版本，跨平台的数据复制。\r\n2，实现异构数据库的复制。\r\n3，实现多master的复制。\r\n	2019-05-26 14:19:41.520165	f
864	440	Issue	5		2019-06-06 13:32:38.361511	f
851	425	Issue	5	https://www.google.com/imgres?imgurl=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F127628%2Ftoptal-blog-image-1543512398486-eaab4770b9aac7e8b7d360ec04489385.png&imgrefurl=https%3A%2F%2Fwww.toptal.com%2Fmysql%2Fmysql-master-slave-replication-tutorial&docid=kwNfoc0eVIVUOM&tbnid=z79gaiZZhvcOeM%3A&vet=10ahUKEwjww6X--rviAhUCzmEKHS4zA2IQMwhGKAIwAg..i&w=1720&h=1234&bih=619&biw=1269&q=binlog%20replication%20implement&ved=0ahUKEwjww6X--rviAhUCzmEKHS4zA2IQMwhGKAIwAg&iact=mrc&uact=8\r\n\r\nbinlog同步过程图。\r\n\r\nGTid顶多解决数据复制的重复执行问题。但是异常场景下如何确保一致性似乎没看提及，比如master挂了，binlog还有一堆没同步。这时去切换slave为master就废了。\r\n\r\nhttps://downloads.mysql.com/presentations/EverythingYouNeedToKnowAboutMySQLGroupReplication-final.pdf\r\nhttps://downloads.mysql.com/presentations/EverythingYouNeedToKnowAboutMySQLGroupReplication-final.pdf	2019-05-27 20:23:48.876137	f
853	404	Issue	5	调研：\r\n1，目录树，zookeeper等存储结构\r\n2，复合索引的存储形式	2019-05-28 06:25:02.136208	f
854	404	Issue	5	1，存储格式\r\n1.1 基于内存索引的实现\r\n以encoding方式将内存中的数据存入磁盘，可能性能会比较差。最好是内存组织本身就利于持久化。\r\n\r\n1.2 基于磁盘索引的实现	2019-05-29 09:18:55.796857	f
855	386	Issue	5	1，论文是在不断扩大适用范围，最终把sql语言给cover住。在没有count的时候，没法处理agg。\r\n   可以从查询树的角度看，如果每个叶子scan能cover，通常整个树是可以cover住的。\r\n2，条件目前考虑是等值的，但是范围的，以及表达式的也可考虑。比如可以推到A+1=B等。\r\n3，AC的应用具备方向性，delivery。论文中可能有routine的概念。在腾飞原型中优化后的sql需防止pg优化器改变顺序。\r\n4，A->B,B->C 得到AC但是需要check exist\r\n5，引入count，重度概念。没有count不仅不能处理agg，连join的结果都是不对的（输出target的条数）\r\n6，JR（join reduce），通过Fetch+，Fetch-，Fetch处理JR之后记录数量的处理问题。\r\nJR能实现以图的概念来理解，就是R1和R2有一样的Path。就是说执行Plan的graph中有重复边。\r\nFetch+ = count(X) * count(Y)\r\nFetch = count(Y)\r\nFetch- = count(X)\r\n7,Bcheck是检查是否有界，BA是bounded attr， BR是bounded attr， BQ是bounded query.\r\n8,如果agg(sub_query),sub_query有界可推出agg有界。如果查询的level0 scan的所有输入bounded，其输出一定bounded么？ 不一定，这才取决于输出的列。可能还跟计算方式有关系。\r\n9，AccessIndex需提供全表扫描，基于x或基于xy的扫描。\r\n10，关联查询的情况\r\nparent SQL->child SQL (父查询的条件作用于子查询，这样会产生相互依赖，但执行时是单向的。子SQL会重复执行)\r\nchild SQL-> parent SQL(子查询的输出作为父查询条件)\r\n11，图的建立过程就是利用rule将点连接起来的过程。rule1：常量，rule2：等价条件， rule3：AccessConstraint...\r\n\r\n\r\n\r\n	2019-05-29 15:09:28.989146	f
856	107	Issue	5	花园系统对待人和事。不仅是新的人和事，当下都如此	2019-06-01 02:54:58.282326	f
364	136	Issue	5	8，个人可以持续增长，但要实现指数增长需要建立与其他人的连接。\r\n9，没有什么比正确的选择更重要，但要会正确的选择必须有丰富的知识。人不能缺乏在政治，历史，经济上的基本知识，如果不具备，你应该找个顾问。\r\n10，有趣的灵魂可以吸引人。\r\n11，想去做的事，如果没有时间表就做不出来。目的性目标感的强弱可能相差上百倍。无动力的人生是如何开启的。\r\n12，没有多少人敢于做前面的石头，人们希望被掌控的人生。人数人掌控多数人的命运。\r\n\r\n以便让自己做更合适的选择。\r\n	2018-10-26 06:13:31.704389	f
857	433	Issue	5		2019-06-01 11:16:13.887608	f
865	442	Issue	5	http://liuyangming.tech/05-2018/MvccAndVacuum.html	2019-06-06 16:08:54.295037	f
866	438	Issue	5	<pre>\r\nBTPageState - tree的每个level都有一个，在build阶段使用\r\nBTWriteState - btree的整体写入情况\r\nlinp0与offset 1是啥关系， offset从1开始。linp从0开始。\r\nItemID对应的就是linp。\r\n\r\nbuild过程是自底向上的，先通过heap tuple构建index tuple，填充level 0.\r\n在level 0产生新的page时，添加到level1，这样递归处理。\r\n最后把每个level的最后一个page向上添加，一直到root，将root加到meta。然后结束。\r\n\r\n对于ac而言，主要在insert时注入参数，表面unique时使用特殊行为（增加count，并且扩展PKs）。\r\n\r\nsmgr与其他模块的关系？\r\n\r\n\r\nBTStackData- search的输出结果，包含搜索路径。\r\n\r\ninsert是找到>=scankey的位置，注意是插入在相等key的最前面的。在_bt_findinsertloc的注释中有解释。\r\n除了scan的时候有move right的处理，实际insert的时候也有。move right之后将释放原page的锁，并移到下一个page\r\n</pre>	2019-06-06 16:10:03.328404	f
1067	520	Issue	5	成瘾的杜绝：\r\n也许依据过去对人的影响，人可以分为2大类，过去迷恋型的，与面向未来型的。\r\n成瘾的人在其行为发生时，是过去行为的建立起来的机制决定的行为。而面向未来的，则主动编制行为。\r\n从而可以抑制成瘾行为，这就是自律的本质，也是自由与平等的本质。真正的自由是自我意思的控制，\r\n其行为完全源自我自意识。\r\n\r\n成瘾最好的杜绝方式就是面对它，看到其他事情的有趣和意义。接受自己，接受感觉的结束。	2019-09-22 14:43:20.153844	f
861	438	Issue	5	一种思路是ac在btree之上封装一层接口，并且实现多层tree的逻辑。三层。\r\n要考虑mvcc机制如何运用。count值对于不同的事务看到的。\r\nac只有索引，没有heap。对于需要通过heap来触发索引操作，这层关系不存在了，可能不少地方会受到影响。	2019-06-05 15:07:50.117256	f
868	404	Issue	5	Relation:table/view/index都抽象为Relation结构，IndexTuple也是一种Tuple。Index本质上就是有组织结构的数据。只是与Heap的数据组织方式不一样。\r\n这可能也是index与table等都丢到access目录的原因。ac也是一种数据组织方式。\r\n\r\nac模式确定，修改受限的。操作也非常有限。 然后定义一个特别的AcSan即可。PG框架对于可见性实现的约束。或者叫PG的可见性框架。\r\n基于此框架下实现Ac。Ac除了insert，都是HOT。\r\n\r\nAC不存在需更新某个列的情况，除了pk。 \r\n\r\n能否在IndexTuple中放下可见性信息？或者说Ac的事务信息要求怎样的格式。\r\n对于回滚段机制，如何找到delete tuple的老版本？\r\n老版本拷贝到undo，并且记录了tid。新的删除在原记录上标记，并记录newtid。空间回收要等小于删除tid的事务都提交。\r\n除非采用回滚段机制，否则记录2个事务id，可能是必须的。\r\n\r\n要么在Indextuple的头部携带事务可见性信息。pg的可见性并非简单的在头部增加两个tid就搞定了。\r\n在头部还记录了事务信息。 问题变成了如何重用mvcc那套机制。\r\n在pg12上新增am之后，代码变化非常大，对外暴露的是TupleTableSlot，通过这个可以得到HeapTuple，以及MinimalTuple。\r\n但事务这块仍然变化不大。\r\n\r\n	2019-06-10 11:52:39.965698	f
884	449	Issue	5	https://dba.stackexchange.com/questions/119386/understanding-bitmap-heap-scan-and-bitmap-index-scan\r\nbitmap scan使用顺位的bit表示对应的page是否有记录满足要求。\r\n\r\ntidbitmap解释了lossy storage chunk，lossy意思是没有记录到tuple级别。信息有损。对于非常大的表，可能需要使用lossy方式，从而减小bitmap的规模。\r\n\r\nhttps://blog.csdn.net/hmxz2nn/article/details/87788032\r\nbitmap scan的核心价值是在读取大量page时，其可以通过物理顺序读取数据。\r\n在数据量非常少时适合用index，非常多50%+时可能更适合seq scan。\r\n\r\n如果ci采用分离数据存储的方式，实际上无法支持bitmapscan。但是Iot是可以考虑采用bitmapscan的。\r\n不过CI的目标是全内存存储。	2019-06-19 08:58:22.068615	f
883	404	Issue	5	不管怎样，根据其数据特征。\r\nac可以存储为 xy， count， pk。\r\n这三者是分离存储的，对于IoT也是如此。我们没必要为old tuple记录xy，回滚段也可据此设计。这是由语义决定的。\r\n\r\nac的特征是：\r\n1，数据根据x，y聚集\r\n2，数据格式固定， 不存在增加字段，删除字段等场景。\r\n3，查询总是从xy出发，或fullsync\r\n\r\n抽象出ac的价值在于使用特殊存储结构，得到最优的性能。\r\n定义一个普通的表为ac表。在ac表上执行各种操作。\r\n增加ac抽象层也可以，主要是方便同时支持不同的数据组织格式，就像table的组织形式也可不一样。\r\n\r\n需要验证一个问题，没有任何索引可以走索引扫描么？\r\n\r\nvocuum时在ac上执行，然后清理ci的表，并清理其索引。\r\ninsert：\r\n1，找到index记录\r\n2，如果找到，则产生新tuple(count+1)，更新ci表，以及索引\r\n3，如果没找到，则插入表，并增加索引\r\n\r\ndelete：\r\n1，查找index记录\r\n2，如果找到，则产生新的tuple(count-1)，更新ci表，以及索引\r\n3，如果没找到，则打印错误。（这里应该不必退出）\r\n4，如果count为0，则执行删除操作。\r\n	2019-06-17 15:24:03.557021	f
878	404	Issue	5	采用xy索引，count，pk数据存在的问题\r\n1，删除时，由于可能只修改了count。在无法做HOT的时候，需删除xy后再创建。有点多此一举了。\r\nheap页能否配置空置率，针对new tuple对page满的判断不一样。\r\n设置合适的fillfactor，https://stackoverflow.com/questions/45087790/postgres-set-fillfactor-to-50\r\n当xy不存在时，对表写入就是insert。\r\n如果能找到xy，则是update操作。但这个update有点不一样，对于pk其是插入操作。\r\n1.1 如何在heap上调用HOT。\r\n使用heap_update操作。\r\n\r\n2，使用fork实现index？\r\n3，唯一索引的管理如何应对update的情况，实际索引还在，记录只是更新了。\r\n4，分离xy，count pk一致性上是否存在问题。\r\n应该没有问题，事务层面一致性保证。pk可放在第二阶段处理。或第一阶段仅支持内联实现的pk。\r\n5，显然ac更新不存在command，都在一个command内。\r\n6，如果不好在记录中剔除xy，那就考虑用null等值做特殊处理。\r\nAC的relation作为统一的Relation，自然是使用所有列构成TupleDesc，但AcInsert内部接口的实现是可以build我们想要的数据结构的。\r\n7，如何表示获取的记录？pg执行模型中会将记录拷贝出来么？\r\n8，count和pk基于ac的Relation能实现么？另外可以填充隐藏字段以实现特殊功能么？\r\nRelation不仅是描述了一组数据，其中还有锁信息，还有存储信息，因而在storage与access层贯穿其存在。\r\nRelation本来是逻辑结构，但是实际上存储也与之关联。\r\n走heap_create_with_catalog接口就可以。\r\nindex也是一样。本质上就是两个relation，对应于2个oid。\r\n这层接口在ac里面调用确实不合适。这是由ac反向依赖的特点决定的。ac不会做relation一样的操作。因而这些并没关系。\r\n不过话说回来，如果以后ac里面使用多种数据结构，relation结构也不一定符合要求。\r\n\r\n\r\n9，能否针对pk实现限定长度，超出则使用toast或其他方式存。\r\npk存储的一种方式是采用pkv的方式存储。当插入时，优先写入到tuple内，\r\n如果tuple内确实没空间或超过一定长度。可以将其中frozen的pk做转存。\r\npk的可见性问题也可以通过这种方式解决。即可见的pk=当前tuple的pk + frozen的pk。\r\n\r\npg当前的toast机制没法满足要求，toast本质上还是按照事物特性的行来存的，更新时涉及整个字段值。\r\n\r\n\r\n9.1 pk的问题本质上是大字段局部更新的代价问题。\r\n这点也是与存储系统最大的区别，存储系统通常有局部overwrite或append方式修改。\r\n而数据库修改一个bit，可能就得生成新行。放大了X倍。\r\n\r\n10，自己实现的机会点应该主要是数据组织更加紧凑，一些情况下可以避免多次更新。\r\n另外一个机会点是优化事务机制，降低多版本，vacuum带来的影响。\r\n\r\n	2019-06-14 07:13:53.609301	f
882	362	Issue	5	https://wiki.postgresql.org/images/9/97/Concurrency.pdf\r\n官方文档还是很详细的，要仔细看：\r\nhttps://www.postgresql.org/docs/9.1/explicit-locking.html\r\n行锁是可能引起disk io的。\r\n\r\n另外看官方README文档。	2019-06-17 12:29:11.723863	f
885	404	Issue	5	可以在tuple上记录一个反向的\r\n1，在pg原有实现中，增加ac relation，然后把insert的tuple给hack掉。\r\n逻辑调整为先查找tuple，如果存在，则将count修改。否则正常插入。\r\nDelete逻辑调整为查找tuple，如果存在，则将count修改，如果count为0。则删除记录。\r\n2，在scan方式上，采用index scan，并且调整其实现为从index和heap中获取数据。\r\n\r\n\r\n3，数据导入上，构建虚拟数据，导入pg。\r\n增加import命令，支持按照指定数据格式导入数据\r\n\r\n后面再考虑增加ci的heap am组织方式。扩展下am，然后根据am来区分逻辑，这套仍然可用。\r\n\r\n\r\n现在要做的工作，本质上就是利用heap和btree实现iot，这是一种次优的方案。\r\ntai | iat | iot  基于pg实现的3种模式。\r\n\r\ninsert：\r\n1，查找index记录\r\n2，如果找到，则产生新tuple(count+1)，如果是HOT，则更新ci表即可\r\n否则，写入index记录，并且在heap tuple中更新index id。\r\n3，如果没找到，则插入表，并增加索引\r\n\r\ndelete：\r\n1，查找index记录\r\n2，如果找到，则产生新的tuple(count-1)，更新ci表，以及索引\r\n3，如果没找到，则打印错误。（这里应该不必退出）\r\n4，如果count为0，则执行删除操作。\r\n\r\n先做一个简化版本的。\r\n不存在子事务，不存在multitrans，暴力锁定表。\r\n理解vm等机制， 优化内部实现。\r\nac在heap上的格式是确定的，因而可以做很多优化。\r\n要不要考虑下在线vacuum？\r\n\r\n组成新tuple的逻辑可以放到上面，先查找。然后形成新的tuple。\r\n底下ci纯粹实现数据组织与扫描。且这块的代码对于pk也是通用的。\r\nci地位等价于Iot。\r\niat是把部分column分解成index，另外一部分column拆成heap的存储方式。适用于索引变更不频繁，数量变更频繁的场景。\r\nci master table可以用这种存储方式，ci extra table也可组织成这种形式。其他表也可使用。\r\n在第一个版本仅要求在表上建立该索引并指定使用这种存储方式。\r\n\r\nscan上可能不用非常特别的处理，只是需要将原先从index和heap取数据的逻辑调整下。但代码上怎么嵌入是个问题。\r\n\r\n先做一个约束，ci可以对应于一个表，一个不支持index字段变更的表，如果想变更index，可使用delete + insert在上层实现。\r\n虽然有限制，但这个表仍然是很常用的。\r\n\r\nscan期间buffer是pin住的，但不会加lock，由于mvcc，可以支持这种并发。\r\n\r\n1，怎么无缝的对接vacuum\r\n2，对接scan\r\n3，对接analyze	2019-06-20 08:35:08.624431	f
887	438	Issue	5	10，indexOnlyScan没有拷贝数据，如何处理与分裂并发场景。\r\n\r\n1，在indexOnlyScan期间，index page的pin不会释放。直到处理下一个page。\r\n参考StoreIndexTuple其中不会释放锁。\r\n注意区别：index tuple的buffer不会赋给slot，因而根本不会释放\r\nExecStoreTuple中则不一样，当slot->tts_buffer 与当前buffer不一致时就可以释放buffer。\r\n\r\n2，indexscan，当去heap上取数据时，就可以释放index page的pin了。\r\n参考index_getnext，index_fetch_heap\r\n\r\n但是光pin住够么？ 能防止page分裂么？\r\n在buffer的README文章中解释了这种情况，如果page需彻底删除记录，或变更空间。在获取LOCK的同时需检查pin的情况，\r\n如果有pin则应该等待。	2019-06-21 07:21:19.527445	f
888	438	Issue	5	11， order key在index搜索中的作用\r\n12，scankey的结构与具体用法。\r\n13，查询具体如何与scan接上？ 存在哪些修改点。\r\n14，索引读取时，如果读完一个tuple，page被修改怎么处理？\r\n总是一次性读取一个page，请参考_bt_readpage.如果是index only scan，则把符合条件的记录拷贝出来。\r\n否则记录tid，然后去heap中读取数据。因而heap中的数据的清理总是在index清理之后。\r\n\r\n15，对于中间的page呢？不会也是一次性读取吧\r\n	2019-06-21 09:22:30.123757	f
870	362	Issue	5	并发控制有很多门类：\r\nhttps://www.zhihu.com/question/60278698\r\nhttps://zhuanlan.zhihu.com/p/37087894\r\n《A Critique of ANSI SQL Isolation Levels》中给出了异常操作序列的定义。\r\n\r\n何谓正交，即两种完全不同的维度。这是做纵横向分析必须清晰的。\r\n快照与并发控制什么关系？\r\n直观理解快照必然与时序有关系，也必然产生多个版本。\r\n\r\n锁与多版本就是并发控制领域的一对正交因素。	2019-06-11 12:05:59.227843	f
860	438	Issue	5	找到btree实现的核心点，做好这些就能实现好索引。\r\n\r\n整体介绍的ppt：\r\nhttps://www.pgcon.org/2016/schedule/attachments/423_Btree\r\nREADME\r\n\r\n1，存储形式\r\n1.1 header and special space\r\n1.2 left/right sibling\r\nleft sibling实现反序遍历。\r\n\r\n1.3 high key\r\n1.4 fastroot/root\r\nroot和fastroot信息都保存在meta中，fastroot是当出现大量数据删除时（因为此时每层的rightmost节点不会删除，树的高度永远不会下降），\r\n其直接指向第一个有分叉的节点(或叶子节点)。避免从root一层层往下找，从而实现这种情况下的加速。\r\n\r\n1.5 HOT\r\nhttps://blog.csdn.net/wanghai__/article/details/6340906\r\n就是更新了非索引相关column时，采用HOT方式优化，避免去更新索引。\r\n\r\n2，操作类型\r\n2.1，插入\r\n2.1.1 分裂\r\n2.2，扫描\r\n2.1 扫描额外任务：标记dead，添加miss downlink\r\n2.3，删除，vacuum\r\n2.3.1 vacuum的物理顺序支持\r\n2.3.2 删除page，合并\r\n2.3.3 在tuple删除之后，如果在page内移动tuple，索引如何据此更新。\r\n\r\n3，加锁机制\r\n3.1 vacuum会等到page并没其他锁，且没有pin的时候进行。\r\n3.2 反序扫描时加锁机制，如何防止死锁\r\n如果存在加多个锁的情况，一定是从左到右，从下到上。按照这种顺序去加锁是没问题的。\r\n其他情况都是加单个page的锁。\r\n\r\n3.3 中间节点的加锁机制\r\n对于中间节点，只有分裂与删除时，涉及到修改。这时满足自下而上的操作顺序。\r\n\r\n4，访问顺序\r\n4.1 在分裂以及删除页面时，如何找到其parent\r\n\r\n5，分裂处理\r\n6，合并处理\r\n7，持久化\r\n7.1 mvcc快照\r\n7.2 miss downlink的处理\r\n分裂时每层的操作作为一个原子操作记录wal，但是上层的操作可能尚未完成，这时crash了，就缺乏downlink。\r\n\r\n8，统计信息\r\n9，空间管理\r\n	2019-06-04 13:37:58.74386	f
904	454	Issue	5	行为与index不一样的地方：\r\n1，scan时自行判断可见性\r\n2，最底层tuple为heap tuple。\r\n3，vacuum单独实现，自行根据事务信息来做删除。\r\n4，原表删除时，需调用其删除接口。在indexam增加单条删除接口。\r\n5，插入时，如果有重复值，其行为是增加count。同样删除时其行为是减少count。只有count为0时标记真正删除。\r\n6，它不存储item pointer，因为不需要。而且也没办法存储。\r\n7，与index一样的是不支持update\r\n\r\n问题：如何支持pk？\r\n生成附加字段pkid，pkid在插入时根据规则生成。\r\n然后导数据接口，根据输入的pk，以及查询到的pkid，插入到pkid与pk组成的CI中。\r\n\r\n能否只使用一个Relation？提供不同的获取TupleDesc的方法。应该没有问题，一起都在掌控之中。\r\n\r\n其实ac相当于自行实现的btree index，只是在最底层与接口层做了特殊处理。因为页面结构与btree完全一致，因而可以重用btree的大部分代码。\r\n\r\n存储结构是 x|y|pkid|count，只有最后的count是经常变化的。无论是否想要，count总是存在，这就是CI！\r\n\r\n\r\n想想给外表建本地索引！！\r\n\r\n\r\n	2019-06-26 08:36:00.590042	f
869	439	Issue	5		2019-06-11 08:22:48.145827	f
902	438	Issue	5	16，最左边的索引元组处理\r\n<pre><code class="text">\r\n\t/*\r\n\t * Create downlink item for left page (old root).  Since this will be the\r\n\t * first item in a non-leaf page, it implicitly has minus-infinity key\r\n\t * value, so we need not store any actual key in it.\r\n\t */\r\n\tleft_item_sz = sizeof(IndexTupleData);\r\n\tleft_item = (IndexTuple) palloc(left_item_sz);\r\n\tleft_item->t_info = left_item_sz;\r\n\tBTreeInnerTupleSetDownLink(left_item, lbkno);\r\n\tBTreeTupleSetNAtts(left_item, 0);\r\n</code></pre>\r\n	2019-06-25 12:23:35.145391	f
863	439	Issue	5	事务ID回卷问题，pg通过vacuum frozen机制将特别老的事务id改为Frozen的XID。这个选择是有点扯的。扫描大量页面，修改这玩意，还不如使用int64类型来表示。\r\n快照的一致性：通过xmin，xmax，xplist来区分事务对于快照的可见性。\r\nhttp://blog.itpub.net/6906/viewspace-2562652/\r\n\r\npg/innodb/oracle的对比\r\nhttp://www.postgres.cn/downfiles/pg2016conf_day2_s1_pm3.pdf	2019-06-06 09:31:14.851894	f
903	451	Issue	5		2019-06-26 08:13:34.855604	f
909	438	Issue	5	17，索引中非key字段总是排在后面么？\r\n是的，通过这个函数可以看出来 _bt_nonkey_truncate\r\n\r\n18，有可能加隐藏字段么？	2019-06-27 07:48:27.814589	f
906	455	Issue	5	马上问题来了 vm怎么玩？只能舍弃vm。 那vacuum怎么搞？按照index的玩法？增加删除标记？\r\n为什么之前不同步标记index item删除，因为无法标记。\r\nindex现在的vacuum机制是heap把删除的tid保留起来，index vacuum时做全部扫描，然后通过回调机制检查对应htup有没删除，如果删除，则把index page中的一起删除。\r\nac增加了事务信息之后可单独vacuum。\r\n\r\n事务这块的处理。 不支持cid，不支持除了read committed之外的级别，没有谓词锁。\r\n删除可见---\r\n查询可见---\r\n\r\nHeapTupleSatisfiesVisibility\r\n\r\n可以使用	2019-06-26 12:04:51.024008	f
912	455	Issue	5		2019-06-27 10:17:27.56375	f
915	440	Issue	5	SPI：存储过程编程接口\r\nRI：RI trigger(Generic trigger procedures for referential integrity constraint checks.), heap接口中的crosscheck就是给这个用的。	2019-06-28 07:51:30.041978	f
918	455	Issue	5	不支持update，支持删除。\r\n\r\n有个bug，在关闭seqscan之后，删除tuple，虽然没删成功，但是记录不知道为啥不可见了。可能_bt_checkkeys中失败，tuple变成DEAD了。	2019-06-28 14:33:46.972676	f
919	439	Issue	5	为什么需要pg_subtrans？\r\npg_subtrans从数据上解决了父子事务的关系问题。当然可能也有其他方式来记录。\r\n\r\nsavepoint名称会持久化么？如果异常，事务被完全回滚吗？\r\n\r\nmulti trans是解决tuple lock问题的，详解见heap 下的README.tuplock\r\n	2019-06-29 14:32:22.780857	f
1001	423	Issue	5		2019-08-09 17:16:08.728974	f
1004	289	Issue	5	FoundationDB的Deterministic Simulation也挺有意思的。这可以算是另外一种测试方式了。与测试驱动一样，这些都是强大的方法。	2019-08-11 20:29:14.559046	f
862	439	Issue	5	抛几个问题：\r\n1，索引有mvcc概念么？ 还是都可见。\r\n 索引的可见性是通过tuple来实现的。vacuum的时候根据tuple可见性来清理索引。\r\n mvcc实现了ACID的I。WAL实现了ACID的A，持久化技术实现了D，约束实现了C。\r\n \r\n2，cmin/cmax管理\r\n3，当前系统事务id如何维护，重启之后如何维护？\r\n4，快照如何运用？\r\nhttp://liuyangming.tech/05-2018/MvccAndVacuum.html\r\n快照的本质就是可见性，因而事务隔离的实现就是通过快照。\r\n\r\n\r\n4.1 pg中有哪些快照，具体如何使用？\r\n快照的类型是根据判断函数来的，实际上有些类型的快照根本不需要记录当前系统的事务状态，比如HeapTupleSatisfiesAny与HeapTupleSatisfiesSelf。\r\n\r\n5，如何理解子事务，与事务的区别与关联是什么\r\n6，clog规模如何缩减。\r\n由于pg没有undo机制，事务abort状态记录在clog中，这个状态什么可以被清除呢？\r\n通过frozen机制，每个表都记录了frozen_xid，在该事务之前的clog都应该运用更新到表上，因而在此之前的clog可以清楚。\r\ndatabase据此可计算出最小的frozen_xid。 在vacuum的时候就可以清理在此之后的clog。multitrans等也是这样被清理的。\r\n\r\n7，table的vm机制\r\nhttps://www.postgresql.org/docs/9.5/storage-vm.html\r\n(2020.5.26注:请看最近版本https://www.postgresql.org/docs/11/transaction-iso.html，其中有明确RR下pg不存在幻读问题)\r\n主要是加速可见性判断的，如果一个page所有tuple对所有其他事务可见，则设置标记。用一个bit代表一个page。\r\n\r\n8，pg的隔离级别\r\nhttps://www.postgresql.org/docs/current/transaction-iso.html\r\n中文版\r\nhttp://www.postgres.cn/docs/9.5/transaction-iso.html\r\n\r\n<pre>\r\n如果想保证真正的数学上的可串行化，数据库必须使用谓词锁(predicate lock，SQL Server叫range lock)，\r\n意思是如果一个事务T1正在执行一个查询，该查询的的WHERE子句存在一个条件表达式E1，那么另外一个事务T2 就不能插入或删除任何满足E1的数据行。\r\n例如，一个事务A正在执行一个查询SELECT ... WHERE class = 1，另外一个事务就不能插入、更新或删除任何满足“class=1”的数据行。\r\n只有在A提交以后，B才能进行这样的操作。\r\n</pre>\r\n\r\n总之，可重复读以及串行化级别都存在系列化失败的情况，串行化级别的序列化检查是通过谓词锁来实现的。谓词锁理解是记录了谓词涉及的数据，这并非真的锁，\r\n通过检查数据之间的关系，来发现序列化失败。\r\n\r\n对于可重复读的情况。\r\n如tuple 1，2 被事务1改为1，3\r\n可重复读事务2改为1，4.\r\n事务1提交成功。那么问题来了事务2到底看到的是1，2还是1，3. 按照可重复读应该看到的是未被删除的1，2.然而事务2显然无法更新1，2（只能在1，3基础上更新）. 这里存在矛盾。\r\n因而事务2只能撤销。\r\n\r\n9，事务中断之后如何处理，在断连之后，用户如何感知事务状态？如果用户不abort又将如何？\r\n	2019-06-06 08:48:20.323717	f
871	444	Issue	5		2019-06-11 13:16:01.058232	f
877	444	Issue	5	rebuild_relation这个函数可以好好看看，可以深入理解heap与relation，tuple的关系。\r\n\r\nheap_update执行过程\r\n\r\nExecIndexScan，执行scan找到TupleTableSlot，然后调用ExecUpdate。\r\n\r\n对于ac而言，没有必要。ac可以根据x，y找到tuple，然后调用heap_update这层的方法。	2019-06-13 17:39:10.632212	f
880	444	Issue	5	<pre><code class="text">\r\n * The executor stores tuples in a "tuple table" which is a List of\r\n * independent TupleTableSlots.  There are several cases we need to handle:\r\n *\t\t1. physical tuple in a disk buffer page\r\n *\t\t2. physical tuple constructed in palloc'ed memory\r\n *\t\t3. "minimal" physical tuple constructed in palloc'ed memory\r\n *\t\t4. "virtual" tuple consisting of Datum/isnull arrays\r\n</code></pre>\r\n\r\n\r\nTupleTableSlot在每种scan下的使用。\r\n1，indexscan，属于第一种情况\r\n2，indexonlyscan，属于第四种情况\r\n3，nodescan也是第一种情况\r\n4，dml操作显然属于第二种情况，最终会构造tuple\r\n\r\n什么是minimal tuple？\r\n主要用于hash join等需要产生大量内存记录的情况，去掉了头部的很多信息。	2019-06-14 13:17:09.866162	f
867	404	Issue	5	方案1：\r\nx| y | pk 各使用一层btree。\r\n\r\n方案2：\r\nx y count | pk 使用2层btree。\r\n\r\n方案3：\r\nx y count使用btree，pk使用其他方式存储。\r\n\r\n先按照方案2，往下走看看。\r\npk的存储形式是一个重点，一方面pk个数不确定，另一方面在删除时需要根据pk来查找。\r\n综合上述两种需求，考虑采用index的tid | pk复合键使用btree索引存储。\r\n分裂时如何处理？分裂时其tid被复用。 考虑使用page的lsn或其他page内递增标识。\r\n\r\n这种方案增加了一点约束：tid不能被其他x|y复用，x|y|count不能先于pk删除。 删除时，优先删除pk，然后减少count。如果删除pk成功，减少count失败。\r\n则该条语句需重复执行，重复执行时pk不存在不影响最终成功。\r\n\r\npk的存储可考虑采用表类似vm的机制，使用一种新类型的ForkNumber 。13768 13768_key的形态\r\n\r\n\r\n1，接口定义\r\n1.1，insert(acName, x, y，count，pks)\r\n1.2，delete(acName, x, y，count，pks)\r\n1.3，update(acName, oldx，oldy，oldpk，x, y，pk)\r\n1.4，truncate | clean（acName）\r\n1.5，create(acName,x,y,inlcude_pk)\r\n1.6，drop(acName)\r\n1.7, scan(x) return x | y | count [| pks]\r\n\r\n2, 实现\r\n2.1 create的时候为ac定义索引结构，acName与索引关联.\r\n区别在于ac没有数据实体。同样使用Relation结构管理么？\r\n2.2 count作为covered index的include字段。\r\n2.3 pk作为一个什么类型的字段创建？\r\npk作为原来类型字段创建即可，在逻辑上就是一个简单类型。需要展开是因为物理存储形式决定的。\r\n2.4 count的字段在check之后做修改，然后重新构建tuple后插入。\r\n2.5 delete的时候将index tuple标记为dead。这点与原来btree在scan时标记为DEAD是不一样的。\r\n2.6 vacuum机制上需支持独立vacuum index。\r\n2.7 何时使能AccessConstraint？\r\n2.8 如何处理ac与数据源的数据一致性问题？\r\n2.9 代价评估\r\n2.10 extractor发过来的事务相关的操作，ac需要体现事务性。分析covered index的实现，covered index是通过找到对应的tuple来分析其可见性么？\r\n分析IndexOnlyNext函数。\r\n2.11 一致性的考虑，重复执行某个lsn的log，执行一半异常的情况。count与pk数据一致性。\r\n2.12 即便与数据源存在时差，确保数据的一致性，对于ac仍然有意义。比如批量修改了某个字段，则在该字段上的分析应该在批量生效之后执行。\r\n其意思在于可以确保ac部分在语义上与源库保持一致。\r\n一种方案是index基础上增加可见性处理。另一种自行实现ac，其原型并非covered index，而是IoT。所谓Index必须与原表关联。\r\n2.13 复制，ac的容灾\r\n2.14 升级，与GP对接.如果基于新的AM实现，与GP对接得等到GP升级。\r\n2.15 如果后续形态发生变化，AC的维护方式也会改变。如果constraint index的更新本身包含在源表更新的事务中。\r\n则其是货真价实的index。但以数据抽取方式工作时，其本身需提供事务机制。后续这里会存在事务头部的冗余，但这估计是\r\n不得不走的。\r\n\r\n\r\n	2019-06-10 07:32:27.704135	f
879	444	Issue	5	StoreIndexTuple真的拷贝了所有数据么？ 但是没看到调用memcpy。\r\nDatum看上去更像一个数据指针，当数据并非定长时。\r\n对于非indexonlyscan应该找到tid之后就可以释放buffer了？还是要等scan完成？\r\n_bt_drop_lock_and_maybe_pin，对于ac xs_want_itup这个标记得带上。	2019-06-14 12:26:11.503881	f
873	404	Issue	5	1，CI管理\r\nciCreate：\r\n根据ac中的relfilenode或oid等唯一标识，利用Relation中的结构创建表以及索引。需要的信息是x | y | count | pk等字段信息。\r\nciDrop：\r\n根据ac与ci的表与索引名称关系，找到对应的表和索引，执行删除操作。\r\nciTruncate：\r\n根据ac与ci的表与索引名称关系，找到对应的表和索引，执行truncate操作。\r\n2，数据导入\r\n考虑每个数据源独立进程，否则进程模型可能存在一些问题。\r\n数据写入会做合并，否则额外产生一些中间过程的列。这个合并操作可以在外部实现，也可以在Ac写入接口之上封装实现，但其与AcAmRoutine没关系。\r\nAcTupleOp \r\n{\r\n  Datum *values;\r\n  bool *isnull;\r\n  uint32 count;\r\n  Datum *pks;\r\n  uint32 op_type; //insert or delete\r\n}\r\nciPrepare\r\nciSet\r\nciExec\r\nciSimpleExec  //将上述3个接口融合\r\n3, 数据扫描\r\n提供AcFetch node，在AcAmRoutine基础上封装数据抽取。	2019-06-13 07:16:49.920043	f
874	406	Issue	5	ubuntu上登录mysql：\r\nmysql -uroot -proot 或者\r\nmysql -h localhost -uroot -proot\r\n\r\nshow database;\r\n\r\n查看binlog命令：\r\nmysqlbinlog --base64-output=decode-rows --start-datetime="2019-06-13 11:40:00" -vv /var/log/mysql/mysql-bin.000001\r\nxxd /var/log/mysql/mysql-bin.000004\r\n\r\n	2019-06-13 09:25:24.334918	f
881	444	Issue	5	不管是heap还是index，都强烈的跟Relation关联。\r\n甚至metapage都缓存在relation中。	2019-06-14 16:09:41.400719	f
872	444	Issue	5	heap_fill_tuple(TupleDesc tupleDesc,\r\n\t\t\t\tDatum *values, bool *isnull,\r\n\t\t\t\tchar *data, Size data_size,\r\n\t\t\t\tuint16 *infomask, bits8 *bit)\r\n\r\nDatum从其他数据而来，不同类型的存储形式不一样。\r\nisnull是字段是否为null的数组。\r\n注意对于null的字段Datum仍然是有值的，但是最终在heaptuledata中仅占用bit位。\r\n\r\nfill_val这个函数有点看不懂，从pointer怎么计算出数据长度？\r\n如果是变长 Datum结构的前面部分就包含了数据长度，参考函数inv_write\r\n\r\nbinlog，pg的logic log如何表示空置？\r\n从binlog解析结果看应该也是有null数组，以及列值：\r\n<pre><code class="text">\r\n### UPDATE `testdb`.`tt2`\r\n### WHERE\r\n###   @1=1 /* INT meta=0 nullable=1 is_null=0 */\r\n###   @2=NULL /* STRING(10) meta=65034 nullable=1 is_null=1 */\r\n### SET\r\n###   @1=2 /* INT meta=0 nullable=1 is_null=0 */\r\n###   @2=NULL /* STRING(10) meta=65034 nullable=1 is_null=1 */\r\n\r\n</code></pre>\r\n\r\nbinlog for truncate table\r\n\r\n<pre><code class="text">\r\n#190613 14:20:57 server id 1  end_log_pos 1641 CRC32 0x5ddeceeb \tAnonymous_GTID\tlast_committed=6\tsequence_number=7\trbr_only=no\r\nSET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;\r\n# at 1641\r\n#190613 14:20:57 server id 1  end_log_pos 1728 CRC32 0xa14a0044 \tQuery\tthread_id=14\texec_time=0\terror_code=0\r\nuse `testdb`/*!*/;\r\nSET TIMESTAMP=1560406857/*!*/;\r\nSET @@session.pseudo_thread_id=14/*!*/;\r\nSET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;\r\nSET @@session.sql_mode=1436549152/*!*/;\r\nSET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;\r\n/*!\\C utf8 *//*!*/;\r\nSET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=8/*!*/;\r\nSET @@session.lc_time_names=0/*!*/;\r\nSET @@session.collation_database=DEFAULT/*!*/;\r\ntruncate table tt1\r\n/*!*/;\r\nSET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;\r\nDELIMITER ;\r\n# End of log file\r\n/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;\r\n/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;\r\n</code></pre>\r\n\r\n	2019-06-12 09:40:19.033133	f
875	444	Issue	5	Index有哪些列，每个列是什么数据类型在内存中哪里有体现？	2019-06-13 12:10:44.257089	f
886	450	Issue	5	typedef struct HeapTupleData\r\n{\r\n\tuint32\t\tt_len;\t\t\t/* length of *t_data */\r\n\tItemPointerData t_self;\t\t/* SelfItemPointer */\r\n\tOid\t\t\tt_tableOid;\t\t/* table the tuple came from */\r\n#define FIELDNO_HEAPTUPLEDATA_DATA 3\r\n\tHeapTupleHeader t_data;\t\t/* -> tuple header and data */\r\n} HeapTupleData;\r\n\r\n注意page里面并未存放HeapTupleData结构，而是HeapTupleHeaderData开始的格式。\r\n\r\n这里处理就得非常注意了。	2019-06-20 13:25:05.91176	f
822	404	Issue	5	pg存文本字段的上限。文本搜索的实现。\r\n\r\n1，以索引形态存储ci\r\n2，以表形态存储ci\r\n3，列存储技术有没运用空间\r\n\r\n约束列表：\r\n1，x，y只能是单列\r\n\r\n本质上access constaint是一个表，可以在x上建立聚簇索引。\r\n本质上constraint index是一个索引，通过x获取y以及对应的tupleid。\r\n\r\n问题1：大量tupleid如何存储？pg行内存储的最大长度是多少？\r\n  pg约束记录不能超过一个block，默认是8k，否则启用toast机制\r\n\r\n问题2：pg的hash index如何实现？是否适合\r\n  hash index跟常见的hash实现类似\r\n2.1 溢出页内的数据有序么？\r\n  是有序的。\r\n问题3：如果以索引形态存储，是用什么类型的索引？联合索引的用法(能否支持c1c2，从c1找到c2)？还是自定义某个类型索引的一个实现？\r\n问题4：以索引形态存储，其value能否很好的自定义？\r\n问题5：是否考虑采用其他手段如redis给src_tid-> ci_tid的映射。\r\n    一种实现方式是采用pg的hash索引，桶内根据tid排序。 因为没有排序需求，只有根据tid插入，删除。\r\n问题6：如何在beas上实现？放在pg还是beas模块中？\r\n问题7：优化：同一个表上多个access schema如何避免冗余的hash索引？	2019-05-20 07:49:36.905359	f
1177	312	Issue	5	https://www.cnblogs.com/lojunren/p/3856290.html\r\n\r\nepoll是多路复用技术，并非异步编程框架。	2020-02-16 20:58:51.953004	f
876	400	Issue	5	跟何大神打球发现问题：\r\n1，出球线路比较单一，且未仔细考虑\r\n慎打斜线杀球\r\n平抽不要抽到别人拍子边\r\n\r\n2，跳球仍然不到位\r\n  原因是局部发力有问题，小臂与手腕手指发力\r\n\r\n3，扑球不够快，手法有问题\r\n\r\n4，后侧步问题大\r\n\r\n5，拍面的控制\r\n反手有两种握拍方式，要看情况运用。	2019-06-13 16:30:30.101717	f
1178	574	Issue	5	富者掌握资源，智者掌握知识	2020-02-18 06:30:35.121048	f
1483	708	Issue	5	s3接口根据ak/sk生成s3Client\r\nhdfs接口根据配置和url生成FileSystem操作类。\r\n\r\n可以找个服务器搭建ceph或hdfs环境，大家一起测试	2020-11-15 04:41:20.209219	f
892	451	Issue	5		2019-06-22 12:11:20.929511	f
897	451	Issue	5		2019-06-24 06:51:51.476103	f
894	449	Issue	5	<pre>\r\n\tpostgres.exe!ExecModifyTable(PlanState * pstate) 行 1947\tC\r\n \tpostgres.exe!ExecProcNodeFirst(PlanState * node) 行 445\tC\r\n \tpostgres.exe!ExecProcNode(PlanState * node) 行 247\tC\r\n \tpostgres.exe!ExecutePlan(EState * estate, PlanState * planstate, bool use_parallel_mode, CmdType operation, bool sendTuples, unsigned __int64 numberTuples, ScanDirection direction, _DestReceiver * dest, bool execute_once) 行 1723\tC\r\n \tpostgres.exe!standard_ExecutorRun(QueryDesc * queryDesc, ScanDirection direction, unsigned __int64 count, bool execute_once) 行 364\tC\r\n \tpostgres.exe!ExecutorRun(QueryDesc * queryDesc, ScanDirection direction, unsigned __int64 count, bool execute_once) 行 307\tC\r\n \tpostgres.exe!ProcessQuery(PlannedStmt * plan, const char * sourceText, ParamListInfoData * params, QueryEnvironment * queryEnv, _DestReceiver * dest, char * completionTag) 行 161\tC\r\n \tpostgres.exe!PortalRunMulti(PortalData * portal, bool isTopLevel, bool setHoldSnapshot, _DestReceiver * dest, _DestReceiver * altdest, char * completionTag) 行 1286\tC\r\n \tpostgres.exe!PortalRun(PortalData * portal, long count, bool isTopLevel, bool run_once, _DestReceiver * dest, _DestReceiver * altdest, char * completionTag) 行 799\tC\r\n \tpostgres.exe!exec_simple_query(const char * query_string) 行 1145\tC\r\n \tpostgres.exe!PostgresMain(int argc, char * * argv, const char * dbname, const char * username) 行 4182\tC\r\n \tpostgres.exe!BackendRun(Port * port) 行 4361\tC\r\n \tpostgres.exe!SubPostmasterMain(int argc, char * * argv) 行 4883\tC\r\n \tpostgres.exe!main(int argc, char * * argv) 行 205\tC\r\n\r\n从ExecProcNode进入了scan\r\n \tpostgres.exe!heap_beginscan(RelationData * relation, SnapshotData * snapshot, int nkeys, ScanKeyData * key) 行 1406\tC\r\n \tpostgres.exe!SeqNext(SeqScanState * node) 行 71\tC\r\n \tpostgres.exe!ExecScanFetch(ScanState * node, TupleTableSlot *(*)(ScanState *) accessMtd, bool(*)(ScanState *, TupleTableSlot *) recheckMtd) 行 95\tC\r\n \tpostgres.exe!ExecScan(ScanState * node, TupleTableSlot *(*)(ScanState *) accessMtd, bool(*)(ScanState *, TupleTableSlot *) recheckMtd) 行 162\tC\r\n \tpostgres.exe!ExecSeqScan(PlanState * pstate) 行 129\tC\r\n \tpostgres.exe!ExecProcNodeFirst(PlanState * node) 行 445\tC\r\n \tpostgres.exe!ExecProcNode(PlanState * node) 行 247\tC\r\n>\tpostgres.exe!ExecModifyTable(PlanState * pstate) 行 2025\tC\r\n\r\n\r\n>\tpostgres.exe!heap_delete(RelationData * relation, ItemPointerData * tid, unsigned int cid, SnapshotData * crosscheck, bool wait, HeapUpdateFailureData * hufd, bool changingPart) 行 3064\tC\r\n \tpostgres.exe!ExecDelete(ModifyTableState * mtstate, ItemPointerData * tupleid, HeapTupleData * oldtuple, TupleTableSlot * planSlot, EPQState * epqstate, EState * estate, bool processReturning, bool canSetTag, bool changingPart, bool * tupleDeleted, TupleTableSlot * * epqslot) 行 719\tC\r\n \tpostgres.exe!ExecModifyTable(PlanState * pstate) 行 2170\tC\r\n\r\n查询的执行堆栈。\r\n>\tpostgres.exe!heap_beginscan(RelationData * relation, SnapshotData * snapshot, int nkeys, ScanKeyData * key) 行 1406\tC\r\n \tpostgres.exe!SeqNext(SeqScanState * node) 行 71\tC\r\n \tpostgres.exe!ExecScanFetch(ScanState * node, TupleTableSlot *(*)(ScanState *) accessMtd, bool(*)(ScanState *, TupleTableSlot *) recheckMtd) 行 95\tC\r\n \tpostgres.exe!ExecScan(ScanState * node, TupleTableSlot *(*)(ScanState *) accessMtd, bool(*)(ScanState *, TupleTableSlot *) recheckMtd) 行 145\tC\r\n \tpostgres.exe!ExecSeqScan(PlanState * pstate) 行 129\tC\r\n \tpostgres.exe!ExecProcNodeFirst(PlanState * node) 行 445\tC\r\n \tpostgres.exe!ExecProcNode(PlanState * node) 行 247\tC\r\n \tpostgres.exe!ExecutePlan(EState * estate, PlanState * planstate, bool use_parallel_mode, CmdType operation, bool sendTuples, unsigned __int64 numberTuples, ScanDirection direction, _DestReceiver * dest, bool execute_once) 行 1723\tC\r\n</pre>	2019-06-22 13:33:22.47694	f
899	451	Issue	5		2019-06-24 09:00:15.943711	f
895	451	Issue	5	优先提供一套嵌入pg的算法，确保代码的通用性，同时辅助测试。\r\n\r\n*IOT的核心问题是itempointer会变*。\r\n此处可参考btree的处理在README或代码注释中都有说明。\r\n\r\n_bt_readpage(IndexScanDesc scan, ScanDirection dir, OffsetNumber offnum)\r\n	2019-06-22 13:35:43.91084	f
889	451	Issue	5	CI IOT：\r\n没有left指针，不支持反序扫描。\r\n但是有right指针，以处理分裂完成部分的情况。\r\n也有HIGH KEY，避免每次都去找right sibling。同时high key作为索引的key。\r\n\r\n1，能否证明heap的page 0总是left most节点。\r\n基于两条规则，一是合并总是将右边向左边合并。二是分裂总是从左边向右边分裂。\r\n\r\n2 基于此规则，是否总能找到对应的tuple。\r\n合并：\r\n    删除索引\r\n    对左page加锁。\r\n    对右page加锁。\r\n    将右page数据拷贝到左page。\r\n    修改左page的right sibling。\r\n    释放锁。\r\n    回收右page。\r\n分裂：\r\n    分配右page\r\n    对左page加锁\r\n    将左page的数据拷贝到右page\r\n    修改右page的right sibling\r\n    修改左page的right sibling\r\n    释放page锁\r\n    在索引中插入右page的item\r\n\r\n    注意：除了最后一步，其他步骤是需要确保都成功的。最后一步失败没太大关系，相当于索引更稀疏了些。\r\n\r\n查找：\r\n    根据索引找到page，如果tuple大于page的最大key，则去right sibling查找。\r\n    否则page内执行2分查找。\r\n\r\n3，redo机制是否可用？需要做哪些调整？\r\n主要区别点在于right sibling。\r\n\r\n4，需要给IOT的表的page增加special space，保存right sibling。\r\n具体参考PageInit函数，page的special space是可自定义的。\r\n\r\n5，根据itemid排序处理\r\n在PageAddItemExtended函数上体现的明显，如果指定了插入位置，且并非overwrite的情况。说明就是排序情况了，索引需要挪动记录。\r\n对heap而言是不会这么干的。heap要么不给offset，自动在page内找位置，要么指定位置就一定是overwrite。\r\n\r\n6，加锁的风险\r\nsuper-exclusive lock，为了避免non-full vacuum与indexscan的顺序引入。\r\n-对于ci没必要。ci没有其他index-\r\n这是一个约束。\r\n但ci本身的index维护可能存在该问题	2019-06-22 09:45:09.705511	f
891	451	Issue	5	6，vacuum怎么玩？能兼容吗\r\n首先也是vacuum heap page，但是对于IOT，vacuum是否回收page呢？而且回收page对page的scan顺序应该有所要求？或与右侧合并。\r\nindex vacuum分为2步，第一步根据heap标记index item dead。第二步执行cleanup，清除deap page。\r\n7，analyze怎么玩？\r\n8，HeapTuple这套可以兼容吗？\r\n9，page 0的处理\r\npage 0不需要key，凡是找不到合适page的，都用page 0.\r\n10，不支持table scan的table？\r\nvacuum和analyze根本不用table scan。 \r\nvacuum是直接按照blocknum来的。analyze随机抽取page。\r\n11，AcScan的实现\r\n局部拷贝nodeIndexScan，少数地方还得处理下，比如order，比如实际不带scankey的情况。\r\n但不论如何AcScan出来的结果是按照X，Y有序的。\r\n如果key不好使，就从page 0开始。本质上还是IndexScan。\r\n所以目前可以伪装下，即AcScan总是IndexScan。区别仅在于scan完成后，需从ac page上取出满足条件的所有记录。\r\n\r\ntable scan还是有意义的，可以更多的利用顺序读。分阶段来做吧\r\n\r\n12，对于没有可用条件的情况\r\n_bt_first中有处理，其逻辑是符合ac要求的，从最左或最右边开始扫描。就是index full scan。	2019-06-22 10:22:57.287384	f
890	449	Issue	5	在哪里决定用什么scan的，又是如何将参数带下来。	2019-06-22 10:20:48.736259	f
901	423	Issue	5	page的LSN确保其不会优先于wal进行持久化。	2019-06-25 07:26:38.901917	f
898	451	Issue	5		2019-06-24 08:57:20.568395	f
893	451	Issue	5	约束：\r\n1，不支持反序扫描。 \r\n2，不支持索引。\r\n3，不支持记录级别的锁，即不支持select for share/update语法。\r\n4，不支持谓词锁\r\n5，不支持commandid	2019-06-22 12:47:21.307164	f
896	449	Issue	5	还要分析查询条件是如何获取的。\r\n\r\n<pre><code class="text">\r\n \tpostgres.exe!create_scan_plan(PlannerInfo * root, Path * best_path, int flags) 行 536\tC\r\n \tpostgres.exe!create_plan_recurse(PlannerInfo * root, Path * best_path, int flags) 行 380\tC\r\n \tpostgres.exe!create_plan(PlannerInfo * root, Path * best_path) 行 317\tC\r\n>\tpostgres.exe!standard_planner(Query * parse, int cursorOptions, ParamListInfoData * boundParams) 行 412\tC\r\n \tpostgres.exe!planner(Query * parse, int cursorOptions, ParamListInfoData * boundParams) 行 263\tC\r\n \tpostgres.exe!pg_plan_query(Query * querytree, int cursorOptions, ParamListInfoData * boundParams) 行 832\tC\r\n \tpostgres.exe!pg_plan_queries(List * querytrees, int cursorOptions, ParamListInfoData * boundParams) 行 898\tC\r\n \tpostgres.exe!exec_simple_query(const char * query_string) 行 1073\tC\r\n\r\n</code></pre>\r\n\r\nselect语句的执行主体\r\nExecutePlan\r\n\r\nruntime key的处理：\r\n\r\nExecIndexScan，会提前确定相关的值。\r\n	2019-06-22 13:37:31.325441	f
900	442	Issue	5	\r\nvm机制引入原因：\r\n1，可以避免重复vacuum，frozen\r\n2，index only scan用来判断可见性\r\n\r\n特点：\r\n1，需要与页面的内容修改一起记录wal，保证一致性。\r\n   all_visible_cleared\r\n\r\n2，page上的标记和vm里面的标记应该保持一致性。\r\n\r\nvm并发控制：\r\n1，check page flag\r\n2，pin vm\r\n3，lock buffer\r\n4，lock vm buffer\r\n\r\n2和3顺序不颠倒，主要是因为第2步有IO。\r\n\r\n<pre>\r\n * In heapam.c, whenever a page is modified so that not all tuples on the\r\n * page are visible to everyone anymore, the corresponding bit in the\r\n * visibility map is cleared. In order to be crash-safe, we need to do this\r\n * while still holding a lock on the heap page and in the same critical\r\n * section that logs the page modification. However, we don't want to hold\r\n * the buffer lock over any I/O that may be required to read in the visibility\r\n * map page.  To avoid this, we examine the heap page before locking it;\r\n * if the page-level PD_ALL_VISIBLE bit is set, we pin the visibility map\r\n * bit.  Then, we lock the buffer.  But this creates a race condition: there\r\n * is a possibility that in the time it takes to lock the buffer, the\r\n * PD_ALL_VISIBLE bit gets set.  If that happens, we have to unlock the\r\n * buffer, pin the visibility map page, and relock the buffer.  This shouldn't\r\n * happen often, because only VACUUM currently sets visibility map bits,\r\n * and the race will only occur if VACUUM processes a given page at almost\r\n * exactly the same time that someone tries to further modify it.\r\n</pre>	2019-06-25 07:12:41.004625	f
905	454	Issue	5	实施计划：\r\n1，开发的时候可以基于不带count的，即在某个表上创建ci类型的索引。然后就可以导入数据，查询。查询不经过heap。\r\n后面等元数据模块合入之后，就可以拿到ac的Relation，把特殊行为加进去。并且可以让ac relation兼容index relation，从而ciam可以单独使用。\r\n\r\n2，可以先不支持delete，但需支持scan。而且让其走indexonlyscan。把代价搞低方便调试。indexonlyscan就是最优的。	2019-06-26 09:11:32.426851	f
1050	513	Issue	5	可以借用现有的index到heap获取tuple的方式获取kd记录。\r\nscan->xs_cbuf.\r\nscan->xs_ctup\r\nxs_continue_hot\r\n\r\n拼装tup给xs_itup\r\n使用一块固定内存。\r\n\r\n关于压缩前面level的处理：\r\n问题：如何找到某个id的node？\r\n在header里面下自己的id，然后根据id可计算出层次，以及层次内的序号，然后根据page链查找。\r\n\r\n还有一个办法，就是在树输出的过程中，临时记录上存储位置，在存储其child时，把parent位置记录下来。\r\n另外一种办法就是记录下scan stack，在查找某个key时，记录下来。\r\n	2019-09-11 14:49:57.461926	f
1051	393	Issue	5	剩下的工作：\r\n1，把tuple desc替换\r\n2，把距离计算引入\r\n3，测试demo版本功能。	2019-09-12 15:26:50.645814	f
907	439	Issue	5	<pre><code class="text">\r\n/*\r\n * HeapTupleSatisfiesUpdate\r\n *\r\n *\tThis function returns a more detailed result code than most of the\r\n *\tfunctions in this file, since UPDATE needs to know more than "is it\r\n *\tvisible?".  It also allows for user-supplied CommandId rather than\r\n *\trelying on CurrentCommandId.\r\n *\r\n *\tThe possible return codes are:\r\n *\r\n *\tHeapTupleInvisible: the tuple didn't exist at all when the scan started,\r\n *\te.g. it was created by a later CommandId.\r\n *\r\n *\tHeapTupleMayBeUpdated: The tuple is valid and visible, so it may be\r\n *\tupdated.\r\n *\r\n *\tHeapTupleSelfUpdated: The tuple was updated by the current transaction,\r\n *\tafter the current scan started.\r\n *\r\n *\tHeapTupleUpdated: The tuple was updated by a committed transaction.\r\n *\r\n *\tHeapTupleBeingUpdated: The tuple is being updated by an in-progress\r\n *\ttransaction other than the current transaction.  (Note: this includes\r\n *\tthe case where the tuple is share-locked by a MultiXact, even if the\r\n *\tMultiXact includes the current transaction.  Callers that want to\r\n *\tdistinguish that case must test for it themselves.)\r\n */\r\n</code></pre>\r\n	2019-06-26 18:59:55.450119	f
908	439	Issue	5	10，如果一个事务，涉及多个操作，其中部分写了WAL，部分没有写。事务如何回滚？	2019-06-27 07:47:43.215314	f
910	455	Issue	5		2019-06-27 09:07:21.326816	f
911	455	Issue	5		2019-06-27 10:06:27.318211	f
913	455	Issue	5		2019-06-27 10:17:57.25956	f
922	444	Issue	5	Datum 使用指针存储int64，因而需要使用Datum特定接口来访问int64字段的值。显然对于其他字段也应该使用这种方式，这样更加符合规范。	2019-07-05 15:05:35.321956	f
914	455	Issue	5	隐含字段，header，其起始位置使用itempointer表示。只有需要解析出tuple时才用到。其他时间随着其他字段一起拷贝，管理。\r\n不支持toast index	2019-06-27 12:15:45.105085	f
924	459	Issue	5	<pre><code class="text">\r\nWhen it is necessary to wait for a tuple-level lock to be released, the basic\r\ndelay is provided by XactLockTableWait or MultiXactIdWait on the contents of\r\nthe tuple's XMAX.  However, that mechanism will release all waiters\r\nconcurrently, so there would be a race condition as to which waiter gets the\r\ntuple, potentially leading to indefinite starvation of some waiters.  The\r\npossibility of share-locking makes the problem much worse --- a steady stream\r\nof share-lockers can easily block an exclusive locker forever.  To provide\r\nmore reliable semantics about who gets a tuple-level lock first, we use the\r\nstandard lock manager, which implements the second level mentioned above.  The\r\nprotocol for waiting for a tuple-level lock is really\r\n\r\n     LockTuple()\r\n     XactLockTableWait()\r\n     mark tuple as locked by me\r\n     UnlockTuple()\r\n</code></pre>\r\n\r\n这段意思是由于之前锁唤醒机制的问题（没有等待队列，按序唤醒的机制），因而增加了共享内存中的tuple lock机制。\r\n但是由于冲突的情况通常少，且冲突时进程会等待，因而这种锁不会很多。	2019-07-07 19:33:01.937857	f
917	455	Issue	5	create table test8(x int, y int, z int, count int);\r\ncreate index idx8 on test8(x,y) include(count);\r\n\r\nSET enable_seqscan = OFF;\r\nSET enable_bitmapscan=0;\r\nselect pg_backend_pid();\r\nselect x,y,count from test8;\r\ninsert into test8 values(1,1,1,1);\r\ninsert into test8 values(1,2,2,1);\r\ninsert into test8 values(1,3,3,1);\r\ninsert into test8 values(1,1,11,2);\r\ninsert into test8 values(1,1,111,3);\r\ninsert into test8 values(1,2,22,2);\r\ninsert into test8 values(1,2,222,3);\r\n\r\ntest=# insert into test8 values(1,2,222,3);\r\nINSERT 0 1\r\ntest=# select x,y,count from test8;\r\n x | y | count\r\n---+---+-------\r\n 1 | 1 |     6\r\n 1 | 2 |     6\r\n 1 | 3 |     1\r\n(3 rows)	2019-06-28 14:26:12.017728	f
921	439	Issue	5	12，为什么tuple lock需要持久化? 莫非有事务在重启之后还需执行？\r\n13，key和nokey对于tuple lock有何影响？为什么要区分？	2019-06-30 18:33:40.625548	f
927	347	Issue	5	提供一个通用，方便的数据处理和交易平台。企业或个人参与平台的动力在于其需要别人的数据。\r\n支持大家一起维护数据，共享与使用。数据的引用度，以及评分。\r\n\r\n数据交易的透明化。	2019-07-10 07:57:20.928157	f
931	458	Issue	5	减少\r\n优化\r\n冗余\r\n三大方向。	2019-07-11 07:00:33.703094	f
932	406	Issue	5	cmake 3版本安装：\r\nsudo yum install epel-release\r\nsudo yum install cmake3	2019-07-11 07:27:58.86887	f
933	442	Issue	5	https://blog.csdn.net/pg_hgdb/article/details/79490875\r\nvacuum full：创建一个新的heap，把老的数据导出来，再导入并重建索引。\r\nvacuum：扫描heap，释放可用空间（表尾部占用的空间会被回收）。其中比较大的优化是利用vm来跳过部分page，但跳过page有要求（连续32个page是clean的）。\r\n然后根据删除的tuple的itempointer找到索引，在索引上执行bulkdelete。	2019-07-11 13:35:36.823949	f
937	456	Issue	5	成败论英雄，比赛见输赢，但人生应当豁达，乐观。	2019-07-13 19:01:38.530078	f
944	469	Issue	5	我理解是pg不支持单个进程不做AbortTransaction直接退出的。在退出处理时buffer状态是BM_IO_ERROR。这时读取该buffer的进程需重新加载该buffer。	2019-07-17 08:24:05.311926	f
947	469	Issue	5		2019-07-17 09:04:24.044732	f
949	468	Issue	5	vm处理困难主要在于性能，如果在btree上加锁，找到对应的插入位置，然后释放锁，读取vm。这样原来的buffer其key位置可能发生了变化。\r\nheap不存在这个问题，heap页面被修改之后，大不了recheck一下，看看空间是否足够。\r\n当然btree也可以这么做。释放锁之后，读取vm信息，然后再检查插入位置。\r\n\r\n另外btree的vacuum可以直接从叶子节点开始。\r\n\r\nbtree上的vm还有一点，其中间节点不存在vm，没有tuple 可见信息。\r\n\r\n	2019-07-17 18:35:22.576379	f
952	472	Issue	5		2019-07-18 15:22:01.594539	f
953	472	Issue	5	配置文件位于data目录下，修改后重启server生效。\r\n\r\n关于pg配置：\r\nhttps://blog.csdn.net/tencupofkaiwater/article/details/81069248	2019-07-18 15:22:41.450212	f
972	475	Issue	5	test=# copy ac810 from 'D:\\test600.data' delimiter ',';\r\nCOPY 10000000\r\nTime: 25941.265 ms (00:25.941)\r\ntest=# create table test810(x int, y int, count int);\r\nCREATE TABLE\r\nTime: 1.557 ms\r\ntest=# copy test810 from 'D:\\test600.data' delimiter ',';\r\nCOPY 10000000\r\nTime: 14902.586 ms (00:14.903)\r\ntest=#\r\n\r\n性能相差不到一倍。	2019-07-24 14:14:31.023041	f
920	280	Issue	5	有一天我站在阳台上，站在深圳的阳台与家里的有什么区别吗？\r\n为什么没法放下呢？我又在执著什么？\r\n\r\n成年人的世界多了很多责任，也多了很多世俗与成见。仿佛我们没有退路，竞争似乎在把人逼疯掉。\r\n然而我们似乎忘了自己生活在最好的时代。\r\n\r\n当我打羽毛球时，我想我想要的真的是羽毛球本身吗？不是的，我想要的是一种感觉，是安得倚天剑，是十步一杀人的侠客情怀。\r\n是领悟与获取成就的快乐。在羽毛球运动中我不仅看到了专业，热爱，认真带来的巨大效果，同时也看到唯有千锤百炼才能成为高手。\r\n所以不仅得走在正确的路上，还得不断的练习实践提高。\r\n\r\n但这不意味着"吃得苦中苦，方为人上人",这过程没有所谓的成功，更何谈人上人。这是一个无限的游戏，快乐相伴我们成长。\r\n\r\n德：知道什么是合适的，并按合适的方式生活工作。\r\n智：掌握做事情的方法，技巧。是知识与技能的结合。\r\n体：君子厚积薄发，体魄意志是人的基础。	2019-06-30 09:17:57.391006	f
916	455	Issue	5	CI可见与清理：\r\n\r\n相同key的tuple按序排列。插入时不需要清除。\r\n当count为0时，设置xmax标记。但对于btree这仍然是插入操作。\r\n\r\n\r\n扫描时，同一个key只需找到一个可见的。\r\n如果找到一个可见，但count为0.应该跳过后面的。\r\n或者连第一个都不可见。理论上不存在这种情况（前提条件是不设置xmax），要么就所有都不可见。\r\n\r\n如果xmin HeapTupleIsSurelyDead并且count为0，则可标记为DEAD。\r\n如果同一个key，有前面的key可标记为dead，则后面的key也可以标记为dead。\r\n第一个如何删除呢？\r\n\r\n另外如何支持后序扫描？\r\n\r\n并发控制：如果在一个key的最新版本上冲突，则回滚事务（后续可考虑使用内存锁机制，ac基本上不存在一次update很多行的情况）\r\n          对于update，永远不可能在非最新版本上执行（heap是通过行锁实现的）。ac的逻辑并非针对每行判断是否satisfy update。\r\n后序扫描：暂不支持，要支持后续扫描，则每个版本的可见性要独立出来。这样就需要遍历版本，找到可见版本。\r\n\r\n找到最新版本，并标记为不可见。然后插入新的版本。\r\n将insert和delete的逻辑合并，唯一区别就在于对count的处理上，这个在上层稍作处理。\r\n\r\n\r\n	2019-06-28 10:16:50.371029	f
923	459	Issue	5	1，为什么有default和user不同的lock method？\r\n可能是行为不一样，user的需用户释放\r\n\r\n2，proclock具体是指？\r\n\r\n3，tuple lock放在tuple持久化，内存中记录了啥？如何做死锁监测？\r\n在冲突等待的时候，内存中还是有记录的。\r\n	2019-07-07 19:12:11.69621	f
925	390	Issue	5	激励自己的目标这个一定要看清楚。当我一个人的时候，有空闲的时候我会投入精力去做它么。	2019-07-07 21:46:03.022498	f
926	463	Issue	5		2019-07-10 07:52:18.907389	f
928	347	Issue	5		2019-07-10 07:59:18.113935	f
936	442	Issue	5	vacuum是先清理index，然后回收heap item的。\r\n\r\n使用特殊标志，标记frozen：\r\n#define HEAP_XMIN_FROZEN\t\t(HEAP_XMIN_COMMITTED|HEAP_XMIN_INVALID)	2019-07-13 18:37:24.068984	f
930	458	Issue	5		2019-07-11 06:59:08.58921	f
934	438	Issue	5	18，为什么在非mvcc，非wal-logged，以及index-only情况下不能提前释放pin？\r\n\r\n<pre><code class="c">\r\nstatic void\r\n_bt_drop_lock_and_maybe_pin(IndexScanDesc scan, BTScanPos sp)\r\n{\r\n\tLockBuffer(sp->buf, BUFFER_LOCK_UNLOCK);\r\n\r\n\tif (IsMVCCSnapshot(scan->xs_snapshot) &&\r\n\t\tRelationNeedsWAL(scan->indexRelation) &&\r\n\t\t!scan->xs_want_itup)\r\n\t{\r\n\t\tReleaseBuffer(sp->buf);\r\n\t\tsp->buf = InvalidBuffer;\r\n\t}\r\n}\r\n</code></pre>\r\n\r\n其中一个作用可能是killitem（pin），但是这跟index-only似乎没关系。\r\n\r\nhttps://www.postgresql.org/message-id/920499679.2734010.1425495532615.JavaMail.yahoo%40mail.yahoo.com\r\nbtree-nopin有点意思	2019-07-11 18:58:55.980934	f
935	447	Issue	5	对于toast字段，在创建index tuple时会展开。如果记录长度超过index最大size(代码里面是8k)，就会报错。\r\n但是要考虑压缩长度。超过TOAST_INDEX_TARGET后就会压缩。\r\n\r\n实测数据达到8112长度时，index写入会报错，但是错误不是size超过，而是：\r\n<pre><code class="text">\r\ntest=# copy ac12 from 'D:\\test100.data' delimiter ',';\r\nERROR:  could not find a feasible split point for index "ac12"\r\nCONTEXT:  COPY ac12, line 1: "1,11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111..."\r\n</code></pre>\r\n	2019-07-12 15:02:46.968197	f
938	460	Issue	5	我能看到自己身上悲观的情绪，也能看到自己骨子里的散漫与放纵。这与自由相差甚远。\r\n当独自一人时，我们更能看清自己。无数时刻，自己在刷着无聊的文章和视频，玩着游戏与别的。\r\n任凭自己的头脑就如此贫瘠着。我在任何领域都离高手都相差甚远。\r\n\r\n英雄情节？万丈豪情？ no,no 那不是我。狭隘，悲观，消极，散漫是当下的我。\r\n如果你看不到别人的努力和认真，那你不可能是高手。	2019-07-13 19:10:36.770232	f
940	438	Issue	5		2019-07-13 20:32:18.310907	f
941	465	Issue	5		2019-07-13 20:32:18.316395	f
942	466	Issue	5		2019-07-13 20:33:45.925297	f
943	439	Issue	5		2019-07-13 20:33:45.929679	f
973	479	Issue	5	常规测试用例：\r\n如果一个事务内插入100条记录。重复N次，占用的存储空间应该不会增长。\r\n\r\n_bt_vacuum_one_page在执行该函数之后，应该需要重新定位offset，位置可能变化。	2019-07-24 18:26:23.432304	f
969	479	Issue	5	构造一个含各种数据类型，带NULL值，以及存在各种数量，各种插入顺序的表，导入ac，然后对比测试结果。\r\n这个用例可以一直跑下去。直到出错。\r\n\r\n输入：\r\n1，构造一个大表，包含各种数据类型\r\n2，构造各种情况下的数据，包含插入和删除操作。\r\n3，构造比较语句\r\n4，手动触发vacuum\r\n5，手动触发analyze命令\r\n6，vacuum full\r\n\r\n内部任务：\r\n1，配置好vacuum时间，导入ac的同时导入到另外一个表，每次验证都对比查询结果。\r\n2，同步。\r\n\r\n异常：\r\n1，postgres进程被杀死\r\n2，全体被杀死，然后拉起\r\n	2019-07-23 15:03:18.740113	f
1044	511	Issue	6	「八点定江山」2019.9.4  胡冬寅\r\n预约：5\r\n客户接洽：3\r\n需求面谈：0\r\n成交面谈：0\r\n签单：0\r\n新增准客户：0\r\n增员洽谈：0\r\n1.中午和丹丹一起吃饭，聊了工作近况，对我比较认可，对我的工作也比较支持，感觉还不适合直接提保险，她的边界感比较重，想等她主动来口说会比较好。\r\n2.下午约了罗姐，由于临时有课取消\r\n3.下午去南山国安居复核衣柜尺寸，约了红花姐见面，加了林姐微信，78年人，后期加强联系，争取成为客户\r\n4.微信预约5人，琼约周五见面未回复，凯莉约周四晚上送脱口秀门票，番茄妈微信链接下周碰时间，文卓微信链接目前正在备孕打算有空约见面，雩霖微信主动链接约下周见面暂未定时间\r\n	2019-09-08 22:24:17.685053	f
929	442	Issue	5	Freezen触发时机：\r\nSelects aggressive "freezing" of tuples. Specifying FREEZE is equivalent to performing VACUUM with the vacuum_freeze_min_age and vacuum_freeze_table_age parameters set to zero.\r\n Aggressive freezing is always performed when the table is rewritten, so this option is redundant when FULL is specified.\r\n\r\n正常情况下Freezen是必须做的，但是有参数可以控制是否做aggressive。\r\naggressive模式下如果遇到锁冲突会等待。通过table age参数控制是否aggressive。\r\ntuple age用来计算tuple是否需要frozen。\r\n相关参数：\r\n<pre><code class="text">\r\ntest=# select name,setting, short_desc  from pg_settings where name like '%freeze%';\r\n                name                 |  setting  |                                  short_desc\r\n-------------------------------------+-----------+-------------------------------------------------------------------------------\r\n autovacuum_freeze_max_age           | 200000000 | Age at which to autovacuum a table to prevent transaction ID wraparound.\r\n autovacuum_multixact_freeze_max_age | 400000000 | Multixact age at which to autovacuum a table to prevent multixact wraparound.\r\n vacuum_freeze_min_age               | 50000000  | Minimum age at which VACUUM should freeze a table row.\r\n vacuum_freeze_table_age             | 150000000 | Age at which VACUUM should scan whole table to freeze tuples.\r\n vacuum_multixact_freeze_min_age     | 5000000   | Minimum age at which VACUUM should freeze a MultiXactId in a table row.\r\n vacuum_multixact_freeze_table_age   | 150000000 | Multixact age at which VACUUM should scan whole table to freeze tuples.\r\n</code></pre>\r\n\r\n\r\nrelation_needs_vacanalyze函数用来计算table是否必须vacuum。\r\n\r\n<pre><code class="c">\r\n\txidForceLimit = recentXid - freeze_max_age;\r\n\tif (xidForceLimit < FirstNormalTransactionId)\r\n\t\txidForceLimit -= FirstNormalTransactionId;\r\n\tforce_vacuum = (TransactionIdIsNormal(classForm->relfrozenxid) &&\r\n\t\t\t\t\tTransactionIdPrecedes(classForm->relfrozenxid,\r\n\t\t\t\t\t\t\t\t\t\t  xidForceLimit));\r\n\tif (!force_vacuum)\r\n\t{\r\n\t\tmultiForceLimit = recentMulti - multixact_freeze_max_age;\r\n\t\tif (multiForceLimit < FirstMultiXactId)\r\n\t\t\tmultiForceLimit -= FirstMultiXactId;\r\n\t\tforce_vacuum = MultiXactIdPrecedes(classForm->relminmxid,\r\n\t\t\t\t\t\t\t\t\t\t   multiForceLimit);\r\n\t}\r\n</code></pre>\r\n\r\n\r\n	2019-07-10 14:03:06.295196	f
945	469	Issue	5	https://postgreshelp.com/operating-system-kill-signals-on-postgresql/\r\n如果是kill -9就直接退出所有进程\r\n\r\n<pre><code class="c">\r\n/*\r\n   * Additionally, for shared-memory-connected workers, just like a\r\n   * backend, any exit status other than 0 or 1 is considered a crash\r\n   * and causes a system-wide restart.\r\n   */\r\n</code></pre>\r\n	2019-07-17 08:47:18.15546	f
946	469	Issue	5		2019-07-17 09:04:19.286478	f
959	473	Issue	5		2019-07-19 08:26:09.124372	f
948	468	Issue	5	把vm加上去，最后需不需要btree代码扣出来再看。\r\n\r\n先用简单做法，在page上增加标记。不过貌似也不算简单。可以随带标记。---------后面如果觉得效率不行，也可以把vm加上去\r\n并且在vacuum的时候可以先加读锁，然后使用写锁。\r\n\r\n貌似可以共用一套逻辑，将ci tuple的删除与frozen使用同一个操作码。（万一不行启用新的操作码也没关系）。\r\n	2019-07-17 09:17:10.232636	f
966	477	Issue	5	人性格的不同，所以关注点不一样，喜欢的点也不一样。有人只喜欢羽毛球场上的部分。有人喜欢研究策略，研究已有选手。 有人喜欢研究装备，参数。有人擅长体能训练。\r\n这就是流派。 江湖就是流派pk，生态就是涉及所有过程的上下游以及支撑体系。	2019-07-19 15:08:10.907063	f
950	468	Issue	5	看看bt build的实现。全量加载数据可以利用内存缓冲。\r\nVACUUM FULL还是得支持，否则空间无法释放。\r\n\r\nvacuum之后，如果page可以释放，那么再pg_class中显示的page数量是否可减小，不能，这个反应的实际page数量。计算的时候要注意这点。\r\nindex页面膨胀代价，测试下插入100万，vacuum再插入100万，ac占用空间应该不会上升。\r\n\r\nrelpages | reltuples       | relallvisible\r\n总页数     总live记录数      非叶子节点总是可见的	2019-07-18 11:51:56.231501	f
951	442	Issue	5	index page空间回收利用：\r\nindex recycle page需要page mark delete的事务id小于RecentGlobalXmin,然而如果近期没有事务则该值不变。会导致index page无法recycle。	2019-07-18 13:41:37.031542	f
955	468	Issue	5	<pre>\r\ntest=# copy ac100 to stdout;\r\n1       2       50005000\r\n1       3       500000500000\r\ntest=# select * from pg_class where relname='ac100';\r\n relname | relnamespace | reltype | reloftype | relowner | relam | relfilenode | reltablespace | relpages | reltuples | relallvisible | reltoastrelid | relhasindex | relisshared | relpersistence | relkind | relnatts | relchecks | relhasoids | relhasrules | relhastriggers | relhassubclass | relrowsecurity | relforcerowsecurity | relispopulated | relreplident | relispartition | relrewrite | relfrozenxid | relminmxid | relacl | reloptions | relpartbound\r\n---------+--------------+---------+-----------+----------+-------+-------------+---------------+----------+-----------+---------------+---------------+-------------+-------------+----------------+---------+----------+-----------+------------+-------------+----------------+----------------+----------------+---------------------+----------------+--------------+----------------+------------+--------------+------------+--------+------------+--------------\r\n ac100   |         2200 |       0 |         0 |       10 |   403 |       16388 |             0 |    12227 |      6114 |             0 |             0 | f           | f           | p              | a       |        3 |         0 | f          | f           | f              | f              | f              | f                   | t              | n            | f              |          0 |   4244967870 |          0 |        |            |\r\n(1 row)\r\n重启后再次vacuum，出现了计算非常不准确的情况，但不是必现的。\r\n</pre>	2019-07-18 18:09:00.481794	f
957	468	Issue	5	IndxAmRoutine在后面会慢慢无法适合AC，其中一个例子就是insert操作无法携带command ID	2019-07-19 07:50:34.213888	f
968	476	Issue	5	tuplesort_sort_memtuples\r\ntuplesort_performsort\r\n	2019-07-22 07:05:15.722939	f
967	475	Issue	5	在内存中sort之后，进行一次合并操作。\r\n\r\n插入过程：\r\n可以给每个页面预留一些空间，以便于增量更新。	2019-07-22 07:00:52.779596	f
1052	514	Issue	5	1，完成at demo\r\n2，支持ik去重\r\n3，修复测试用例不稳定问题\r\n4，屏蔽ac的dml功能\r\n5，考虑回滚段方案\r\n6，分布式kv系统调研	2019-09-12 15:28:18.815298	f
1053	202	Issue	5	冯友兰 关于心学与理学的思考 http://www.xinhuanet.com/book/2018-08/16/c_129932622.htm	2019-09-15 19:00:22.687031	f
1054	280	Issue	5	心学，科学，体学。 凭经验编程是混淆了科学与经验，经验更多是心学，是直觉。而科学是分析，逻辑。体学是维持身体健康的。\r\nhttp://www.xinhuanet.com/book/2018-08/16/c_129932622.htm\r\n\r\n	2019-09-15 20:27:41.110492	f
1057	513	Issue	5	bug：\r\n1，kdTreeUpdateLevelInfo中sortkey使用不正确，应该使用dy对应类型的sortkey，而不是y对应类型的sortkey。\r\ndy的类型不一定是y的类型，这个假设可能有问题。如果假设成立，则可不必额外准备sortkey。\r\n\r\n2，每个类型的零值获取。\r\n\r\n得到比较函数的方案\r\n方案1：\r\n第一步：根据am和type找到opclass\r\n第二步：根据opclass找到opcfamily\r\n第三步：根据opcfamily，以及type和number，找到对应的比较函数。\r\n\r\n方案2：\r\n1，根据operator，找到operid\r\n2，查找得到Form_pg_operator得到functionid\r\n3，找到对应的func\r\n\r\n\r\n	2019-09-17 15:56:37.556254	f
1055	513	Issue	5	将Y在整个表的range带出来，用于精度计算。\r\n\r\n遇到一个比较纠结的问题，在存储层需要使用函数。但是之前存储层使用的函数都是和am相关的。\r\n要么就专门为at构建实现一下，不使用pg_operator的cache。	2019-09-16 08:36:54.406061	f
1056	515	Issue	5	1，collation是什么？\r\n2，indclass，amop，amproc用来干啥？\r\n3，indoption具体怎么用？\r\n\r\nhttps://www.postgresql.org/docs/9.1/collation.html\r\nhttps://yq.aliyun.com/articles/55713	2019-09-17 08:17:54.836924	f
1179	573	Issue	5	coder却不时常思考代码相关的东西，英语学习者却不使用英语思考，这算哪门子的学生。\r\n就像热爱生活的人却很懒惰，这不是真爱。\r\n\r\n知识不仅仅是用来解决问题的工具，知识融入灵魂才能让自己真正掌握其力量，用来创造改变。	2020-02-18 06:34:33.617802	f
954	442	Issue	5	https://www.pgcon.org/2015/schedule/attachments/367_Vacuum.pdf\r\n\r\nExtremely high rates of update transactions,\r\nFOR SHARE LOCK, or concurrent FK checks can cause freeze problems\r\n\r\n<pre><code class="text">\r\nFor each table\r\n‣ Scan heap, remembering tuples to remove\r\n‣ Scan indexes, removing tuples\r\n‣ Remove tuples from heap\r\n‣ If ANALYZE option specified, do analyze. \r\n</code></pre>\r\n\r\n<pre><code class="text">\r\nIt is very difficult to reduce the size of a bloated index. \r\nDon’t let bloat happen, and if it does, reindex\r\n</code></pre>\r\n\r\n<pre><code class="text">\r\nvac_update_datfrozenxid\r\n\r\n• Called by vacuum()\r\n• Updates datfrozenxid and datminmxid\r\n• If new values for either\r\n‣ Truncate Commit LOG files (pg_clog)\r\n‣ Update internal frozen XID and MXID info\r\n‣ MultiXact files (pg_multixact) are truncated during checkpoint\r\n</code></pre>\r\n\r\n<pre><code class="text">\r\n• Long running transactions hurt vacuum\r\n• High transaction rates, use of FOR SHARE LOCK and concurrent FK checks increase the need to FREEZE\r\n• Indexes referencing heavily updated columns prevent HOT\r\n• Make maintenance_work_mem large for vacuum\r\n• It's very difficult to reduce the size of a bloated index\r\n• autovacuum can only do so much\r\n</code></pre>\r\n\r\n\r\n	2019-07-18 16:23:43.71353	f
956	468	Issue	5		2019-07-18 18:09:33.362292	f
960	473	Issue	5		2019-07-19 08:26:13.798636	f
962	332	Issue	5	tikv，spanner需要解决的分布式事务冲突问题，通过时间戳产生数据的唯一版本，然后在冲突时回滚。	2019-07-19 12:51:56.547274	f
961	475	Issue	5	内存中的管理可参考BTSpool，不过需增加累计的处理。\r\n搞清除2个约束条件：一是内存空间，二是记录条数。\r\n\r\n来一批，写满之后刷到临时文件。\r\n再来一批，写满之后刷到临时文件。\r\n全部完成后，排序并构建btree。\r\n\r\n合并count：\r\n1，每个批次都进行合并\r\n2，最终排序时也做相同key的合并。	2019-07-19 09:26:16.436122	f
963	476	Issue	5	tuple sort的算法完全是可以重用的。区别主要在于从sort结果取出来，生成具体的data page的时候，可以进行合并。	2019-07-19 13:53:41.359452	f
964	475	Issue	5	<pre><code class="text">\r\n\t/*\r\n\t * spool2 is needed only when the index is a unique index. Dead tuples are\r\n\t * put into spool2 instead of spool in order to avoid uniqueness check.\r\n\t */\r\n\tBTSpool    *spool2;\r\n</code></pre>\r\n\r\n这个对于ac是不需要的，将所有活着的相同key的tuple合并，实际上可以断言是不存在这种情况的。\r\n对于数据导入的情况，是允许非unique的，在实际写入时合并。	2019-07-19 13:57:47.408868	f
965	475	Issue	5	看来IndexAmRoutine已经包不住了，需要增加一个接口：支持从排序的数据中构建出新的ac存储体（如ci的btree）\r\n\r\n最好在sort的时候就合并，这样可以节省内存空间。即批次的合并。	2019-07-19 14:31:49.259381	f
971	475	Issue	5	将多个批次的内存记录写入到相同文件 显然逻辑上就有错误。\r\n一个批次的内存记录是有序的，除非把原来写入的记录读出并重新排序。\r\n\r\n还有一种办法是不写入文件，先做一次内存compact。然后继续写入。这与加大点内存的效果类似。\r\n\r\nTODO：先作为一个优化点吧，这效果应该不如将index记录瘦身。	2019-07-24 13:55:50.542738	f
970	474	Issue	5	技术债务：\r\n1，事务这块需要完全搞清楚，能否压缩成只需必要字段。\r\n2，并发机制简化是否可行，后续会不会数据来源于本地事务？\r\n\r\nheader优化，主要麻烦在于Satisfy 相关函数。其中使用了cid，并且直接使用HEapTupleHeader结构。\r\n同时HeapTupleSatisfiesVisibility使用函数指针，需根据情况来决定使用了哪个satisfy函数。\r\n\r\n在扫描ac表的时候替换下函数？	2019-07-24 13:51:47.442073	f
958	473	Issue	5	<pre><code class="text">\r\nThe hole in this logic is that there can be multiple active scans with\r\ndifferent values of CurrentCommandId (eg, within a function\r\nCurrentCommandId may be different than it is outside).  If you overwrite\r\ncmin with cmax then you are destroying the information needed by a scan\r\nwith smaller CurrentCommandId than yours.\r\n</code></pre>\r\n\r\n<pre><code class="text">\r\n * We store five "virtual" fields Xmin, Cmin, Xmax, Cmax, and Xvac in three\r\n * physical fields.  Xmin and Xmax are always really stored, but Cmin, Cmax\r\n * and Xvac share a field.  This works because we know that Cmin and Cmax\r\n * are only interesting for the lifetime of the inserting and deleting\r\n * transaction respectively.  If a tuple is inserted and deleted in the same\r\n * transaction, we store a "combo" command id that can be mapped to the real\r\n * cmin and cmax, but only by use of local state within the originating\r\n * backend.  See combocid.c for more details.  Meanwhile, Xvac is only set by\r\n * old-style VACUUM FULL, which does not have any command sub-structure and so\r\n * does not need either Cmin or Cmax.  (This requires that old-style VACUUM\r\n * FULL never try to move a tuple whose Cmin or Cmax is still interesting,\r\n * ie, an insert-in-progress or delete-in-progress tuple.)\r\n</code></pre>\r\n\r\n在一个事务内，scan可能拥有老的CommandID，比如游标操作。这样就存在这种情况：scan到同一个事务在scan开始时对应的CID之后的数据。\r\n\r\n一旦事务结束，Command ID就可以复用了。因而vacuum可以复用该字段。\r\n\r\nCombo CommandID是用来解决在一个事务内同时insert和delete了一个tuple，这时同时需要cmin和cmax的情况。\r\n\r\nAC不存在这个问题，AC的写入删除总是与查询分离的。\r\n\r\n	2019-07-19 08:14:27.962886	f
974	481	Issue	5		2019-07-25 14:45:02.356287	f
985	472	Issue	5	PG日志缺陷：\r\n代码中能看到的pg日志非常少，即便当前日志级别是debug2，debug3级别的日志仍然会处理。\r\nmultitrans为了调试，还专门增加了debug_elog2宏	2019-07-31 15:33:52.443225	f
975	475	Issue	5	使用在原来relation上重建有个问题，就是oid发生了变化，这点可能打破了pg原来的约束。需要看看oid与relfilenode的关系。\r\n\r\n是否需要invalidate relcache呢？ \r\n老的文件没有删除掉？\r\n      删除掉了，在整个重启之后老文件就不见了。\r\n\r\n\r\n\r\n	2019-07-29 06:45:06.502318	f
976	482	Issue	5	多线程模型在这点上相对简单一些，进程收到退出信号后，整体退出。不像pg还考虑共享资源。	2019-07-29 07:29:17.176075	f
977	475	Issue	5	调试过程中出现一个bug：实际数据已经写入了，但是使用copy命令无法读取任何数据。\r\n重启server之后又能看到数据。	2019-07-29 09:29:04.172021	f
978	482	Issue	5	README: Resource Owners 	2019-07-29 15:18:17.359086	f
979	423	Issue	5	注意有些操作是不能rollback的，也就是说只能往前走。比如truncate，请参考RelationTruncate。	2019-07-29 15:28:14.363479	f
980	484	Issue	5	https://madusudanan.com/blog/all-you-need-to-know-about-sorting-in-postgres/	2019-07-29 18:19:57.362655	f
982	485	Issue	5	没有WAL的table特征：\r\n1，vm信息不准确\r\n2，page没有正确的lsn\r\n3，故障后丢弃数据，且面临index与heap不一致的问题。	2019-07-31 12:50:32.105156	f
983	485	Issue	5	存在的意义：\r\nUnlogged tables are appealing for data that needs to be shared across backends, but which we're willing to lose in the case of a server restart. For example, consider a web application maintaining a table of active user sessions. If the server restarts, we may be willing to lose this data. Everyone will need to log in again, but considering that database crashes are rare, that may not be such a big deal. Unlogged tables also won't be replicated to standby servers, since replication relies on WAL. But, on the plus side, skipping WAL-logging should hopefully yield a significant performance benefit. 	2019-07-31 12:58:47.076897	f
986	479	Issue	5	增加了debug日志，果然好用。\r\n可以看到vacuum online与mark dead，删除老版本都是可以工作的。\r\n但是在线vacuum在大量写入时效果有限，因为当前页面很多record无法清理。但是可以想象在数据分布随机时，应该有不错的效果。 --- 可以使用x万个事务，每次写入相同记录，理论上数据应该不会超过一个页面。\r\nvacuum可以有效的抑制膨胀，但是需要系统事务往前走。\r\n追加写入的优化虽然有，但是效果不好，因为ac总是在一个版本的最原始的位置写入。\r\n	2019-07-31 18:07:29.228128	f
988	289	Issue	5	https://stackoverflow.com/questions/10241957/difference-between-fuzz-testing-and-monkey-test\r\n\r\nUI/Application Exerciser Monkey is a fuzz testing tool. \r\nThe name is probably related to the fact that it behaves as if a monkey uses your application. \r\n\r\nThe bottom line is that Monkey test and Fuzz testing are different names for essentially the same thing. \r\nHowever, there might be one subtle difference: \r\nwhile Fuzz testing is more about using *random data*, Monkey testing is about *random actions*.\r\n\r\n可以结合起来，Monkey testing实际也会用到各种hook，从而构造异常的action。当然也有很多异常是不需要特别构造的。	2019-08-01 14:49:38.719544	f
989	426	Issue	5	知识：\r\n\r\n定义，分类，结构, \r\n关系，过程，并行，\r\n\r\n动作：\r\n分享，同步，一致\r\n\r\n变化，时间，空间	2019-08-01 15:32:22.546175	f
991	479	Issue	5	rebuild之后relfilenode与表oid不一致会不会有问题。	2019-08-02 12:29:53.589671	f
994	446	Issue	5	功能与单元测试：\r\nhttps://wiki.postgresql.org/wiki/Test_Frameworks\r\n\r\n使用regress实现功能测试基本没问题，甚至可以使用extension细化测试。\r\n\r\n进程故障测试可以模拟，当前可使用count为负数构造transaction失败情况。\r\n\r\npostmaster重启故障\r\n\r\n注入故障测试，在指定的点出现PANIC或ERROR。\r\nhttps://www.postgresql.org/message-id/CAMkU=1xEUuBphDwDmB1WjN4+td4kpnEniFaTBxnk1xzHCw8_OQ@mail.gmail.com	2019-08-05 08:53:00.773328	f
993	479	Issue	5	分三步走：\r\n1，继续补充基本功能用例\r\n  recovery and frozen测试，使用复制来测试recovery。\r\n\r\n2，完善page inspect工具\r\n3，在pg上实现一个注入框架	2019-08-05 08:45:44.293509	f
995	469	Issue	5	errfinish：\r\npg当日志出现PANIC以及以上级别错误时，会直接abort子进程，父进程也会因此退出。	2019-08-05 17:53:49.328004	f
998	488	Issue	5	set fault to "funcname mode step;"\r\nreset fault 	2019-08-08 08:23:03.828485	f
999	489	Issue	5	常量赋予给结构体成员，会报如下错误：\r\nassignment discards ‘const’ qualifier from pointer target type\r\n\r\n有时我们不得不将只读变量赋予给其他变量，虽然不会修改。但是该变量不方便携带const属性。这时临时处理只能强制转换了，将const类型转换为普通类型。\r\n\r\nconst具备传染性~~~~~	2019-08-08 14:18:22.615804	f
984	465	Issue	5	再次解读：\r\npg相关commit：\r\nReduce pinning and buffer content locking for btree scans.\r\n\r\n\r\nSince VACUUM deletes index entries before reclaiming heap tuple line pointers\r\n\r\n1，删除index entry\r\n2，reclaiming heap tuple line pointer\r\n\r\n问题：\r\nheap tuple的line pointer写入新的tuple。但是scan缓存的是老的tuple。\r\n但这问题与上述顺序无关系，如果先reclaiming heap line pointer，这问题就更容易出现了。\r\n\r\nthe super-exclusive lock guarantees that VACUUM can't reclaim for re-use a\r\nline pointer that an indexscanning process might be about to visit.\r\n怎么做到？就是排除当前page被index scan，这就要求index scan不释放pin从而完整这个检查。\r\n\r\nThis guarantee works only for simple indexscans that visit the heap in sync\r\nwith the index scan, not for bitmap scans.\r\n\r\nbitmap scans怎么办？\r\n\r\nWe only need the guarantee\r\nwhen using non-MVCC snapshot rules; when using an MVCC snapshot, it\r\ndoesn't matter if the heap tuple is replaced with an unrelated tuple at\r\nthe same TID, because the new tuple won't be visible to our scan anyway.\r\nTherefore, a scan using an MVCC snapshot which has no other confounding\r\nfactors will not hold the pin after the page contents are read. \r\nMVCC下tid对应的tuple变长其他new tuple也没关系，反正也是看不见的。\r\n但是有例外情况：\r\nThe current reasons for exceptions, where a pin is still needed, are if the\r\nindex is not WAL-logged or if the scan is an index-only scan.\r\n1，index-only scan例外是因为它利用vm判断可见性，可能不会读取heap tuple可见信息\r\n2，not WAL-logged特殊是因为其没有lsn信息，如果释放pin，则_bt_killitems无法根据lsn判断是否可以清除item。\r\n\r\nhttps://www.postgresql.org/message-id/848652045.4044965.1426259305233.JavaMail.yahoo%40mail.yahoo.com\r\n\r\n>>> At some point we could consider building on this patch to\r\n>>> recheck index conditions for heap access when a non-MVCC\r\n>>> snapshot is used, check the visibility map for referenced heap\r\n>>> pages when the TIDs are read for an index-only scan, and/or\r\n>>> *skip LP_DEAD hinting for non-WAL-logged indexes*.  But all those\r\n>>> are speculative future work; this is a conservative\r\n>>> implementation that just didn't modify pinning where there were\r\n>>> any confounding factors.\r\n\r\n_bt_killitems(IndexScanDesc scan)：\r\n>>> If the pin was released after reading the page, then we re-read it.  If it\r\n>>> has been modified since we read it (as determined by the LSN), we dare not\r\n>>> flag any entries because it is possible that the old entry was vacuumed\r\n>>> away and the TID was re-used by a completely different heap tuple.	2019-07-31 14:02:49.71994	f
987	479	Issue	5	Postgresql用例可以使用相对路径的，在regress下的input output目录就是相关用例。	2019-08-01 08:59:57.703077	f
990	438	Issue	5	关于amoptionalkey \r\n\r\nhttps://www.postgresql.org/docs/9.4/index-catalog.html\r\n对比btree其支持full scan，更别说没有first key了。但是没有first key，很可能无法快速找到第一个page，只能遍历时用来过滤。\r\n\r\n_bt_first中有具体逻辑，有针对null情况的优化。\r\n	2019-08-02 08:56:44.773091	f
992	458	Issue	5		2019-08-02 14:43:18.765047	f
996	488	Issue	5	typedef struct FaultDescData\r\n{\r\n    db_char name[MAX_FAULTNAME_LEN];\r\n    FaultMode mode;  // cycle, once, random\r\n    db_uint32 step;  // counter for trigger the fault\r\n    db_uint64 count; // total call count\r\n} FaultDescData;\r\n\r\n对于random，step是概率，取值范围是0~100	2019-08-07 15:35:19.121267	f
997	488	Issue	5	无比怀念ceph的admin socket，提供了一个很好的手段操作内部数据。	2019-08-08 07:37:15.306628	f
1002	423	Issue	5	实际上pg的多版本，不仅承载的并发，还是其正确性的基础。没有多版本，就没法支持redo/undo。\r\n要么就实现纯粹的redo，这要求不同事务不修改相同block，这点上存储可以满足，因而ceph实现的是纯粹的redo。\r\n\r\npg本质上是不是将undo留在了原地？\r\n时间在分布式系统中意味着什么？\r\nwal有哪些地方必须做特殊处理？\r\n--无法回滚的操作，replay guard\r\n--必须立即成功的操作，否则即便事务提交，也永远成功不了。	2019-08-09 17:26:20.857553	f
1000	423	Issue	5	数据库设计与实现中单纯使用redo或undo存在什么问题？\r\n1，undo日志，事务对应的commit记录必须在所有脏数据写入之后写入。\r\n2，redo日志，commit记录必须在任何脏数据写入之前写入。\r\n3，redo的checkpoint要求所有在checkpoint日志点之前的提交事务，其修改都已经写入磁盘。\r\n单纯使用redo日志的系统存在一个问题。如果一个page即被一个提交的事务写入，又被一个未提交的事务写入，这时checkpoint该怎么办？\r\n\r\nundo信息并非单纯的冗余，因而其也不仅单纯的提高性能，其还有实现逻辑优化的价值。	2019-08-09 17:09:32.387738	f
1003	280	Issue	5	哲学：\r\n凡是皆有利弊，这是辨证。但选择最好合乎当下。\r\n知行合一，相辅相成\r\n身体：\r\n心灵：\r\n社交：\r\n事业：	2019-08-11 11:08:46.746211	f
1007	486	Issue	5	gcc需要使用-D DEBUG\r\nhttps://stackoverflow.com/questions/9034700/how-to-use-ifdef-debug-on-linux	2019-08-12 18:58:48.102501	f
1008	322	Issue	5	反手关键点：\r\n1，转身\r\n2，不要让球超过肩部\r\n\r\n其实正手也是如此，快压底线的球之所以有威胁，就是因为步伐难到。	2019-08-13 05:15:20.004358	f
1005	479	Issue	5	4，实现对特定场景的注入测试。\r\n实际上场景并不多\r\n4.1 写数据失败之后的replay\r\n4.2 xid的frozen\r\n4.3 vacuum与写入的并发\r\n4.4 读与写的并发，写与写的并发\r\n4.5 可见性判断\r\n4.6 all visible与all frozen flag的正确清楚。\r\n\r\ndirty hint与visible flag有关系么？\r\n\r\n用例可以存在多种执行结果，只要符合其中一种就是ok的。\r\n\r\n对测试框架的需求：\r\n1，支持重连\r\n2，支持多种结果\r\n\r\n模拟故障当然不能长期运行，对于pg而言，可以模拟正常错误输入。	2019-08-12 06:47:44.818695	f
981	479	Issue	5	vacuum，\r\nanalyze，\r\nrebuild，\r\nfullsync，\r\nincsync，\r\ninline vacuum， 构造用例验证膨胀情况，是否能否正常在线vacuum。在线vacumm，需在scan发现tuple dead之后才有效，而vacuum则会判断tuple是否dead并回收。\r\ndata type，different schema，\r\nfetch with condition，\r\nphycical replica，\r\nlogic replica， \r\nhot standby，\r\nrecovery，\r\nconcurrency，\r\nSSI\r\nfailed condition，比如count为负数导致出错的情况，能否重复执行。\r\nincremental写入时，应该有优化。\r\n\r\n	2019-07-30 15:09:32.929504	f
1046	511	Issue	6	「八点定江山」2019.9.6胡冬寅\r\n预约：5\r\n客户接洽：2\r\n需求面谈：0\r\n成交面谈：0\r\n签单：0\r\n新增准客户:1\r\n增员洽谈：0\r\n1.下午见美苑，聊了生活近况，带她到公司看了我们的文化墙并进行了讲解，目前家里的经比较紧张，约定下周有空去跟她讲金三角及进行保单体检。\r\n2.晚上见雩霖一起吃饭，她聊了工作近况，由于之前投资做餐饮亏了不少钱，最近加班比较多，我讲了友邦三宝，告知如果身边有保险有需求的人推荐给我。\r\n3.小邹微信告知小孩出生，由于目前在老家，合适的时候可以聊一下小孩保险\r\n4.微信胡琪因加班多，取消晚上见面，改约下周六见面\r\n5.子歆姐，有机蔬菜公司老客户就送菜问题咨询我，保持链接\r\n6.房子销售人员微信联系我告知可以拿礼品，计划下周过去，保持链接\r\n7.随缘滴答顺风车司机郭大哥，加微信\r\n8.厨房门销售人员微信沟通安装细节，保持链接\r\n	2019-09-08 22:25:41.476042	f
1047	460	Issue	5	自强，平等，博爱 ------- 顺序不可乱，平等的意思是每个人都能做自己。没有自强，就难以有平等。有了平等的追求就有自强。	2019-09-09 06:37:20.800568	f
1059	513	Issue	5	IDEA ： kdtree变体，最后超出kdtree size的记录，统一作为heap，当作kdtree的扩展。可作为max level。\r\n	2019-09-18 12:59:33.97663	f
1058	513	Issue	5	支持at上的数据过滤，支持copy导出不同层次的数据。	2019-09-18 10:41:56.827016	f
1006	491	Issue	5	1，为什么需要redo\r\n数据库系统其数据通常会按照其一定结构组织，且一个事务通常会涉及多个操作。为了实现原子性。我们需要记录数据的新老版本，从而在\r\n出现故障时，可以统一恢复成老版本或者新版本。\r\n如果一个系统其不涉及多个操作，单个操作且要么成功要么失败，那么就不需要redo。\r\n或者某些操作成功或者失败都没关系，也不需要记录redo，比如postgreslq中标识heap tuple可见性的逻辑就不需要记录redo(在某些情况下需要是\r\n因为page内容改变之后checksum匹配不上)\r\n\r\n2，为什么需要undo\r\n对于已经有了redo的系统，实际上可以不用undo的。比如ceph，leveldb等都没有undo。\r\n这类系统有个特点：事务非常短，实际上他们不支持外部事务，因而可以控制事务的长短。这种短事务可以确保先写完redo，再去改数据。\r\n即不存在将未提交事务的数据持久化的情况。\r\n而像postgresql和oracle等支持外部事务的数据库，其事务可能非常长，如果推迟到commit时执行，数据库的性能可能非常低。因而其存在\r\n将未提交事务的数据持久化的情况(因为没法将未提交事务和提交事务的数据分离开，他们可能操作同样的数据)。这时undo不可避免，pg虽然概念上\r\n没有undo，但其多版本起到类似作用。\r\n\r\n同样对于一个只使用undo，而不使用redo的系统。如果系统能确保只要事务尚未将所有写入的脏buffer持久化，就不将commit记录写入到日志队列。\r\n确保凡是commit日志出现在日志队列中，则其buffer都持久化。那么就不会出现将未提交事务的commit写入日志的情况。这时该系统不需要redo机制。\r\n其实这点不难保证，仅使用undo来实现事务其性能代价过大。因为数据组织通常有其逻辑结构，每次都刷buffer，IO会放大。\r\n\r\n3，为什么需要checkpoint\r\ncheckpoint是为了加速恢复过程的，对于undo而言checkpoint是将已提交(已将所有修改持久化)事务的commit日志持久化，对于redo而言则是将已提交事务的buffer持久化。\r\ncheckpoint分为静止checkpoint与非静止checkpoint，静止checkpoint要求系统停止接受事务，等当前事务全部完成后，写入checkpoint点到日志中。\r\n	2019-08-12 13:00:46.121312	f
1009	479	Issue	5	postgresql vacuum不会启用使用新事务id，在vacuum事务提交之后挂掉，vacuum的效果可能无法体现出现。这有点违背事务特性。或者说单纯的vacuum命令是没有事务的，这样更好理解。	2019-08-14 09:24:53.533166	f
1010	459	Issue	5		2019-08-14 13:29:22.026676	f
1011	491	Issue	5		2019-08-14 13:34:13.605989	f
1016	474	Issue	5	在ciDeleteLatest递归寻找上一个可见版本时，可能遇到最近期的版本被回滚了，且是DEAD的情况，即可见的版本处在这个链条的中间。	2019-08-19 15:39:42.793854	f
1019	494	Issue	5		2019-08-23 06:51:02.238751	f
1041	509	Issue	5	方案2：\r\n仍然基于KDtree对空间划分的思想。这里已经将distance放大。\r\n比如将y1上的元素按照(min-max)等分的方式映射到0~1之间。（这方案有点问题，如果y1属性处于递增趋势，那么刚开始的划分方法就不合适）\r\n\r\n对于增量的处理，采用随机选取某一层的方式。但是不更新distance值。	2019-09-04 13:45:18.260721	f
1042	511	Issue	6	「八点定江山」2019.9.2胡冬寅\r\n预约:2\r\n客户接洽：2\r\n需求面谈：0\r\n成交面谈：0\r\n签单：0\r\n新增准客户：3\r\n增员洽谈：0\r\n1.下午到建材市场，随缘3人\r\n2.预约罗姐，美苑，时间待定，明天跟进\r\n3.新邻居2人见面喝茶聊天，加深了解\r\n	2019-09-08 22:23:15.944014	f
1045	511	Issue	6	「八点定江山」2019.9.5胡冬寅\r\n预约：3\r\n客户接洽：3\r\n需求面谈：1\r\n成交面谈：0\r\n签单：0\r\n新增准客户:0\r\n增员洽谈：0\r\n1.中午第二次见冬琴姐，和她老公及同事一起吃午饭，讲了友邦三宝，初步了解了她们家的基本情况，与老公共同经营物流公司，有两个孩子，保持链接，下次约见面进行需求面谈。\r\n2.晚上见罗姐，她目前保险理念已经比较强，对医疗险、意外和重疾的认识都比较到位，目前还在考虑中。\r\n3.给kelly送脱口秀门票，最近因为同事离职，加班比较多，没有聊太多，周六见面再聊。\r\n4.微信梦圆，目前已回老家，主动提起问过是否有小孩保险，告知我已经买了，目前已经入职友邦，对保险比较认可，主动提起如果有需要可以约时间跟她讲讲保险，目前还没有确定具体时间，过段时间再跟进。\r\n5.微信文卓约见面，由于送朋友回家，未约成，下周继续约见面。\r\n6.微信琼约见面，时间错开，未约成。\r\n	2019-09-08 22:24:52.525822	f
1048	460	Issue	5	过好此刻，没有执念。既往不咎，未来不念，去恶为善。\r\n所以每时每刻都能享受场球上打球的感觉。	2019-09-09 15:03:41.835495	f
1015	492	Issue	5	隐藏自己，欺骗也是非常消耗带宽的。\r\n行为与观念的矛盾消耗带宽\r\n身体不适会影响带宽\r\n心结防御心态在消耗带宽。\r\n角色扮演，执念影响带宽。\r\n挑剔也影响带宽。	2019-08-19 09:18:36.661393	f
1049	513	Issue	5	原先的btree生成那块的逻辑仍然需要，只是额外增加了kdtree的保存。且item pointer指向的是kdtree节点。	2019-09-11 06:46:35.108609	f
1024	500	Issue	5	使用x|y|count, count模拟key来验证去重实现。\r\n把其他需要的元数据属性也加上去，构造一个期望的tupledesc，sort key，scan key等中间结构。\r\n\r\n今天先把count的验证完，要求写入的数据最终输出时按照count排序.\r\n	2019-08-26 18:25:03.243275	f
1025	498	Issue	5	文化是一个很重要的领域，关注人的身心健康，成长，文化也是其中重要组成部分	2019-08-27 17:11:30.974525	f
1026	212	Issue	5	就像羽毛球打球会想着发力，步伐一样。编程的时候应该想着数据结构与算法逻辑。 体系结构则是策略篇了。\r\n\r\n排序，求和，比较，唯一，平均值，最大值，方差，过滤，选取等等都是计算。人们需要数据符合一定的特征或在数据基础上进行运算。	2019-08-27 17:14:30.025909	f
1027	502	Issue	5		2019-08-27 18:43:36.320636	f
1030	504	Issue	5	1,采样应该从目标节点查找周边节点，这样才能实现用少的数据高精度的回复查询/	2019-08-28 09:04:09.452779	f
1032	500	Issue	5	该工作中断，等元数据ready，目前工作在分支merge_fix_test1	2019-08-29 08:13:51.564048	f
1034	504	Issue	5	但是AQP的问题采用临近算法不是更好吗？基于临近算法的精度。\r\nAQP是回答问题，你查询符合X=1的Y，返回一定精度的抽样值即可，同时利用数据规模来评估精度。	2019-08-30 09:25:07.006164	f
1036	504	Issue	5	不管怎样，给定一些tuple，然后构建kd tree这一步少不了。这是可以提前开搞的。	2019-09-02 09:03:30.228524	f
1039	504	Issue	5	在统一不同维度的作用域之后，使用加权值来算距离。这跟欧式距离虽然仍然有区别，但也是一种折中吧。\r\n加权值的意思是在类似分布程度下。\r\n\r\n基于分割来计算距离，距离的计算自顶向下，树的构建也是自顶向下。然后根据分割将数据放入不同的kdtree叶子节点。允许树不平衡。\r\n等失衡达到一定程度之后进行重建。	2019-09-04 08:22:54.319607	f
1040	508	Issue	5	1，批量数据进来之后，先排序进行去重。\r\n2，将排序的数据，根据x的值分组。\r\n3，将分组数据丢入kdtree，如果记录数量非常少，则只构建0层\r\n4，否则启动kdtree构建\r\n5，构建完成后将结果写入ATD和AT表。（目前先考虑大表方案）	2019-09-04 13:30:52.892841	f
1060	504	Issue	5	AQP就像在不同精度尺dy下看地图。精度越高，看的数据越细。	2019-09-18 15:15:57.566145	f
1062	515	Issue	5	pg_amop通过opfamily以及数据类型查找使用的情况比较少，反而通过amopopr查amopfamily的场景很多。详见syscache AMOPOPID的使用\r\n	2019-09-18 16:56:32.320907	f
1037	508	Issue	5	x1：distance的计算\r\n1，可根据抽样后排序的值保留min和max，然后切分这中间的值，给其附上距离。\r\n2，在kdtree构建完成后，自底向上每个维度自底向上计算distance。\r\n\r\n这里还不能直接给出，还是先吐出去吧。	2019-09-02 16:31:40.133413	f
1012	491	Issue	5	11，TrueTime API相当于实现了全局的事务ID，并且通过StartTime和CommitTime可以实现事务的隔离。想想pg的事务id与snapshot的关系就清楚了。\r\n    在实际生产中，使用一个高可靠的事务ID分配器就够用了，像TIKV的方案。\r\n\r\n16，二阶段是解决分布式事务的原子性问题的，paxos是解决多副本的一致性问题的。分布式事务涉及的多个操作要么成功要么不成功，这用paxos多数派显然解决不了。\r\n    只有一种分布式事务算法，就是二阶段提交及其变种。\r\n    只有一种分布式一致性算法，就是Paxos。\r\n\r\n17，wal通过额外记录新版本数据，具备了实现事务D特性的能力。同时事务状态也通过wal记录，因而辅助支持了事务管理器。MVCC是实现事务的I特性，同时其具备老版本数据，因而也提供实现回滚的能力，即实现了部分A特性。\r\n \r\n14，二阶段提交其核心思想是在第一阶段让本地事务具备了commit或abort的能力，第二阶段提交只是在执行大家一致同意的结果。在RM故障时，只要确定结果是达成的，就不能更改。故障节点重启后从TM（transaction manager获取事务状态，重新执行第二阶段提交）。 如果TM故障或TM与收到commit消息的RM故障，这时其余RM节点不知道事务状态而一直等待。 引入prepare commit，三阶段提交可以解决这个问题，如果当前所有RM都没有prepare commit，则事务必然没提交，可以放心Abort。如果确实有prepare commit，则commit。当然这没彻底解决问题。\r\nhttps://stackoverflow.com/questions/7389382/two-phase-commit\r\nIf a replica that has committed the transaction has crashed, we know that every other replica has received a ‘prepare to commit’ message (otherwise the co-ordinator wouldn’t have moved to the commit phase), and therefore the recovery node will be able to determine that the transaction was able to be committed, and safely shepherd the protocol to its conclusion. If any replica reports to the recovery node that it has not received ‘prepare to commit’, the recovery node will know that the transaction has not been committed at any replica, and will therefore be able either to pessimistically abort or re-run the protocol from the beginning.\r\n\r\nhttps://cloud.tencent.com/developer/article/1357869，目前还没看到文章讲得非常清楚，但总之一点不论是二阶段还是三阶段，在各种故障场景下总会出现行为不一致的时候。不过实际生产系统要求没那么高。\r\n比如TM搞一个分布式的，如果TM不可用，则系统不可用，这是可以接受的。在这个前提下，RM的事务要么提交，要么不提交，或者RM不可用，则整个系统也不可用。 RM也可以使用分布式替代节点，或备份节点等。一个shard的数据系统，如果有shard不可用，则整体不可用。 所以二阶段提交中的问题本质上无解的，需通过其他手段确保节点之间的连通，以及单个节点的可靠。	2019-08-14 13:47:36.156653	f
1013	489	Issue	5	windows下x64是64位程序，x86是32位程序。 windows下不论32位还是64位，其数据类型长度是一样的。但是指针的长度在32或64下不一样。	2019-08-17 12:43:11.450092	f
1014	311	Issue	5	尝试回答一下CockroachDB在multi raft方面做了什么事情multiraft的问题 楼上 @人类的好朋友 已经说了，就是大量流量耗费在心跳上，故做了个心跳合并的优化。这里有个设计文档，cockroachdb/cockroach，原理是引入了一种Node级别的lease，只要Node级别的lease有效，那么这个Node上的所有的raft group的leader的lease都是有效的。这样就不必频繁更新range级别的lease，只需要更新Node级别的lease即可还有一个优化就是关闭某一些不活跃的raft group，基于的假设就是数据库这么大，其实，很多数据很长时间根本都碰不到，所以维护着lease没啥用。设计文档： cockroachdb/cockroach\r\n\r\n作者：吴镝\r\n链接：https://www.zhihu.com/question/54095779/answer/192921271\r\n来源：知乎\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。	2019-08-17 14:06:10.000727	f
1017	481	Issue	5	更新则与快照无关系，更新要求被更新列处于提交状态。如果有人未提交，则使用锁等待。\r\nMysql：\r\n事务隔离级别\t               脏读\t不可重复读\t幻读\r\n读未提交（read-uncommitted）\t是\t是\t是\r\n不可重复读（read-committed）\t否\t是\t是\r\n可重复读（repeatable-read）\t否\t否\t是\r\n串行化（serializable）\t        否\t否\t否	2019-08-20 13:23:11.981414	f
1018	494	Issue	5		2019-08-23 06:50:47.625978	f
1020	494	Issue	5		2019-08-23 06:51:07.513361	f
1021	495	Issue	5		2019-08-23 06:53:41.418433	f
1022	369	Issue	5	1, 问题是什么\r\n2，涉及的概念\r\n3，当前的现状\r\n4，出现的机遇\r\n5，趋势\r\n6，解决方案\r\n6.1 思路\r\n6.2 实现原理，框架，层次与分解\r\n6.3 实现的关键点(确保正确或设计达成的核心)\r\n6.4 实际输入场景以及未来可期的变化\r\n6.5 接口与交互推演\r\n6.6 Dfx\r\n7，验证方法\r\n8，维护	2019-08-23 06:59:26.159284	f
1023	497	Issue	5	相信自己会变得更好，相信每个人都会更好，相信社会会变得更好。\r\n选择去做让这一切都更好的生活方式。\r\n\r\n消除心中的隐忧，激发每个人的美好。人生编制师。\r\n\r\n在开始时开始，在结束时结束。允许好的事情结束，也允许不好的事情开始。顺天时地势，达到没有矛盾的状态。	2019-08-25 19:39:44.753059	f
1028	500	Issue	5	需求：\r\n1，去重\r\n2，支持unqiue IOT和normal IOT\r\n  可能有null->x的需求，这种索引也是有意义的\r\n3，支持回滚段\r\n4，支持ac的dml操作，甚至支持iot类型？	2019-08-28 06:48:16.512763	f
1029	502	Issue	5	skiplist不太适合持久化存储，更新代价非常大。 跟二叉树不适合持久化一样	2019-08-28 08:34:43.329006	f
1031	504	Issue	5	1，直接使用level0到levelm选取的数据与目标key的关联度不高，因而给出的是最低概率，这样岂不是很低。为什么不选取目标key最近的节点呢？\r\n2，e(m/p) 表示的是最大距离。\r\n\r\n算法：\r\n1，根据记录数量，算出需要使用的层次i，以及其dy值\r\n2，取0~i层数据\r\n3，根据查询条件k，以及dy过滤数据[-dy + k, dy + k]，返回符合条件的记录\r\n4，根据dy计算精度。\r\n\r\n这里面有2个概念：\r\n1，匹配度\r\n2，距离dy\r\n实际上精度在语义上应该是查询结果与精确结果在bound范围内的匹配度。\r\n距离在语义上不知道该怎么理解，（i+1）层的最大偏差作为i层的dy，有啥语义? 偏差度。\r\n\r\nKD树的采样符合空间分布，因而相邻节点间的距离得以保障。使用N个数据来回答查询，在数据量足够大时，其精度的偏差下限是 1/（1 + dy），这里假设dy的范围是0~1.	2019-08-28 13:17:20.431469	f
1043	511	Issue	6	八点定江山」2019.9.3胡冬寅\r\n预约:7\r\n客户接洽：1\r\n需求面谈：0\r\n成交面谈：0\r\n签单：0\r\n新增准客户：0\r\n增员洽谈：0\r\n1.下午约阿珂第二次见面，聊聊彼此的经历\r\n2.预约罗姐，胡琪确定本周见面时间\r\n3.晚上参加跑步活动，谢先生爽约\r\n4.邀约琼参加公司活动，因为晚上时间太晚无法参加，看看周末活动是否能参加\r\n5.周六脱口秀邀约4人参加\r\n	2019-09-08 22:23:46.76228	f
1035	504	Issue	5	问题：\r\n1，删除操作的效率\r\n2，构建kd tree时的如何计算count？\r\n   先合并\r\n3，没有找到合适的external的kd tree构建方法。\r\n4，如何全量重建kd\r\n5，增量kd的维护\r\n\r\n仍然像AC一样维护数据，支持从AC表采样一定规模的数据，组建kd树，避免原方案中创建大量小表的问题。\r\n并非对每个x的y都构建KD树。支持对部分x的KD tree重建。\r\n\r\nAQP作为AC的扩展方案。AQP的亮点在于通过控制数据规模来控制精度。\r\nAQP使用的数据规模是整体数据规模。还是局部数据规模？	2019-09-02 09:01:30.005738	f
1033	504	Issue	5	kd树这里的运用就是一个距离采样算法。\r\nAQP中的精度是采样精度，采样精度是指采集数据与全量数据的偏差。如果把数据理解成一个曲线，则精度度就是得到的数据曲线与真实数据的匹配程度。\r\n精度不仅反应了匹配程度，还有数据的聚集程度，在采样完全不变的情况下，如果数据本身非常分散，则dy值变大。精度也会变差。\r\n*显然数据聚集性好，采样越多，精度越高。*\r\n\r\n如果用画圈来比喻的话，AQP算法每次都是取圈附近的节点。将中位点视为骨架的话，采样就是用骨架模拟整个人。	2019-08-30 07:37:23.614939	f
1038	504	Issue	5	KDtree提供了带“距离的采样”，AQP需要的是一颗带“距离”的去重平衡KDtree，但是动态维护代价非常大。\r\n\r\n\r\n\r\n方案1：\r\n\r\n1，第一次全量生成。\r\n\r\n2，增量数据随机选择某一层插入，并更新相关的距离值。\r\n\r\n3，在一段时间根据一定标准对AT进行重建。\r\n\r\n\r\n\r\n方案1代价大的地方：\r\n\r\n1，平衡KDtree的external构建复杂\r\n\r\n2，需在AT表上维护2个索引，一个是层次用于查询，另一个是Y用于支持增量的插入删除。\r\n\r\n3，插入时动态调整每个层次的“距离”\r\n\r\n4，重建对于更新与查询的阻塞\r\n\r\n\r\n\r\n方案2：\r\n\r\n将AT视为AC的扩展，数据维护利用现有AC的机制。\r\n\r\n1，AT的数据通过对AC采样而来，对于X→Y, N数量较少的情况，不必生成AT\r\n\r\n2，基于统计信息，可以重新采样重建AT，重建过程对于AT的更新和查询不影响。	2019-09-03 12:36:26.258279	f
1064	510	Issue	5	行存储与列存储是在用不同的角度看数据。kv是无schema的。	2019-09-19 07:54:24.922381	f
1180	573	Issue	5	发力，动作是羽毛球的灵魂。\r\n关系，逻辑是程序的灵魂\r\n信息，表达的语义是沟通的灵魂。	2020-02-18 06:43:50.315578	f
1061	515	Issue	5	<pre>\r\n索引相关系统表\r\n\r\n说明：\r\n\r\n1，索引的具体类型信息存储在pg_class中\r\n\r\n2，索引基于特定的数据类型创建，数据类型关联操作类型，操作类型关联于运算符与函数。\r\n\r\n3，pg_opfamily是操作类型分类，pg_opclass对应于具体类型操作。每个opclass都有对应的opfamily。\r\n\r\n\r\n\r\n以am开头的表是索引针对其他表的映射，通过存储oid，利用索引访问类型缩小数据范围。 主要是operator和proc。\r\n\r\nopclass是某个column数据类型在某个索引类型下对应的operator类。\r\n\r\n\r\n\r\n\r\n\r\nopfamily对应于一组可以交叉运算的opclass。\r\n\r\n\r\n\r\n一个family可以在pg_amop中找到一组操作符，在pg_amproc中找到一组方法。以用于该am。\r\n\r\n\r\n\r\n索引字段对应的函数\r\nrd_support的计算过程：\r\n\r\n1，在ComputeIndexAttrs→ResolveOpClass中根据索引类型realm，以及字段类型。查询pg_opclass表获得oid作为indclass。\r\n\r\n2，在LookupOpclassInfo， 根据indclass查询pg_opclass 得到opcfamily\r\n\r\n3，在LookupOpclassInfo，根据opcfamily，opcintype。 将opcintype作为left type和right type，搜索pg_amproc得到对应am的一组函数oid。即是rd_support\r\n\r\n4，根据amproc 中的proc oid在pg_proc中找到实际的函数。\r\n</pre>	2019-09-18 16:54:49.009035	f
1075	489	Issue	5	地址截断，函数返回之后，指针地址变更。 *汇编定位诡异问题的作用*\r\n\r\n一条cltq指令引发的血案：https://www.jianshu.com/p/d2e22da3a71b\r\n\r\n<pre>\r\n   0x0000000000584868 <+108>:\tmov    %edx,%esi\r\n   0x000000000058486a <+110>:\tmov    %eax,%edi\r\n   0x000000000058486c <+112>:\tmov    $0x0,%eax\r\n   0x0000000000584871 <+117>:\tcallq  0x48555c <at_open>\r\n   0x0000000000584876 <+122>:\tcltq   \r\n---Type <return> to continue, or q <return> to quit---\r\n   0x0000000000584878 <+124>:\tmov    %rax,-0x28(%rbp)\r\n=> 0x000000000058487c <+128>:\tmov    -0x28(%rbp),%rax\r\n   0x0000000000584880 <+132>:\tmov    $0xb30587,%esi\r\n   0x0000000000584885 <+137>:\tmov    %rax,%rdi\r\n\r\n</pre>\r\n\r\n根因是没有包含头文件！！！！	2019-09-26 14:56:04.337107	f
1076	521	Issue	5		2019-09-27 06:46:02.899678	f
1063	513	Issue	5	问题：\r\n1，需要将原先在x，y上统一的条件给分开，从而分别支持at meta和 at data的scan。\r\n  可在ac_rescan上改造\r\n1.1 level条件也有多种玩法，也可用scankey来表示。\r\n\r\n统一：\r\n1，meta的scan还跟以前一样，但是tupledesc用的是meta的\r\n2，data的scan另外使用一个filter\r\n3，层次使用另一个参数传递。\r\nindexrelation\r\n\r\n2，at重用bt代码的地方需要将RelationGetDesc改为RelationGetMetaDesc。\r\n并且注意原tupledesc上key的列与metadesc可能不一致。\r\n\r\n约束：\r\n1，at对于btree的写入是一次性的，仅在重建时。\r\n2，y的条件用来过滤，在索引之上使用。（因而不必考虑拆分scankey）\r\n	2019-09-18 18:53:04.153395	f
1066	520	Issue	5	成瘾的判断： 当一个人持续做一件事，知道事情本身无法让其快乐时，仍然在继续就是成瘾。\r\n\r\n所以玩游戏超过一定时间，玩手机超过一定时间都是成瘾。	2019-09-22 14:41:48.590107	f
1065	520	Issue	5	成瘾本质：\r\n\r\n可能是在逃避现实，在人非常疲惫又无法很好休息时，这种成瘾就出来作祟了。\r\n所以在最初的一会去决定玩游戏可能是因为有趣或刺激。而过了之后纯粹是在逃避了。\r\n身体上的成瘾估计也是如此。	2019-09-22 14:39:37.420849	f
1068	521	Issue	5	自省或变故才会让一个人抛弃现有模式，开辟新模式。 当然新模式不一定是好的，可能是过激的策略。	2019-09-22 14:46:12.98972	f
1069	212	Issue	5	通俗的理解计算可能是：\r\n查找，寻找数据的关系，使数据具备某种特征，最优解，分析发现。	2019-09-22 14:59:18.799747	f
1070	510	Issue	5	1，key-value为什么赢得大发展？ 是分布式的东风么\r\n2，key-value能解决哪些问题\r\n3，key-value的特征\r\n4，kv的代表产品\r\n5，key-value的未来	2019-09-22 15:02:05.414758	f
1071	521	Issue	5		2019-09-22 15:16:09.868216	f
1072	521	Issue	5	世间只有一种美好，就是活在当下，不是岁月静好。人的头脑本身就是寻求成长，成就的机制。真正的静好就是死亡。\r\n\r\n每个人都应该有一种信念，即我们能幸福快乐的生活，这是自爱自尊自信的前提。\r\n就像打羽毛球一样，我知道自己能打好，我们相信，热爱，行动因而可以达成。	2019-09-22 15:19:12.46176	f
1073	510	Issue	5		2019-09-23 07:24:51.35929	f
1074	526	Issue	5	改进：\r\n1，放弃强行说服\r\n2，用科学与行动来争取认可，如果真的想要的话\r\n3，形成自己的成功学与心灵世界。	2019-09-24 06:44:09.738725	f
1077	521	Issue	5	世界是逻辑的，成功可以复制，只是难以找到所有条件，这是佛教等不能普世的原因。有逻辑因而人们有可为就是一个充满可能性的世界。\r\n不能用哲学笼统的表述具体问题，具体问题具体分析，这是科学发展告诉我们的。\r\n\r\n因而人生在于找到适合自己的算法逻辑，去过好这一生。\r\n活在当下，过往不念，未来不追。\r\n1，有知觉的开始\r\n2，有知觉的进行\r\n3，有知觉的结束\r\n4，累了就放下，忙碌不会让人快多少\r\n\r\n小孩的生活方式也许就是最合适的方式。	2019-09-27 06:53:13.118136	f
1078	516	Issue	5	去递归一个基本原因是性能，递归栈深了之后性能会惨不忍睹。\r\n\r\n参考pg的qsort实现，在大量记录时比纯递归实现高出几百倍。\r\nTake care to recurse on the smaller partition, to bound stack usage.	2019-09-28 08:07:29.869496	f
1079	528	Issue	5	读写流程的分析：\r\nhttps://zhuanlan.zhihu.com/p/51360281\r\n\r\n实现上相当于把最新的删除都暂存起来，后续遍历过程中如果出现了删除对应的key，则将其skip掉。	2019-10-09 12:00:59.131728	f
1080	510	Issue	5	列存储并未完全破坏行记录的语义，通过列仍然能够完整还原出行。\r\n	2019-10-09 14:50:25.29393	f
1081	525	Issue	5	看上去在存储上kudu跟tikv最大的区别可能就是支持列式存储。\r\nkudu功能上目前可能还有不少限制，需看代码了解。是否支持二级索引，多行事务等。	2019-10-09 14:52:42.850965	f
1082	529	Issue	5	需求：\r\n0，支持单条记录的增删改查，not only ETL\r\n1，blocked存储\r\n2，多ac的使用，id的运算\r\n3，列式存储（有序的列式存储）\r\n4，多维索引\r\n	2019-10-09 15:02:17.95941	f
1083	386	Issue	5	通常数据访问模式是x->rowid->y，这样是无界的，虽然可以通过索引过滤rowid，但从根本上并未将数据按照特征归类。\r\nbeas的数据访问模式是x->y.\r\n但是现实情况是难以使用ac cover所有访问模式。比如x->y,与y->x.\r\n\r\n	2019-10-09 15:16:17.555754	f
1087	500	Issue	5	实现：\r\n1，导入数据时，如果含key，则将count转换为递增的数字，如果是写入，则用奇数表示。删除用偶数表示。\r\n2，数据根据x|y|key|count排序\r\n3，合并相同x|y时，根据key进行去重，处理相同key的最后一条记录，如果其count为偶数，则count(x|y) + 1,否则不变。	2019-10-10 12:34:50.778654	f
1279	624	Issue	5	目录的完整删除，imcs pool目录未删除。\r\n进程异常，比如访问不存在的pool，导致master重新加载后，device共享内存引用次数异常。	2020-05-17 20:02:57.305483	f
1090	386	Issue	5	beas的ac虽然基于语义，但是也有其经验成分。即是过往访问模式的总结。\r\n但是数据分析还有一点就是去突破未知，在未知的维度之间寻找关系。	2019-10-11 06:33:15.279895	f
1085	438	Issue	5	merge join会用到mark pos， restore pos。	2019-10-09 17:57:26.9571	f
1086	529	Issue	5	第一次讨论纪要：\r\n1，暂不考虑多个ac拼成全表的实现，后续可能采用简化实现，比如仅查询内存中的数据。\r\n2，数据批量导入，每个批次的进来之后单独作为block。后续进行合并\r\n3，32位rowid？怎么产生？\r\n4，在刚创建表之后，如何进行ac分割？ column group。\r\n\r\n调研Parquet 	2019-10-10 09:20:47.639416	f
1092	529	Issue	5		2019-10-11 10:17:15.690428	f
1094	525	Issue	5	这篇文章讲了kudu的存储结构：\r\nhttps://blog.csdn.net/Apache_Jerry/article/details/88669885	2019-10-11 18:23:02.784487	f
1084	529	Issue	5	数据都按block组织，但是等到一定时机后，按规则进行split。该规则考虑ac的特征。\r\n如果同一个x的数据量非常少。那么就将一堆x放在一起存储。\r\n\r\nblock的增量修改先使用delta方式记录，等到一定时机进行合并。（列式存储的增量修改，可以参考下kudu）\r\n\r\n如果考虑根据rowid来生成整个row，那就有点复杂了。这涉及row record是按heap方式组织还是有序组织。\r\n\r\n问题3：相同rowid（or primary/unique key）的数据要保证在一个partition？\r\n多个ac使用什么来分区来确保相同行记录落在一个节点上？对于对象存储而言，甚至不支持同一个节点的多个key的原子性。\r\nac engine必须支持事务。\r\n\r\n问题4：修改分散，同一个表的数据修改不能很好实现log struct，数据被打散了。\r\n不过这个主要涉及性能，后面可以再考虑优化。增量修改的处理是核心问题。\r\n\r\n\r\n关键点1：key很有讲究，主要就是利用key来尽可能多的过滤数据。如果将y打包一起放在一个block作为value，那读取操作也就是读这个value。\r\n	2019-10-09 16:25:44.266527	f
1088	529	Issue	5	最小系统：\r\n1，不考虑列压缩\r\n2，只考虑批量写入\r\n3，只考虑基于ac的查询	2019-10-10 14:15:38.169188	f
1089	202	Issue	5	心学解决了日常中如何行事，如何心随意动的问题。\r\n但正如王阳明的知行合一，具体事情，还是得具体去干，珍重客观规律。这是科学的成分。\r\n\r\n心学 + 科学，还有个问题就是人内心的困惑或者伤害需要去拯救，否则可能出现知善，但是不为善的情况。	2019-10-11 06:29:11.133035	f
1096	531	Issue	5	分析kudu，parquet的列存内部结构	2019-10-12 15:42:59.240809	f
1093	529	Issue	5	需求：\r\n除了key prefix过滤外，最好能支持key的其他部分过滤。通常kv系统没这种能力。\r\n但是对于ac而言这个非常必要，那么支持二级索引。考虑到ac可能将不同的key放在一个block，二级索引也不是普通的二级索引。\r\n\r\n合并的时候可能每个range都合并一点，如果重新生成block结构可能会影响性能，是否block支持delta，等数据达到一定规模之后再合入。\r\n<pre>\r\nLevel 0的SSTable文件有些特殊，尽管每个文件也是根据Key由小到大排列，\r\n但是因为level 0的文件是通过minor compaction直接生成的，所以任意两个level 0下的两个sstable文件可能再key范围上有重叠。\r\n所以在做major compaction的时候，对于大于level 0的层级，选择其中一个文件就行，\r\n但是对于level 0来说，指定某个文件后，本level中很可能有其他SSTable文件的key范围和这个文件有重叠，\r\n这种情况下，要找出所有有重叠的文件和level 1的文件进行合并，即level 0在进行文件选择的时候，可能会有多个文件参与major compaction。\r\n</pre>\r\n\r\n这篇文章解释了这个问题。leveldb对每层的数据量做了限制，每个sstable大小也有限制，因而可以控制参与合并的sstable数量。\r\n或者说leveldb搞这么多level就是为了控制compact时的规模。\r\nhttp://openinx.github.io/2014/08/17/leveldb-compaction/\r\n\r\n比如level1的一个sstable与level2进行合并，参与的sstable数量可能不会超过10个	2019-10-11 14:22:16.550818	f
1091	529	Issue	5	今早讨论又提出了几点：\r\n1，coral不是单独的进程，可能与查询器在同一个进程\r\n2，coral接口层无状态，缓存数据不必考虑刷新，数仓场景数据都是新增的。\r\n3，事务处理可能在任意一个进程中，事务状态这块怎么搞？\r\n4，计算下层怎么玩？filter，project。如何下沉到存储。Oracle Exadata了解下\r\n5，元数据在存储层肯定是需要的，比如字段的长度变更了，元数据修改只能向前兼容。不能拿老版本的table schema来读取新的数据。\r\n6，开发语言可以使用c\r\n\r\n\r\n首先敲定使用哪种分布式存储引擎。\r\n\r\n使用rados，可以自定义数据处理，从而支持filter，project。这种打通的能力其他系统不一定具备。	2019-10-11 08:44:54.250736	f
1095	377	Issue	5	GPL有LGPL，AGPL变种。\r\nLGPL是为类库的方式使用开源软件提供的窗口。\r\n<pre>\r\n但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，\r\n涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。\r\n因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，\r\n但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。\r\n</pre>\r\nAGPL限制了云服务提供商免费且不开源的使用开源软件。	2019-10-12 06:41:21.474326	f
1097	531	Issue	5	1,按照某个字段排序的block是一个基础数据结构。\r\n2，数据以列存组织  x->y block -> id blockblock\r\n3, 元数据也如此组织，这里元数据主要是索引。比如一个ac分为1万个rowgroup，这个信息可以放入一个或多个block。\r\nDB | AC, AC | range, key|value.这三种组织结构。\r\n\r\nblock本身可以作为一个value值，如果block过大，则将其使用另外的kv存储，在原来的地方放一个link value。	2019-10-14 13:47:49.450166	f
1098	532	Issue	5	人生没有说明书，如果成功是通过超出负载的付出得来的，那成功本身就血淋淋。\r\n即便开局带挂的人，在获得快乐满足方面几乎是平等的，因为得到越容易的东西就越没快乐感。\r\n同样痴心妄想也没成就感。 最快乐的是那种凭借自己的天赋和努力达成巨大目标的人。	2019-10-20 12:14:19.91885	f
1101	489	Issue	5	内存越界可能引起数据异常，比如	2019-10-24 17:20:57.117368	f
1099	513	Issue	5	修改精度计算方法\r\n方案1：\r\n由每层的父子之间对比"精度"(距离)，取最小值。再在每层取最大值。距离的计算逐层累加，dn-1=dn + distance(n). dn_max = 0;\r\n\r\n方案2：\r\n选取局部距离大的点上移，确保下层节点dy足够小\r\n\r\n\r\n问题1：\r\nnumeric使用null distance函数有bug。\r\n\r\n问题2：\r\n1/1000的记录数量是否包含count？ 这个目标有点不明确。	2019-10-22 14:53:34.592283	f
1100	504	Issue	5	精度理论是可计算的。所以我们的测试数据不能超越理论值，这是符合逻辑的前提。\r\n但是精度又是非常不准确的。\r\n\r\ncoverage,覆盖度，反应的是近似解与精确解的距离，距离/最大距离 就是精度。\r\nrelevance反应的是啥，相关度。使用不同的相关度，对比在该相关度下精确解与近似解的距离，得到近似解接近的相关度。\r\n论文定义accuracy = min(1/(1 + Fcov), 1/(1+ Frev))	2019-10-22 15:24:01.374899	f
1102	513	Issue	5	new方案：\r\n1，根据value来进行划分数据，而不是中位点。达到精确比例尺的效果。\r\n2，按1的方式计算就不是平衡二叉树，因而整体深度会上升，限制最大深度，并将超出部分的记录全部加到最后一层。\r\n\r\n3，利用父子节点计算dy，然后将最大值作为level的dy算法也只适合部分场景，另外这种算法累加可能超过max-min，要做下处理。	2019-10-24 17:28:50.297806	f
1103	339	Issue	5	m18665394433@163.com\r\nAnewday@xx	2019-11-02 18:52:04.363466	f
1104	536	Issue	5	还有可以将经常同时访问到的partition做compact。	2019-11-08 07:37:04.464562	f
1105	535	Issue	5	1，第一阶段coral计划\r\n2，如何满足beas的要求	2019-11-08 15:56:14.598155	f
1106	533	Issue	5	从接口入手，\r\n\r\n数据结构，存储方案，有哪些数据，各如何存储？\r\n\r\n组件结构，多层展开，串通流程。	2019-11-10 20:49:44.948822	f
1107	533	Issue	5	设计过程最难在于取舍。更难的在于要做下这个选择，即便你可能没有全盘信息的情况下，你不能一直犹豫彷徨。	2019-11-10 20:55:23.627543	f
1109	493	Issue	5	在线计算工具：\r\nhttps://toolslick.com/programming/data-structure/bloom-filter-calculator	2019-11-11 07:30:52.206305	f
1108	535	Issue	5	a simple coral的方案。\r\n1，剥离pg的事务\r\n2，fuelpump写入使用批量写入增量ac partition。\r\n3，ac支持既有事务框架，由元数据模块提供ac partitin管理能力。\r\n4，coral作为一个接口层直接使用。相当于只有一个coral。coral as a lib。\r\n数据按照x做partition内排序。 partition有元数据，提供基于x的扫描能力。	2019-11-10 21:15:54.164999	f
1110	535	Issue	5	Endian	2019-11-12 13:33:03.953517	f
1111	537	Issue	5	Shuffle:洗牌	2019-11-15 08:58:48.843454	f
1112	386	Issue	5	AC实现上就像带聚集的cover index。好处就是直接通过x能找到y。并且是聚集的。\r\n聚集这个特征在倒排索引，data cube中也有	2019-11-15 15:00:48.313941	f
1113	115	Issue	5	https://www.jianshu.com/p/c23f3ea5443d\r\nhttp://utf8everywhere.org/zh-cn	2019-11-21 13:40:55.751989	f
1115	497	Issue	5	反面是 忽视，逃避，轮回。\r\n\r\n很少有人真的看得起每个别人，将别人的故事一样精彩的来看待。耐心的倾听。	2019-11-23 22:26:10.076302	f
1114	115	Issue	5	乱码的根源在于没有一个超类，即对于任意一个字符流。\r\n软件没有办法知道其编码格式做自动的转换。只能约定其与自己编码方式一致来处理。\r\nfor example：\r\n屏幕输入一串字符，输入程序将其使用GBK编码，并将内存通知处理程序。\r\n处理程序拿到一个内存片段，应用程序根据系统默认编码类型，将输入转换为自己的存储类型，如utf8.\r\n处理完之后，将utf8编码转换为系统默认编码，交给显示器显示。\r\n\r\n	2019-11-21 13:52:55.982109	f
1116	541	Issue	5	第一阶段：\r\n1，type定义\r\n2，metadata模块\r\n3，基本类型与计算\r\n4，编码\r\n5，列编码\r\n6，元数据持久化\r\n7，通用模块接口\r\n8，数据持久化	2019-11-28 15:34:08.74365	f
1117	239	Issue	5	如果手腕是紧的，就领会不了高远与杀球的手指的握紧与压。\r\n一个很明显的特征就是倒拍时，拍是松的，快要掉的。等挥拍到上方之后就必须用手指手腕发力把拍子旋转起来，否则打不到球。\r\n另外要去感受借力的感觉。	2019-11-30 18:48:42.125974	f
1118	239	Issue	5	1，大臂的三种运动方式\r\n2，发力的整个过程\r\n3，臀部和腰腹才是大树的根和躯干，是根基。\r\n对于步法也同样如此，出发点并非腿部。\r\n4，发力时是逐节进行的，否则就成了甩大臂。\r\n5，动作一致性就在于最后时刻的手腕和手指变化。\r\n\r\n冰王：\r\nhttps://zhuanlan.zhihu.com/p/58946980	2019-12-01 04:52:48.519078	f
1121	541	Issue	5	create\r\ndrop\r\nget_column_vector,解码时直接使用column对应的内存。\r\nread\r\n\r\ncolumnid,tableid的表达方式，meta中间层还是需要的。否则持久化层就和上面的接口层耦合了。\r\ntable或column都有改名的需求。coral这层仅感知id就可以了。\r\n\r\n又比如需要在内存中表示column之间的父子关系等。	2019-12-03 07:28:13.099072	f
1122	541	Issue	5	怎么将具体的trait object转换为实际的object。	2019-12-03 14:07:47.144877	f
1123	541	Issue	5	改回使用一个文件，把错误处理加进去，接口设计。	2019-12-05 07:14:40.020882	f
1125	541	Issue	5	1，数据进来\r\n2，按x1x2x3y1y2y3排序并去重，生产rowid vector。{rowids + len}，以及offset vector用于快速定位到rowid vector。\r\n3，按x2x3x1,x3x1x2排序，生成 index vector，其中存的是offset vector的下标。\r\n4，进行基数检查，确定是否采用字典，如果采用则进行替换，以及统计最小最大值，null count，distinct count等等\r\n5，在index vector上构建多维索引划分，并记录每个划分的范围。\r\n6，根据划分的 {offsets }和第2步生成的vector，对每个ac block进行持久化。	2019-12-07 12:40:56.196266	f
1128	541	Issue	5	泛型和枚举当前不一样。\r\n枚举说明变量存在多种类型的值。\r\n而trait object是说只有一种情况，只是仅运行时才知道值的类型。\r\n枚举是我自己知道类型，trait object是用户需要知道类型。\r\n即rust枚举是一种更强的类型，其不仅有转换到某个具体数据类型的能力。\r\n同时其还是自知的。\r\n\r\n泛型接口意味着凡是使用该接口的类型必须满足要求。\r\n如果简单类型满足要求，而复杂类型不满足要求，那么就不能用统一的泛型接口。\r\n凡是调用的子函数使用泛型参数，则子函数也必须是泛型的。\r\n\r\n如果结构体使用泛型，则结构体所有使用泛型数据的方法也必须是泛型的。\r\n\r\n1，表达一个table中有多种类型的column vector。\r\n有2种表达方式：\r\n1，table { cols ：vec<enum {}>}\r\n2, table { cols : vec<box<dyn trait object>>}\r\n\r\n方式1是一种更强的表达，但是对于coral不是必须的。coral在读写接口层\r\n可自行根据元数据来确定column存储的类型。	2019-12-08 22:21:27.923006	f
1126	541	Issue	5	<pre>\r\nuse std::any::Any;\r\nuse std::fmt::Display;\r\nuse core::fmt;\r\n\r\npub trait ColumnVectorInterface {\r\n    fn as_mut(&mut self) -> &mut dyn Any;\r\n    fn as_ref(&self) -> &dyn Any;\r\n}\r\n\r\npub struct ColumnVector<T:'static + Copy> {\r\n    null_count : i32,\r\n    null: Vec<bool>,\r\n    data: Vec<T>,\r\n    length : Vec<i32>,\r\n}\r\n\r\nimpl <T: 'static + Copy> ColumnVectorInterface for ColumnVector<T>\r\n{\r\n    fn as_mut(&mut self) -> &mut dyn Any { self }\r\n    fn as_ref(&self) -> &dyn Any { self }\r\n}\r\n\r\nimpl<T: 'static + Copy> ColumnVector<T>\r\n{\r\n    fn new() -> ColumnVector<T> {\r\n        ColumnVector { null_count : 0, null : Vec::new(), data: Vec::new(), length: Vec::new() }\r\n    }\r\n\r\n    fn insert_batch(&mut self, null: &Vec<bool>, values: &Vec<T>)\r\n    {\r\n        for iter in null {\r\n            if *iter == true {\r\n                self.null_count += 1;\r\n            }\r\n            self.null.push(*iter);\r\n        }\r\n\r\n        for iter in values {\r\n            self.data.push(*iter);\r\n        }\r\n    }\r\n\r\n    fn get(&self, i : usize) -> &T {\r\n        &self.data[i]\r\n    }\r\n}\r\n\r\nstruct TableRowBatch {\r\n    cols : Vec<Box<dyn ColumnVectorInterface>>,\r\n}\r\n\r\nimpl TableRowBatch {\r\n    fn get_column<T: 'static + Copy>(&self, id : usize) -> &ColumnVector<T> {\r\n        (*self.cols[id]).as_ref().downcast_ref::<ColumnVector<T>>().expect("cast error")\r\n    }\r\n}\r\nimpl Display for TableRowBatch {\r\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n        for i in 0..self.cols.len() {\r\n            let col = (*self.cols[i]).as_ref().downcast_ref::<ColumnVector<i32>>().expect("cast error");\r\n            let x : &i32 = col.get(0);\r\n            write!(f, "{},", col.get(0));\r\n        }\r\n        write!(f, ";")\r\n    }\r\n\r\n}\r\n\r\nimpl TableRowBatch {\r\n    fn insert_batch<T: 'static + Copy>(&mut self, null : &Vec<Vec<bool>>, values: &Vec<Vec<T>>)\r\n    {\r\n        for i in 0..self.cols.len() {\r\n            let col = (*self.cols[i]).as_mut().downcast_mut::<ColumnVector<T>>().expect("cast error");\r\n            col.insert_batch(&null[i], &values[i]);\r\n        }\r\n\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let m = vec![true, false];\r\n    let x = ColumnVector::<bool>::new();\r\n    let mut t1 = TableRowBatch {cols: vec![Box::new(ColumnVector::<bool>::new()),\r\n                                       Box::new(ColumnVector::<bool>::new())]};\r\n\r\n    t1.insert_batch(&vec![vec![false,false], vec![false, false]], &vec![vec![true, false], vec![false,true]]);\r\n    let col = t1.get_column::<bool>(0);\r\n    println!("{} {} ", col.data[0],col.data[1]);\r\n}\r\n\r\n</pre>	2019-12-07 22:22:29.479608	f
1129	280	Issue	5	做一个有灵魂的程序员，热爱它。不是一个复制粘贴程序员。	2019-12-08 22:47:35.005355	f
1132	517	Issue	5	clean architecture，核心思想就是处理依赖。这是很多问题的根源。比如pg中rel的跨模块使用就产生了依赖。\r\n元数据跨模块，层次产生依赖确实不应该。数据的依赖呢？	2019-12-26 08:27:26.656842	f
939	429	Issue	5	搜索技巧：\r\n1，可以带pdf搜文档，论文\r\n2，优先考虑上官网\r\n3，带专业词语搜索，结果会好很多\r\n4,  alternative\r\n5， 带能查阅的资料中的信息，更换关键词，再次搜索（尤其是代码中出现的概念，或函数名等）\r\n\r\n工作技巧：\r\n1，如果不能进一步思考，或一团乱麻时。先理清概念，用逻辑方式一步步严密的演绎。	2019-07-13 19:24:02.395625	f
1140	384	Issue	5	数据库的核心就是事务，ACID。存储产品其实也有ACID，但是I非常弱，C也很弱。这是数据库的存储比块存储，对象存储复杂的地方。\r\n数据库天生的特征就是记录聚集在一起存储，这样就必然涉及到并发访问，锁的问题。行锁不可能放入内存，因而有了事务状态管理。	2019-12-30 06:41:43.900217	f
1141	384	Issue	5		2019-12-30 06:45:23.313328	f
781	384	Issue	5	<pre><code class="text">\r\n作者：浙江智臾科技有限公司\r\n链接：https://www.zhihu.com/question/67356221/answer/488694086\r\n来源：知乎\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\r\n前面说了AWS相比于Greenplum，架构上的一些缺陷。再来说说Greenplum和Redshift这类MPP数据仓库面对PB级数据时，架构上一些共同的局限性。\r\n（1）在节点层面对数据进行distribution的局限性。如果采用even distribution，也就是说简单的round robin，能把每个节点的资源都充分的利用起来，\r\n但是对于较小的query和计算任务，也需要发送到所有的节点来完成，浪费集群的资源，增加任务的延迟。如果按某一个业务字段来distribution数据，\r\n譬如测试案例中的日期字段或股票代码字段，那么当query限定为某一个日期或某一只股票时，所有的计算都到一个节点上，不能把集群的所有资源调动起来。\r\n（2）leader节点限制整个集群的并发性能。MPP数据仓库通过leader节点连接客户端和数据节点，leader节点成为系统的瓶颈所在，抑制了系统的并发性能。\r\n（3）增加数据节点时，数据的resharding非常耗时。基于分布式文件系统构建的数据仓库，在架构上能很好的避免MPP的上述局限性。\r\nDolphinDB就是建立在分布式文件系统之上的分布式时序数据库（可以看成是分布式OLAP系统），在时序类数据的写入性能和查询计算性能上，\r\n跟Redshift和Greenplum相比（也是列式存储模式），性能优势在一个数量级左右。如果你的数据量非常大，实时性要求高，而且你的数据一旦写入后，\r\n不再需要更新或删除部分行，或者说这样的操作非常低频，譬如金融市场的行情数据，物联网产生的数据，DolphinDB是一个很好的选择。\r\n</code></pre>\r\n\r\ngreenplum的分布式就像一个出生就带残疾的人。	2019-05-09 19:59:49.079461	f
1142	545	Issue	5	复杂不是因为数量多，而是关联多。\r\n多但是能规则化就不那么复杂。\r\n\r\n复杂处理方式：表达，推导。数学表达好可以极大的减轻心智负担。\r\n\r\n这个世界的本质矛盾就在于复杂度，是人的思考能力与世界复杂度增加不匹配的矛盾。	2019-12-31 07:30:59.426561	f
1145	546	Issue	5	1，partial ac，ac cache技术\r\n尤其是支持跨表的ac，pre join。\r\npartial ac指全量ac数据太大，仅构建部分ac，即create ac where XX。\r\n\r\n2，数据库上ResultSet cache加速\r\n3，查询预测技术\r\n淘汰算法，slab\r\n4，数据生命周期技术，数据的断舍离\r\n\r\nyy：\r\n1，一个公司的数据系统的整体使用方式\r\n2，flink，storm流数据处理\r\n3，Esper，Drools规则引擎，DSL规则语言。	2020-01-03 11:51:17.178257	f
1144	545	Issue	5	复杂系统的涌现特征，即会出现新的行为模式。\r\n\r\n语言-描述\r\n探路者，直面问题，真正思考的魅力。	2020-01-02 07:58:16.767949	f
1484	709	Issue	5	反手还有一点就是脚的落地击球，即有一个左脚蹬地的发力。\r\n是不是所有发力都是力从地起？\r\n击球方法不同体现在：\r\n1，网面与球的角度\r\n2，击球点	2020-11-15 20:02:20.50179	f
1119	239	Issue	5	网前的跳球，平抽根本不用大臂发力。\r\n只要手放松，小臂和手腕的旋转+ 手指的压足以打出非常大的力量。很多时候力道不够是发力过程不完整导致的。\r\n\r\n任何一次击球都有步法+架拍，引拍击球，收拍回动的步骤完成的。\r\n\r\n第一阶高手：\r\n1，发力无障碍\r\n2，动作一致性\r\n3，步法灵活\r\n\r\n第二级高手：\r\n1，体能，速度上升\r\n2，线路，落点精确\r\n3，配合\r\n\r\n顶尖高手：\r\n1，预判\r\n2，观察对手优缺点，队友优缺点	2019-12-01 17:49:44.792123	f
1120	541	Issue	5	数据可能以列式组装，也可以按行式组装。根据schema得到原始数据的多个数组。\r\n索引阶段就是对数组进行重排。\r\n编码就是根据数组生产数据流。	2019-12-02 18:20:43.238262	f
1127	541	Issue	5	binary类型，varchar类型看出byte和char的数组，因而都可以采用泛型处理。	2019-12-07 22:23:25.133671	f
1124	517	Issue	5	计算机软件的力量在于抽象，与数学是同源的。编写代码的本质就是抽象和逻辑，必须认清事务的本质，才能进行合理的抽象。\r\n而boring程序员没有灵魂，不会进行抽象就没有正向逻辑，横看竖看都好像可以就是抓不住本质。\r\n\r\n跳跃性思维对于实际动手编程是不利的。对于洞察与发现比较有利。\r\n要称为高手就得进行这些思维训练。\r\n1，抽象，理解编程中已有的抽象与事物表达的关系。\r\n2，逻辑，展开事务运转的细节与关系\r\n3，落地，设计要有设计文档，要能讲清楚道明白，实现在于这些细节。\r\n\r\n抽象的时候一定要学会2点：\r\n1，竖向逐层展开\r\n2，横向明确划分不同概念\r\n\r\n为什么思维会绕，想不清楚，就是因为没打开啊。\r\n不要以为看上去简单就不去展开，想清楚再行动，而不要一味模仿，i am not a cp 程序员。	2019-12-06 06:33:18.209678	f
1130	517	Issue	5	想不清楚，没法决定。试下隔离这个工具。隔离清楚，在考虑一个点时，屏蔽其他点。\r\n代码注释就是要解释why？当你需要思考时，就写注释。 就跟写文档一样。	2019-12-25 17:29:43.350597	f
1131	541	Issue	5	数据整体经过排序，字典处理，然后交给下层工序处理。	2019-12-26 08:23:52.351957	f
1133	533	Issue	5	https://kb.cnblogs.com/page/505321/	2019-12-26 21:43:46.514748	f
1134	442	Issue	5	vacuum cycle id主要是用于解决vacuum使用物理页面顺序扫描导致的可能遗漏页面的问题	2019-12-27 12:11:37.804302	f
1135	459	Issue	5	MultiXacts 的存在是为了解决多个事务在tuple上加锁的问题。多个事务同时加锁存在么？ 是存在的。且看：\r\nThe conflict table is:\r\n\r\n                  UPDATE       NO KEY UPDATE    SHARE        KEY SHARE\r\nUPDATE           conflict        conflict      conflict      conflict\r\nNO KEY UPDATE    conflict        conflict      conflict\r\nSHARE            conflict        conflict\r\nKEY SHARE        conflict\r\n	2019-12-29 21:04:41.104043	f
1137	429	Issue	5	英文阅读技巧：\r\n概括性阅读----一般文章段落都有大意，比如解释一个机制，描述一个结构等。带着对大意的理解去拉通句子，阅读起来会更容易。\r\n推理---- 这是必须进行的一步，作者一般不会讲明为什么必须这么做，或这个点跟另一个点的关系，这需要我们去建立一些链接。	2019-12-29 21:15:32.654809	f
1139	517	Issue	5	为什么成不了高手，因为你还不够快，思考不够快，不够聪明。\r\n思考的速度，精度，技巧的比拼。这是智力游戏。\r\n问，分，隔，连。思考不能前行与羽毛球打球不去移动一样，并非是不愿意，不够放松等原因。还有技巧在。一次只考虑一个点。要么考虑链接点，要么就考虑模块内。切记紧，散，乱。\r\n\r\n复杂性是软件架构的核心\r\n关键点：沟通，分层，分块。\r\n多个参与者，复杂的行为，为了特殊目的而引入的偶然复杂性，加入了不必要的东西。\r\n复杂性分类：\r\n根本复杂性\r\n历史复杂性\r\n偶然复杂性\r\n\r\n如果你用工程师思维，你可能永远成不了架构师。\r\n如果你只是想打羽毛球出汗，永远成不了高手。\r\n世界可能不是量变到质变，而是跳跃式的。猩猩永远成不了人。\r\n\r\n高级工程师只是摸了整个大象。但可能不了解大象的本质特征，以及内部关键点。	2019-12-29 21:27:46.097125	f
1138	544	Issue	5	ac本质特征：\r\n1，聚集，聚集意味着很多，比如多个heap tuple关联于一个ac tuple。并发更新\r\n2，独立的可见性，意味着没法依赖heap tuple做唯一可见性判断，同时意味着必须保证heap tuple与ac tuple可见一致性。没法异步删除等。\r\n\r\n2个问题：\r\n1，ac构建过程，如果有tuple删除与ac 读并发，可能ac删除比ac插入先执行，而引起数据一致性问题。\r\n2，2个heap tuple，同时修改一个ac tuple。\r\n\r\n聚集天生就是反并发的，聚集的效果在事务失败时，必须做反向处理，而不能通过简单的标记来处理。\r\n即undo中的数据有可能需要被恢复，同时聚集如果允许并发，还不能直接恢复到上一个版本，必须做反向操作。	2019-12-29 21:22:29.729334	f
1143	459	Issue	5	一种防止对象上乱序执行的锁机制。\r\n问题起源：\r\n事务1：读取  插入AC\r\n事务2：删除  删除AC\r\n如果执行顺序为：1.1 2.1 2.2 1.2，那么heap和AC就不一致。\r\n\r\n用select for update可以解决这个问题，但是粒度稍微大了点。\r\n其实我们并不想在整个事务周期内互斥，只是在一个小区间范围内对某个资源互斥操作。\r\n还有一种实现方法是在读取页面期间使用latch锁定，lock buffer，等处理完该页面再释放。\r\n\r\n\r\n	2019-12-31 08:02:57.785861	f
1150	552	Issue	5		2020-01-11 11:56:23.390426	f
1151	521	Issue	5	会打羽毛球的人很少，会生活的人也很少。\r\n打球的基础是发力，生活的基础是心态。\r\n何时松，何时紧，没有松就不会有紧。\r\n生活也是如此，何时紧，在需要直面困难时紧。	2020-01-12 20:01:46.420756	f
1152	551	Issue	5		2020-01-12 20:02:04.902696	f
1156	545	Issue	5	从postgresql btree实现看复杂度来自：\r\n1，更细粒度的并发\r\n2，细节场景特殊处理的优化\r\n比如fast root， fast insert\r\n3，功能支持\r\n比如back scan等\r\n\r\n而要掌握一个这样的系统，得非常熟悉这些细节，然后才能把整体行为串联起来。	2020-01-19 17:52:01.988497	f
1157	548	Issue	5	少有人走的路就是一个人生游戏的高手之路。\r\n觉察自己，别人的情绪与思想。选择与行动。看到。\r\n人生困难重重。人生错综复杂。\r\n唯有直面问题，选择改变才是应对各种问题。\r\n但是仅此显然不够，还得有知识，能力应对。\r\n就像发力一样，看似自然，实际却不容易做到。\r\n真正热爱人生的人非常少，就像热爱工作的人一样。\r\n\r\n真实与谎言，善与恶\r\n积极准备，应对复杂，避免简单思维\r\n承受该承受的苦，应对该有的复杂。\r\n\r\nrule：\r\n1，不会真正忘记，发生的一切都记录于我们的意识，潜意识，身体之中。\r\n2，承受该承受的苦，其他的都是乐\r\n3，善良是接受与改变，人生是复杂的，改变是应对之道。\r\n4，简单的思考本质上就是懒惰，懒惰是人性之恶。\r\n5，一个心智成熟的人并不恪守教义，真实是他们唯一能够接近和信奉的。\r\n6，你不应对危机，危机就来找你。你不处理问题，你就成了问题。\r\n7，我们生活在一个胆怯的，否认死亡的文化之中。\r\n8，分割的人，就像科学与宗教(更高的神秘力量？)的分割一样，现代人被更细的分割。\r\n根据凡是有利有弊的观点出发，分割利于专业化，但是联合才能产生更好的整体效能。\r\n科学的发展与内心的空虚不是必然的。\r\n9，王阳明说心外无物，所以你知道觉察和看到是多么重要了。\r\n\r\n改变是痛苦的，也是艰难的，就像小孩断奶一样。\r\n小孩进行自行断奶的可能性微乎其微。我们改变恶习也是如此。\r\n比如打游戏，即便我现在没法从游戏中感受到很大快乐，\r\n即便理性认为应该切换娱乐方式，但是身体的记忆力仍然强大，克服它还是非常困难，\r\n尤其是选择及其自由，无人监督时。自由对于一些人而言可能就像水一样可怕，因为没法驾驭。\r\n真实的世界也像水一样让一些人感到可怕。\r\n\r\n羽毛球与工作游戏一样，其困难并非在于技术本身，还在于我们选择一种\r\n生活方式，一种强健身体，一种是独立积极思考。\r\n\r\n很少有人在说话前充分思考，所以这算是会说话吗？\r\n很少有人在行动前制定计划，这算会行动吗？\r\n怎样发而借中节的圣贤状态？积极思考，主动准备的状态？\r\n\r\n\r\n心智分类：\r\n1，幼稚者，无法分清对错，没有逻辑，仅凭喜好和感情用事。撒谎者缺乏战胜谎言的勇气。\r\n2，麻木者，是非观念，逻辑都依存于体制，与体制共存亡，顺民愚民，缺乏了生机与独立。\r\n3，邪恶者，压制生命，喜欢控制，喜欢没有生机确定受控的事物。\r\n4，软弱者，害怕独立，懒惰，恐惧支配了他们，喜欢依赖与安全感\r\n5，怀疑者，具备独立思考能力\r\n6，创世者，相信更高力量的存在，审视自己与他人，热衷于创造并改变这个世界。让人获得成长。\r\n\r\n思维工具：\r\n分类分层分阶段\r\n比如羽毛球分级，这并不严格，但大体的量化有助于我们了解事物。	2020-01-27 18:07:23.107092	f
1159	561	Issue	5	通过不断的磨练，认清真相，明白人是什么，什么是对的，什么是错的，何为善，何为恶。	2020-01-29 08:53:56.728167	f
1160	280	Issue	5	羽毛球的目标达到6级，参与纯业余羽毛球比赛。\r\n怎么做到：\r\n1，每天花1个小时锻炼身体素质，把身体提升到6级。\r\n2，每周进行2次羽毛球活动，把技术磨练到6级\r\n3，对于专项可以请教练	2020-01-30 12:20:00.296425	f
1136	459	Issue	5	<pre>\r\nLocking tuples is not as easy as locking tables or other database objects.\r\nThe problem is that transactions might want to lock large numbers of tuples at\r\nany one time, so it's not possible to keep the locks objects in shared memory.\r\nTo work around this limitation, we use a two-level mechanism.  The first level\r\nis implemented by storing locking information in the tuple header: a tuple is\r\nmarked as locked by setting the current transaction's XID as its XMAX, and\r\nsetting additional infomask bits to distinguish this case from the more normal\r\ncase of having deleted the tuple.  When multiple transactions concurrently\r\nlock a tuple, a MultiXact is used; see below.  This mechanism can accommodate\r\narbitrarily large numbers of tuples being locked simultaneously.\r\n</pre>\r\n\r\n这段提纲般的讲明了，pg的行锁是放在tuple上持久化的，即xmax上。why？ 因为内存可能放不下。\r\n其说明tuple被某个事务使用，但是至于事务是否结束，就得另外查询了。\r\n\r\n内存中的锁主要是用来实现等待，唤醒机制的。\r\n\r\n为什么要tuple lock？ 为了尽量有序的进行唤醒。\r\n	2019-12-29 21:09:33.288887	f
1147	549	Issue	5	Mysql：\r\n<pre>\r\n#if defined(_MSC_VER)\r\n/** An unsigned 64 bit integral type. */\r\ntypedef unsigned __int64\tib_u64_t;\r\n#else\r\n/** An unsigned 64 bit integral type. */\r\ntypedef uint64_t                ib_u64_t;\r\n#endif\r\n\r\ntypedef ib_uint64_t\t\tib_id_t;\r\ntypedef ib_id_t\t\ttable_id_t;\r\ntypedef ib_id_t\t\tindex_id_t;\r\n\r\n\r\n/** Row identifier (DB_ROW_ID, DATA_ROW_ID) */\r\ntypedef ib_id_t\trow_id_t;\r\n/** Transaction identifier (DB_TRX_ID, DATA_TRX_ID) */\r\ntypedef ib_id_t\ttrx_id_t;\r\n/** Rollback pointer (DB_ROLL_PTR, DATA_ROLL_PTR) */\r\ntypedef ib_id_t\troll_ptr_t;\r\n/** Undo number */\r\ntypedef ib_id_t\tundo_no_t;\r\n</pre>	2020-01-06 15:26:03.839638	f
1148	322	Issue	5	特点：\r\n1，借不到太多力\r\n2，看不准球\r\n\r\n发力：\r\n1，腰力，折叠身体到打开\r\n2，收肩，展开\r\n3，架拍，手肘不要太低，注意有效挥距\r\n4，甩小臂，手腕-鞭打道理一样\r\n5，拇指抵压，握紧。	2020-01-09 11:45:02.375366	f
1149	552	Issue	5		2020-01-11 08:20:53.771951	f
1146	548	Issue	5	孔子 -让我明白了 什么是正确的道路，什么是合适，以及生命本来该有的样子。\r\n原则 -让我知道了一个成功系统的方法论\r\n少有人走的路- 让我看到的生命过程该有的样子，直面问题，让心灵获得成长。建立正常的人际交往，让我们与社会美妙的相处。这是生命最美的演绎，也是最美的风景线。让我明白了懒惰与改变是反义词，善良意味着进步。	2020-01-04 05:13:58.790714	f
1153	551	Issue	5		2020-01-12 20:02:52.299926	f
1154	478	Issue	5	relation_needs_vacanalyze 看该函数的注释。\r\n注意只有dead tuple超过一定数量才会触发vacuum，不会基于：1，changed数量 2，时间 等维度来触发。\r\n另外就是事务id freeze触发。\r\n\r\n对于ci而言这可能不够，我们需要及时回收undo segment，利于item pointer无效的判断。	2020-01-16 15:41:31.494675	f
1155	478	Issue	5	而且vacuum时必然触发freeze操作。	2020-01-17 10:20:03.736518	f
1158	187	Issue	5	第五阶段对于动作完整性，一致性有要求。只有极端被动时才没法把动作做完。\r\n第六阶段技术已经没有明显不足，胜负主要在于看谁强大的地方更强。	2020-01-28 07:04:20.142638	f
1161	560	Issue	5	移情一个典型的例子就是看到某个人还没了解就不喜欢	2020-01-30 12:20:45.818546	f
1162	322	Issue	5	反手挥拍手腕一样有甩的感觉\r\n手肘基本固定，主要靠旋小臂带动手腕，手指。	2020-01-30 18:28:24.177501	f
1163	559	Issue	5	发力的核心在于甩出速度，羽毛球不像打拳，打拳速度是快不了的，只有甩起来才快。\r\n尤其是反手，你不甩，仅靠小臂的纯粹力量是打不好的。\r\n\r\n步法的核心是重心控制。\r\n\r\n策略的核心就是利用场地，寻找对方的漏洞。	2020-01-30 20:31:39.315028	f
1164	564	Issue	5		2020-01-30 20:33:39.098628	f
1165	551	Issue	5	一个人是否能对一个事情投入热情，主要取决于这个人的人生观，价值观与该事情的契合程度。\r\n当人有了明确的人生观价值观之后，在事情上能否看到其乐趣和意义，然后选择注入自己的灵魂，这样我们才能看到一个事的灵魂。	2020-01-30 20:39:15.293695	f
1166	564	Issue	5	注入自己灵魂，把一个东西看得直到有颜色，这种心里的训练本身就能极大提高水平。\r\n就像观看羽毛球选手的比赛，脑中会残留其招式一样，这种记忆深入骨髓的话会渗透到部分肌肉记忆。\r\n\r\n你曾何时把软件想到如此痴迷吗？	2020-01-30 20:41:59.72883	f
1167	565	Issue	5		2020-01-31 09:59:29.637245	f
1168	564	Issue	5		2020-02-01 07:23:21.354081	f
1169	545	Issue	5	我们知道越简单的数据结构越容易理解，因而树比链表复杂，图比树复杂。	2020-02-06 20:41:09.501542	f
1170	545	Issue	5	特性越多，系统就越复杂。比如要支持进程内部分线程的推出不影响其他线程，使得其具备局部退出的特性，就得需要在代码很多地方做出处理。\r\n为什么互联网公司产品推出的快，因为他们砍掉了很多不必要的特性，系统的复杂度会下降非常多。\r\n\r\n	2020-02-06 20:58:42.143018	f
1171	560	Issue	5	10，爱是因为具备感知力，爱的反面是麻木，麻木是心智带宽窄的表现。\r\n11，善是接受真实，恶是逃避，谎言，压制\r\n12，恐惧在最初可能是源自能力不足，久之不理就变成不敢为，就成了恐惧\r\n13，恶源自极深的恐惧与不自信，没有接纳自己与别人。\r\n14，不自信，自我怀疑，到迷失自我。没迷失的人总会找到自己的路，即便那路是崎岖小径。\r\n   而迷失的人最终不仅失去自我，也将失去别人。	2020-02-07 13:36:40.190708	f
1172	568	Issue	5		2020-02-07 13:41:27.514312	f
1173	570	Issue	5	只有研究透彻了，才能触类旁通。	2020-02-11 22:31:56.317848	f
1174	561	Issue	5	1，觉擦自己的行为和心念。在日常的小事中不断磨练。\r\n2，接收状态不好的时候，这时不要继续消耗自己，而是去做一点轻松愉悦的事情，然后让自己回来。	2020-02-12 06:32:07.015608	f
1176	562	Issue	5	王垠有篇文章批评关系模型和sql的http://www.yinwang.org/blog-cn/2014/04/24/relational。\r\n知乎上也有探讨：https://www.zhihu.com/question/23602133。\r\n\r\n我很佩服王垠精通编程语言PL领域，其对计算机有着比很多从业者更深入的理解。\r\n上述讨论的问题在现实中也存在，不然也不会衍生出各种各样的数据库。\r\n总之在技术的Tree上，会有分叉，或者方向不对从发新枝，但这并不容易，尤其是sql的强大生态。\r\n新技术出现在有相当差异的地方。	2020-02-16 19:19:44.760308	f
1175	562	Issue	5	https://homepages.cwi.nl/~manegold/teaching/DBtech/slides/appA-8.pdf\r\n这篇文章，尤其是里面的图很明了的阐述了什么是网状数据库。\r\n在关系数据库之前，都是使用link来存储数据之间的关系，link是一种物理表达方式。就相当于pg中的itemid。\r\n*而关系数据库使用关系这种统一模型来表达实体和关系，这种统一是关系计算的基础。*\r\n索引也同样表示为关系。	2020-02-16 16:39:38.668602	f
1181	567	Issue	5	是对事务本性和特性的运用。	2020-02-20 18:45:17.104584	f
1182	561	Issue	5	有两个有趣的比喻：\r\n1，人的认知地图与真实世界地图\r\n2，身边发生的一切就如球面，我们的心在球心，但我们只观察到部分球面区域。\r\n\r\n而修行就是要将自己的地图纠正，让它接近于真实的地图。与自然合二为一。\r\n如果有幸，我们还能修正，影响，扩展下世界的知识树，以及人类发展图，那将是很有趣的事。\r\n总有有心的人追寻到我们的路径，继续发展它...	2020-02-21 08:18:22.036764	f
1184	553	Issue	5	状态是命令式编程语言的核心之一，多个线程，反复执行搞来搞去都是在做状态处理。想想100个状态的程序，其状态管理本身就非常复杂了，这样规模的系统，你要理解\r\n系统并且让其适应变化是非常艰难的，这就是编程活动的核心矛盾。\r\n程序员大把的时间都消耗在理解与管理这些状态，以及优化状态的表达，增加或减少状态适应变化。\r\n\r\n自然语言难就在于状态太多，每个含义的表达都单独使用一个概念。而领域语言相对简单。\r\n\r\n函数式编程没有跨函数状态，它是通过一种反馈的机制来表达调整自己状态的能力。这区别就像每个时间都是一个新的你，还是只有一个你只是状态在变化？\r\n\r\n状态基本都是用来控制的，参数是简单的，他不会穿插于多次并发执行。	2020-02-22 08:50:06.612968	f
1187	565	Issue	5	重点在于甩到后面去，想想挥拍的有效距离，是从9点到1点。不是从12点或11点 挥到3点，那样差了一倍的有效挥距。	2020-02-26 21:45:38.837078	f
1210	579	Issue	5	补充：\r\npg的进程还有一种重要的数据是其关联的database。backend总是关联于0个或1个database。\r\n这就是vacuum为什么分为latcher和worker的原因，worker关联于database。	2020-03-12 07:38:58.433405	f
1188	561	Issue	5	人的肉体，自我与灵魂，灵魂是作为自我的观察者出现的。 即观察自我与观察别人。\r\n有观察自然有善恶，是非的判断。所以灵魂有正的，有恶的。有灵魂的交流即我知道我在和你交流，你也知道你在和到交流。这也是一种悟性。\r\n\r\n金钱可以表达爱，也可以表达恶。如果是分享自己的劳动成果给别人，为了让对方变得心智成熟，那就是爱。如果是抢夺，控制和奴役那就是恶。	2020-02-27 14:38:02.529636	f
1190	575	Issue	5	Coder不仅仅是软件工程师，而是完成一件事情，包含设计，规划，实施等。为什么要成为Coder？因为这样才能成为一个Lover。\r\n一个有能力去爱自己，爱别人的人。	2020-02-27 19:11:05.176247	f
1192	577	Issue	5	测试场景：\r\n1，可能在一个事务内修改多次，即link上的多个记录都是abort的	2020-02-28 12:37:22.705673	f
1194	577	Issue	5		2020-03-01 21:02:02.086155	f
1195	577	Issue	5	完成ci测试：\r\n1，initdb ok\r\n2，多次插入后，数据能正确写入ci undo segment\r\n3，覆盖写入，能正确读取之前写入的tuple。且ci undo segment数据正常持久化。\r\n4，简单写入后重启也正常，会使用下一个undo page写入。\r\n\r\n接下来：\r\n1，测试vacuum功能\r\n2，测试ac scan功能\r\n3，insert，delete接口尚未测试。\r\n\r\n开发：\r\n1，支持事务的超时退出。\r\nBackendXidGetPid还真有这函数。还有一种做法就是消息接口中采用超时机制，超时后检查是否需退出事务。	2020-03-02 22:18:33.162375	f
1196	577	Issue	5		2020-03-02 22:52:01.692878	f
1215	587	Issue	5	第一轮review意见：\r\n1，ci undo header file元数据是否可能损坏？这样仅flush header部分是否足够？\r\n这个问题或许存在，\r\n2，segment deleting状态是否不需要。\r\n需要，存在这种情况，再设置cleanPos之前，事务读取了segment上的undo page，这时如果立即删除undo segment文件。\r\n可能导致正常读操作失败。延迟一段时间后删除可以将此问题概率降到很低，毕竟读取一个buffer要不了几十秒。	2020-03-12 16:48:43.159889	f
1197	577	Issue	5	测试分2波：\r\n1，基本功能\r\n\r\n2，多事务，同时写入，多读一写。\r\n\r\n3，多事务，单事务内多次修改\r\n\r\n4，强制回收场景，snapshot too old，以及kill活跃事务。\r\n\r\n5，segment切换\r\n\r\n6，segment回收\r\n\r\n7，复制\r\n\r\n8，recovery场景。\r\n\r\n9，rollback场景	2020-03-03 07:12:16.55256	f
1199	578	Issue	5		2020-03-04 08:08:37.898635	f
1200	579	Issue	5		2020-03-04 11:52:14.068629	f
1203	578	Issue	5	还有一点尾巴，清理必须在事务内进行，则必须像vacuum一样初始化，而不是像辅助进程	2020-03-05 00:39:11.002733	f
1207	583	Issue	5	简单测试下，ci undo插入性能比btree索引差一点：\r\ntest=# insert into test101 values('abc',7, generate_series(1,1000000),1);\r\nINSERT 0 1000000\r\nTime: 15147.147 ms\r\ntest=# insert into test100 values('abc',7, generate_series(1,1000000),1);\r\nINSERT 0 1000000\r\nTime: 17430.082 ms\r\n\r\n给定一个数据模型下测试。\r\n1，ci tree的空间规模，这个决定了vacuum代价与scan代价。\r\n2，ci tree插入性能与btree插入性能对比\r\n	2020-03-07 00:09:28.849356	f
1208	585	Issue	5	掌握TCP-DS，OLAP的概念	2020-03-09 08:38:19.90533	f
1209	553	Issue	5	程序的步伐与手法：\r\n1，数据组织，及其特征\r\n2，软件的功能，运行框架\r\n\r\n分清主次很重要，功能的频率，不同数据的主要程度是不一样的。\r\n\r\n软件的本质就是使用计算机对事物的本质进行逻辑表达。\r\n这句话的重点在于事物的本质，事物的本质是由事物的内在关系决定的。比如书桌，其本质是含平面的容器（桌子），其次要特性是修饰语"书"。\r\n第二是逻辑表达，而不是其他表达，不是物理表达，也不是情感表达，色泽表达。\r\n\r\n软件的复杂性，一致性，可变性，不可见性都要求我们对事物的本质有统一而深入的认识。这就是软件编程难的地方。	2020-03-12 07:36:49.403957	f
1217	591	Issue	5		2020-03-18 06:49:29.027505	f
1220	472	Issue	5	日志接口分为elog和ereport，参考https://www.postgresql.org/docs/8.3/error-message-reporting.html。\r\n推荐使用ereport.\r\n注意如果ereport不指定错误码，与elog一样，默认是ERRCODE_INTERNAL_ERROR。\r\n这时错误信息会带上文件名和行号。\r\n\r\n对于输出到文件的日志都会带上最详细的信息。	2020-03-20 14:09:15.745406	f
1630	827	Issue	5	24：打通cursor上本地三个接口\r\n25，实现rlog\r\n26，实现rlog\r\n27，实现cursor上rlog相关操作\r\n29，实现后台定期线程刷object，管理dirty list\r\n30，综合调测\r\n31，综合调测	2021-03-23 15:00:43.987031	f
1631	827	Issue	5	执行框架基本ok，但是目前在cache模块遇到了点困难，cache拿出来不能执行。\r\n明天先把对象在rlog上缓存下看看。\r\n然后把flush实现，就可以看到对象修改结果了。\r\n还有rlog持久化管理等等。读取rlog等\r\n这样整体框架就有了	2021-03-25 19:27:36.608991	f
1632	829	Issue	5		2021-03-26 07:10:03.884156	f
1633	827	Issue	5	rlog中保留更改的对象列表，dirtyList。\r\n问题：如何从trait object得到实际对象？\r\n\r\n	2021-03-26 09:38:32.967989	f
1183	553	Issue	5	数据是生产资料，\r\n算法是服务，是工序，是一序列动作提供的能力。\r\n计算能力，逻辑能力，存储能力，传输能力，输入输出能力。\r\n从图灵机的角度来看，后面三者都是文件，文件是输入输出流。\r\n因而计算机的核心就在三部分：1，计算 2，内存 3，输入输出。\r\n\r\n数据是对现实的抽象。\r\n函数是对行为的抽象。\r\n\r\n同时\r\n程序的三个组成部分：计算过程(包含计算与逻辑)，输入输出，状态(内存)\r\n你会把锄头丢在田里吗？还是带回家。\r\n有状态与无状态对于程序有天差地别。\r\n无状态的程序只有输入输出，不必去查找状态。\r\n无状态的程序是不需要全局变量的。\r\n\r\n计算机表达关系的方式：\r\n1，使用指针，即一个指针指向关联数据。\r\n2，使用下标或者id，即有一种办法可以查找到数据，而且查找方式的部分信息在id之中。\r\n3，使用key，这是纯逻辑的表达方式，关系数据库就是使用这种方式。\r\n在内存中状态可以使用1，2，3三种方式表达。\r\n在外存中的状态只能使用2，3表达。\r\n表达的独立性与访问能力是成反比的，方式1最快，但是依赖性最强。\r\n想想如果所有状态都用指针表达，程序中各个模块就直接关联，这是不合适的。\r\n\r\n状态本身也会被组织起来，比如在ceph中pg挂在全局变量osd下，object cache挂在pg下。\r\n\r\n函数式编程特点就在于消除了状态，因而只有计算过程，输入输出。\r\n因而其存在大量的数据拷贝，因为计算的数据总是在计算时才需要。\r\n函数式编程无副作用。\r\n\r\n理论上无状态的程序可以随意分布，这是函数语言在并行计算下受欢迎的原因。\r\n如果一个程序执行时总是假设无状态的，则是可以随意分布与扩展的。\r\n这就是hadoop框架的实质。而spark在此基础上引入了内存状态。\r\n	2020-02-21 12:53:13.906134	f
1185	553	Issue	5	状态，用户数据，参数是三类基本的数据	2020-02-23 07:16:36.849402	f
1186	423	Issue	5	wal_consistency_checking:\r\n可以针对不同的rmgr配置，作用是确定replay即redo的逻辑是否正确。\r\n其逻辑：\r\n1，记录下当前redo record对应的修改后页面内容，为block1，\r\n2，在完成某个redo record的replay之后内容为block2，\r\n3，检查block内容是否一致。\r\n\r\n即完成了modify操作 和 redo函数效果是否一致的确定。\r\n不过greenplum不支持这个功能。	2020-02-23 20:04:17.897102	f
1189	577	Issue	5		2020-02-27 16:19:41.440917	f
1191	577	Issue	5		2020-02-27 23:06:28.074617	f
1193	560	Issue	5		2020-03-01 18:24:48.29787	f
1198	553	Issue	5	程序原本就是让数据的状态与数据的关系发生改变。\r\n函数语言是下一秒的你是上一秒的你与最新输入造成变化的叠加态。\r\n即一旦支持：\r\n1，数据表示\r\n2，数据关系表示\r\n3，数据及其关系的修改\r\n4，数据以及其关系的使用\r\n5，顺序，选择，循环的支持\r\n6，基本运算\r\n7，输入输出\r\n这样就具备了无限的能力。\r\n\r\n由关系的表达方式，诞生了关系数据库。\r\n对于时序特征的利用，诞生了时序数据库。	2020-03-03 11:46:44.97271	f
1201	580	Issue	5		2020-03-04 16:16:14.443761	f
1202	578	Issue	5	3和4未完成。\r\n3从目前看coral没有特别利用ac之处，\r\nac的核心特征是count，然而分布式下这个效果难说。\r\ncoral分为多个ac+ rowid的模式并非独创。	2020-03-04 22:30:43.436469	f
1204	579	Issue	5	pg的进程类型分为4类：\r\n1，postgres master\r\n2，vacuum\r\n3，auxiliary\r\n4，postgres\r\n\r\n其中2和4是可以启动事务的。\r\n\r\nbackendid是为了得到ProcState结构，这个结构里面有消息与vxid信息。\r\n\r\n\tvxid.backendId = MyBackendId;\r\n\tvxid.localTransactionId = GetNextLocalTransactionId();\r\n\t\r\nAuxiliary 进程没有这个，因而无法启动事务。\r\nAuxiliary有自己的PGProc结构，也在共享内存中。\r\nAuxiliaryProcs。\r\n\r\n数据结构：\r\n1，PGProc\r\n这个结构显然是需要的，存放每个进程的一些全局信息。\r\n它是放在共享内存中的，目的在于方便进程间同步，通信。进程持有锁在这里可以看到。\r\n\r\n也方便系统提供视图查询当前的进程情况。\r\n其共享内存空间挂载全局变量ProcGlobal上。\r\n注意总PGProc的数量是需提前准备好的，否则会错乱。\r\n新增一个后端服务，则对应的MaxBackends需要调整。\r\n\r\n2，PGXACT\r\n从注释看，该结构拿出来主要是出于性能。\r\n他描述的是当前process的事务信息，也存在共享内存中，通过ProcGlobal可以找到。\r\nGetSnapshotData需要从该结构获取数据。\r\n\r\n3，TMGXACT(greenplum引入)\r\n\r\nsubpostmasterMain：\r\n	2020-03-05 22:49:23.494243	f
1213	587	Issue	5	启动由ci cleanup进程启动，启动时获取databaseid。其来自于回滚事务列表的第一个事务的databaseid信息。\r\n\r\n所以这里有个问题，即databaseid信息来自于哪里？必须由cleanup找到，然后再启动回滚进程。\r\n\r\n已经回滚完成的事务记在哪里？ \r\n方案1：\r\n事务aborted状态即表明回滚完成。\r\n如果支持了事务级别的回滚能力，这他妈就是一个完整的undo了，而不是ci undo。\r\n可实际上这不就是一个完整的回滚段机制吗？\r\n\r\n扫描的截至位置即为rollback的起始位置，那实际上也不需要什么专门的rollback进程了。\r\n就在启动过程中进行rollback（错，启动过程也没法完成rollback，启动过程没有relcache信息）。主动rollback的进程则自己来完成rollback。\r\n\r\n方案2：\r\n记在共享内存中。\r\n这样存在的问题是如果cleanpos没跨过该事务的undo tuple，则重启后又得对该事务执行rollback。\r\n增加一个scanPos，scan得到具体需要回滚的databaseid列表，然后启动进程对该区间的undo进行rollback。\r\n但是这样实际上是按位置进行rollback，而不是按照事务。但是按位置又没法完整page粒度的清理，因为page内可能含来自不同database的undo记录。	2020-03-12 09:10:15.15727	f
1206	472	Issue	5	core配置：注意除了系统的core设置之外，pg_ctl要指定-c才能打开core。\r\nGreenplum可修改该脚本：install/lib/python/gppylib/commands/gp.py	2020-03-06 23:27:19.114522	f
1214	587	Issue	5	所以常见做法是将不同事务的undo page串联起来，以便于按事务粒度清理，rollback。	2020-03-12 11:34:25.120703	f
1205	583	Issue	5	搞清楚：\r\n1，pg进程如何单独启动调试 （显然，实现不了）\r\n2，pg的日志体系\r\n\r\n发现一个bug，ci的tuple中没有长度，因而ci_restore_page实现有问题。 （已解决）	2020-03-06 10:17:45.348226	f
1211	560	Issue	5	还有一个修炼是：\r\n把自己放在独立的位置，\r\n即不依赖于任何组织，不依赖于任何个人，不去恐惧比自己更强的人，也不与更弱的人做乌合之众。\r\n自由与独立。\r\n自由与独立就要求自己能不断按照自己的节奏变得更好更强大。\r\n	2020-03-12 07:45:00.388894	f
1212	586	Issue	5	abort测试出现功能问题。	2020-03-12 07:45:29.116145	f
1216	579	Issue	5	补充2：\r\n1，在pg上开发要注意内存从哪来。\r\n如果要在进程间共享就得在共享内存上创建，共享内存的空间是需要提前计算好的，采用预分配的方式。\r\n只有这样才能保证所有进程看到的共享内存地址空间是完全一致的。\r\n如果是全局变量，应该分配自全局生命周期的MemoryContext，而不是本地的事务MemoryContext。释放同样如此。\r\n\r\n2，多进程调试确实不便\r\n	2020-03-16 16:40:44.315957	f
1218	591	Issue	5	标哥识别的AC在OLAP应用中2大问题：\r\n1，AC的识别\r\n2，跨表AC问题，在TPC-DS场景下，他识别出的AC大部分都是跨表的。\r\n   这与其雪花模型设计有关系。大部分查询都是join的。\r\n\r\ncoral：\r\n如果用户按雪花模型设计表，那AC在coral中存在的意义是什么？\r\ncoral是不是只要管表的存储就可以了。coral is on Iot on cloud，这样其设计目标几乎与snowflake完全一致。\r\n其创建点仅在于使用自定义字段的多维索引，从而可以更好的过滤数据。\r\n\r\n而且按照snowflake的玩法，micro partition内的数据剪裁性能要求没那么高，多维索引这种高复杂度的实现有意义吗？\r\n\r\n还有一个问题是coral与gp，beas2.0的关系？	2020-03-18 08:49:35.304864	f
1219	472	Issue	5		2020-03-20 14:04:20.484038	f
1230	565	Issue	5	近期领悟的2要点：\r\n1，要有立腕的意识，有了立腕，甩腕就是自然的。不管什么球都要有立腕意识。这是手上快的意识之源\r\n2，脚上随时做好防御启动动作\r\n3，内外旋并非指手腕，还有小臂，是小臂加手腕的内旋运动。要想小臂围绕大臂内旋，则他们之间应该有一定角度。\r\n所以手臂不能伸直，也不能送太远，而是上臂与小臂之间保持大于90度的夹角。这点非常关键，否则实现不了内外旋.\r\n另外要体会侧身给手臂带来的速度加持。\r\n4，手指握紧发力。最后时刻的握紧是爆发力的来源。\r\n5,大拇指磨破皮说明一个问题，发力太靠后，因而力量需要大拇指制动。\r\n	2020-03-25 19:49:01.980909	f
1222	553	Issue	5	软件还有一点是行为，没有行为的事务就是静态的，是常量。 没有任何行为的软件是不存在的。行为即软件的执行，软件的流程，动作都是其行为。\r\n\r\n而且软件的数据与状态是用来支撑行为的。\r\n\r\n程序的灵魂在于数据结构与算法，为什么这么说？\r\n数据结构反应了事务的特征，特定的数据组织方式使得事务具体一些特性，而特性是用来支撑行为的，因为具备某些特性因而可以更好的具备一些行为。\r\n但不同程序在这2着之间的侧重点不一样，有的程序侧重计算，有的侧重数据组织。\r\n\r\n抽象的本质在于使用概念体系来表达事务，人类自然语言中也充满了概念和抽象。\r\n概念是将一堆有关系的事物作为一个整体，或将一类相近事物归纳为同一类。\r\n在程序中，结构体或类是最为重要的抽象语法。结构体与数组不一样在于结构体是直接地址访问，即结构体增加成员不影响其他成员的访问。\r\n有了结构体就有了抽象能力，同时也有了构建复杂事物的内部组织树的能力。函数是对行为与步骤的抽象。\r\n\r\n计算的本质是对事物关系的量化表达。比如求和，排序，比较，求差。求最小值，最大值，最短路径等等。	2020-03-20 14:38:17.851789	f
1225	593	Issue	5	ci_dodelete接口有问题，再想想ci的能力，以及提供的接口。\r\n在冲突时，search接口可以直接向右，而不从头开始。\r\n\r\n禁止在本事务内读取ci记录，仅RR隔离级别下。\r\n我们能否不支持同一个事务内记录的多个版本，本事务内扫描就只支持看到最新版本，其他事务看到老版本。在没有子事务的时候。	2020-03-24 08:12:02.653649	f
1227	593	Issue	5	节点重启后分布式事务id回到最小的问题。	2020-03-24 14:48:37.856878	f
1229	533	Issue	5	不，设计应该围绕核心数据结构与算法来，即我们关注的特性，以及该特性带来的核心优势上。\r\n接口是流程的入口，也是与用户直接打交道的，这是设计非常重要的一块。\r\n内部流程，比如gc，后端刷数据是一种内部接口。\r\n设计最最重要的部分就是理清系统涉及的概念，事务，是否新增概念。清理关系。\r\n流程内部实现的时候需要进行分解，分割成不可分单元，这就是函数。	2020-03-25 05:19:21.69459	f
1233	595	Issue	5		2020-03-26 20:59:56.770102	f
1231	565	Issue	5	我终于懂为什么杨晨大神说砸了，对就是砸，不考虑转身与怎么内旋，这就是砸的动作，想想怎么把一个东西丢远。\r\n砸就能用上手臂的力量，然后砸到高点才是后续动作。\r\n\r\n3.27附：\r\n凡是需要大力击球的，其实都是顶肘甩小臂的过程，没顶肘则出球不稳，力量不大。\r\n想想正手抽球，不出肘，则击球点在哪？\r\n反手更是如此，不出肘没法打。\r\n所以大力击球在发力阶段原理是一样的，动作也一样。区别在于击球点和挥臂引拍路径的差异。\r\n\r\n动作一致性都来自手指，学会了击球前的手指放松，最后的握紧变化，动作一致性自然就有了。	2020-03-26 06:07:14.891755	f
1235	559	Issue	5	其实不论正手，反手发力的核心都是一样的，那就是把身体的力量链条用起来。\r\n最初是整个身体，其次就是腰腹，再就是大臂，小臂，手腕，手指。\r\n1，每个部位都是发力之前要放松，发力时收紧。\r\n2，从一个部位转到另一个部位发力要连贯，这可能就是一个曲线。\r\n越好后面的关节发力时间越短，但速度的加成作用仍然在。想想下转身很快，但是摆臂很慢，那样是没用的。\r\n3，发力的行程要控制好，比如摆动小臂发力是引拍的末尾到头顶这段区间，多余的力发了不仅没好处，\r\n反而还造成动作不稳定，不隐蔽等问题。\r\n4，最最关键的一点就是手指发力，这要求引拍时要放松，再发力时握紧手指。	2020-03-28 16:06:58.397652	f
1238	597	Issue	5		2020-03-31 19:58:10.172408	f
1239	601	Issue	5		2020-04-06 19:17:46.547537	f
1240	188	Issue	5	羽毛球运动要素\r\n1，球拍\r\n球拍决定了其鞭打发力的特征，是一个速度为主的发力。\r\n2，羽毛球\r\n球的速度衰减很快，因而防守靠后更容易。\r\n球是弹性的，因而能否借力很关键。能借力球很轻松就过去了。\r\n\r\n3，场地\r\n注意场地是三维的，低位球，中位球，高位球差别很大的。\r\n4，人\r\n单打就是2个人，自己的优缺点，对方的优缺点都得摸清楚。\r\n双打各2个人，就讲究配合，交叉地带可能是一个薄弱点。	2020-04-12 09:18:57.518559	f
1241	606	Issue	5	比如ci undo的设计就是一个典型例子，显然应该设计通过的undo，不要回避问题。	2020-04-13 05:49:35.282016	f
1242	553	Issue	5	可变性：\r\n数据可变性与行为可变性，用户侧的是行为可变性。落实到软件则主要是数据可变性。\r\n因为对于软件其接口修改相对容易，而数据修改则非常困难，越是基础的数据越难修改。\r\n\r\n可修改性与结构的复用程度是成反比的，这点可能是架构设计的精髓之一。\r\n\r\n\r\n抽象可以降低复杂度，但是不合适的抽象将非常难受。	2020-04-13 05:54:12.254933	f
1243	608	Issue	5	octupus目前是直接向所有segment上发数据的。这样只有duplicated分布下是正确的。\r\nhash分布下数据会增加，而range分布下则查不到数据。\r\n\r\n存在2个问题：\r\n1，发给segment节点的数据不属于该segment的处理\r\n2，发给segment节点的数据进行repartition，在range分布下。	2020-04-13 14:09:31.053463	f
1847	958	Issue	5	思维的起点：\r\n1，这个世界是有因果逻辑的，即便是一定概率下的因果逻辑。\r\n   这就是我们做抉择的依据，利弊好坏等等可以不看，都是因果等参考。\r\n2，物质客观性\r\n3，空间，时间	2021-09-27 16:39:06.950093	f
1221	592	Issue	5	1，客户端执行路径，这里还可以看到出错消息处理\r\n<pre>\r\n#0  pqGetErrorNotice3 (conn=0x9b8960, isError=1 '\\001') at fe-protocol3.c:994\r\n#1  0x00007f0c14717f59 in pqParseInput3 (conn=0x9b8960) at fe-protocol3.c:284\r\n#2  0x00007f0c1470d895 in parseInput (conn=0x9b8960) at fe-exec.c:1740\r\n#3  0x00007f0c1470d9ae in PQgetResult (conn=0x9b8960) at fe-exec.c:1815\r\n#4  0x00007f0c1470e062 in PQexecFinish (conn=0x9b8960) at fe-exec.c:2088\r\n#5  0x00007f0c1470dcbc in PQexec (conn=0x9b8960, \r\n    query=0x9e1ec0 "select count(*) from test100 where x='abc' and y='1';")\r\n    at fe-exec.c:1922\r\n#6  0x000000000040b00d in SendQuery (\r\n    query=0x9e1ec0 "select count(*) from test100 where x='abc' and y='1';")\r\n    at common.c:981\r\n#7  0x000000000040f02d in MainLoop (source=0x7f0c144af640 <_IO_2_1_stdin_>)\r\n    at mainloop.c:257\r\n#8  0x000000000041520f in main (argc=2, argv=0x7ffdf522c8a8) at startup.c:330\r\n</pre>\r\n\r\n2，进程执行失败路径\r\n关键函数\r\n#define sigjmp_buf jmp_buf\r\n#define sigsetjmp(x,y) setjmp(x)\r\n#define siglongjmp longjmp\r\n结合日志，实现了异常跳转，出错处理。\r\n\r\n关键函数：EmitErrorReport\r\n实现了日志输出，不仅输出给客户端终止请求，还输出给server，文件作为调试信息。	2020-03-20 14:28:23.974997	f
1223	593	Issue	5	undo设计增强：\r\n1，支持增量的写入，不一样的实现方式，这样就无法通过x|y来查找对应的key用于回滚了，即回滚必须基于事务本身的信息。这是个大问题。\r\n对于ci而言可能没法简单的缩减。\r\n2，undo完全独立于ci，场景扩展，成了一个通用的框架，ci也应该是一个独立的框架。\r\n   当z加入之后，ci就得支持变长了，ci接口的再次梳理。\r\n3，支持各种不同type的回调函数，有没办法让ci的undo执行不依赖于relcache，即不必加载对应database的信息？\r\n4，支持事务粒度的回滚？这样就不需要扫描方式的回滚了，但是在恢复过程中需建立完整的事务信息。	2020-03-24 05:56:17.902288	f
1224	593	Issue	5	问题可能不在于不支持事务，而是信息有误。	2020-03-24 06:47:14.281149	f
1226	593	Issue	5	ci的fastpath优化	2020-03-24 14:33:38.826278	f
1228	593	Issue	5	预分配是一种比iov机制更少消耗的机制。\r\n\r\n设计的聚焦特性：\r\n1，结构特性：undo not only ci，undo的归undo，外部的归外部\r\n2，支持增量undo，这对于恢复模式要求，必须沿着版本链反向的rollback。即事务粒度的回滚。\r\n3，preserve空间的接口\r\n\r\n\r\n	2020-03-25 05:14:01.600571	f
1232	362	Issue	5	pg事务模块的整理：\r\n\r\npg与gp\r\n\r\nREADME文档：\r\n事务的接口\r\n分为三层：\r\n上层实现了对于每个语句都是一个事务。\r\n中层实现了对外提供事务语句，即控制事务状态的能力。\r\n底层实现了实际的事务语义。\r\n\r\ntransactionid的管理\r\n事务有VXID和SubTransactionId。\r\nVXID用于在没有修改操作时标识事务。\r\nSubTransactionId用于标识子事务，TopTransaction的SubTransactionId为1.子事务没有自己的VXID，其与父事务共享VXID。\r\n\r\n取快照与事务状态变化的并发：\r\n\r\n什么是快照？\r\n\r\n\r\nclog的维护\r\n父子事务的维护\r\n\r\n父子事务与可见性判断\r\n\r\nArchiveRecovery\r\n\r\n分布式事务\r\n\r\n快照\r\n\r\n与事务相关的全局结构\r\n\r\n\r\n事务与wal，checkpoint\r\n\r\nwal与pg_rewind\r\n\r\n复制的实现原理	2020-03-26 14:17:50.400202	f
1234	593	Issue	5	可能有个地方有bug，回滚的版本链上可能有来自不同事务的老版本，仅凭事务id来判断回滚位置可能有bug。	2020-03-27 08:33:15.657329	f
1236	565	Issue	5	击球时手臂就是在右边，但最关键的还是放松以及后三指的发力。\r\n扑球应该用大拇指顶宽面，球在身前的平抽也是如此，而且大拇指与其他手指垂直，这样有大距离顶压发力。\r\n时刻体会自己手指的发力。	2020-03-30 21:24:58.375682	f
1237	597	Issue	5	用户可以查看自己的用户信息，以及自己所属角色的角色信息。\r\n但不能创建用户和角色，看来这个限制了必须root角色才能执行。\r\n\r\n能赋予的权限：\r\nread or write\r\n\r\n权限作用的范围：\r\nkey，不包含权限本身。\r\n\r\ngrant和revoke的key需要对应起来么？\r\n可以给多个range么？\r\netcdctl不支持，后面的参数直接被忽略\r\nrange和prefix可以一起用么？\r\n也不支持，只能单个key，或prefix或range。\r\n会报错：\r\n./etcdctl --user="root:root" role grant-permission yy --prefix=true write b9 b10\r\nError: unexpected endkey argument with --prefix flag (前端错误)\r\nrange和单个key可以一起用么？\r\n也不支持\r\n可以用*指代prefix=true么？\r\n不行，没有通配符\r\n一次输入多个role也是错误的，不能一次添加多个。\r\nrole名称只要utf8字符串都满足？\r\nrole名称似乎没长度限制。\r\n可以带global option？\r\n可以，不清楚rpc也有支持的global option。\r\n\r\nhttps://github.com/etcd-io/etcd/blob/release-3.4/Documentation/dev-guide/api_reference_v3.md\r\nhttps://github.com/etcd-io/etcd/blob/release-3.4/etcdserver/etcdserverpb/rpc.proto\r\nhttps://github.com/etcd-io/etcd/blob/release-3.4/auth/authpb/auth.proto\r\n\r\n这命令可以通过，其将/xr1/ 与write视为一个range。\r\n./etcdctl --user="root:root" role grant xr read  /xr1/ write /xr2/\r\n这样也可以，看来不检查区间有效性\r\n./etcdctl --user="root:root" role grant xr read abc aba\r\n\r\netcdctl中role grant/revoke命令可以使用。\r\n但是revoke权限有bug！！！！	2020-03-31 19:57:08.534027	f
1244	608	Issue	5	刚才跟阿港看代码ao表选择导入哪个segment file是在master节点做的，master维护了使用状态。\r\nsegment节点直接假定ao表一个segment file上是不存在并发的。 这样直接给segment的ao表发数据是非常危险的，存在并发冲突。\r\n即octupus可能没法支持ao表。	2020-04-13 14:10:52.840636	f
1246	608	Issue	5	只要对数据进行partition并确定本地是否有对应分区即可。	2020-04-15 13:53:46.431827	f
1247	562	Issue	5	计算：UDF，窗口函数。\r\nRDD：内存列存，中间结果存储	2020-04-15 19:15:38.922413	f
1249	611	Issue	5	问题是这个方向对么？\r\n后面我们会做成怎样？\r\n\r\n这是一个临时方案，等路由表这块成熟后，就不再需要了。\r\noctupus的角色跟CN一样，从master获取路由数据，然后直接与segment通信.\r\nsegment仅需支持对于路由信息的判断，即在路由信息版本不一致时的容错处理。	2020-04-22 07:13:49.578983	f
1250	612	Issue	5	当稳定性提升，动作变小后。步伐也更容易轻快起来，不必为维持稳定而耗费很多。\r\n当能移动到位后，反手位的平高球，推后场的威胁就没那么大了。最终就能达到摸到6级的门口，即任何位置都没有很大压力。	2020-04-22 07:22:16.192679	f
1318	643	Issue	5	生长是一种可持续的改变，加以时间，这种力量改变了天地	2020-06-16 06:30:10.905175	f
1321	645	Issue	5	梳理知识结构，建立良好的大脑连接体系，这样在思考时就能快速的找到素材。\r\n\r\n逻辑推理又是什么，我们学得7*8 等价于7个8相加。	2020-06-17 06:45:07.478992	f
1245	607	Issue	5	1，space只是最基本的空间分配能力，块内的空闲空间管理由上层完成。\r\n2，使用space的主体有一层结构，该层对分配给自己的空间做映射，并自己做空间管理。\r\n3，space上一层名叫partition之类的，这层还没展开讨论。具体如何将表的列对应到partition上需讨论。\r\n\r\nspace管理这块：\r\n1，要考虑共享内存的动态创建，比如4g一个内存映射文件，支持按需来分配内存。\r\n   程序不要假设每个内存映射文件的地址是一致的。\r\n2，前期可支持提前分配，但不假设地址是一致的。\r\n3，block也有类似buffer的descriptor，其中包含如下信息：\r\nfree list（用于加速访问）， \r\nblock是否加载的tag，\r\ndirty标记，dirty list\r\n锁信息\r\n是否处于原子操作的flag\r\n4，space的元数据块，维护全局的freelist，以及一些元数据信息，统计信息。\r\n5，要支持lazy，parallel load，加载这块性能很关键\r\n6，空闲块使用list在头部分配还好，但是块内空闲空间使用list管理代价很大。\r\n\r\nAotmic：\r\n为什么需要原子操作？ 原子操作的封装或者叫抽象是为了简化涉及多个buffer的操作。\r\n原子操作有进出block的栈，用于保证有序的使用block。\r\n原子操作包装住多个buffer操作，在最后完成时统一刷redo，设置page的lsn。\r\ncheckpoint需检查如果buffer处于原子操作内，则要等待其完成。\r\n\r\n\r\n	2020-04-14 07:11:29.044041	f
1251	607	Issue	5	1,undo记录最多一次修改64条，就是spacebitmap对应的一个batch。\r\n在检查是否有空闲空间时，需要按照batch对齐。\r\n2，lock区一旦事务提交，就可以重用，而不必等到事务对所有快照可见。\r\nlock上不同事务的undo是串联的，及时的打破这个链对于性能是有帮助的。\r\n3，除了当前的2种形式的undo外，还需增加extend partition的undo，但该undo在extend成功即便事务abort也无需rollback。\r\n可以通过partition上的uncomplete imcs handle来分辨。	2020-04-22 14:20:18.388746	f
1253	612	Issue	5	需发力的击球都是从倒排的末尾移动到手指握紧，这是一个完整的发力过程。\r\n手肘的位置根据发力的路径适配。	2020-04-22 20:56:57.461738	f
1254	611	Issue	5	改动点4：\r\n需要将pg_partition和pg_partition_rule的oid下发segment，保持oid一致，虽然不是必须。\r\n具体参考CreateKeyFromCatalogTuple。 oid_dispatch.c中。\r\n	2020-04-23 09:18:23.709197	f
1255	354	Issue	5	共享内存一定依赖文件而存在么？\r\n解除映射后共享内存一定回写文件么？\r\n注：一个共享内存区域可以看作是特殊文件系统shm中的一个文件，shm的安装点在交换区上。\r\n是不是mmap这种方式会涉及文件？\r\n不同进程打开同一个文件，写入的自然是相同地址的内容。\r\n\r\n注：实际上，mmap()系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。\r\n\r\n\r\n注意：在IPC的通信模式下，不管是共享内存、消息队列还是信号灯，每个IPC的对象都有唯一的名字，称为"键(key)"。通过"键"，进程能够识别所用的对象。"键"与IPC对象的关系就如同文件名称于文件，通过文件名，进程能够读写文件内的数据，甚至多个进程能够公用一个文件。而在IPC的通信模式下，通过"键"的使用也能使得一个IPC对象能为多个进程所共用。\r\n\r\n\r\n问题：IPC下其他进程需要执行attach吗？子进程会自动继承吗？\r\n\r\n要素：\r\nshm key：file name\r\nshm id： file id\r\nshm： file content\r\n\r\nattach减为0时，shm一定会被删除吗？为啥系统中看到一些为0但是没删除的？\r\nIPC_RMID可以强制删除吗？\r\n\r\nipc有三种类型，其他类型也使用shm接口吗？显然不是的。	2020-04-27 05:47:30.494044	f
1256	354	Issue	5	显然system v共享内存与文件没关系，mmap才跟文件有关系	2020-04-27 05:48:41.744126	f
1262	614	Issue	5	1,一个segment创建后，之前连接的segment不可见，之后segment从master可见。\r\n2，一个segment extend之后，之前segment根据访问数据attach，之后segment自动从master\r\n获取attach地址\r\n3，测试分配和释放能力\r\n4，测试持久化与load（先仅支持直接加载）	2020-04-30 11:59:59.607894	f
1263	616	Issue	5	数据是增量的，计算也可以部分增量化	2020-05-04 12:00:54.900653	f
1264	615	Issue	5	并行计算\r\n批计算\r\n压缩计算\r\n连续计算（计算可中断）\r\n移动计算（计算过程传递给其他节点执行，hadoop的思想）	2020-05-04 12:13:55.503642	f
1266	155	Issue	5	计算机科学是研究事物行为，及其关系的科学。\r\n力学是研究事物之间力及其关系的科学。	2020-05-06 05:55:58.719186	f
1267	614	Issue	5	手动验证：\r\n1，启动2个连接\r\n1，在一个连接中创建space，然后分配页面使用，在页中写入10条数据。\r\n2，在另一个连接中查看数据\r\n3，新创建一个连接，查看数据\r\n4，重启，\r\n5，创建2个连接，其中一个调用命令加载数据，查看数据，然后释放页面\r\n6，另一个连接分配大量页面，触发extend。然后释放页面\r\n7，在原连接中查看数据\r\n\r\n基本用例：\r\n1，调用接口创建space\r\n2，调用接口分配页面，在页面写入数据\r\n3，一直到触发extend\r\n4，再释放页面，再分配，写入新数据\r\n5，调用flush刷数据，然后reload数据，查询	2020-05-06 15:08:32.635417	f
1270	614	Issue	5	问题列表：\r\n1，space单独使用redo\r\n出于效率考虑得这样做，为了保证space操作的原子性，需写undo\r\n\r\n2，latch使用sleep方式等待的代价是否过大\r\n3，block的full write没法使用buffer机制，在redo group内实现full write	2020-05-07 19:46:19.344896	f
1275	553	Issue	5	概念实体->空间\r\n动作序列->时间\r\n状态->变化	2020-05-15 06:28:11.135585	f
1278	624	Issue	5	还有个地方，创建共享内存后header需设置。\r\n如果从文件加载，则header中的poolid和handle就被重置。这里需要处理下。\r\n\r\n采用唯一key方式，8位segmented，4位magic，4位poolid，16位deviceid。\r\n100万device，则目录需要分层次了，限制device大小最小为32M，则16位deviceid，64K，总空间是2TB。TB级别的内存库，就非常大了。	2020-05-15 16:36:27.7376	f
1277	624	Issue	5	在进程退出时要能删除共享内存，否则影响下一次attach。\r\n在脚本中完成清理。\r\n\r\n不同segment实例看到的应该不一样。\r\ncreate过程attach了2次\r\n\r\n文件路径这块还得考虑清楚	2020-05-15 13:08:02.568859	f
1248	607	Issue	5	1，row group的block会先内部串起来，在失败时一次性释放，row group创建成果后会挂到partition\r\n2，为什么要partition？增加并发，方便管理\r\n3，rowset记录数不超过64条，默认值为64\r\n4，heap和icam记录相互指向？\r\n5，使用编译时assert优化，比如sizeof(xx) < BLOCK_HEADER_SIZE，该assert不需要运行时执行。\r\n6，原子操作有redo group，一个redo group里面有事务id，里面有多条redo\r\n7，ddl锁可以在上层实现，如使用gp的relation lock。\r\n8，上层尽量不要使用变长，短小的变长类型尽量转换为定长存储。（使用建议）\r\n9，extend parttition分配block失败，需要rollback，否则空间会泄露。\r\n10，mchInsertRows接口只是分配slot，SetColumn接口写入数据。\r\n11，row group中增加了对column index的索引，以方便快速定位某个column的column index起点。\r\n12，row group的column index可能存在空洞，如果一个block不能放入某个column的所有column index，可能会跳到下一个block分配。\r\n13，全局信息，事务等等都挂在session上，避免直接使用全局变量。\r\n14，not null block挂到column block上，没有column index。	2020-04-21 21:18:33.607352	f
1252	607	Issue	5	localBufUsed在小于local chunk size时是空闲空间高位的偏移。\r\n大于时，是使用的偏移。\r\n\r\n修改：\r\n1，给redo预留一点空间。\r\n\r\nsession是一个执行的上下文，一个语句可以有多个，并行扫描的时候。\r\n看样子有必要给写单独预留一个session，读单独起session。不过这也要看写是否会分配redo之外的内存。\r\n写事务创建一个session，读scan启用一个session。\r\n\r\n	2020-04-22 15:07:35.43991	f
1257	354	Issue	5	确实子进程会继承父进程的attach，并且kill -9杀死，attach也会释放。	2020-04-27 07:22:07.046439	f
1258	354	Issue	5	shmat给出null地址，系统会找page对齐的地址加载\r\nhttp://man7.org/linux/man-pages/man2/shmat.2.html\r\n\r\nSHMLBA实际就是pagesize：\r\n/usr/include/bits/shm.h:#define SHMLBA\t\t(__getpagesize ())	2020-04-27 14:05:02.768733	f
1259	607	Issue	5	检查undo方案下buffer是否为std，可以为std，虽然undo是追加写，但是page header仍然存在	2020-04-29 05:35:22.514068	f
1260	297	Issue	5	创业的本质是给世界上存在的问题提供解决方案并实施。\r\n\r\n比如蒋凡在阿里上位是因为给阿里提供了走上移动互联网的方案。\r\n拼多多黄铮的崛起是在当前的电商格局下提供了有别人阿里和京东的方案与实施。\r\n\r\n所以什么时候适合创业，当你发现了世界的问题，并找到有竞争力的解决方案就是创业的时候。\r\n\r\n如果连工作的问题都不能胜任，说明连改变自己都还有差距，还谈什么改变世界。	2020-04-29 08:02:18.865808	f
1261	614	Issue	5	1，dirty list如何串联\r\n2，如何load\r\n	2020-04-29 15:00:17.362698	f
1265	155	Issue	5	架构是什么？\r\n架构就是对系统上层概念层次的组织。\r\n架构是对系统中不容易变化的部分，是我们不想别人随意修改的部分。\r\n架构是系统中那些基本关系的假设。\r\n经常大改的软件即说明动摇了系统的基本假设，这种假设就是牵一发而动全身的。\r\n\r\n时间是序列\r\n空间是容器\r\n架构是一个技术线路，选择\r\n精力管理-脑力管理-体力管理\r\n无聊对于大脑的作用\r\n激发兴趣与降低难度	2020-05-06 05:54:46.813969	f
1268	614	Issue	5	全部写完再测试，lock和atomic，session都需想清楚。\r\n空间分配也在原子操作内，不要随便跳转。	2020-05-06 15:15:01.900756	f
1269	614	Issue	5	给shm key重试增加次数限制。\r\nspace空间管理不应该作为atomic本身，这样实现效率太低了，不同的进程都会涉及空间分配。\r\n要避免空间分配后没有挂到任何地方，需使用undo。	2020-05-07 06:44:45.220297	f
1272	614	Issue	5	每个pool都有脏页列表，不同pool之间是独立的。\r\n所有pool共享double write buffer。\r\nImcspool其中既有静态配置，又有ImcsPoolExtendMsg，这样合适吗？ImcsPool这个名称合适吗？	2020-05-09 15:32:55.748534	f
1273	619	Issue	5	什么场景下使用内存屏障？原子变量与内存屏障的关系，原子性与锁的关系？	2020-05-11 12:52:12.630704	f
1280	624	Issue	5	完善日志描述，后续定位问题非常有用	2020-05-18 14:12:19.820582	f
1274	619	Issue	5	13，要考虑将锁区部分移到block尾部，并按128字节对齐，以支持change number，用于检查page完整性。\r\n后续可能扩展支持校验码。\r\n\r\n14，预留几个cursor，提前分配好内存。 仅scan使用cursor。\r\nCBU分配内存时要注意对齐。先大块分配，然后再切	2020-05-12 09:53:09.422832	f
1283	553	Issue	5	改变接口-> 改变内部数据结构->改变内部行为	2020-05-21 04:18:54.376774	f
1276	553	Issue	5	数据的属性：可变性，可见性(共享性)，层次性(关系)，生命周期，空间性，持久性。\r\n      编程语言中表示：地址，值，类型(本质是数据长度)。\r\n行为的属性：有序性，并发性，原子性。\r\n\r\n\r\n特别的动作会有一些特别的属性，比如redo操作要具备可重入性。\r\n动作也有千变万化，就像羽毛球挥拍动作细节一大堆。	2020-05-15 07:23:55.103233	f
1281	628	Issue	5	思考：\r\n羽毛球挥拍其实前阶段不用很快，不是一个一直快的过程。前阶段是把身体，手肘搞到位，具备一定初始速度。加速在小臂和手腕手指上。\r\n鞭打与打的区别也就在此。 *刻意的练习慢和松，快和紧2阶段，肘到位是第二阶段的基础*\r\n\r\n步伐则相反：\r\n新手步伐总是启动慢，后面去追。正确的是启动快，后面根据球来。 刻意练习 "快速启动与击球后的回弹", 这是步伐的2个关键点。一个是借蹬地的力，另一个还借了挥拍的余力。这二步到位，步伐就能突飞猛进。要有哪只脚蹬地的意识。\r\n\r\n核心力量与蹬地力量的关系：核心力量可以调整上半身的重心与稳定，而腿部力量移动腿部用于蹬地与移动(本质是另一只脚的摩擦力)，使人位置发生改变。\r\n蹬地的力可以传到核心帮助转移，但是移动的力则不具备这效果。所以要明确蹬地与移动的区别。\r\n\r\n这种节奏不对，对重心影响很大。大力挥拍本身影响身体的稳定性，步伐最后击球时仍然在冲，身体就失去了平衡，也没法借助反弹的里回位。\r\n最终体力消耗比别人快很多。	2020-05-20 06:16:51.94803	f
1282	624	Issue	5	5.20 更新：\r\n1，文件删除仍然未完成，这块等元数据打通一起做\r\n2，异常情况下共享内存的清除，原来是记录在data下面的postmaster.pid文件中，找到一个segment对应的device进行删除。	2020-05-20 13:14:24.145844	f
1285	629	Issue	5		2020-05-23 18:59:40.479155	f
1284	629	Issue	5	稍微扩展下就可以支持了，build.py既然可以连master，自然连segment也不是问题。\r\n\r\n用扩展的方式实现pg的单元测试，模块测试	2020-05-23 18:58:51.63276	f
1286	630	Issue	5	取消，gp的fault是在extension function中自己发消息的，当然可以开发一个通用的消息框架给其他扩展使用。\r\n但是连到segment测试，这个在外面做也可以。	2020-05-23 19:01:49.964982	f
1287	631	Issue	5	甩的精髓在于放松，甩后逐节集中发力，甩上一节时下一节放松，并在其发力的起点。	2020-05-24 16:02:13.189305	f
1288	631	Issue	5	到目前为止，手腕的三种发力方式都学了，大拇指的顶，食指的压，后三指的放松与握紧。\r\n这些如果都能掌握好，然后不断加以巩固，则发力基础就具备了。\r\n\r\n技术：\r\n1，正反手抽球，后场高远球\r\n2，后场吊球，后场杀球\r\n3，前场的扑球，前场的挑球。\r\n4，前场的放网，推球，勾球。	2020-05-24 18:38:17.284551	f
1289	631	Issue	5	还有一点这次上去跟董雷拉高远时，发现自己有点被动了。我想原因是我甩大臂的发力减弱了，而手腕手指发力又没发挥好的原因。\r\n所以拉高远也是如此，主要的是发力效率的问题，并非发狠力。\r\n\r\n实际上编程工作又何尝不是如此呢？给自己固定时间，然后在此基础上不断改进。	2020-05-25 05:27:01.272375	f
1290	632	Issue	5	imcs heap主要处理的就是空间管理和并发控制。\r\n条件过滤，变长的处理都在外部实现。	2020-05-25 07:35:45.397942	f
1271	553	Issue	5	动作，状态，关系，架构是软件的核心。\r\n动作有顺序，分解，并行，并发，锁，异步等等玩法\r\n状态有cache，有分割，软件中完全是抽象的，你可以把一个状态放在一个结构体，也可以在另一个结构体，或一个子结构体，不同组织都影响了软件的实现。\r\n架构是软件中的基本抽象与框架，比如pg的datum， buffer， relfilenode。架构是改动很费劲的东西，软件中有2处难以改动：一是基本抽象，二是大体框架。\r\n基本抽象是说一切都是XX，比如对于生命体，一切器官都有细胞构成。这是微观层面的。\r\n大体架构是宏观层面的，比如动物和植物的架构就不一样，并且难以通过进化改变。人也难以进化成更复杂的形态，这就是架构。	2020-05-09 15:17:06.59863	f
1291	439	Issue	5	snapshot不可能实现串行化隔离：因为串行化要求事务必须可以像一个一个执行的效果。而snapshot只能保证事务内的执行顺序。\r\n例如：\r\n如果两个事务同时开始，相互读取对方修改的数据，那么使用snapshot，根据快照，互相看不到对方的修改，这就是串行化失败。\r\n参考官方串行化示例。\r\n\r\n串行化实现逻辑：\r\n1，事务的所有读操作（包括写操作的读）都加谓词锁，谓词锁是一种树状加锁。\r\n实际实现是如果系统有串行化事务，但是开始时机这块没研究。\r\n2，SI隔离下的写操作，判断是否有谓词锁冲突，如果冲突则串行化失败。\r\n\r\n隔离性本质上还是并发下的数据一致性问题。\r\n	2020-05-26 06:36:54.643358	f
1292	332	Issue	5	CAP理论的理解：\r\n\r\n一致性C与原子性A：\r\n一致性可以理解成一个动作序列，这些动作执行完后，系统(准确说是系统的数据或状态)满足用户定义的一致性状态。\r\n它是一个比原子性更广的概念，并且具备语义属性，也许改变执行序列或以不同顺序执行仍然满足语义一致性。\r\n\r\n原子性是说一个动作序列，要么全部执行，要么全部不执行，不可分割。其最终能够达成这个动作序列下的一致性。\r\n\r\n它面临的挑战有：\r\n1，操作失败，可在线处理失败的回滚\r\n2，并发\r\n3，故障重启，重启后的一致性\r\n4，分区，跨节点的一致性\r\n5，隐含约束\r\n\r\n对于1，可以使用原子性A来解决，即确保失败后能恢复成一致性状态。\r\n对于2，其实有不同的要求对应于不同隔离级别，并发控制来处理\r\n对于3，ACID的D，结合A一起实现\r\n对于4，Paxos协议或其退化形态实现(如选举+复制)\r\n对于5，ACID的C，定义隐含动作，使其满足用户一致性语义要求。\r\n\r\n	2020-05-26 07:32:38.451257	f
1294	569	Issue	5	CI不允许读取本事务内修改版本，这是一个巨大的限制。\r\n该限制存在的原因是CI的写采用的是RC隔离级别。（采用RC的原因是CI聚集的特殊性决定的）。\r\n即如果更新都是由其他事务完成，则CI支持RR隔离级别。	2020-05-27 13:35:52.709451	f
1293	439	Issue	5	对于RR的读：scan的时候根据事务(父事务？子事务？)快照来判断可见性。\r\nRR的写：根据scan拿到的TID，如果记录是已经被人删除了，则返回HeapTupleUpdated，因为不能基于一个删除的版本更新，次数更新失败。\r\n\r\n对于RC的读，scan拿事务的command快照判断可见性。\r\nRC的写：如果scan拿到Tid对应的记录被删除了，那么如果是hot update，则找到新版本进行操作，此处会再次进行条件判断看tuple是否满足条件。\r\n        如果不是hot update，则记录可能真的被人删除了，处理是跳过。\r\n\r\n可见对于RC，其实并非准确的基于command快照，只要更新了，则RC的写就可能对其可见。\r\n*RC并非完全基于快照*\r\n	2020-05-27 13:08:20.236747	f
1324	648	Issue	5	思考，情感与欲望是相互关联的，一体的。 欲望是行为的导火索。\r\n意义是思考和情感的矛，因为思考方式赋予了场景意义，而意义影响者人的情绪。\r\n\r\n这也是需要不断练习的，如果心灵不够强大，讲道理也是没用的，就像手上无力，还没掌握与体验时，你告诉他动作要小是做不到的。	2020-06-21 20:48:57.521398	f
1295	439	Issue	5	PG在scan拿到记录后，没有加锁操作。\r\n这样等修改再看该tuple时，可能已经被人修改。这时会出来再做条件检查。\r\n（注意pg的select for update也是这么玩的，先scan，满足条件加锁，如果冲突，在此检查条件，理论上可能反复很多次）\r\n\r\nmysql是scan过程中加锁，如果不满足条件就释放tuple lock。\r\n\r\n本质：\r\n1，mysql是通过长时间加锁\r\n2，pg是通过短锁+ 检查的机制。\r\n\r\n对于imcs情况更复杂些，imcs没法使用一个block lock锁住记录。要防止记录部分column被修改可见的情况\r\n	2020-05-28 10:27:02.655495	f
1296	633	Issue	5	https://tcbbd.moe/lang/rust/ 这篇博客中也有不少rust资料	2020-05-28 13:56:53.268772	f
1298	621	Issue	5	体会下小臂挥拍后，手指拳握，很明显在小臂挥拍时手指还是放松的，然后在小臂挥拍的末端，拳握集中发力球拍的速度会快很多。\r\n如果不是再次加速，则球拍的速度就跟小臂差不多。\r\n\r\n这跟大臂到小臂这一节的原理是一样的。也是鞭打的精髓所在。\r\n不过要注意下力量锻炼，因为这种力量是有反噬的，想想拿一个重拍这样拳握就有难度了。\r\n\r\n鞭打发力的引导：手引导发力，手可以快速的先动起来，尤其是手指手腕，这样反应链表比身体来得快，如果想每次都能鞭打，得建立这种良好的反射。\r\n              而不是只有时间来得及时才能进行鞭打。\r\n\r\n准备一个引子，脚的引子是下蹲，手的引子是立腕或展腕，这时其实同时也完成的握拍转换。	2020-05-29 05:18:48.404773	f
1299	634	Issue	5	在还没形成潜意识时，要通过训练和觉察来不断锻炼	2020-06-01 05:47:37.008346	f
1300	635	Issue	5		2020-06-02 04:36:19.190685	f
1301	635	Issue	5	1，做点小事\r\n2，独立负责一些事\r\n3，独立带小团队做一些事\r\n4，带大团队做一些事\r\n5，成立一个小规模公司\r\n6，管理一个中等规模的公司\r\n7，管理一个大型组织\r\n8，xx\r\n\r\n综合能力评定，如果有几个象限。\r\n有：\r\n1，技术\r\n2，管理\r\n3，外交\r\n4，方向\r\n5，财务\r\n\r\n其中最关键的是4和1，没这个没法开始。	2020-06-02 04:49:31.65288	f
1302	632	Issue	5	1，考虑锁区查询优化，比如分割，比如加bitmap加速判断。\r\n2，考虑下共享内存的大页问题\r\n3，column index的下标管理，实际上与table desc对应不上。\r\n对于变长，是否保留slot，指向同一个column index？这样column id还是外部定义的。\r\n这里存在2中语义，一是column在表中的id，另一个是在实际存储的表(imcs或heap)中的编号。	2020-06-03 13:09:49.46687	f
1303	636	Issue	5	内核为每个进程维护一个页表，如果使用小页面，则页表比较大，而且多进程下每个进程都得有。\r\n\r\n多进程与多线程下各做了些啥事。	2020-06-03 14:39:37.310359	f
1304	632	Issue	5	还有几个问题：\r\n1，提前break chain\r\n2，无lock时的等待，任意一个事务成功都可能\r\n\r\ncheck TODO。	2020-06-03 15:36:23.316069	f
1305	636	Issue	5	共享内存的原理都是将文件系统映射到进程地址空间，从而达到共享的效果。\r\nhttps://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html	2020-06-03 18:11:27.887897	f
1307	553	Issue	5	方法涉及的数据有：主体，客体，状态(状态通常用于与其他动作协同或控制其他行为)，输入材料，输出加工结果，或生成半成品或成品。\r\n概念结构涉及的数据：组成成分(组合关系)，关联关系，依赖关系。\r\n类型系统：继承，接口实现，类型转换。	2020-06-07 06:58:11.697921	f
1306	155	Issue	5	架构解决的问题是如何完成一个系统，分哪些角色，哪些组件，组件选什么，是分布式来做还是单机做，单机要不要搞多线程或多进程。\r\n组件之间交互的方式，通信协议等。\r\n\r\n设计模式解决的问题是如何让代码架构更加合理，适应变化。即其考虑的层面不一样。但两者确实有些交集。\r\n设计模式研究的是类的划分，生成，关联关系等\r\n\r\n具体编码还需考虑动作分解，概念的表达，命名，动作验证等等。\r\n\r\n软件将行为变得可以复制，这是软件改进生成力的根本原因。\r\n因而软件内部的动作，概念本身的可复制性，可发展性非常重要。否则只能推倒重来。\r\n\r\n编写函数时，一定要考虑其行为的抽象性，明确定义一个行为，行为的入参，出参。这样才是一个好的行为。\r\n否则会经常变化。就像打羽毛球一样，动作不固定，高手不是不变化，不受约束，高手是在通晓规则，遵守规则之后的灵巧变化。	2020-06-05 05:21:19.77093	f
1308	155	Issue	5	设计模式讲究以抽象方式考虑问题，比如文件系统抽象，文件抽象就是非常经典的例子。	2020-06-07 07:14:42.136771	f
1309	632	Issue	5	TODO：临时表空间的回滚问题。	2020-06-08 19:15:59.659923	f
1310	638	Issue	5		2020-06-09 04:09:03.878584	f
1311	638	Issue	5	看专业比赛软推，软挡很多。硬别人可以借力有时反而容易陷入被动。\r\n但不能快显然是个问题，如果对方站位很好，快的攻击力就没那么强。\r\n\r\n7分步法，3分手法，21分是连贯。\r\n\r\n什么意思：如果你会手法，可以得3分，如果会步法可以得7分，如果能很好把两者连贯起来，可以一战。	2020-06-09 04:34:41.100571	f
1312	632	Issue	5	支持多线程：\r\n1，快照\r\n2，undo\r\n3，内存管理\r\n4，事务可见性判断\r\n\r\nscan接口定义：\r\n行式接口与列式接口。\r\ntid接口	2020-06-10 06:24:37.201578	f
1313	632	Issue	5	如何定义session，cursor，接口使用与关系\r\n\r\n如果scan使用cursor，cursor需要做锁栈？\r\n\r\n\r\nsession对应于一个连接，假定一个连接同时只有一个写任务，但可能存在多个读任务。\r\ncursor对应于scan任务，\r\n\r\n多个连接可能在同一个进程。\r\n\r\n明确session和cursor接口\r\n内存分配和可见性判断可以通过注册外部函数来实现。\r\nud或需要改造	2020-06-11 07:45:33.312742	f
1314	553	Issue	5	程序是将行为变得可复制，不仅可复制，而且还可以基于复制不断改进，这就是其强大的地方，技术革命带来的生产力的飞速发展是人类最大的福利。\r\n\r\n行为，属性，状态，关系，算法，抽象	2020-06-14 20:31:47.338914	f
1315	553	Issue	5	有些特性具备传染性，比如不可重入的函数，是有传染性的。	2020-06-14 20:42:30.383503	f
1297	622	Issue	5	1，没有结构化思维的写程序。\r\n比如ci从undo读取数据的代码，只想着怎么把数据搞出来，毫无边界。\r\n\r\n编程应该从结构和行为入手，这些是概念自然引申出来的。不是为了动作而动作。那样是菜鸟行为。\r\n\r\n2,undo的数据链放到undo header是不合适的，数据链是由上层控制的，并不一定在该链上的都是同一条记录，比如IMCS的实现就不是。	2020-05-28 14:08:46.307132	f
1316	642	Issue	5	2020-06-15 18:52:31.566651 CST,"gpadmin","tpcdb",p33527,th-1310373696,"10.1.1.111","43388",2020-06-15 18:52:28 CST,1349,con217,cmd3,seg1,,dx1261,x1349,sx1,"PANIC","XX000","Waiting on lock already held! (lwlock.c:668)",,,,,,,0,,"lwlock.c",668,"Stack trace:\r\n1    0x96cb1a postgres errstart (elog.c:558)\r\n2    0x96f273 postgres elog_finish (elog.c:1730)\r\n3    0x85d569 postgres LWLockAcquire (lwlock.c:633)\r\n4    0x5de174 postgres _ci_getbuf (cipage.c:587)\r\n5    0x5de46f postgres _ci_getroot (cipage.c:133)\r\n6    0x5e4d1b postgres _ci_search (cisearch.c:71)\r\n7    0x5e4ea7 postgres _ci_search_item (discriminator 3)\r\n8    0x5e1b27 postgres ci_rollback (ci.c:1019)\r\n9    0x5b3bc3 postgres udRollback (udtracker.c:346)\r\n10   0x5901ff postgres <symbol not found> (xact.c:3302)\r\n11   0x593ba5 postgres AbortCurrentTransaction (xact.c:3996)\r\n12   0x86c8fd postgres PostgresMain (postgres.c:5003)\r\n13   0x52c741 postgres <symbol not found> (postmaster.c:4656)\r\n14   0x80f786 postgres PostmasterMain (postmaster.c:1546)\r\n15   0x52da8b postgres main (discriminator 1)\r\n16   0x7facae2e4505 libc.so.6 __libc_start_main + 0xf5\r\n17   0x52e929 postgres <symbol not found> + 0x52e929\r\n\r\nabort事务的时候buffer尚未释放	2020-06-15 17:11:22.157151	f
1325	280	Issue	5	我的选择：\r\n这世间游戏我要按规则玩好，做一个纯正的玩家，才能体会其快乐，作弊方式是体验不到快感的。\r\n所以我将奉行一下原则：\r\n1，公平交易的原则对待身体的一切人和事，拿到什么付出什么。\r\n互利互惠。\r\n2，不以作弊方式玩游戏，比如意外之财，比如用金钱作弊玩游戏，那是变味了的游戏，不会有乐趣。\r\n3，既不做“好心人”，也不去欺瞒控制。\r\n我不会随意馈赠，也不随意索取，我愿交易。这是对别人尊严的保护，这就是德。\r\n不对等的欺瞒控制本质上就是恶。这就是未成年必须保护的原因，因为他们尚未完成理解自己的行为，容易被欺瞒。\r\n	2020-06-21 21:07:42.922182	f
1326	648	Issue	5	为什么给别人讲对自己有帮助？ 因为这是一个思维外显的过程，也是一种审查方式，即我们怎么知道自己知道？我们如何确定自己是否在思维陷阱中，是否有漏洞？	2020-06-22 09:11:56.226783	f
1319	644	Issue	5		2020-06-16 06:35:05.74065	f
1320	280	Issue	5	你很疲惫？是你不够强大\r\n你不想要？是你能力不足\r\n放弃恐惧，过往只是经验，成长是当下每天的所为。\r\n害怕失去？害怕就意味着失去。唯有成长才能战胜恐惧，软弱。	2020-06-16 06:36:54.933511	f
1317	642	Issue	5	2中可能性：\r\n1，undo tracker错误\r\n2，清理逻辑错误\r\n\r\n1，在undo tracker中增加检查，如果事务确定为abort，则不必rollback\r\n2，先不跳过页面做清理，避免可能漏检查页面\r\n目前逻辑分析不会出现，如果事务未结束，则根据分布式事务id，oldestxmin仍然停留在该事务启动时看到的最小活跃事务。\r\n如果事务异常结束，则按逻辑重启后必须先rollback完，才开始清理。\r\n\r\n有没可能一个事务在后续不去拿快照，直接写数据，这样其事务信息比abort事务小。\r\n不可能oldxmin是所有事务都能看到得最小事务id，如果某个事务在abort事务之后写了undo，但其对abort事务又不可见，这是不可能的。\r\n\r\n\r\n3，drop使用md接口，避免checkpoint找不到文件\r\n4，mirror使用udtracker或有bug\r\n\r\n上述4问题已解决	2020-06-15 20:00:52.156495	f
1322	641	Issue	5	1已经解决。\r\n\r\n3，ci支持include变长记录\r\n  目前已经支持key的变长，因为长度变化就不是同一个key了，没有打破unique key的约束。\r\n  这时delete，exec方法都得循环了，因为ci上会存在重复记录.	2020-06-17 17:47:38.484216	f
1330	254	Issue	5	软件工程关注：\r\n1，可测试性\r\n2，可观测可监控\r\n3，持续集成，团队配合，项目管理，工程效率\r\n4，可调整性\r\n5，安全性\r\n	2020-06-23 14:20:49.774177	f
1331	647	Issue	5	打点的意识，击球点非常重要。\r\n启动意识，借力的意识。\r\n即便重杀，最后还是通过手腕用力，把身体其他的力借到手腕上。\r\n目前打球还是没传递到手腕\r\n\r\n后场如射炮，中场如杆枪，前场是手术刀。	2020-06-25 23:04:44.983635	f
1335	155	Issue	5	软件架构的定义：就是关于软件中的组件，以及其关系组织结构。\r\n架构的核心目标是应对可变性，复杂性。\r\n可变性是系统的生命力，本质复杂性是系统的能力来源。\r\n\r\n组件我们知道，主要是选择，这与团队能力模型有关系。\r\n\r\n关系则相对微妙，什么是关系，比如说文件系统暴漏的fd，事务系统暴漏的事务id。\r\n这些就是子系统对外暴漏的概念，暴漏的概念就会形成依赖关系。\r\n\r\n比如你讲文件系统内文件内容结构暴漏出来，那内部实现就暴漏给外面了。\r\n\r\n所以概念很重要，而且概念大家理解可能不一致。\r\n而且实际设计时概念会加上很多限制词，要注意限定词是可变性的大敌。\r\n比如ci undo， ac cache。\r\n这种一致性理解对于设计和核心开发团队非常重要。\r\n架构师工作于抽象层次，要学会用概念，关系，依赖等角度来看待软件。\r\n\r\n容器通常提供迭代器的访问方式，比如数组，其实undo空间也是一个容器。\r\n	2020-07-04 04:12:22.075193	f
1336	655	Issue	5		2020-07-07 15:58:38.882824	f
1337	654	Issue	5		2020-07-08 08:24:29.69269	f
1343	655	Issue	5	讨论纪要：\r\n关键点：\r\n1，上云后，最好device可以共享，否则数据大量冗余。\r\n因为云盘本身就有多副本。\r\n\r\n2，如果不使用读写节点分离，则系统的读负载能力就取决于写节点数。\r\n而写节点数量又与分区规则相关。\r\n\r\n结论：\r\n读写分离方案的问题：\r\n1，cn需感知micro partition信息，但micro partition在dn上生成。\r\n2，读节点仍然有同步partition元数据需求，否则一致性难以保证。如果读节点任意扩展，同步怎么保证？\r\n\r\n读写不完全分离，将备机作为读节点，并且分为物理备机和逻辑备机。\r\n逻辑备机不同步active partition，但是需保证其他partition的元数据一致性。\r\n如果读压力过大，则扩展逻辑备机。\r\n	2020-07-08 15:40:38.005778	f
1345	654	Issue	5		2020-07-08 16:33:44.572405	f
1339	655	Issue	5	方案：\r\n其他都维持一样，proceesor也基本跟以前一样，有自己的局部数据。\r\n但是每个partition内采用micro partition来管理空间，采用全量+delta方式管理。\r\n扩展节点也非常容易，因为processor上数据不多。\r\n\r\n这里有一个问题：我们是像snowflake一样完全弹性扩展吗？还是仅解决数据扩展问题？\r\n\r\nsnowflake出发点：\r\n1，SaaS\r\n自管理，多租户\r\n\r\n2，弹性扩展\r\n应对数据的爆发式增长\r\n这个对于企业用户通常没那么迫切，互联网用户增长可能是从1到100.\r\n企业用户通常是从100到120.\r\n\r\n3，半结构化数据分析\r\n这里是一个关键点	2020-07-08 09:17:36.470247	f
1347	654	Issue	5	IMCS可能支持not all in memory形态，支持换到ssd等。	2020-07-08 18:40:31.930562	f
636	292	Issue	5	9，人都喜欢权力，同时模糊责任。 权力的本质就是选择决定的能力。能者居之，意思就是让具备选择决定能力的人来做决策，同时应该尽量避免独裁，独裁者成功与其能力成正比。\r\n权力是支配别人的行为，控制。\r\n10，欲望总是需要更强烈的刺激来满足，减弱会让人难受，只有强者能觉察并主动选择。\r\n11，人都要未准备好的时候，在此之前说什么都没用\r\n12，人只能看到自己能看到的，还有别人想让你看到的。\r\n13，时机未到，功力未到，你看不到本来可见的东西，就像自然不会把一切直接展示给你，你会疯掉的。\r\n这或许就是大脑的屏蔽机制，有利有弊。或者这一切都在你脑中留下了痕迹，只是你还未曾发现。	2019-03-03 21:51:00.526613	f
1327	647	Issue	5	7，打球要尽量迎上去打，抢前点。所以打完高球一点要前移一点，不然中路和前场都是空挡。\r\n8，高远球为啥要高？只有这样才能将对方调到后场。	2020-06-23 05:42:57.798963	f
1360	660	Issue	5		2020-07-17 12:50:17.763362	f
1328	646	Issue	5	不不不！\r\n关键点是顶肘，想想看只有顶肘，小臂才能后倒，小臂后倒才有充分引拍空间。\r\n想想高远球是向上弹出去的，实际上只要稍微爆发力，仅仅手腕手指就可以弹到对方后场。\r\n这不仅仅是力量的问题，是后倒之后力量有效的作用于球拍的效果。\r\n\r\n中羽有个帖子挺好，想象你是用手肘打球，够不着用手掌打，再够不着用手指。\r\n\r\n知道新手偶尔可以打好杀球，但是打不好高远的原因。\r\n\r\n用一个词来形容就是弹射，像大炮一样。	2020-06-23 05:46:32.890652	f
1329	610	Issue	5	行为分解，描述你干了啥：我今天开车回家了。\r\n再具体点：从哪里出发，怎么下楼，怎么上车，怎么启动，怎么走，路上会遇到什么等等。	2020-06-23 07:20:46.414747	f
1332	648	Issue	5	这本书的重点：\r\n0，批判性思维要求对自己的思维过程进行观察并不断改进\r\n1，思考，情绪，欲望之间相互关联的关系\r\n2，意义对于心灵的重要性\r\n3，思考的8个要素，以及每个要素的理解\r\n4，思考的陷阱\r\n4.1 自我中心\r\n4.2 社会中心\r\n4.3 稀缺\r\n4.4 感知屏蔽与思维简化\r\n5，校验\r\n要有方法校验，没标准就难以改进\r\n	2020-06-27 16:24:22.703266	f
1333	651	Issue	5	竞争的汇报非常丰厚，但是代价也非常大。	2020-06-27 18:14:38.017467	f
1334	579	Issue	5	还要注意这个函数AssignPostmasterChildSlot。\r\nPMChildFlags，看注释其用于检查后端进程是否是从共享内存干净的退出的。\r\n但实际上没看到检查的地方。\r\n\r\n注意这个分配和释放要匹配，不然slot用完之后，没有slot可用会导致postmaster fatal错误而挂掉。	2020-06-30 07:37:52.481526	f
1338	654	Issue	5		2020-07-08 09:11:05.974764	f
1340	655	Issue	5	这跟pg的external table，fdw都不一样。fdw通常对io模式有限制，不支持更新，删除。	2020-07-08 12:01:20.124717	f
1341	655	Issue	5	coral出发点：\r\n1，海量冷数据\r\n如何低成本存储，并且高效查询\r\n对象存储，AC\r\n2，半结构化数据	2020-07-08 12:14:42.140004	f
1342	155	Issue	5	架构还涉及在架构团队之间共享的知识和概念。\r\n\r\n架构讨论要抓住关键关系，这些点虽小，但牵一发而动全身。这是架构之微妙。\r\n	2020-07-08 12:25:00.767084	f
1344	655	Issue	5	还有一块没讨论：\r\n1，半结构化数据\r\n半结构化数据的分解在SQL引擎层完成，在SQL引擎层做这层映射。\r\n2，基础AC	2020-07-08 15:47:18.173252	f
1349	657	Issue	5		2020-07-09 11:46:01.646215	f
1352	655	Issue	5	coral逻辑备机没法保证一致性读，允许逻辑备机存在一定的同步时差，在cn上取一个老的scn来读取。	2020-07-09 15:30:48.869662	f
1354	155	Issue	5	https://www.martinfowler.com/architecture/\r\n\r\n架构的几个属性：\r\n1,the shared understanding that the expert developers have of the system design.\r\n2,the decisions you wish you could get right early in a project.\r\n3,Architecture is about the important stuff. Whatever that is.\r\n\r\n即多讨论，尽早讨论，找出那些重要的事情，这是一个架构师该有的品质。	2020-07-09 15:39:05.148508	f
1355	654	Issue	5	imcs支持将多个ac放入一个slice\r\ncoral支持hash索引，以便支持快速的点更新\r\n变长部分也要转移\r\n索引可总指向imcs记录而非变长，再通过imcs找到变长，暂不使用反向链\r\nimcs slice block可以是32k，这样其slice与coral直接对应起来	2020-07-10 06:59:35.643246	f
1323	645	Issue	5	参考书籍：\r\n金字塔原理\r\n思考的快与慢：附别人的读书笔记，https://zhuanlan.zhihu.com/p/65313710\r\nhttp://www.woshipm.com/zhichang/3034414.html\r\n\r\n这里面提及的一个观点很有意思：\r\n1，思考力的阈值，科学家持续思考的能力比普通人强，而且也没普通人容易累。\r\n这点真跟体能差不多啊\r\n2，思考的积累，知识的积累\r\n积累能让你熟能生巧，不那么费力就完成一些事，思考也是如此。\r\n3，思考的方法\r\n这点也非常关键，遇到全新问题时，如何思考。	2020-06-19 12:25:47.97463	f
1358	660	Issue	5		2020-07-17 07:52:19.717785	f
1359	660	Issue	5		2020-07-17 12:49:56.512094	f
1367	553	Issue	5	行为变化多端，行为每步的顺序。并行，延迟。\r\n模块划分也有各种变化。\r\n节点架构也有多种玩法。MPP架构，计算存储分离架构。	2020-07-30 12:14:11.806831	f
1368	553	Issue	5	分析，抽象，推理\r\n关系，行为，状态\r\n构件，组装，实战	2020-07-30 12:17:43.205383	f
1363	582	Issue	5	分析，抽象，推理，封装，记忆\r\n\r\n其中前2个都是跟结构化有关系，概念和事务的结构化理解。\r\n推理是关系的处理，涉及变换，转化，反证。\r\n\r\n对应于程序中，状态，关系，转换。\r\n这些特性使得程序具备行为，以及有益属性，从而对人展现于价值。\r\n	2020-07-20 07:29:26.721309	f
1490	659	Issue	5	羽毛球除了多关节旋转逐步节发力外，\r\n还有一个核心点就是弹射，弹射是为什么要握紧球拍的原因。\r\n另外一个点是击球时机：\r\n1，在加速期击球，重杀和包击是这种情况，羽毛球受力时间长，因而减速慢。\r\n2，在最高速时击球，这是点杀和推球常见情况，出球快，但是减速也快。\r\n3，在挥拍减速阶段击球，这是网前球会用到的。	2020-12-02 14:46:02.537799	f
1492	711	Issue	5		2020-12-05 07:24:02.958492	f
1496	718	Issue	5		2020-12-19 06:43:46.323051	f
1499	649	Issue	5	软件设计就是不断分化的过程。\r\n就如同实现世界一样。不断迭代分化，复杂度提升，结构出现分支，支持了新的功能。\r\n\r\n分化过程要尽量合理，不是人为造作的。像万物生长一般，这既是约束也是锤炼。\r\n	2020-12-19 15:03:40.142029	f
1348	653	Issue	5	法家思想就是压在人民身上的那座大山，然而法家的人本身都聪明，独立，思辨。\r\n这不是一种讽刺么，儒家讲己所不欲勿施于人。\r\n儒家也却有问题，就如荀子而言，人并非道德驱动。\r\n所以最终选择外儒内法是比较符合人性的。\r\n\r\n从人性的角度也可以看出政治，人有情感需求，也有利益需求。\r\n如果你对于他人既有一定情感基础，同时也有利益帮助，则关系稳固。\r\n	2020-07-09 06:56:49.795826	f
1350	657	Issue	5	update的scan使用RC,但实际更新时check使用cc，必须基于最新版本进行修改。	2020-07-09 11:47:20.815181	f
1351	654	Issue	5	IMCS的锁区效率问题，因为其记录上没有预留字段来指向其使用某个锁区。	2020-07-09 11:53:23.107288	f
1346	655	Issue	5	imcs可以作为coral本地存储形态。\r\n但是imcs一个row group可能太小，或将其扩大，或多个row group合并写入一个coral file。\r\ncoral一个文件记录数量要达到一定值，这样比较好的利用TP引擎的预读机制。\r\n\r\ncoral可支持多种本地存储形态。\r\n标哥提及将imcs的partition改为slice，然后将slice合并成coral的文件。\r\ncoral自身采用extend/page方式，外加索引信息等。\r\n\r\n然后coral的海量读压力，通过支持一致性逻辑复制的备机来解决。	2020-07-08 18:39:45.679321	f
1353	654	Issue	5	创建一个coral类型的表，其活跃slice使用imcs或heap格式存储，stale的slice使用coral的file格式存储。	2020-07-09 15:33:22.348733	f
1356	655	Issue	5	coral增加子表，每个子表就是一个slice，子表可以使用imcs，heap等格式。\r\nslice有active和stale状态。\r\n转换时将slice数据scan出来，然后在内存进行格式转换，压缩等，再写入远端，成功后删除本地表。并增加统计信息和valid bitmap。	2020-07-10 07:55:41.224516	f
1357	654	Issue	5	在锁区 itl上增加事务状态信息。	2020-07-10 09:24:02.072566	f
1361	648	Issue	5	批判性思维要求我们使用慢思维，而不是尽快得出结论。审视自己思考的过程。	2020-07-20 05:20:09.392664	f
1362	662	Issue	5	电脑相对人脑缺乏的是：\r\n1，抽象能力\r\n2，想象力\r\n\r\n	2020-07-20 07:21:27.237757	f
1364	658	Issue	5	认知，目的->思考，思考->情绪，行为。 这些都是操作系统范畴。\r\n\r\n通过改进底层，升级系统，开花应用，行为之花。\r\n\r\n使命：为人类的生产活动提供最佳的存储形式。	2020-07-20 08:12:00.039019	f
1365	659	Issue	5	手指手腕后倒，小臂外旋。\r\n击球过程，小臂内旋，手指变拳握，力量会爆炸。	2020-07-22 05:45:32.829265	f
1366	666	Issue	5	儿童时期是人生一个特殊时期，如果在成年期遭遇障碍，人可能期望回到童年时期，然而时间不可逆。\r\n人只有在当下成长过程中去寻找新的意义和快乐。\r\n\r\n人不必刻意追求变得强大，人追求快乐，这过程本身就需要成长。强大可以更好的玩游戏。\r\n但强大不一定能玩好游戏。就看这强大本身为什么服务，强大的意义是什么。\r\n\r\n放下工作回老家，过农业生活，很美妙？ 那只是人们的妄想。 认真思考下就知道那样面临的问题比当下多很多，除非你真的具备能力能在那环境下很好生活。\r\n\r\n我难道不应该感谢这个社会吗？ 感谢公司提供了工作不仅给我钱还提供我成长的平台，感谢人们制造的工具，让我节省了不少时间。\r\n开心快乐是一种能力。	2020-07-28 05:33:55.209136	f
1369	666	Issue	5	童年时期的快乐建立在1，由其他人提供物质基础。 2，人与生俱来的学习能力 这2点上。\r\n在成年期这2点都需要自己克服困难才能维持。\r\n\r\n人生在世，就是体验这个世界的过程，主要是个体与世界的关系，个人与其他个体的关系。\r\n如果你将自己的目标定为成为更强的自己，那么每天你关心的是自己时间花在哪里，今天我增强了哪些？那些其他人的世界我们无法感同身受，也不在关心。\r\n别人再强，再美好，而我仍然要走自己的路。无论遭遇什么，我都有能力适应并很好的生活下去。\r\n人痛苦在于期盼着不切实际的外界的诗和远方，然后这诗和远方其实就在自己内心。\r\n人痛苦还在于找不到方向，这里看看，那里找找，然而始终迷茫着。没有理想，即没有目标，没有目标就没有意义。\r\n	2020-07-30 12:20:43.388088	f
1370	667	Issue	5		2020-07-30 19:48:25.711247	f
1377	677	Issue	5	1，检查\r\n是否ac上该key具备唯一性，估计是这样\r\n2，能否在scan undo时检查如果事务未提交，则undo tracker必须存在。\r\n3，是否存在undo强制被清理的问题。\r\n4，增加undo保留时间，以便确定写入的undo的真实情况。\r\n\r\n如果推断数据必然是delete未成功导致，rollback遗漏，undo被清理因而无法做行级回滚。\r\n此问题出现都是在undo被清理时。\r\n还有一种可能是行级回滚有bug，数据不对。尤其是在反复删除失败的情况下。\r\n\r\n审视：\r\n1，事务异常之后，一定会rollback么？ 会不会某些情况调不到rollback。\r\n这里可以检查下，看看有没in progress的事务。还可以增加检查在行级回滚时，如果使用行级回滚，则必然是有ud tracker，事务应该处于未结束状态。\r\n2，主备切换tracker有没可能没运用。\r\n	2020-08-10 05:41:27.641901	f
1379	677	Issue	5	2020-08-06 18:26:04.502093 HKT,,,p119835,th-1442453568,"10.1.1.111","50030",2020-08-06 18:26:04 HKT,0,,,seg3,,,,,"LOG","08P01","incomplete startup packet",,,,,,,0,,"postmaster.c",2225,\r\n2020-08-06 18:26:04.684138 HKT,,,p119839,th-1442453568,"10.1.1.111","50054",2020-08-06 18:26:04 HKT,0,,,seg3,,,,,"LOG","08P01","incomplete startup packet",,,,,,,0,,"postmaster.c",2225,\r\n2020-08-06 18:26:04.928759 HKT,"gpadmin","tpcdb",p119568,th-1442453568,"10.1.1.111","44792",2020-08-06 18:24:13 HKT,12589,con180,cmd18,seg3,,dx2464,x12589,sx1,"LOG","00000","Process interrupt for 'query cancel pending' (execProcnode.c:969)",,,,,,"delete from web_sales where ws_item_sk = 5401",0,,"postgres.c",3833,\r\n2020-08-06 18:26:04.928817 HKT,"gpadmin","tpcdb",p119568,th-1442453568,"10.1.1.111","44792",2020-08-06 18:24:13 HKT,12589,con180,cmd18,seg3,,dx2464,x12589,sx1,"ERROR","25M01","canceling MPP operation",,,,,,"delete from web_sales where ws_item_sk = 5401",0,,"postgres.c",3942,\r\n	2020-08-10 06:42:53.968192	f
1381	677	Issue	5	最后分析是二阶段提交中abort prepare动作可能由其他backend执行导致。其他backend就不具备一些全局变量了。	2020-08-12 17:18:44.731063	f
1371	643	Issue	5	增长3倍，别人能明显感觉到你的变化。\r\n增长10倍，你将看到不一样的世界。\r\n如何增长，保持独立自由，放下私心，让自己直面这个世界，独立思考，直面问题，不断练习，纠正。\r\n改造自己认知，寻找意义，营造自由自主且积极的世界观。\r\n\r\n为什么回不到童年的快乐？\r\n1，物质基础\r\n2，学习能力，童年是快速成长的。\r\n3，认知新鲜事物的，世界是展开的。\r\n虽然回不去，但是我们仍然可以有这种快乐，怎么做：\r\n1，热爱并努力工作，解决物质基础\r\n2，维持持续学习，应对不断出现的困难与问题\r\n3，热爱生活，保有对世界的热情\r\n这样就能保有仁和乐，就像孔圣人一样，生机畅达。\r\n	2020-07-31 05:05:43.729647	f
1384	679	Issue	5	田园上种植了可以转卖的劳动成功。\r\n\r\n祥和的人生可能是既可以享受田园农作，也可以以自己的方式与海相处，也可以偶尔登登高山，看看自己也看看别人的风景。\r\n但这一切或许都得以身体作为支撑，这是生命之重。\r\n\r\n时间是财富，但要以活泼健康的时间，剑雨中的人不惜一切只为补全自己，可见财富是什么，就是那个想要的自己和自己的时间。	2020-08-17 05:48:01.742057	f
1373	654	Issue	5	锁区存在两个问题：\r\n1，判断事务状态每次都得读undo，锁区没事务状态信息\r\n2，并发时每个锁都得检查\r\n3，undo链表非常深，每条undo都得检查。\r\n因为不知道下一条undo是否影响了该行。\r\n但是一旦事务某个锁区最新事务提交，则不必去判断之前的undo了，因为最新状态就在CBU上。	2020-08-05 13:08:27.646914	f
1374	659	Issue	5	闪腕击球，腕部是不发力的，是小臂发力把手腕甩起来，并且手指握紧的过程。\r\n当然在逐节发力中，前面一节都是只有到它发力时才握紧。	2020-08-05 21:33:50.774248	f
1375	675	Issue	5	看专业比赛很明显，发高远球的出球速度非常快，几乎跟杀球一样。	2020-08-05 22:03:52.545539	f
1372	671	Issue	5	世界观：\r\n1，世界是分化的\r\n分化因而产生名，新的概念，新的关系，以及新的功能，同时也产生新的问题。\r\n结构化，越来越复杂，也越来越精细。\r\n2，事务是发展变化的\r\n\r\n价值观：\r\n1，意义是赋予的，是对于状态的偏好。\r\n2，交易存在价值，透明交易就是德。\r\n\r\n人生观：\r\n1，每个人看到的世界不一样\r\n2，人只能看到自己所能看到的世界，受限于人的身心，认知等\r\n\r\n三观是思考的起源，是认识世界的根本。	2020-08-04 06:45:26.287504	f
1376	553	Issue	5	事务具备动作能力，但催动还得有其他因素。\r\n就像地球是太阳能驱动的。\r\n\r\n能动者，线程就是代码的太阳。\r\n但线程本身由系统驱动，系统由时钟和电源驱动。\r\n\r\n事物，包含资源，资源可能是空间，也可以是其组成部分。可能是其他事物。	2020-08-06 06:42:16.555248	f
1380	677	Issue	5	./gpdb-2020-08-06_180816.csv:2020-08-06 18:26:04.126012 HKT,"gpadmin","tpcdb",p119827,th-1442453568,"10.1.1.111","49992",2020-08-06 18:26:04 HKT,0,con196,,seg3,,,,sx1,"LOG","00000"," rollback top transaction 0 from 0",,,,,,,0,,"udtracker.c",287,\r\n./gpdb-2020-08-06_180816.csv:2020-08-06 18:26:04.126093 HKT,"gpadmin","tpcdb",p119827,th-1442453568,"10.1.1.111","49992",2020-08-06 18:26:04 HKT,0,con196,,seg3,,,,sx1,"LOG","00000"," rollback top transaction 0 successfully",,,,,,,0,,"udtracker.c",369,\r\n什么情况会是从0到0？在没有rollback子事务的情况下？	2020-08-10 06:50:22.035641	f
1378	677	Issue	5	还有一个可疑点：undo出现过跳转。\r\n./gpdb-2020-08-06_162917.csv:2020-08-06 18:00:51.047382 HKT,,,p104244,th315250624,,,,0,,,seg3,,,,sx1,"LOG","00000"," set undo clean page to 20223, clean xid 11090",,,,,,,0,,"ud.c",921,\r\n./gpdb-2020-08-06_180816.csv:2020-08-06 18:17:23.504090 HKT,,,p108639,th-1442453568,,,,0,,,seg3,,,,sx1,"LOG","00000"," set undo clean page to 20226, clean xid 11315",,,,,,,0,,"ud.c",921,\r\n./gpdb-2020-08-06_180816.csv:2020-08-06 18:18:23.564668 HKT,,,p108639,th-1442453568,,,,0,,,seg3,,,,sx1,"LOG","00000"," set undo clean page to 20232, clean xid 11866",,,,,,,0,,"ud.c",921,\r\n./gpdb-2020-08-06_180816.csv:2020-08-06 18:19:23.625529 HKT,,,p108639,th-1442453568,,,,0,,,seg3,,,,sx1,"LOG","00000"," set undo clean page to 20234, clean xid 12064",,,,,,,0,,"ud.c",921,\r\n./gpdb-2020-08-06_180816.csv:2020-08-06 18:24:25.900005 HKT,,,p108639,th-1442453568,,,,0,,,seg3,,,,sx1,"LOG","00000"," set undo clean page to 20330, clean xid 12167",,,,,,,0,,"ud.c",921,\r\n./gpdb-2020-08-06_180816.csv:2020-08-06 18:25:25.960726 HKT,,,p108639,th-1442453568,,,,0,,,seg3,,,,sx1,"LOG","00000"," set undo clean page to 20334, clean xid 12464",,,,,,,0,,"ud.c",921,\r\n./gpdb-2020-08-06_180816.csv:2020-08-06 18:27:26.378202 HKT,,,p108639,th-1442453568,,,,0,,,seg3,,,,sx1,"LOG","00000"," set undo clean page to 20391, clean xid 12617",,,,,,,0,,"ud.c",921,\r\n./gpdb-2020-08-06_180816.csv:2020-08-06 18:30:44.234265 HKT,,,p108639,th-1442453568,,,,0,,,seg3,,,,sx1,"LOG","00000"," set undo clean page to 20410, clean xid 12666",,,,,,,0,,"ud.c",921,\r\n./gpdb-2020-08-06_180816.csv:2020-08-06 18:36:44.596737 HKT,,,p108639,th-1442453568,,,,0,,,seg3,,,,sx1,"LOG","00000"," set undo clean page to 20523, clean xid 12706",,,,,,,0,,"ud.c",921,\r\n./gpdb-2020-08-06_180816.csv:2020-08-06 18:38:44.717897 HKT,,,p108639,th-1442453568,,,,0,,,seg3,,,,sx1,"LOG","00000"," set undo clean page to 20539, clean xid 12754",,,,,,,0,,"ud.c",921,\r\n\r\n理论上有oldestXmin保护，事务未回滚，则必然未结束。\r\n分析12464~12617区段，并无事务处于in progress状态。但有很多是abort的。	2020-08-10 06:39:29.220242	f
1392	686	Issue	5		2020-08-31 05:53:59.55272	f
1385	155	Issue	5	架构的本质上是在处理结构化与复杂度的矛盾。\r\n结构化不仅有软件的结构化，还有硬件的结构化，以及组织的结构化。\r\n组织结构化还有存在性矛盾，即组织结构本身的维护。\r\n\r\n结构化是为了达到目的，目的是某种特性，功能。\r\n目的本质上是为了更好的存在，于他们而言就是竞争。\r\n\r\n这也是世界的根本性问题，佛家讲空，就是让大家不要去争这些虚妄的东西。\r\n道家也讲无为，即按正常的去作为就可以了。儒家开始变得有为了，但是也是基于人道的为。\r\n而科学只为，现代社会的为进一步在强化各个方面，全方面的创新，也可能是全方面的毁灭	2020-08-20 06:13:38.000746	f
1386	155	Issue	5	所以少做一点，能满足就好的就是无为之道。降低作为。	2020-08-20 06:20:35.656309	f
1387	676	Issue	5	动作除了功能动作外，支持动作，核查动作，监控动作等也要考虑进去。	2020-08-23 13:58:27.303044	f
1388	346	Issue	5	微积分，坐标系等使得动态状态的计算成为可能。数学本质上就是研究空间关系以及数值计算的学科。	2020-08-26 06:52:09.110418	f
1391	683	Issue	5	人文主义的核心就是自由，科学与人文主义是工业时代的标配。\r\n\r\n为什么中国没有科学？\r\n这或许是一个复杂的问题，可以从多方面来说，但是核心是中国的礼俗文化。\r\n这种文化下，人只需要按规矩和经验行事就好了，到处都存在依赖与权威。而不是遵照既定事实来行事。\r\n这与中国社会抗拒变化，领导集团的封锁有很大关系。从根上不论是法家还是儒家都是如此，其目的是出于天下安定。\r\n而非人个性的自由与发展。\r\n\r\n经验与技术是一对。\r\n自由与科学是一对。	2020-08-30 06:13:10.097933	f
1393	658	Issue	5	世界观模块升级，以算法来看待世间。\r\n人生观是我们赋予的意义。	2020-09-01 05:41:26.484935	f
1394	582	Issue	5	1，定义问题，将问题归类\r\n2，确定解决问题的思路，战略。差异点特性。\r\n3，设计解决问题的步骤，动作分解。\r\n4，运用抽象和分解来定义系统的形态\r\n5，在此基础上确定动作的实现。\r\n6，由于问题本身的发展变化，系统还要考虑扩展性，系统本身还涉及配置，监控，运维等方面要求。	2020-09-02 05:11:40.155655	f
1382	671	Issue	5	什么是知识。\r\n在天地之初，一切刚刚分化，那时的知识就是你知道有那些事务，事务之间的关系，做事的方法或叫动作序列，是一种因果关系。也可以说是时间。\r\n即空间，时间，事物(包括人)构成了这一切。\r\n\r\n随后事物开始分化，事物的动作也开始分化。知识信息越来越多。\r\n物理学家，化学家对于天地之道的研究始终在进行，但这方面进展缓慢。\r\n数学家对于计算方法的研究也难以进展。\r\n生物学家对于事物的变化研究还可以不断进展。\r\n生理医学与生物同样是研究人物的。\r\n社会学，政治，经济是研究人的活动的，也会连绵不绝。\r\n体育和心理是研究人的，只要人还没研究透就还会继续。\r\n信息科学本质上也是研究事物的，并且其关注事物动作自动化，发展最快。\r\n\r\n所以知识是什么，就是这整颗树。这混沌世界的特征，以及其发展变化。	2020-08-13 05:20:37.692753	f
1383	679	Issue	5		2020-08-17 05:23:14.743091	f
1389	683	Issue	5		2020-08-27 07:47:02.649507	f
1390	683	Issue	5	自由是指不受他人控制，独立是指不依赖于他人，但另外一个方向是被自己的心魔控制，就像一个没长大的孩子没有自控力，这样也不得自由与独立。	2020-08-27 08:30:44.230371	f
1396	534	Issue	5	jerry.xr86@gmail.com	2020-09-03 11:52:21.228052	f
1397	687	Issue	5	不不，目前打的还是反手推球，主要是利用小臂和手腕手指打的。这种要打出真正的高远是比较难的。\r\n区别在于小臂和手腕的甩动方向。\r\n\r\n真正的反手高远是需要完全背对球网的，而上述推球可以侧身对球网。	2020-09-08 04:59:01.376955	f
1398	553	Issue	5	算法翻译成动作，数据结构翻译成关系与状态，就理解世界一切了。\r\n动作改变了关系与状态。使事物呈现不同的状态变化，这就是计算机的能力。\r\n\r\n算法与数据结构是一体的，相辅相成的。算法可以借助新的结构而实现，结构本身也在发生变化。	2020-09-08 05:02:47.521982	f
1402	690	Issue	5	无为境界也需要修炼，否则行为偏颇。\r\n\r\n不管儒家，道家，佛家出发点都是治心治世的，比较少研究自然本身。\r\n老子讲无为，但无为也没法回到过去，人的智力是展开的。\r\n\r\n所以上述都无法持续展开，以致几千年都没啥大发展。\r\n\r\n古人在现代能做到极致的假设是曾国藩，但是与科学也没大关系。所以就算再过千年，在此大环境下估计也难有突破。	2020-09-10 05:22:08.662927	f
1401	671	Issue	5	任何事情都是有意义的，但前提是这是真实的。至少对于身处其中的人能认真的对待它。\r\n\r\n改变不容易，积累不容易，但一旦开发也没那么难。	2020-09-09 16:56:37.903373	f
1403	658	Issue	5	我们要走的路，就是在天道人道的环境下选择自己的路，蒙蔽状态岂能谈无为，仁，正念？\r\n心学都讲究自然而然，生命本该有的样子。\r\n科学是自然的，技术是非自然的。	2020-09-10 06:11:33.644976	f
1399	683	Issue	5	有一天， 我发现我首先要处理的是我与这个世界的关系，而且必须由我自己来处理，外物他人只是这个世界的结构与状态，从此我自由了。\r\n我终于能与自己的时间做朋友，做自己的人生算法。我观察这个世界也观察自己，选择自己的行为，去体验每时每刻那个最好的世界和自己。	2020-09-08 10:24:22.180723	f
1400	671	Issue	5	知识分为体验性知识与概念性知识。乔布斯认为体验性智慧非常重要，而这正是塔勒布所说的启发法随机探索。 ​​​​\r\n说服一个人需要逻辑，但说服一群人需要的是故事。	2020-09-09 16:40:52.417832	f
1395	654	Issue	5	1，不同的查询\r\n索引查询与点查的区别在于其对于顺序有要求。\r\n所以对于imcs存在三种查询：1，index查询。 2，scan但是点查。 3，scan大范围查询。\r\n\r\n其执行区别主要在于数据离散性，顺序性。\r\n对于index查询数据是只能假设是离散的（因为无法确定索引数据顺序与heap一致），按索引key有序。\r\n对于scan点查，数据离散，数据无序。rowid有序\r\n对于scan范围查，数据聚集，数据无序。rowid有序\r\n\r\n查询时需决定是否将数据拷贝出来还是直接引用数据页。这需要查询引擎的支持。即判断是point query还是range query。\r\n\r\n对于索引查询或点查情况，如果一批数据不一定处于一个batch，则update/delete操作需处理这种情况。\r\n索引查询可以将dataset数据按rowid重排序。以尽可能批量执行update/delete。\r\n\r\nscan对于update/delete可以每次返回batch，多batch也没用，而且加大冲突可能性。\r\n但是index/index only scan是否也尽量批量化。\r\n\r\n2，CR页内存管理的风险\r\nCR重用机制是怎样的？\r\nCR页如果较长时间(复杂计算)不释放，对于buffer管理是否有风险\r\n\r\n3，变长字段内存管理\r\n1是dataset中的变长字段管理\r\n2是作为CR构建出来的内容，其内存管理。\r\n如果是一次性的，那相对简单，每次根据变长CR页取到相关列的数据组织在申请的内存即可。\r\n如果需要重用，则可能需要tag关联变长CR页，重用采用与变长CR页类似机制。\r\n\r\n4，undo的写法\r\n在scan完成后，对符合条件的row加锁并判断是否可修改。\r\n这时可以先完成批量undo写入，然后再修改（修改涉及多个原子操作）。\r\n需要确保的是如果修改没实际发生，执行rollback对一致性没影响。\r\n\r\n系统中delete相对少，主要是truncate场景。\r\n对delete操作undo记录老数据\r\n对insert操作undo不记录老数据\r\n	2020-09-02 20:15:26.936488	f
1404	610	Issue	5	再加一件武器：数学\r\n用数学与计算机科学来理解这个世界。\r\n而不仅仅是人心。	2020-09-11 06:02:04.670238	f
1405	691	Issue	5	于林丹的成功，于李宗伟的失败。 我觉得浑然天成，都可以接受。\r\n而不是像一些运动员，强求成功，失败便放弃，始终如一的追求更强，但也不过之。	2020-09-11 06:12:07.778866	f
1406	654	Issue	5	imcs的记录是否对应于xslot？ row可见性判断是否足够？\r\ninsert使用一行与该行处于删除中的矛盾。延迟标记删除？\r\nank heap中产生cr页为什么需要等待？	2020-09-11 08:34:38.796062	f
1407	654	Issue	5	问题列表：\r\n1，XACT_PHASE1是事务动作已经做完，但是尚未设置SCN时的状态吗？	2020-09-11 08:41:55.305381	f
1408	654	Issue	5	封装好事务和undo操作。\r\n引入local area概念。	2020-09-12 08:02:46.932303	f
1410	553	Issue	5	动作特征也是软件特征：\r\n一致性是计算机科学中的一个重点问题。\r\n复杂性是计算机科学另一个重要问题。\r\n可变性：\r\n 外部可变性，内部可变性\r\n不可见性：\r\n 在软件做出来之前其不可见，不可见性更体现在动作上，结构上尚可通过工作展现。\r\n 不可见性是软件修改N多次的一个重要原因。有时我们未实现时，就看不清结构变化对于动作的利弊。\r\n\r\n设计过程也是选择过程。\r\n	2020-09-13 21:07:27.530055	f
1414	553	Issue	5	结构与状态不一样。\r\n结构是固有的数据关系。\r\n状态是用于辅助变化的，临时记录的数据。\r\n\r\n设计实现时，从结构入手。\r\n状态是实现的派生。	2020-09-15 06:07:54.785602	f
1415	695	Issue	5		2020-09-15 06:10:05.190898	f
1409	654	Issue	5	LockArea即为mvcc的核心思想。\r\nredo和undo，事务状态是处理事务一致性的关键。\r\n还有底层提供的原子性。\r\n存储结构是为了提供某些特性。struct。\r\n\r\n接口设计：\r\n1，TryLock\r\n2，FreeLock\r\n3，WriteUndo\r\n4，ReadUndo\r\n\r\n可以独立测试的lockArea模块。\r\n\r\n自下而上的实现。\r\n\r\n该undo模块，负责组装undo格式，并且按列过滤查找。\r\n对外提供抽象，对于mch其写入的仍然是一条undo，undo包含一个头部，还有很多列。\r\n即提供接口init， AddRowId， AddColumn。\r\n读取时候可以getRowId, 也可以getColumn。\r\n\r\n其实细想没必要搞多片段的undo。\r\nundo组织关系的是什么问题：\r\n1，CR页构建查找效率\r\n2，rollback效率\r\n3，dml性能，undo写入代价\r\n4，找到xslot的第一个undo\r\n用于行检查是否有冲突。还有如果是更新，且更新的列不在本次修改scan列与目标列中，是否可以认为不冲突？\r\n\r\n	2020-09-13 21:07:02.960988	f
1413	533	Issue	5	等价类问题，一个非常简单问题，抓不住本质，可以搞出100种方法，天天修改。	2020-09-14 21:14:29.365004	f
1416	695	Issue	5		2020-09-15 06:10:19.990279	f
1411	654	Issue	5	heap记在哪里？怎么写入？\r\n\r\nrevert与 undo动作差异	2020-09-14 18:40:34.502378	f
1418	654	Issue	5	1，rowset这个结构是需要对外的，比如update，除了传入数据之外，还得知道那些行符合条件，从而填充rowset结构，再调用update\r\n2，update的运算最好基于列，对于imcs而言。否则需要拼成行比较，还有update的值的表达。\r\n   即update时候拿到scan结果，计算出rowset和update values，再传给update接口\r\n\r\nrowid使用xbu物理块id，update和delete操作可能传超过batch的数据，即他们是按自然行对齐的。\r\n	2020-09-17 04:48:36.444662	f
1420	553	Issue	5	你必须考虑很多因果逻辑，把隐式思考的部分显式化。\r\n必须考虑很多利弊来做决定，如果把逻辑推理也作为计算的话，你得进行各种计算才能做出决定。\r\n\r\n不是可能，也不是或许，也不是不做决定	2020-09-17 20:34:48.479938	f
1422	658	Issue	5	给我最多3年时间，我要做国内最顶尖的存储工程师。	2020-09-17 20:44:51.633712	f
1423	646	Issue	5	手臂发力还有一个关键点就是逐节打开，这是一种律动，不是绝对运动。\r\n1，逐级律动\r\n 律动是未到不动且松，到了就动且紧，动完即松\r\n2，逐级内旋\r\n这2点是羽毛球发力的根本	2020-09-19 07:13:12.761908	f
1426	658	Issue	5	施一公总结：\r\n1，投入大量时间\r\n时间不仅积累知识，还雕刻大脑，磨练方法论\r\n\r\n2，方法论\r\n与经验方式相对，科学技术需要坚实的基础\r\n\r\n3，批判性思维\r\n自我，集体自我更新的需要\r\n\r\n黄仁勋总结：\r\n1，敢于冒险\r\n2，面对现实\r\n\r\n我的5个武器：\r\n1，理想的算法世界\r\n感谢所有读过的书，都在告诉我这个道理\r\n2，无碍的心灵世界\r\n感谢孔子，佛家\r\n3，热爱\r\n感谢父母，感谢身边的人与自然\r\n4，方法论\r\n5，批判性思维	2020-09-21 05:37:25.4577	f
1417	654	Issue	5	关键点：\r\n证明：对于batch操作，同样可以使用block上的scn和xslot信息完成冲突判断。\r\n\r\n1，如事务A通过其他xslot修改了本行，事务B也修改了该行，则事务A必然提交，\r\n   否则事务B应该等待或冲突退出。因而其无法拿到该xslot。\r\n2，如事务B拿到了Xslot，但其可能仅修改了row B，则由于row A其使用该xslot，可推断出有事务\r\n    修改了row A，可能是事务B，也可能是早点的事务A。\r\n    这时可通过row is changed和SCN来比较，如cursor scn小于block scn，则可能row A 被修改。\r\n3，该行不指向xslot，则修改它的事务，其scn不超过block scn。\r\n    但是block scn可能被其他事务修改，而不是row A修改对应的事务scn，此处可能存在误判？\r\n\t即使用了页面级别的冲突检查。\r\n\r\n正常情况下准确的判断是找到这行最新修改，判断该版本对于当前事务是否不可见来检查冲突。\r\n这样就要求存在版本链，如上一个版本在undo中找不到则说明其对于当前事务必然可见或冲突(undo提前清理情况)。\r\n\r\n结论：使用该机制，否则XBU上冲突检查时间可能接受不了。\r\n\r\nCC隔离级别的概念：使用当前SCN来读取。Cursor扫描级别的SCN。\r\nAnchorBase可见性原则：\r\nrow对应的scn要小于扫描scn。\r\nrow的scn可来自于xslot或block。\r\n\r\n问题2：如何快速定位某列的undo？尤其在undo跨页的情况下？\r\n目前没有很好办法，xslot指向第一条undo。后面的undo只能顺序找。\r\n但是这问题本身没那么严重，一方面缩小了batch(63)，跨页可能性降低。\r\n另外只有delete操作会记录全列。update通常涉及比较少的列。\r\n\r\n问题3：heap接口对于partDict的依赖。	2020-09-16 07:16:04.24317	f
1419	646	Issue	5	大臂的位置决定了挥拍的结束点，这是头顶球与高远球区别。\r\n注意一点挥拍过程手掌的下方是对着挥出方向的，然后再最后一会利用手腕手指力量旋拍完成击球。	2020-09-17 05:47:35.007994	f
1421	658	Issue	5	我要做最强程序员\r\n\r\n你必须考虑很多因果逻辑，把隐式思考的部分显式化。\r\n必须考虑很多利弊来做决定，如果把逻辑推理也作为计算的话，你得进行各种计算才能做出决定。\r\n\r\n不是可能，也不是或许，也不是不做决定。	2020-09-17 20:43:11.858944	f
1424	659	Issue	5	手臂发力还有一个关键点就是逐节打开，这是一种律动，不是绝对运动。\r\n1，逐级律动\r\n律动是未到不动且松，到了就动且紧，动完即松\r\n2，逐级内旋\r\n这2点是羽毛球发力的根本	2020-09-19 07:15:48.990579	f
1425	533	Issue	5	开发软件别着急，\r\n先摸清问题，确定核心概念，然后我们做做证明题。\r\n然后再看最优实现，看清本质很重要，想不清楚不如列出问题来论证。\r\n\r\n不战而胜就是架构师的核心目标。\r\n\r\n	2020-09-19 07:23:42.923871	f
1412	533	Issue	5	软件设计当然是围绕问题而来，权衡取舍，走向不同的发展方向。\r\n本质上其实是问题求解的过程。\r\n\r\n一个大问题分解成很多小问题，每个小问题的求解。\r\n所以软件设计实现大概步骤：\r\n1，问题描述\r\n2，问题分解\r\n3，求解\r\n包括寻找已知解，创新解。\r\n这里有假设和论证过程，这是我之前软件开发吃亏的地方，实现时举棋不定。\r\n说白了就是没算清楚。没算清楚就没算法。怎么实现？\r\n\r\n同时还有利弊的权衡，实际的选择。\r\n\r\n4，使用系统描述问题\r\n5，系统分解\r\n6，实现系统(自下而上适合封装,组合)\r\n7，测试，集成\r\n8，...\r\n\r\n软件设计和开发都可以自上而下，或自下而上，或从中间向两边。\r\n但前提的大体战略方案确定。\r\n\r\n再简单浓缩点步骤就是：\r\n1，问题\r\n2，求解\r\n3，分解\r\n4，综合\r\n5，验证(实践)\r\n6，改进(迭代)\r\n	2020-09-14 21:13:36.141414	f
1427	533	Issue	5	开发规律：\r\n1，越晚发现问题代价越大。\r\n2，可能出问题的地方一定会出问题。\r\n\r\n开发环节注意：\r\n1，保证每个函数写完都尽量可编译可测试。\r\n所以我换了Clion直连linux测试感觉爽了很多，可以立即测试。\r\n而且Clion可以提示语法错误，效率提升非常大。\r\n\r\n1.1 一定要feature list\r\n\r\n2，尽量不要遗留债务，还债是痛苦的。\r\n\r\n	2020-09-22 06:30:40.252259	f
1428	647	Issue	5	1，7分步法，三分手法\r\n2，人比球移动慢\r\n3，甩起来，有节奏速度才快\r\n4，动作越小越可能精确\r\n5，胜负场上只占了30%	2020-09-23 21:03:05.588153	f
1431	533	Issue	5	该系统在其他系统之上引入了什么特性，其最明显的差异点是什么。\r\n要哪些求解方式，哪些解本质上是等价的。\r\n如何用数学语言来描述问题，从而找到问题的本质	2020-09-23 21:14:51.98831	f
1433	701	Issue	5		2020-09-27 05:46:08.383306	f
1434	702	Issue	5	考虑是否支持挂载列方式，即支持用户一次性定义一些列，或随后添加列。\r\n只是要求在冻结时，数据是完整的。\r\n\r\n其实本质上列有2种形成方式：\r\n1，分配内存在dataset上创建，然后慢慢填充数据\r\n2，直接挂一列数据在其上。	2020-09-29 12:33:58.4346	f
1437	703	Issue	5	成为金字塔顶端的人，虽然说人类社会没有进行分级，但就像大护法中的花生人一样，\r\n底层的人在上层人看来可能就是给点吃喝就能提供点服务的花生人。自由，独立是一个谎言，\r\n恐惧和愚昧支配了他们。但首先得成为领导者。\r\n在这个游戏中底层个体没有资源，只能依靠自己的身体和大脑来完成这种艰难的升级。\r\n除了真正的实力外，还有一种是偶然机会，追随大势有些猪可以上岸。\r\n妄想别人直接教给你他最核心的技能是不现实的，一方面这有点不切实际，另外这不符合交易原则。\r\n但是通过其他赋予一些利益或情感而获取一些非核心知识是可能的。还有一种更广泛的获取知识途径\r\n就是自学，总结，思考。	2020-10-05 09:15:54.100779	f
1436	702	Issue	5	dataset本身维持其灵活性，可支持不同列采用不同内存管理方式。\r\ndataset上可能有如下工作：\r\n1, 支持创建写入类型的dataset。一次性传入所有列定义，并自动决定列的内存管理方式为在dataset上分配。\r\n2，支持创建scan类型的dataset，一次性传入所有列定义，并自动决定列的内存管理方式为不在dataset上分配。除了rowid列之外。\r\n3，支持一次性传入所有列，如上述2种方式，一个接口完成dataset的初始化，加列和构建操作。\r\n4，支持往某列写入批量重复数据，如columnSliceAddBitNRepeat\r\n5，支持一次性写入批量数据，如columnSliceAddBitN	2020-09-30 07:53:20.074089	f
1432	658	Issue	5	1，成为领导者\r\n领导者要知人知事，要做成事，这是一种很强大的力量，没有决心做成一些事的人不可能成为领导。\r\n所以领导者首先要想明白人生的意义，选择自己要走的路。领导者是团队的大脑，负责制定算法。\r\n\r\n我要展开我的生命，并且帮助想要展开自己生命的人。赋予有德者以能力。\r\n如同渡船\r\n\r\n2，用科学方法来思考工作\r\n2.1 学习运用离散数学，运用符号化表达问题，并解决问题\r\n2.2 寻找等价类证明方法，想清楚问题的本质\r\n2.3 寻找利弊分析方法，想清楚方案的差异\r\n2.4 寻找实施方法，既能管控进度，又能尽早发现问题，及时修正，并且坚实的快速推进。\r\n2.5 思考通用，常见问题的解法，并运用于新问题的解决。	2020-09-27 05:11:29.280034	f
1435	654	Issue	5	依赖关系：\r\n1，update/delete 依赖于fetch和fetchbyrowid\r\n2，索引依赖fetchbyrowid\r\n\r\n\r\nFetchByRowId\r\n1，dataset是否可以内生？免去填充所有列的情况？\r\n2，dataset能否支持拷贝定义？这样冲突时去获取数据，可以直接从scan的dataset派生出来\r\n3，按索引查询，其数据是否按行组织？\r\n最后可以吐出行，但在rollback阶段，CR阶段都还必须是列式的。\r\n4，dataset如何支持行列式\r\n5，fetchByRowid的accessor也要构造么？\r\n即便构造也不能分配那么多空间，可以为更新和删除创建一个accessor，该accessor\r\n既支持批量，也支持单条。对索引扫描也如此，构造一个accessor。\r\naccessor支持指定访问某个batch。\r\n6，对于索引扫描一定要吞出行数据？对于行存而言，其获取的是所有行，但对列存是不是可以去掉不需要的列，形成新的行？\r\n拷贝后转换少不了。\r\n7，对于cc隔离级别，也一样按照rc处理，只是取scn不一样。heap出于减少数据拷贝，降低代价的目的采用了checkrow以及checkcurrentrow机制，\r\n以降低构建cr页开销。\r\nheap update should be no matter with rc,cc? it should be read committed at read time.	2020-09-29 15:00:17.742518	f
1440	654	Issue	5		2020-10-05 20:08:15.341211	f
1442	533	Issue	5	只有提前思考才能把握主动。\r\n工作和交际都是如此。\r\n\r\n1，问题以及事物的本质的探索\r\n2，多种方案的利弊分析\r\n3，动作分解，内部结构，以及命题论证\r\n4，有节奏的软件开发，严密的，程序正确性证明。\r\n\r\n编程方法：\r\n1，正确性证明 \r\n2，可视化流程，动作\r\n\r\n软件中的数据有三类：\r\n1，持久化数据\r\n2，堆中的数据\r\n3，栈中的数据\r\n堆中的数据其实就是软件的对象树，从全局对象入口到挂在其下的子对象。\r\n栈中的是临时状态。\r\n\r\n编程的关键是对于事物的理解：\r\n怎么去把握事物的本质，动作，特性，结构，关系，状态。\r\n怎么去分解构造事物	2020-10-08 05:42:56.255842	f
1443	654	Issue	5	1，fetch with snapshot\r\n得到rowid -- 对于swf，index scan得到rowid，heap scan可以得到batch。\r\n2, try lock row\r\n3，goto 9 if success. otherwise unlock block.\r\n4，wait if needed\r\n5, scan the newest version(cc)\r\n6, check if new row or delete, skip.\r\n7, check filter, skip if not match\r\n8, goto step 2.\r\n9, exec update or delete, unlock block.\r\n\r\nanchorBase中的优化：\r\n1，在fetch by rowid过程中如果当前block中该row可见，则不构建cr页。\r\n否则按照最新获取的scn构建cr页。\r\n\r\n疑问：\r\n1，heapCheckCurrentVersion看代码作用仅在于过滤该行覆盖写入新记录的情况？\r\n此情况必须处理，即存在该行被删除后再次写入新数据的情况，此时按照规则插入不可见。\r\n2，XACT_PHASE1为什么要等待？而且外部实现看有些地方并未等待？\r\n如heapCheckCurrentVersion。\r\n\r\nswf的几个特征：\r\n1，定长与变长分离\r\n1.1 支持任意定长字节(最大不超过32)，以及bool类型\r\n2，列式存储\r\n2.1 行锁\r\n3，批量执行\r\n3.1 单行看做批量中取部分行\r\n3.2 不支持cr机制，没法按block以及scn cache。\r\n    block不对齐，且读取总是部分block的。	2020-10-09 20:13:12.50828	f
1444	658	Issue	5	所以为什么需要克服困难变强，因为那是达到生机畅达状态的需要，否则你不仅物质肉体贫乏，连精神都会贫乏，成为金字塔下端的人。\r\n这就是这个世界的算法，奖励进取者，你有更好算法么？理想国还是地狱？	2020-10-11 20:34:23.449344	f
1446	654	Issue	5	为什么cursor上要搞2个buf，能否scan数据与后面的冲突检查时重新读共用内存？\r\n可能对于heap是为了简化，scan一次获取一个block，已经占用了getbuf。\r\n\r\n对于swf，可以直接复用，由于记录长度不变，可直接填回去。\r\n\r\n为什么heapFetchBlockRow是cursor的scn存在去row的xslot中获取的情况？对于end的事务，不是其scn已经填充回block了么？\r\n可能存在无法填回的情况，即block scn比row scn大的情况。还有一种情况是事务确实结束了，但是还没来得及填充scn。\r\n主要应该是没填回的情况，block scn本身就放大了，对于一个已经结束的事务，何必在乎scn放大，只有xslot上的scn比block更大，才显得有意义。\r\n意义主要在于减少误判冲突？ 	2020-10-16 08:00:52.726084	f
1458	655	Issue	5	pn无法通过逻辑复制，同时还能保证一致性。\r\n一种解决方案数据需要删除时，将操作转移到dn上。dn完成之后将删除位图再推给pn。然后变更slice状态。\r\n即转移所有权方式，pn是读代理。	2020-10-26 06:27:47.782821	f
1450	654	Issue	5	rowid外部表示还是统一为rowidset，而不是rowid slice，即不与validbits绑定。或2个都填充由用户来决定使用哪个？	2020-10-19 06:52:48.928347	f
1452	646	Issue	5	10.24打球心得：\r\n1，击球时关注到自己的手肘，和手腕。定肘甩小臂，定腕甩手握紧。\r\n2，大臂要打开。击球瞬间一定是大臂，小臂，手在一个平面握紧的情况。手臂不展开有时候难以形成这个平面。\r\n3，这个平面不要太斜，否则手必然需要发力制动，这样速度就下来了。这就是高球好杀的原因。网前小高球杀很容易失误，一般以扑小臂手腕发力为主。	2020-10-25 05:03:40.299631	f
1454	704	Issue	5		2020-10-26 06:20:31.139904	f
1455	610	Issue	5	数学推导的奇迹\r\n结构与组织叠加的奇迹\r\n动作序列的奇迹	2020-10-26 06:22:37.817277	f
1459	704	Issue	5		2020-10-27 05:53:55.59581	f
1460	704	Issue	5		2020-10-30 06:36:02.690314	f
1462	706	Issue	5		2020-10-31 07:54:28.963216	f
1464	706	Issue	5		2020-10-31 07:59:19.668609	f
1466	706	Issue	5		2020-10-31 08:11:33.895524	f
1467	706	Issue	5		2020-10-31 08:12:02.193887	f
1468	706	Issue	5		2020-10-31 08:16:21.246585	f
1471	706	Issue	5		2020-10-31 08:23:17.641514	f
1476	706	Issue	5		2020-11-02 06:06:33.247585	f
1439	654	Issue	5	todo：\r\n1，支持xgroup scn\r\n2，支持fetch by rowid\r\n数据仍然以dataset构建出来。\r\ncr页重用在点查中的作用? \r\n构造cr页成本太高。\r\n3，update的时候覆盖该行数据？或该批数据\r\n4，char(10)如果内部转换为char(16), dataset中标明数据长度是否即可？	2020-10-05 20:06:11.648926	f
1441	654	Issue	5	1，构建cr成本太高，一个block内记录数量非常多。尤其是如果支持不按2的次幂对齐的类型时，block对应的xslot还会跨xbu。\r\n2，即便按xgroup为单位维护cr，也可能存在对于超大字段，跨页面的问题。\r\n即之前没看到cr cache机制失效的问题。也即未论证cr机制在列存格式下的有效性。	2020-10-08 05:36:08.514866	f
1438	703	Issue	5	只有意识到别人与自己平等的，才会意识到论证，论据是交流的核心。\r\n你不能让人相信什么，除非有证据。\r\n数据与可信度。观点是无法说服人的，顶多是打动人。\r\n\r\n人类研究的范式(即科学方法论)：\r\n1，先根据经验总结归纳得到基础理论或猜想。(经验主义，归纳法)\r\n2，运用数学和逻辑方法将该理论扩散。(理性主义，演绎法)\r\n3，如果有矛盾，则反过来修复理论。(实证主义)\r\n其中第一步可能出错，第二步不允许出错。\r\n\r\n爱因斯坦说：西方科学的发展以2个伟大的成就为基础，一是希腊哲学家发明的形式逻辑体系，二是通过系统的实验发现有可能找出因果关系。\r\n\r\n\r\n世界就像一颗扩展的树，知识的发现与应用都不是偶然的，都是因问题而生，是人努力的结果。\r\n前人在这些问题上都花费了大量时间，重复造轮子可以让人对轮子更了解，但这也需要时间。\r\n\r\n我何其狭隘，我似乎从未把别人与自己平等对待吧？\r\n为什么我会因为自己表现没别人好而收获更少愤愤不平呢？\r\n不要做单纯的愤怒者，我们因别人的努力而获利，还反过来中伤别人么？\r\n\r\n为什么我会觉得自己努力一点，做得好一点会有安全感呢？\r\n那是恐惧下的自我安慰，你需要做的是变得更强。\r\n	2020-10-05 09:16:26.024448	f
1445	702	Issue	5	批量接口内存管理讨论：\r\n1，dataset传给crab之后，其中每列的内存所有权转给crab，下次使用时对于每列重新分配内存。\r\n2，已申请内存在cursor上进行管理，以提升效率。\r\n3，提供free内存接口，将内存释放到cursor上挂载的内存管理结构上。\r\n4，dataset定义接口调整，支持传入ColumnDef的数组\r\n5，一批数据可以跨越swf的block。crab fetch时传入最大记录数量。\r\n6，valid bits不需用户指定，返回dataset中可获得有多少记录有效。如存在无效，则认为valid bits列存在。\r\n7，支持往某列写入批量重复数据，如columnSliceAddBitNRepeat\r\n8，支持一次性写入批量数据，如columnSliceAddBitN	2020-10-14 18:06:21.390187	f
1447	654	Issue	5	如何表示扫描到的批量行。\r\n方案1：使用rowidset\r\n这种表示可以统一以后的行列式\r\n\r\n方案2：使用列存的rowbatch\r\n这种不便于统一\r\n\r\n还是采用方案1，仅批量模式下进行初始化。\r\n列存的filter操作根据dataset计算得到rowset。\r\n列存内部仍然使用rowbatch，但是仍然在一些地方需要转换。	2020-10-17 15:16:29.776606	f
1448	704	Issue	5		2020-10-18 06:08:12.202051	f
1449	704	Issue	5		2020-10-18 06:13:49.342209	f
1451	696	Issue	5	回动与球一致，高远球慢回动，杀球快回。平抽挡不回，直接小跳调整。\r\n注意防守时双脚平行。否则身体附近就是弱点，不好反手接球。	2020-10-25 04:54:40.517607	f
1453	533	Issue	5	软件开发方法论：\r\n1，软件是以实体，以及之间的动作串联来完成的。\r\n2，但软件与现实不一样的地方在于实体也是程序员造出来的。\r\n造实体的理论：单一职责，开发封闭原则，隔离原则，最小知识原则，替换原则(现在基本很少以父子类，而是用接口方式)\r\n3，先抽象后实现。面向抽象编程。\r\n即先计算后行动。先推导后实现。\r\n4，犹豫不觉时就启用数学方法，描述论证，转换证明，找到根本区别。	2020-10-25 05:31:27.899937	f
1456	582	Issue	5	数学推导的奇迹\r\n结构与组织叠加的奇迹\r\n动作序列的奇迹	2020-10-26 06:23:27.159881	f
1461	706	Issue	5		2020-10-31 07:39:56.513786	f
1457	553	Issue	5	数学推导的奇迹\r\n结构与组织叠加的奇迹\r\n动作序列的奇迹\r\n沟通的奇迹\r\n\r\n沟通的重要性：\r\n每个人的概念体系是自己归纳的产物，人之间概念通常是不对齐的。这就是为什么要展开，为什么要细节，而不仅仅是概括的原因。\r\n\r\n程序是上述四者的公共体。所以程序员是造物主，动作大师，数学专家，沟通专家。\r\n\r\n程序员面临提前抽象计算，不可见行，一致性，复杂性，可变性等现实难题。	2020-10-26 06:25:27.872313	f
1463	706	Issue	5		2020-10-31 07:56:34.862332	f
1465	706	Issue	5		2020-10-31 08:02:00.167262	f
1469	706	Issue	5		2020-10-31 08:17:17.019049	f
1470	706	Issue	5		2020-10-31 08:21:28.697888	f
1472	706	Issue	5		2020-10-31 08:24:14.571082	f
1473	706	Issue	5		2020-11-01 07:07:32.179121	f
1475	706	Issue	5		2020-11-02 06:05:19.867736	f
1478	582	Issue	5	本质上就是掌握更根本的规律，看到更贴近造物主的世界。\r\n然后设计出来的系统更符合客观规律，符合事物演化方向，有更好的生命力。	2020-11-02 08:02:34.293254	f
1480	654	Issue	5	1，fetch by rowid是否需要检查rowid为新插入记录的情况，来决定是否可见？\r\n   (cursor->attr.xIsolevel != XIL_SERIALIZABLE &&\r\n        checkCurrent && cursor->scn.value > cursor->attr.scn.value)\r\n   其实这个条件，理论上也只有冲突检查能满足，其他情况下\r\n2，冲突检查时，heap改为了总是检查最新版本，即不需要生成cr。只要判断当前版本即可。\r\n   区别似乎只是等待的地方不一样，另外将状态检查留在的当前页面上完成，而不是拷贝的cr页中。\r\n   swf可优化为先检查xbu，然后拷贝记录？似乎不行如果判断完成，释放当前xbu，拷贝cbu，那么有可能这期间xbu和cbu发生变化。\r\n   即拷贝应该是cbu->xbu的顺序。\r\n3，heapLockRow为啥要使用回调的方式prepare undo，如果该函数内不可能使用undo的话？	2020-11-04 09:12:53.979659	f
1474	696	Issue	5	基本原则：\r\n1，双脚平行利于左右移动，双脚前后利于前后移动。\r\n2，重心的高低取决于击球点的高低。\r\n3，快速启动，如贤二田一说的只能在中间圈产生脚步声。\r\n4，视线总是从下而上，击球点也是如此，相对应拍面，应该在12点及之后击球才稳定。\r\n即在击球点与期望的击球飞行终点连线，那么击球应该在1点位置，因为羽毛球有自然下落趋势。难以保证12点一定能打到球。\r\n而风行过程中也会下落，因而在1点位置就能打到目标飞行终点。\r\n5，热启动，使用小碎步维持动态\r\n6，手不要随便放下，注意使用手来维持身体平衡\r\n7，步伐的大小是需要注意的。	2020-11-01 20:55:00.77682	f
1485	654	Issue	5	规则1，每行需要一个missing column，执行引擎根据其填充可以得到新增列的默认值。\r\n规则2，通过给每行增加max columns，以及列只能在尾部追加规则，可以达到规则1的要求。\r\n行为：\r\n1，如果xbu没有被修改，其max columns维持不变。如果发生插入或更新，则可能引起某些行max column变化。\r\n2，查询时如果存在读取的列在部分行中missing的情况，则填充missing辅助列，由上层计算哪些列missing并填充。\r\n\r\n方案1：\r\n1，在xbu增加max columns值\r\n2，增加描述max column信息的cbu，MaxColumn辅助列\r\n从xbu独立出来主要出于新增列并非必然现象。\r\n但是增加了一次跨页的成本。\r\n3，max column使用xbu同样的逻辑页id。	2020-11-21 05:54:47.146892	f
1486	618	Issue	5	SICS-COD_XIER\\	2020-11-24 15:34:23.814482	f
1488	711	Issue	5	毕业生可能具备前三种能力，但是缺乏后面三种能力。这样也难以做出优秀的软件。\r\n有执行力，沟通力的人可能成为模块负责人。有领导力的人可以成为架构师，总负责人。\r\n	2020-12-02 06:16:15.079954	f
1491	711	Issue	5		2020-12-05 07:04:49.870535	f
1493	712	Issue	5	防止勿用也很重要，这是C留给我们的启示。	2020-12-07 06:23:10.237376	f
1494	711	Issue	5	执行力除了个人主观意愿因素外，还就是与专业能力有关系。\r\n专业能力由知识积累，以及做事的方法论2方面来体现。	2020-12-07 06:39:37.670223	f
1520	743	Issue	5	教育人就是在设计系统一样，孔子在育人上基本遵守了自然法则。在此基础上增加了礼仪来规范大家的行为秩序。\r\n礼与来自于共同起草的法具有同等效果，法来自于每个公民的参与，因而封建时代是没有法制基础的。\r\n\r\n道描述了分化的情况，但是试图劝人回到过去，就跟现在人的断舍离一样。 这是一种美好的愿望，但分化的趋势依旧难免。	2021-01-14 06:45:30.17279	f
1497	720	Issue	5	现在也鼓吹人文主义，然后真正看是否是，得看其是否捍卫每个人的利益。\r\n从这个角度看，现应该是有点改良的	2020-12-19 07:26:31.515027	f
1505	646	Issue	5	高远球挥拍有效范围是9点到12点左右，这样就能明白为什么抬头转身都必须到位，否则大臂没有加速空间。\r\n这个看戴资颖 尹达农等女子动作很明显。\r\n\r\n很多人打球后倒在用力，本来加速区间速度上不去，打完球在那加速，或者腰腹转时机不对，都不能很好的转化力量。\r\n大臂的加速很关键，没大臂加速则自然没有小臂后倒，也不可能有小臂加速。速度只能达到别人的几分之一。	2020-12-24 20:49:12.209083	f
1506	724	Issue	5		2020-12-25 06:56:11.174822	f
1495	646	Issue	5	1，(准备环节)右腿丈量击球点，侧身，到位后，抬左腿，左手指向来球，曲右腿，展肩，收右肩右臂。\r\n2，(蹬转环节)撤回左腿左手，蹬地转体，摆臂，右臂上升(这很关键，不然小臂怎么后倒？)，小臂自然后倒，立腕。此时身体被上升的力牵引，并转化为转体的力。\r\n3，(鞭打环节)甩小臂，微内旋（估计45度就够了）保证正拍面击球，甩腕，握紧。\r\n4，(收拍环节)身体此时转正，且成右脚在前姿势，重心在两腿之间。	2020-12-18 06:16:41.350734	f
1498	646	Issue	5	最佳视频：https://www.bilibili.com/video/BV1hZ4y1M7wB\r\n高远球腿步有三个检查点：\r\n1，要能正常发力\r\n2，要能很好后退\r\n3，要在击球后回位\r\n由此得出结论：应该以右腿为步后撤，击球时抬左腿，然后后撤左腿。\r\n退左腿移动范围，重心稳定等方面都好很多。而且可以更大胆的前压。\r\n\r\n转身：\r\n1，不能提前或滞后\r\n2，不能太慢\r\n3，不仅是右转左，还有后转前\r\n4，转身和后撤步大小取决于球是否被动。\r\n\r\n1，右脚仗量落点\r\n2，弯腰应对被动程度\r\n3，左脚后撤平衡\r\n\r\n为什么要外旋再内旋击球，因为手放到身体之后，外旋才舒服。并不是因为减小拍的阻力。\r\n这动作不用刻意做，拍子转到身体后自然就是如此。不过击球时要注意排面。	2020-12-19 14:43:53.62406	f
1502	705	Issue	5	羽毛球有两种发力方法：\r\n1，涉及多关节的甩打，甩是因为有借速度，但不借很大力量。\r\n2，手指的捻打。\r\n3，下一个关节想甩更多，则最好上一个关节提供更大的初速度，否则容易受伤。\r\n   拉弓射箭，不可强行。	2020-12-24 06:29:50.601954	f
1504	723	Issue	5		2020-12-24 19:11:56.325417	f
1507	724	Issue	5	实际\r\n修复bug：7小时\r\n发现了anchorBase 2个bug。\r\n\r\n\r\n总结为什么时间长？\r\n1，上午2小时，对比版本花了一些时间，实际上认真看下错误，检查下堆栈变量花不了那么久。上来就认为是踩内存。\r\n2，下午确实是问题有点复杂度，最终通过脚本查看页面信息，xslot信息，找到对应undo，使用工具导出undo分析才确定是cr读取block版本问题。\r\n	2020-12-25 15:26:44.390306	f
1508	725	Issue	5	实际情况：\r\n1，对于spinlock问题认识不够，导致以为数据页不存在该问题，因为并发操作表的不同页面。\r\n然而没想到spinlock问题发生在空间管理模块，该模块的入口页等是多线程冲突非常严重的。 \r\n\r\n即空间管理结构能支持的最大并发度是有限制的。\r\n\r\n花费了4小时+.\r\n\r\n2，补充miner解析redo与undo代码，晚上加班搞  1小时。	2020-12-28 17:51:36.683113	f
1516	742	Issue	5	这个世界每个人都在并肩行走，只是有些人忘了回家的路	2021-01-08 07:29:12.626028	f
1517	711	Issue	5	动作的时效性，非常重要，就像打羽毛球的容错时间。\r\n动作的顺序关系，不可或缺性。	2021-01-08 15:49:30.620377	f
1518	745	Issue	5	下午review代码，调整代码。	2021-01-12 07:22:54.924229	f
1521	745	Issue	5		2021-01-14 06:47:37.326891	f
1525	742	Issue	5	圣人步步莲花，给万物带来生机，他为什么这么做呢？ 因为大爱，出于对生活的环境和事物的热爱，对于真善美的热爱。	2021-01-15 08:13:50.859526	f
1528	752	Issue	5		2021-01-17 06:06:38.348736	f
1529	752	Issue	5		2021-01-17 06:06:49.942973	f
1531	752	Issue	5	君子之交：\r\n帮不帮助，其实主要在于人情。君子无情，小人有义，非真君子。\r\n那一个人自己是君子会要求别人也是君子吗？不会，君子有能力与其他人打交道。\r\n小人是走偏了的人，君子要有能力决定自己的行为，判断别人的行为。\r\n所以不要因为有小人而减少与人的交往，而是要会观察，注意行为的边界。	2021-01-17 07:43:26.941089	f
1612	297	Issue	5	技术是服务于服务，行为的。\r\n公司核心跟编程是类似的，除了销售，售后，财务等环节。董事会在考虑需求，行为，方向。CTO负责落地。\r\n技术重要，但是想法，方向，路径更重要。	2021-03-17 07:01:33.762987	f
1636	830	Issue	5		2021-03-27 07:05:14.704227	f
1500	533	Issue	5	1，问题。 \r\n2，原理，解释为什么可行。 \r\n3，原则，选择偏好。\r\n4，行为分析，动作分解。\r\n5，设计结构与模块\r\n6，开发(代码的第一次执行就是写下他的时候，人脑的执行，而人脑经常是无意识状态的，逃避问题的，因而\r\n\t实际代码遗漏场景可能非常多，这就是开发阶段引入的bug之源)\r\n\r\n除了功能指标外：设计结构还要考虑：\t\r\n结构的并行能力衡量。\r\n结构的平稳性，即是否会出现卡顿情况，是否有累积效应。	2020-12-19 15:09:00.426322	f
1501	711	Issue	5	领导力构建主要体现在计划，构想，以及成果环节。要用沟通的方式把这些宣传出去。才能形成领导力。\r\n	2020-12-23 06:38:36.090684	f
1503	722	Issue	5		2020-12-24 07:23:03.591972	f
1509	728	Issue	5	达成方法：\r\n1，每周进行2次练习。\r\n2，平时做挥拍和基本动作练习。\r\n持续大约3个月。\r\n\r\n然后参与高水平的群赛：\r\n1，练习作战能力\r\n2，练习战术调整能力\r\n	2021-01-04 05:54:18.74382	f
1522	747	Issue	5		2021-01-14 07:11:55.81249	f
1510	722	Issue	5	每个人都有自己的目标，我们坚定于达到自己的目标，因而有方向与动力。\r\n这个目标应该是有趣的，生动而激励人的。因美丽而神圣我们无限向往。\r\n欲望不能作为目标是因为它是变化的，满足了就觉得它味同嚼蜡，没满足时它让人焦躁不安。\r\n\r\n所以更合适的人生不是比较，评价，而是体验和探索。\r\n就像佛教徒追求修得正果一样，每个人都在走自己的路。\r\n\r\n我想洞察这世间，体检那原生的美妙世界。\r\n我想把这种体验融入到自己参与的行为与设计的结构之中。\r\n	2021-01-04 06:39:33.006073	f
1511	730	Issue	5	1，review代码。 2小时\r\n2，解决select访问的batch数量未按xgroup对齐时，引起的scan xgroup num计算错误问题。\r\n  定位该问题利用了valgrind，通过该现象和分析代码加快了分析。 2 小时。	2021-01-04 12:53:59.489052	f
1512	735	Issue	5		2021-01-06 13:27:29.438432	f
1513	720	Issue	5	这个社会可能被政府牵引往前走，被政府牵引，这是一些复杂因素的综合结果。\r\n但人理当选择自己的路。	2021-01-07 06:33:28.029948	f
1514	722	Issue	5	为了完成工作，则工作索然无味。\r\n为了锤炼技能，工作顺理成章。\r\n打比赛是为了校验自己训练的结果。\r\n自我的那个目标才是核心，这不仅是生活的法则，也是学习的法则。	2021-01-08 06:37:39.64482	f
1515	742	Issue	5	总结下人还是要会跟自己赛跑，跟比人赛跑目标是移动的，看不到目标迷茫，达到了容易停滞，而且总有更强的人出现。\r\n如果不去比较，不去评价，不着相之后就容易陷入虚无，仿佛一切都无所谓没意义。但确定了自己的路，自己的目标理想后，就有了意义。	2021-01-08 07:26:53.244946	f
1523	747	Issue	5	实际：\r\n1，review代码 2小时+\r\n2，下午开会 3.5小时\r\n3，整理代码，验证预读效果  2小时	2021-01-15 06:09:21.985883	f
1519	733	Issue	5	系统中的事务都遵守自己的最优生存法则，即竞争与淘汰是非常要必要的。我们的选择使我们看到美或者丑的事务。\r\n1，理解问题\r\n2，设计\r\n3，选择\r\n4，执行\r\n5，反馈调整\r\n乌托邦的世界通常都是丑陋的，天地不仁，为啥要对人友好呢？对人友好就意味着对其他事物不那么好。\r\n要么就是这个系统就有可延展性。让其他人买单。要么就自己成长，即在同样资料内进行结构重组。\r\n问题出在最初的设计和选择上，而非最后的竞争上。\r\n\r\n所以竞争就是让能生存的生存下去，淘汰丑陋不稳定事物的过程。\r\n就如这系统的游戏规则一般，自然规则保证系统的长期发展。它残酷，真实，也因此而美丽。\r\n\r\n所以你看出来软件开发与自然生长的关系了吗？\r\n它们都得遵守最优化生存原则，最有效率，最稳定。而最好的美丽就是来自于这种结构，及其动作。\r\n系统的真善美。 真就是要真实，要去竞争，面对现实。否则不会有善，也不会有美。\r\n善的意思是以改进其他事物的姿态去与其共存而不是消灭其他事物。即善是生机勃发的，恶是死亡气息。\r\n美就是最优化的结构与动作。\r\n\r\n孔子说的君子感觉就是符合上述标准的个人。君子为善者，然自强不息。\r\n	2021-01-14 06:28:39.396749	f
1559	768	Issue	5	所以那些美好的品质只是外表，而修炼内在才是根本。不可舍本逐末。	2021-01-29 06:02:49.992679	f
1532	752	Issue	5	10年可立得住志否，日日勤为之。\r\n24-28 岁从学校走出来，然而原生问题并未解决，开始面对社会，辛苦压力，焦虑彷徨，但未去寻找。\r\n28-32 慢慢抬头看自己，忽然问自己为何冷漠。问自己该如何生活？是否有其他可能性，发现自己没有直面问题。\r\n33-35 去听，去了解，逐渐明白了一些，也看到很多别人存在的问题。明白该怎么去做，确定了自己的志向，找到了自己的路。\r\n          世间有真善美，学习是真刀真枪干的。真才有善，才有美。	2021-01-17 07:58:51.114812	f
1558	646	Issue	5	1，(准备环节)架拍，架子得有，不然小臂手腕难放松，立腕拍面朝外，右腿丈量击球点，击球点应该尽量在右脚点前上方，侧身，重心后压。\r\n2，(反弓环节)抬头，左手指向来球，曲右腿，展肩，收右肩右臂，后倒。侧身展肩重要是因为这样可以让身体，大臂，小臂在一条线上运动，这样下一节可以充分借速度。\r\n3，(拉转环节)拉回左腿左手，蹬地转体，摆臂，右臂上升(这很关键，不然小臂怎么后倒？)，小臂自然后倒，立腕。此时身体被上升的力牵引，并转化为转体的力。\r\n4，(鞭打环节)甩小臂，微内旋（估计45度就够了）保证正拍面击球，同时食指推球拍，握紧。\r\n5，(收拍环节)身体此时转正，且成右脚在前姿势，重心在两腿之间。\r\n\r\n关键之关键在于2点:一是整体发力在一条线上，二是一定是上一节带动，反过来就容易受伤且速度不快。由此我们也知道右脚没到位难出高质量的高远或杀球\r\n	2021-01-28 20:59:23.765164	f
1562	772	Issue	5		2021-02-01 06:20:06.524935	f
1563	649	Issue	5	设计本质就是认知，分解，分化，认知确定了问题本身的合理性，边界等。分解应对复杂性，分化应对一致性，可变性。\r\n\r\n问题界定：最初能确定的是系统的需求，以及在哪些地方发生变化。\r\n理解软件设计\r\n\r\n方案设计：然后根据限制给出大体实现方案，论证领导先进性，可行性，合理性等。\r\n架构设计：然后展开概要设计，进行系统最枝干粒度的分解。\r\n\r\n架构设计阶段：\r\n系统图，帮助理解系统设计的组件，组件的职责，以及最顶层交互。\r\n层次图，帮助拆分模块，抽象接口，以及思考应对变化。\r\n数据结构图， 帮助阐述具体数据之间的关系，有点像面向对象的类图。通常数据与行为一起，可以辅助子模块划分。\r\n流程图，帮助讲清理复杂动作\r\n\r\n计划分解：按系统扩展生长来分解软件。	2021-02-01 17:35:31.242012	f
1564	768	Issue	5	君子至善至强心平	2021-02-01 17:45:15.788968	f
1524	742	Issue	5	再说不着相：\r\n在现实生活中，我们似乎很难做到不评价，孔子圣人都会评价自己的弟子，而且还有差评。\r\n很多事情我们都会制定一些标准，怎么会有标准而不评价呢？\r\n我想或许问题并非出在评价本身上。不着相或许也不是去评价，而是以无常看待事物，但事物此刻的状态仍然是客观存在的，\r\n是有相的，但不着相，因为事务是变化的。\r\n评价2个关键点：一是基于真实，二是出于善。何为善？善是生的力量，生长的力量，让事物生机勃勃，因而善通常柔。反面是恶，是坚硬的，枯槁的，让事物逐渐死亡。\r\n如果从阴阳来说善是阳，恶是阴。评价是敞开的，是向阳的行为。但这是否意味着评价都要好呢？只是说出发点是为善，但首要原则是真实，真在善之前。没真也就没有善。\r\n评价或许是不好的，但基于事实的意思是这是被评价人需要去面对的问题，评价人只是从自己角度指出该问题，当然被评的可能不这么认为。\r\n故评价人或行为本身不是一件好差事，君子讷言敏行，更多的心思还是在修自己身上。\r\n\r\n如果有些场景下我们需做评价或有人请教，尽量基于真出于善。\r\n\r\n这世界这么美是因为有真，唯有真才有善和美。辛亏这世界很真实，否则人类会生活在自己构造的乌托邦天堂(or 地狱)中。 哪有什么善和美。\r\n当我们去做一些事情时，也要敢于直面问题，把事情做到位。如果有人无法直面问题，尤其是自己团队内的人，理应基于真出于善的指出。\r\n否则我们就是在放任假。 一个放羊的集体，一个真刀真枪在里面待得有点难受的集体，哪一个更善？	2021-01-15 07:44:53.790038	f
1526	750	Issue	5	1，合并性能问题单	2021-01-15 09:07:11.47826	f
1551	766	Issue	5	软件的功能模块是分化的节点，方法与数据都是围绕功能展开的。\r\n比如很多动物都有手，什么是手？我们通过长期抽象知道手是用来移动食物，操作工具的。\r\n而脚这个模块主要是用来移动的。这是最初的分化。	2021-01-26 06:01:08.576198	f
1552	767	Issue	5	比如开会的质量。\r\n\r\n开会先得把本质事情做到了，按量表达到位了。然后还得从时间等各种量化指标来衡量整体质量。	2021-01-26 06:13:14.63867	f
1553	711	Issue	5	沟通还有一点是精确表达，即把事务的本质以及其他属性以量化的方式表达，以及事务内部关系等。	2021-01-26 06:16:23.855015	f
1555	752	Issue	5	唯有发自内心的热爱才能立志，压力与情绪不能让人立志。语言刺激的效果持续不了多久。	2021-01-26 06:53:17.530071	f
1556	768	Issue	5	君子是追求自我改进型的，自我进步就是最大的满足。\r\n小人是追求自我满足型的，其满足并非来自于自我的改变，而是依附于他人和外物。\r\n\r\n小人通常少宽容，少感恩。而君子在出现问题时在自己身上找原因找解决方法。	2021-01-28 07:36:22.267315	f
1530	752	Issue	5	载已载物做君子，携亲引友游世间。\r\n道阻何必满腹骚，当学孔子乐生活。\r\n\r\n为什么游？游刃有余，游也是看见。\r\n为什么是世间？ 世间有真，善，美。\r\n去直面各种问题，跨过难关，看见世间的真善美。\r\n为什么君子？要有这种能力，不断学习，自强不息。\r\n孔子之乐？生机畅达。	2021-01-17 06:07:24.571234	f
1533	754	Issue	5		2021-01-18 06:02:38.443103	f
1534	754	Issue	5		2021-01-18 06:03:49.550037	f
1535	755	Issue	5		2021-01-18 06:16:04.418413	f
1536	757	Issue	5	实际：\r\n1，整理coral方案  3小时\r\n2，定位并修改fetch by rowid问题，3小时\r\n3，定位snapshot too old问题，1小时	2021-01-19 18:20:49.032662	f
1537	758	Issue	5	早上在公园跑步，可携带一个运动服换。\r\n15分钟，5圈，估计也就1.5公里，气喘吁吁。	2021-01-20 06:21:06.396337	f
1538	758	Issue	5		2021-01-20 06:21:16.082322	f
1539	759	Issue	5	实际：\r\n1，提交了2个问题的MR\r\n2，沟通了bit类型格式问题。\r\n3，下午有部分时间状态不佳，未有实际进展（大约2小时）	2021-01-20 16:01:20.125555	f
1540	758	Issue	5	晚上打球2个半小时，运动有点过度，练一小时打一个小时强度差不多。	2021-01-21 06:37:09.237965	f
1541	758	Issue	5		2021-01-21 06:37:21.258702	f
1542	758	Issue	5		2021-01-21 06:37:31.330759	f
1543	761	Issue	5	早上由于无法早起，未运动	2021-01-21 06:38:20.295356	f
1544	760	Issue	5	提问者：\r\n1，这变量啥意思？\r\n2，这函数啥意思，在这种含义下，其名称和函数合理吗？里面逻辑符合名义吗？\r\n3，这过程步骤是否合适？\r\n4，这结构关系清晰否？是否太大或太小？\r\n5，有坏味道？\r\n\r\n符合生长与分化原则吗？	2021-01-21 13:04:46.610717	f
1545	756	Issue	5	不符合开闭原则，也就不符合生长原则，即原实体或过程并非有确切含义	2021-01-21 13:15:32.6579	f
1546	760	Issue	5	TDD，要求不要写垃圾测试，接口应该被良好定义。不好测试的代码当然不是好代码\r\nhttp://blog.cleancoder.com/uncle-bob/2016/03/19/GivingUpOnTDD.html	2021-01-21 15:23:10.248689	f
1547	762	Issue	5	bit转换效率，为什么anchorBase使用该存储格式？	2021-01-21 18:58:53.135685	f
1548	765	Issue	5	http://blog.cleancoder.com/uncle-bob/2014/03/11/when-to-think.html	2021-01-22 06:37:18.57429	f
1549	766	Issue	5	有次结构，review代码就知道该干啥了。\r\n\r\nreview代码就是看每个地方是否合理？ 是否有错误？是否有效率？是否安全？ 是否具备Dfx？	2021-01-24 06:20:10.636116	f
1550	696	Issue	5	1，快速启动原则\r\n1.1 小跳借力\r\n1.2 反向蹬地\r\n\r\n2，水平步防守，垂直步进攻\r\n\r\n3，启动步频快，结束步子大\r\n\r\n4，垫步调整方向，并步接球，交叉步回位。\r\n回位的过程中完全放松，同时准备好击球。\r\n李宗伟就是放松这步做得非常好，因而看上去很轻松。\r\n\r\n5，重心高度与击球位置同步。\r\n\r\n6，预判能力，击球后考虑回位能力，不要一味抢高。	2021-01-24 19:50:17.162382	f
1557	768	Issue	5		2021-01-28 07:36:35.386095	f
1560	771	Issue	5	早上十分钟跑步	2021-02-01 06:12:48.900809	f
1561	761	Issue	5		2021-02-01 06:13:06.038947	f
1554	711	Issue	5	领导力，创新力，探索能力，想象力\r\n认知力，调度大脑进行思考，思考的方法等，方法论。（理解力，底层架构，记忆力与调用知识）\r\n表达力，沟通，描述能力，把理解的展现出来。\r\n执行力，包含管理能力。\r\n\r\n人的基座还是世界观，人生观，价值观。深刻的理解才能举一反十，运用于现实世界。\r\n个人对于世界的理解，自己的追求等。\r\n	2021-01-26 06:50:10.168063	f
1527	573	Issue	5	学习的4个关键点：\r\n1，为学需立志\r\n   立志就是一有空就想到它，取得进步就开心，没有进步就提醒自己。\r\n2，日日之功\r\n   不断完善，通过不断练习，将部分思考变得很快，就有脑力思考新问题。\r\n   比如打羽毛球，当我们还不会手法时，注意力在手法上。\r\n   当我们会了手法，注意力保留在自己步伐上。再之后就在技战术上。再之后就是预判上。\r\n3，知行合一\r\n   要根据实际情况调整，真善美，首先得真。\r\n4，方法论	2021-01-17 05:12:57.581732	f
1565	705	Issue	5	攻：杀，抽，扑\r\n防：高，挑\r\n变：吊，挡，勾\r\n\r\n攻击：要有组合拳，有套路。\r\n防：注意力放在薄弱的地方，也是算法，挑到哪个位置？\r\n轮转算法\r\n\r\n个人技术：\r\n1，身法\r\n2，手法\r\n3，步伐\r\n每个动作都是上述三方面的叠加。\r\n\r\n策略：\r\n1，击球速度\r\n2，击球角度	2021-02-01 18:15:26.998508	f
1571	742	Issue	5	锤炼技术是出于对技术的热爱。很多人对于技术并没热爱，这是问题的根源。\r\n我对技术也没啥热爱，但是我对做出某种结构的产品有兴趣，工作者如果不是为了自己的理想而努力，\r\n就是没找到自己的目标，自然缺乏热情和积极性，除了热爱技术的工程师。	2021-02-18 06:52:23.474967	f
1572	752	Issue	5	锤炼技术是出于对技术的热爱。很多人对于技术并没热爱，这是问题的根源。\r\n我对技术也没啥热爱，但是我对做出某种结构的产品有兴趣，工作者如果不是为了自己的理想而努力，\r\n就是没找到自己的目标，自然缺乏热情和积极性，除了热爱技术的工程师。\r\n\r\n还有人是为了钱而努力，那也没问题，他们会因钱的刺激而有动力。\r\n这社会上愿力够强，实力也够强的人能做成事。\r\n愿望美好而没实力的人，跟实力很强但没目标的人都成功不了。	2021-02-18 06:54:03.061273	f
1576	776	Issue	5	破心中贼，因而我能逐步前行。\r\n\r\n树立了以乐和仁为核心价值观。\r\n让自己乐，让身边的人乐\r\n乐是一种能力，一种感知别人的能力，一种让自己成长探索的能力。\r\n\r\n心中贼没了，可以走出自己，接受现实情况，如有梦想，请往前走。	2021-02-22 06:19:51.39513	f
1582	752	Issue	5	象与骑象人的故事：\r\n1，在最开始的时候骑象人跟象是一体的，因为骑象人是一个幼儿，还没自己的想法。\r\n   主要心思就是玩耍，探索这边的世界。这阶段虽然美好，但是也仅限于其没有额外能力要求。\r\n2，再长大一些，象还是以前的象，但是通过生活它得到了一些感知经验，知道了恐惧，热爱。\r\n   而骑象人也长大一些，开始收到社会规则的约束，开始受身边人的影响。读了书，形成了很多观念。\r\n   但这时候骑象人与象的探索都是不够的，分辨不清楚真假，看不清方向。\r\n   这时象和骑象人经常是矛盾的。\r\n3，训象阶段，等继续成长，人的思想意志会进一步增强，对自己的了解也更加深入。开始利用意识去\r\n   改变大象，并且在行动时考虑到大象的特征。\r\n4，人象合一，终于经过多年练习，自己和象又恢复了最初那和谐的状态。   \r\n\r\n打破一个思维：\r\n我不知道前进是否合适？我想回到过去，回到我的家乡以及曾经美好的年代。\r\n我做不到，王侯将相宁有种。\r\n这是鬼神，宿命论的思维，即便在现代社会，仍然非常流行。\r\n这种人是没长大的，恐惧与稀缺支配了其思维。\r\n\r\n打破一个思维陷阱：\r\n即如果我们一方面做得更好，另一方面就会做得不好。\r\n如果我们把时间用于学习，就没有时间用于玩。\r\n\r\n这是不科学的思维，一方面我们有不少时间没好好利用，另外在效率上我们也有极大提升空间。\r\n在生活中骑象人自己的行为并不合理。容易进入不合适的自动驾驶阶段。\r\n为什么，因为象还没改变，这是非常艰难的阶段，需要积累量变。\r\n成功学的根本问题在于只传授方法，而人的问题在于世界观，人生观，价值观等根本性的东西。\r\n不是一朝一夕能改变的。	2021-02-28 14:04:10.096251	f
1585	788	Issue	5		2021-02-28 14:51:10.878556	f
1587	649	Issue	5	1，定义行为\r\n2，根据行为的大体实现，将系统分为不同的功能模块。(分解，有无，如无必要勿增实体)\r\n3，将不同功能模块进行合并(最小化系统需要的模块)，定义清楚组件之间的边界。\r\n4，定义不可扩展与可扩展部分，重点设计不可扩展部分。\r\n5，行为推导与演练	2021-03-01 06:13:02.419309	f
1591	646	Issue	5	会的标准是一看别人的就知道问题在哪	2021-03-04 06:15:00.859454	f
1593	221	Issue	5	1，筛选简历\r\n1.1 做初步排除，包括学历，经验匹配程度，工作成果，待遇，年龄等。\r\n1.2 输出个性化问题，排除潜在风险点。\r\n2，自我介绍\r\n2.1 了解一个人的精神风貌，表达愿望，条理，个性等。\r\n3，选取一个工作任务，展开讲\r\n3.1 考察表达能力\r\n3.2 考察设计能力,以及创新想法\r\n3.3 考察软件实现能力\r\n\r\n常见问题：\r\n1，why使用某种模块划分，结构？\r\n2，设计目标？关键技术点是？\r\n3，如何改进？(思考力，有无思考方法论)\r\n4，为什么使用该结构？\r\n5，计算方法是否可以改进？(创新想法)\r\n6，(扩展)如何理解设计模式？设计的理解？\r\n\r\n4，工程能力\r\n4.1 怎么做软件开发，使用什么常见工具，版本控制，分支管理。\r\n4.2 如何看待TDD\r\n4.3 一般会遇到什么bug，怎么解决？\r\n4.4 linux基础，网络，存储，计算等。\r\n\r\n5，职业发展\r\n5.1 目前的成绩，为什么转？\r\n5.2 方向是怎样的，怎么看待行业？\r\n\r\n6，三观\r\n这方面的问题比较难问。可从简历中来。这类问题不适合太多。\r\n6.1 如何看待房价，是否有压力\r\n6.2 如何看待工作\r\n6.3 工作或生活中遇到的困难时刻，如何面对？	2021-03-04 15:30:16.866021	f
1592	649	Issue	5	1，架构时一定要封装概念，模块，否则思考容易陷入细节而不能自拔。\r\n比如在设计coral时，关于元数据怎么和PN同步，怎么刷到远端，怎么做物理复制等，揉在一起思考太难了。\r\n如果包装一个延迟执行器概念，瞬间就清晰了。 本来静态对象的操作是在远端执行的，搞出上面同步那些概念\r\n都是出于存储计算分离，因而要做延迟执行引起的。没用本地执行就没用复制，也没用跟PN同步，也不用刷远端。\r\n\r\n为什么才是问题的根本，也是架构推导的基础。\r\n人为什么要口是出于吃的需要，否则就成不了人。\r\n\r\n而且细节不包装成概念就难以复用。	2021-03-04 06:24:16.982253	f
1594	649	Issue	5	软件设计本质上是将我们对人和事物的理解认知，通过软件表达出来的一个过程。\r\n设计能力本身是需要不断去锻炼的，除了掌握基本的设计素材，一些经验，还有核心的将整个设计从理解到变成设计文档表达的能力。\r\n这里有逻辑推理，假设分析，选择等等。	2021-03-05 07:35:34.814744	f
1644	818	Issue	5	步伐的关键在于节奏，为什么脚落地击球是利用其反弹力，进行下一步的调整。\r\n打完球停下来节奏就没了。 所以不能跟什么水平的打球，自己出球后的回动速度是自己击球速度决定的。\r\n这是由自己控制的节奏。等对方开始击球则自动权在对方，要保持耐心跟住他。等到自己时可以变节奏。	2021-04-01 21:16:29.447454	f
1566	772	Issue	5	CoralEntry页\r\n前端格式\r\n后端格式\r\n文件格式的meta\r\nSlice描述符 {\r\n id\r\n state\r\n format\r\n scn\r\n}\r\n\r\nSlice描述符 {\r\n id\r\n state\r\n scn\r\n segment entry\r\n index entry\r\n}\r\n\r\n0号slice固定为active slice\r\n1~9号slice固定为stale slice。\r\n  即最多同时允许9个stale slice。如果无法完成stale slice转换，则可能阻塞写入。\r\n10~ slice是stable slice。  \r\n\r\nindex_meta(定义每列的入口，每种类型一个入口)\r\nindex data\r\n\r\nstatistic与index统一表达，即将null,count,sum等作为sparse index统一处理。\r\n\r\n在writer生成流之后，使用reader接口将统计信息写入到coral中。	2021-02-01 18:18:29.589604	f
1568	705	Issue	5	https://www.bilibili.com/video/BV1hZ4y1M7wB\r\n转身的启蒙，李宇轩教练。	2021-02-02 06:42:12.818317	f
1596	658	Issue	5	人生：\r\n1，真正的安全感，来自你对自己的信心，是你每个阶段性目标的实现。\r\n2，真正的归属感，在于你内心深处，对自己命运的把控。\r\n3，人最大的对手是自己。\r\n4，随意宣战的人不是高手，同样随便压制他人的人也非高手，让他们自己纠缠于其中吧，让自己优秀是对他们最好的回击。\r\n5，我选择了让身边的人变得更加快乐，我选择了充满激情的生活，我选择了在未来去达成理想，我选择了意义。\r\n6，充满困难的时候不要沮丧，提升自己的机会来了。\r\n7，现状的落魄和理想的光芒并不冲突。我能看到美好，并把他们分享给其他人。\r\n8，当我无知(对一些情况不了解)，恐惧，焦虑的时候内心的恶魔就容易跑出来作恶，压制他人生命。看见自己的问题并解决它，\r\n光明就会出现。	2021-03-07 14:03:40.01689	f
1567	705	Issue	5	身法\r\n\r\n有三种球：\r\n1，肩部以上\r\n1.1 身前\r\n1.2 身后\r\n2，肩部以下\r\n2.1 腰部以上\r\n2.2 腰部以下\r\n\r\n\r\n肩部以上，皆需转身。\r\n高球皆可杀：\r\n1，网前高球，扑杀\r\n2，身前高球，向前跳杀\r\n3，身后，或身后左侧，后退蹬地杀\r\n4，身体右边，跳杀\r\n\r\n肩部以下，皆需下蹲。\r\n\r\n打球先瞄点，这个点是击球点，点是立体的。\r\n所以身体高度要变，身体姿态要变，架拍动作要变，脚要瞄点。\r\n\r\n双打除了基本步法外，跳步非常重要。\r\n\r\n身体左侧做与右侧相反动作，保持身体的稳定和平衡。\r\n\r\n右脚尖指向击球方向。\r\n\r\n	2021-02-02 06:17:13.725575	f
1599	795	Issue	5		2021-03-08 06:07:57.142549	f
1617	812	Issue	5	软件的根本是什么才是心法\r\n设计模式的SOLID原则应该算是规则集\r\n设计模式是招式\r\n具体实现是执行\r\n\r\n跟羽毛球一样，羽毛球本质上是对战游戏，平衡与发力是其基本面。核心之所在。\r\n软件的本质是行为的自动化。实体-关系-状态，核心就是复杂度与可变性。\r\n\r\n心法：怎么看待事物相关的一切。由此看去心中便可运行推理。\r\n核心：主导原则集，比如现代社会的高度分化决定了善于连接的人将有巨大的优势。\r\n招式：具体动作序列，这个需要刻意练习\r\n执行：这个讲究灵机应变，很需要实战经验。\r\n\r\n	2021-03-18 06:25:49.763648	f
1605	807	Issue	5		2021-03-16 06:41:44.211454	f
1609	811	Issue	5		2021-03-17 06:16:06.502317	f
1610	811	Issue	5	架构是什么？\r\n设计模式是什么？\r\n编程是什么？\r\n如何判断技术方向？\r\n\r\n辅以代码实例，图解。	2021-03-17 06:20:37.249263	f
1611	807	Issue	5	设计模式在本质上是实体关系的常见范式。比如工厂，适配器，迭代器，餐馆服务员(命令，中介？)，比如零售等等。\r\n想想现实世界中的实体关系就明白了。 企业创新本质上和编程无异。 提供有竞争力的行为是核心。\r\n\r\n模式创新，行为创新，结构创新。\r\n	2021-03-17 06:39:24.485836	f
1613	770	Issue	5	朱程理学如果不是服务于道德教育，走向科学方向。则能大成。\r\n王阳明心学是从心中运转外物，是最基本的规则入手，探究复杂事物，必须强调知行合一，否则容易误入歧途。\r\n\r\n\r\n这2者的区别主要来自于认知方法上的差异，心学的方法是从本心出发。\r\n有点唯心与唯物的区别的味道。\r\n\r\n而理学方法是从外物出发。最终都是为了刷新认知，得到知识。\r\n理学方便延伸细节并打开未知领域，心学便于掌握根本和宏观。	2021-03-17 07:26:14.883691	f
1615	809	Issue	5	对象执行器：\r\n1，提供buffer能力，即多次执行，单次持久化。\r\n2，提供多对象修改的原子性保证\r\n3，提供对象的行为(涵盖局部修改能力)\r\n4，支持一写多读\r\n5，支持写节点上的并发操作\r\n\r\n对象执行器是一个可以独立服务的项目。\r\n其可以启动一个service，其client可定义对象类型，以及其行为。\r\n然后client编辑对象行为序列，将其发给service执行。\r\nservice支持一写多读(可支持类似zookeeper能力)\r\n\r\n其实对象执行器本质上跟zookeeper、etcd类似，区别在于其将元数据操作也存入对象中。\r\n或者本质上其充当了部分元数据的能力。但与上述组件不一样在于其可以完全关闭，甚至可以迁移服务。\r\n不存在本地状态。\r\n\r\n另外一个区别在于etcd等本质提供的是kv接口，而对象执行器提供的是对象上的action。	2021-03-17 09:10:07.78456	f
1604	649	Issue	5	设计是在一定环境下运用结构化的实体来实现具备某种特性的行为。设计的根本困难就是平衡复杂性(一致性可以看成复杂性的一个)和可变性。软件的根本特征还有不可见性(或者说抽象性)，可复制性。\r\n结构化-复杂度-可变性\r\n\r\n结构化：\r\n分解是为了复用和简化。\r\n垂直分解还可以屏蔽细节，同时也可以抽象应对变化，即变化时不增加复杂度。\r\n\r\n除了结构化方式简化复杂度外，还有一种方法可以简化复杂度：将行为动作包装起来。\r\n比如要求多个动作具体原子性，可以利用原子操作概念进行包装。\r\n\r\n设计模式是组织实体的方式，通过模式规范了实体的关系。\r\n\r\n这里提一个疑问：为什么一定要结构化，分化才能演化出新特性？\r\n              话不能这么说，很多结构化尝试都失败了的，但是为啥人类不停止复杂化？这是人被设计之初就确定了的。\r\n              即人有这么大的探索空间。在一个群体中不太可能限制人探索出新结构。只会在某方面变得更强更分化，直到灭亡。\r\n\r\n天地有大美而不言，好的东西没那么容易看见。需要我们努力。	2021-03-15 19:03:24.915938	f
1616	812	Issue	5		2021-03-18 05:52:37.032199	f
1620	817	Issue	5		2021-03-19 12:59:25.789984	f
1621	646	Issue	5	手腕手指不可提前发力，否则会受伤，即小臂的力尚未传到手腕，此时手腕发力就会受伤。\r\n另外手指力量有限，不可强行大发力，否则也容易受伤。	2021-03-20 15:59:50.864591	f
1623	793	Issue	5	手指发力的核心在于拇指和食指要钳住拍子	2021-03-20 16:12:13.662238	f
1625	819	Issue	5		2021-03-21 07:32:25.966242	f
1569	774	Issue	5	终于知道为啥要架好肘了\r\n力是怎么来的，从蹬地来的，即下肢以及臀部发力而来。\r\n我们知道力是带方向的，下肢的力量主要带来的是旋转之力，还有上升的力。\r\n跳杀下肢力量主要用来上升，其旋转是通过腰腹的力量完成的。\r\n原地杀，下肢提供了除了上升之力，还有旋转之力。腰腹是用来辅助旋转，维持稳定的。包括胸肌，背肌也是如此。\r\n做个简单实验：坐在椅子上旋转就比脚落地旋转难很多。\r\n\r\n而且从蹬地接力时，核心要收紧才有很好效果。准确说力不是从地面来，是来自下肢肌肉。人体下肢肌肉发达。\r\n\r\nok，再往上，胸肌和背肌旋转上半身，需从腿部借力，那当然在此以下部位应该绷紧。\r\n通过旋转让大臂，手肘有了初速度，然后大臂带动小臂，做旋臂或摆臂运动，小臂做内外旋运动，手指握紧等。\r\n同样做实验：做椅子上打羽毛球，会发现大臂和小臂都可以运动。但是有一点大臂和小臂不好同时运动。\r\n羽毛球就这点跟其他运动区别巨大，它是速度型的，小臂当然比大臂速度快。\r\n要么动大臂，要么固定大臂肘，动小臂。\r\n\r\n所以理解了为什么肘相对大臂几乎不动。因为肩部不能主动发力。\r\n\r\n另外注意手臂运动对整体稳定性的影响。\r\n\r\n所以羽毛球运动发力链是：\r\n1，蹬地旋转身体(左上旋)+旋臂/摆臂(肘都是定的)+ 小臂内外旋+ 手指握紧\r\n上身旋转把地蹬\r\n收紧腰腹好传力\r\n放松小臂来旋摆\r\n肘步固定不甩臂\r\n小臂内旋手指紧\r\n手腕切莫提前动\r\n\r\n羽毛球只有三类发力：\r\n1，全身发力打后场球\r\n2，手臂发力打中前场\r\n3，手指发力的前场球\r\n后面2种更多不是发力技巧，主要是步伐和身位的问题：\r\n1，下蹲或起跳，确保合适击球点\r\n2，确定好肘部位置。\r\n3，确保步伐能到且身体稳定。\r\n\r\n\r\n	2021-02-04 18:08:11.954205	f
1583	787	Issue	5		2021-02-28 14:48:43.70755	f
1570	752	Issue	5	非要回到某个环境，这不真实，人应该往前走。\r\n\r\n人生经历阶段\r\n四处张望的阶段\r\n\r\n刚开始我不走，也不四处张望，呆滞的站在那里。\r\n慢慢我四处走走，但是偶尔总想回到过去。\r\n如今我知道过去已不可能，我坚定的往前走，但也不往前跑。\r\n\r\n就像中国人的侠客梦，英雄梦一样，很多人做着但梦幻与梦想的区别在于是否真的去做。\r\n人想回到某种感觉，然而这是虚幻的。\r\n\r\n真善强乐美色财名。\r\n不同的人价值观念不一样，上述在其心中地位不一样。\r\n君子顺之，小人反之。\r\n光明与黑暗的较量，黑暗的人是因为生长环境被污染，积重难返。\r\n\r\n\r\n我想自己成为一个充实而活泼的人。这需要切实的能力，以及物质基础。\r\n修身齐家立业这是我要做的事。我亦希望我有实力去感知这美妙世界，去承接外物。\r\n厚德载物，上兵伐谋。\r\n要明白人造物是必然经历的阶段，不完美但其是客观事实。\r\n不要在妄想回到过去，更不要想岁月静好，如果是梦想就去做，如果是梦幻就放下。\r\n更不要害怕冲突，上兵伐谋，如果刀兵相见，而无胜算，则可能已经败了。\r\n往前走去解决问题，而不要妄想倒带。\r\n\r\n人无法往前，通常是因为心中贼，比如如下心中贼：\r\n1，集体主义，过于依赖集体环境。\r\n  在恐惧，稀缺的环境中生活太久，害怕尝试改变，缺乏独立思考的能力。\r\n2，命运论\r\n  别人做到是有其他原因，运气等。\r\n3，神秘主义\r\n  不知可，做了也不一定能成。\r\n4，均衡思想\r\n  认为有所增益，则有所损。原生就很好，不去改变。\r\n5，比较思维\r\n  别人做得好反而不舒服，觉得自己比别人好。零和博弈思维。\r\n  主观树敌。实则完全没必要。人要跟自己比。\r\n6，别人做的不对，别人是SB\r\n  即便别人不对，那也是别人的选择，要立于当下来解决问题。\r\n7，上瘾，在某些事情上明显投入过多无效精力。\r\n  人与物是相互的关系，看似人占用，拥有。反过来说物也占有人。\r\n  过往不念，未来不追，立于当下。\r\n8，yy思想\r\n  幻想回到某个环境，自己很想得到的也不去争取。\r\n  没有梦想，只有幻想。\r\n  \r\n	2021-02-17 16:31:52.305954	f
1584	108	Issue	5	权力的本质是行为约束。	2021-02-28 14:49:23.986267	f
1574	681	Issue	5	经济：\r\n1，从事经济生产的结构\r\n2，商品流动	2021-02-20 19:01:31.412504	f
1573	137	Issue	5	权力本质上是群体环境中对不同个体的对行为约束。\r\n政治是对群体的划分，包括对权力的划分。\r\n\r\n所以良好的政治制度可以将人更好的划分，以及达成更合适的约束。\r\n以利于群体发展。\r\n而一旦制度不合理，则会造成社会矛盾，影响发展。\r\n比如明朝的制度与经济发展就很矛盾。\r\n\r\n政治包含3部分：\r\n1，权力\r\n2，群体划分，以及关系\r\n3，群体价值观，以及行为\r\n   政治正确的含义	2021-02-20 18:57:51.300415	f
1575	752	Issue	5	让自己和身边的人变真正的快乐，正向的快乐。\r\n\r\n1，以好奇心体验真善美\r\n2，以能力获取名权财色\r\n3，身体健康等\r\n\r\n以乐为出发点是比较好的，我们并非冷冰冰的人。\r\n\r\n关键词：\r\n2020年-看见\r\n2021年-破心中贼，至强有为，以乐待人	2021-02-21 06:06:39.974464	f
1577	781	Issue	5		2021-02-23 07:09:45.99392	f
1578	778	Issue	5	快速摆肘后制动，然后甩小臂，关键在于集中发力，想想鞭子慢慢怎么甩得起来。\r\n击球点要控制好，身体要保持稳定	2021-02-25 06:25:19.740493	f
1579	775	Issue	5	存储结构难搞难在ACID，如果能将ACID封装成基本能力。\r\n而结构开发者只需进行结构开发即可。	2021-02-26 07:16:09.023293	f
1580	752	Issue	5	1阶段是虚幻，假的。生命被压制，依赖。\r\n2阶段是蒙昧，鬼神，未可知\r\n3阶段终于做到以真，以可知探索，知道生命当不断努力，生生不息，而且并不排斥去探索。\r\n4阶段，人之道，有了自己的价值选择，不去压制他们生命，以乐以平等对待他人。\r\n\r\n说白了是世界观问题，不能以客观看待世界，因而虚假与鬼神存在。\r\n价值观是对客观事物价值的判断。 你可以认为电视机比一堆材料更有价值，问题在于这相对谁而言。\r\n即观察者很重要。价值观来自于人对于维护谁的利益的选择，通常我们先维护自己，然后是亲人，然后是其他人，再是动物，植物，无机物等。不选择就没价值观。\r\n\r\n你可以认为人生毫无意义，这意义本身就是相对人而存在的。人定义了就有了意义。所以当然你得选择，确定了意义就有了人生观。\r\n世界观，你可以认为这世界是虚幻的，相信自己能回到过去，认为世界是鬼神创造的，相信宿命论。还有一种是坚定的唯物观点。认为世界\r\n的一切状态都是人活动的产物，坚定的改造自然。\r\n\r\n大象与骑象人模型一样，深入骨髓的三观就是那个大象看到的，自动驾驶模式下才会变得更好。\r\n技能和观念就是骑象人。\r\n\r\n	2021-02-28 07:54:10.854616	f
1581	752	Issue	5	还有一种变强的心理障碍是冲突，然而在冲突中只有强才有资本，而且冲突是最坏的选择，在能力强的时候我们可以有更多选项。\r\n就如孙子兵法所言。	2021-02-28 08:34:02.870519	f
1586	788	Issue	5		2021-02-28 14:52:19.19387	f
1588	646	Issue	5	1，(瞄点)架拍，架子得有，不然小臂手腕难放松，立腕拍面朝外，右腿丈量击球点，击球点应该尽量在右脚点前上方，侧身，重心后压。\r\n2，(倒拍)抬头，左手指向来球，曲右腿，展肩，收右肩右臂，后倒。侧身展肩重要是因为这样可以让身体，大臂，小臂在一条线上运动，这样下一节可以充分借速度。\r\n3，(引拍)拉回左腿左手，自然转右肩(旋转之力来自拉转)，蹬地向上摆臂，右臂和肘上升(这很关键，不然小臂怎么后倒？)，重心转到左脚，小臂自然后倒，立腕。此时身体被上升的力牵引，并转化为甩出的力。\r\n4，(击球)甩小臂，微内旋（估计45度就够了）保证正拍面击球，同时食指推球拍，握紧。\r\n5，(收拍)身体此时转正，且成左脚在后姿势，重心在两腿之间。\r\n\r\n关键在于4点:\r\n一是拉转提供旋转之力\r\n二是蹬地提供击球方向上的力，动作要配合这个发力\r\n三是要律动，有节奏的发力和鞭打。整体发力在一条线上，二是一定是上一节带动，反过来就容易受伤且速度不快。定肘很关键，不定肘，则必然甩大臂，只有定肘才能甩小臂。\r\n四是点要准，右脚瞄点，击球的空间点。\r\n\r\n这个版本的改进点：\r\n1，明确了旋转的力和蹬地的力的用途。先拉后蹬地。用蹬地力旋转也不好控制身体的稳定。\r\n   而且从录视频看，还是有明显右脚向前动作，如果蹬地用于旋转这是必然的现象。这样这边的伸展完全是没意义的，拉转的精髓就像李宇轩说的，你要弹出右边，应该在左边发力。\r\n   旋转发力还有一个结果就是没法律动，必然是肘和小臂一起甩出去。要么就是甩大臂。\r\n2，明确了律动，而不是肘，小臂放松一起甩。不然用很大力，效果也不怎么好。\r\n3，同样也是延升自第一点，有个结果是击球点不够靠前，因为旋转的力存在，在侧身处击球最舒服。根本上不需要太大旋转的力，击球来自于蹬地的力。\r\n\r\n\r\n	2021-03-02 06:26:25.780489	f
1589	705	Issue	5	羽毛球拍和球决定了：\r\n1，发力的球需要鞭打\r\n2，球拍和球的碰撞对击球效果影响很大。\r\n击球的角度很关键，如果球从上压的很近，则很难打到前面。	2021-03-04 06:04:11.15498	f
1590	646	Issue	5	今天练高远感悟：\r\n1，大臂要放松\r\n2，拉转和蹬地的力要协调好，这是发力的精髓\r\n3，碰撞的点很关键，在垂直和水平方向的击球点都很关键。	2021-03-04 06:13:20.429403	f
1597	794	Issue	5	实体，动作\r\n动作没推导到实体引起的问题，比如我说slice上的更新可以用删除来表示。\r\n但实际没考虑到多个slice实体，包括stale slice和active均存在的情况下的推导。\r\n即存在2个问题：\r\n1，未定义实体，会陷入想不清楚的境地。\r\n2，没有在每个实体上进行行为推导。\r\n\r\n思考力是什么？\r\n学会内功，他人招式才好为我所用。这就是内功。\r\n编程的内功是思考的能力	2021-03-07 21:07:18.151199	f
1618	610	Issue	5	羽毛球运动本质上是羽球对战运动。\r\n对于运动平衡与发力是其基本面，平衡是核心是因为人是直立动物，保持平衡对于人来说是比较困难的。\r\n羽球特征决定了其鞭打发力，逐节发力，要求慢启动。\r\n\r\n软件的本质是行为的自动化。实体-关系-状态，核心就是复杂度与可变性。\r\n\r\n心法：怎么看待事物相关的一切。由此看去心中便可运行推理。\r\n核心：主导原则集，比如现代社会的高度分化决定了善于连接的人将有巨大的优势。\r\n招式：具体动作序列，这个需要刻意练习\r\n执行：这个讲究灵机应变，很需要实战经验。\r\n\r\n这也分别对应了技术的层次，王国维的三层次是不包含第一层的，因为第一层还没进入深入思考层面。\r\n当然每层不是说领悟了即达到了，还需反复练习。直到随意所欲的地步。\r\n\r\n拥有心法的人才能算有了体系。才能成为大师。	2021-03-18 06:31:34.780161	f
1637	827	Issue	5		2021-03-27 15:57:03.482893	f
1638	831	Issue	5		2021-03-28 16:06:00.979141	f
1619	562	Issue	5	关系数据库在根本上是将数据按实体切割，以对应不同变化。这跟划分结构体没啥区别。范式也是应对更新冲突的。\r\n关系数据库的核心是sql+ACID，是过滤，投影，连接这几种数据集上的公共运算能力，以及事务机制。\r\n\r\n像一次面试中提到的将proto格式消息根据嵌套关系分解存到不同表的技术方案纯粹是扯淡。如果说有必要也不是为了解决存的问题。\r\n关联的数据如在同一个维度变化，为啥要分不同表？况且新增的字段划分到哪个表? 按何种规则去划分？解决嵌套映射到表字段可以有其他办法，不必因此拆分表。	2021-03-19 10:17:30.093279	f
1622	646	Issue	5	平衡->衔接->逐步->旋转->启动	2021-03-20 16:02:41.734595	f
1624	812	Issue	5	软件结构上主要有3点：\r\n1，分化稳定性\r\n  即定义一个变量/结构/函数 它应该有唯一确定的含义。\r\n  不应该随风摇摆，漂浮不定。\r\n  结构概念行为应该出现其相应的分化层次上。\r\n\r\n2，奥卡姆剃刀原则\r\n\r\n3，可见性原则，或最小知识原则\r\n\r\n4，封装变化\r\n  变化再所难免，但变化不应该导致大面积调整。\r\n\r\n5，避免冗余\r\n  重复通常意味着没有很好抽象，或层次不对。\r\n\r\n设计是面向抽象的编程，顶层概念很重要。	2021-03-21 07:10:54.249553	f
1626	649	Issue	5	      行为\r\n    实体 关联\r\n  分化 抽象\r\n状态\r\n\r\n行为是根本因为行为是重点，实体是变化的。\r\n\r\n看软件的根本跟日常表达很接近，主谓宾，主谓。但是理解一个句子核心是谓语。	2021-03-21 08:13:23.254339	f
1628	822	Issue	5	最简单的locker完成\r\n接口暴露\r\nobject\r\nlock range\r\nlock context\r\nlocker	2021-03-22 15:29:06.583272	f
1629	827	Issue	5	基于本地文件系统实现oos模块。\r\n一个完整的系统。	2021-03-23 14:28:52.231476	f
1634	830	Issue	5	<pre>\r\nstruct Talk {\r\n        x : u32,\r\n    }\r\n\r\n    struct Talks {\r\n        ts : RwLock<HashMap<String, Arc<RwLock<Talk>>>>,\r\n    }\r\n\r\n    impl Talks {\r\n        fn get_write(&self) -> RwLockWriteGuard<Talk> {\r\n            self.ts.write().unwrap().get("1").unwrap().write().unwrap()\r\n        }\r\n    }\r\n\r\n这段代码问题出在哪，write().unwrap()限定了出来对象的生命周期\r\n</pre>	2021-03-26 16:25:21.870051	f
1635	830	Issue	5	同理，这种写法也有问题\r\n<pre>\r\nstruct Talk {\r\n        x : u32,\r\n    }\r\n\r\n    struct Talks {\r\n        ts : RwLock<HashMap<String, Talk>>,\r\n    }\r\n\r\n    impl Talks {\r\n        fn get_write(&self) -> &Talk {\r\n            self.ts.write().unwrap().get("1").unwrap()\r\n        }\r\n    }\r\n</pre>	2021-03-27 07:04:49.899626	f
1640	827	Issue	5	log batch大小可控，还可支持savepoint。\r\n这样可保证提交尽可能的快，其实主要是做内存序列化，应该效率没问题。\r\nlog batch提交给op queue，这个动作也应该非常快。read从op queue拿到的也是arc指针而已。\r\nlog batch是只读的。	2021-03-29 19:37:38.760962	f
1641	827	Issue	5	接口是使用pool str，还是使用pool结构？\r\n如果meta是全cache，那么在执行完即可清理rdlog内存中的queue。\r\n障碍在于删除信息，假设记录是100B大小，则极端情况下删除信息占1/800.\r\n假设一个DN内存为64GB，则可以承担50TB对象的处理。\r\n\r\n不同类型对象的cache策略可能不一样。cache大小也不一样。\r\n思想是利用本地数据加速，PN可从DN拉取对象。此cache也可使用SSD，对象是可以序列化的。\r\nregister class的时候可以指定策略。如未指定，则默认使用LRU。\r\n\r\nmerge的效率：\r\nPN淘汰的对象，其rlog需保留，即queue需留存。\r\n这样从下面拉取的对象才能merge得到新对象。\r\n随着DN writer把对象持久化，可以trim rlog。\r\n可能出现前端写了很多对象，writer来不及刷这样queue越来越大。\r\n\r\ncache分2个，一个是不淘汰的，一个是淘汰的。\r\n根据对象类型来。\r\n\r\n以名称后缀作为类型。以简化接口，同时避免误用。\r\n后缀还有一个好处是读取时直接根据后缀可进行解析，否则还得找到对应的文件名。\r\n\r\nCMS：coral metadata service	2021-03-31 16:09:37.839387	f
1595	658	Issue	5	人生理想：一流的人，二流的思想者，三流的设计者，四流的实践者。\r\n写千万人使用的软件，万人学习的代码和文章，why？已达于自己的真善美。\r\n就像ceph一样。人的目标在于完善自我，则可达到内外一致。	2021-03-05 07:41:54.892875	f
1643	834	Issue	5	设计能力\r\n编码能力\r\n领导力\r\n\r\n基础都是需要的，学习能力，基础储备。	2021-04-01 21:08:32.054931	f
1645	818	Issue	5	步伐的四个关键点：\r\n1，起，启动步\r\n2，承，落地击球+回动\r\n3，转，由回动转为启动，进攻步与防守步转换\r\n4，合，空闲期间的放松，调整\r\n\r\n脚始终有蹬地的感觉，速度就会很快。\r\n还有要注意垫步，目前大后撤和大向前都有点问题。\r\n	2021-04-02 05:17:05.379713	f
1642	646	Issue	5	高远球的"终极"奥义：\r\n将欲发力出击，必先放松会倒。而下一节的放松会倒依赖于上一节的发力，这是羽毛球最难的地方。\r\n不转体则大臂不能放松，不出肘，小臂不能放松，不旋小臂，手腕不能放松。\r\n\r\n蹬地，拉回左边，甩出右边。\r\n拉回左边是为了方便顶出右边。重点在于不要急于发力。\r\n右大臂顶出后小臂自然后倒，有2点好处：\r\n1，小臂有了有效的挥拍空间，业余选手要么苍蝇拍在前面打，要么甩大臂，其实有效挥拍距离非常短。大部分力都无效且影响平衡。\r\n2，大臂有发力甩小臂的能力。大臂和小臂联动则必然发不上很多力。而如果大臂相对静止则很好发力。\r\n\r\n如果上述动作练到很协调，基本高远功力应该能到专业入门。	2021-04-01 06:02:45.363001	f
1646	825	Issue	5	编程之难在于实体的明确定义，没有明确的实体，行为无从依附，数据转递混乱。\r\n以及实体之间的关系。	2021-04-02 05:22:07.030961	f
1648	833	Issue	5		2021-04-05 05:56:06.1252	f
1614	790	Issue	5	常见软件错误：\r\n数据类：1，错误的理解变量含义与范围。 2，不一致的状态。 3，离开作用域的数据，4，二义性数据\r\n行为类：1，缺失或多出或乱序，不协调的动作。 2，动作的边际效应。 3，没有约定好的接口。 4，副作用的动作。\r\n设计类：1，缺乏实体包装引起的复杂性 2，不合适的实体关系。 3，弥散的隐式依赖，包括行为的。\r\n\r\n	2021-03-17 07:28:39.746466	f
1650	553	Issue	5	编程就是为人处事，硬件是造物	2021-04-05 06:14:41.550764	f
1653	827	Issue	5	builder还是绕不过去，PN执行的时候也需要具体的类型才能生成实体，而不能在执行时上下文生成对象并cache。\r\n还是要注册类型以及new函数。	2021-04-08 14:48:26.632929	f
1655	839	Issue	5		2021-04-09 07:36:47.673636	f
1656	827	Issue	5	有个问题：事务执行框架如果不是多线程的咋搞？如何实现一个异步框架下的事务？\r\n          那就只能给函数加接口传handle了，handle肯定不能挂对象上，它们之间没有这么强的关系。\r\n          	2021-04-09 14:38:12.630529	f
1659	841	Issue	5	rust在表达约束上能力很强，即类型系统很完善。尤其是静态约束能力。	2021-04-10 13:13:03.760082	f
1661	712	Issue	5	有2种接口依赖方式：\r\n1，即插即用\r\n2，规范\r\n\r\n比如让block修改支持原子性，需要记录redo，调用redo模块接口，这就是使用规范的方式。\r\n而rust中derive就是即插即用模式。比如物体绑定一个手机使得其具备可定位能力，这就是即插即用。\r\n物体不需要做任何改变，只要说我需要什么能力即可。\r\n	2021-04-10 15:57:59.448297	f
1664	829	Issue	5		2021-04-14 08:11:18.944027	f
1665	847	Issue	5	OLAP本质：辅助发现维度之间映射关系。\r\n技术干线：通过维度表，事实表等重新组织数据的方式，来满足olap维度关联查询的要求。\r\n          这决定了其ETL的处理方式，不ETL则与OLTP共享数据。\r\n          汇聚数据分析，在历史，地域，重复中寻找关系。\r\n其他技术：压缩，预计算，索引。          \r\n应用：    决策参考，但是未来数据必然作为生产资料参与计算。作为程序的部分输入。\r\n          统计、预测、洞察、规划、决策等目前都是人做出来的，总有一天这些也会部分被机器取代。	2021-04-15 06:58:47.957577	f
1666	820	Issue	5	如果从人的生产关系来说，可以划分为奴隶时代，土地奴隶时代，机器奴隶时代，程序奴隶时代。\r\n自由，那是少数人才有的奢侈品。更多人的奋斗目的仅在于让脖子上的绳子不勒那么紧。\r\n然而我们可以选择让自己内心自由，不要让物质和生存把我们的内心也奴役。	2021-04-15 07:06:54.663931	f
1669	658	Issue	5	边界，设计一个软件最开始得考虑需求，场景，边界。\r\n人也是如此，我们规划自己的版本也得考虑需求背景之类。\r\n选择自己那颗子树，不断深挖，让事物得以发展，让自己得到成长。\r\n能够去驾驭人驾驭事物。然后具备能力去做更大的真善。\r\n\r\n同事当为朋友，魔界团队。	2021-04-16 06:30:57.806653	f
1670	851	Issue	5		2021-04-16 06:35:19.76635	f
1672	760	Issue	5	代码是生长的，变化的。\r\n不论是一个大系统还是小系统，当我们开始考虑实现它时。\r\n第一步是识别最外部的行为，可以通过Tdd来写。生长的系统。\r\n第二步就是不断识别出实体，这是一个严密推导的过程。包括包装虚拟实体。我们要限定自己的思维层次，否则容易陷入混乱。跳跃的思维，无法走出来。\r\n自定而下的实现。\r\n\r\nTDD抓住了一个重点就是外部接口。这是最难的部分。	2021-04-17 17:48:18.105115	f
1676	847	Issue	5	https://www.cnblogs.com/bjxdd/p/13680688.html	2021-04-18 19:28:54.691334	f
1680	841	Issue	5		2021-04-20 06:33:39.152979	f
1657	841	Issue	5	设计：识别高层实体，以及实体关系，结构。\r\n      CS,MVC,微服务等等都是实体模式，就跟盖房子一样，也是有模式的。\r\n      而且通常模式越宏大，越抓住根本，则适应性更强，推倒的可能性就越小。比如关系数据库的设计就非常经典，难以逾越。\r\n编码：实现实体行为，验证行为。增加底层实体实现等。	2021-04-10 13:06:07.955825	f
1647	221	Issue	5	能力模型：\r\n1级：\r\n刚开始搞，需要人推动指导完成模块开发。\r\n2级：\r\n独立完成模块开发，说自己做过什么，但不提做得怎么样。\r\n不是产品的领导者，还没想清楚想要做什么\r\n3级：\r\n系统开发者，在该产品领域有独立思考。\r\n有自己要做的目标和追求，热爱软件开发\r\n4级：\r\n做出了口碑良好，流传广泛的产品。\r\n5级：\r\n领域开创者，行业主导者\r\n\r\n潜力模型：\r\n1，被动型\r\n2，流程型\r\n3，主动研究型\r\n4，积极探索型\r\n5，立志，墓志铭，海枯石烂\r\n\r\n招人要求：\r\n能力：与工作年限匹配\r\n潜力：越高越好\r\n品德：三观不正，以及不诚实者，直接否决	2021-04-02 07:59:19.338139	f
1639	830	Issue	5	<pre>\r\nimpl obj {\r\n        //fn last<'a, T: A + 'a>(&self) -> &'a T {\r\n        fn last(&self) -> &Box<dyn Any> {\r\n            //let x = self.objs.last().unwrap();\r\n            //x.downcast_ref::<T>()\r\n            self.objs.last().unwrap()\r\n        }\r\n\r\n        fn push<T: A + 'static>(&mut self, o:T) {\r\n            self.objs.push(Box::new(o))\r\n        }\r\n\r\n        fn last1<T: A + 'static>(&self) -> &T {\r\n            let x = self.objs.last().unwrap();\r\n            x.downcast_ref::<T>().unwrap()\r\n        }\r\n\r\n        //得到对象的clone，从而避免生命周期限制\r\n        fn get_mut<T: A + Clone + 'static>(&self) -> Option<T> {\r\n            let x = self.objs.last().unwrap();\r\n            let p: &T = x.downcast_ref::<T>().unwrap();\r\n            Some(p.clone())\r\n        }\r\n    }\r\n</pre>	2021-03-29 18:06:53.300202	f
1649	833	Issue	5	行为一定有实体，如果在实体划分中缺乏了部分，应该增加虚拟实体。	2021-04-05 05:58:18.375088	f
1651	838	Issue	5	纯技术理论推导，从设计上探讨。	2021-04-07 06:11:17.798107	f
1652	765	Issue	5	TDD还有一个好处就是有了明确的入口。接口是模块的关键。\r\n我们不是写好了代码再配套测试，而是写好测试反推代码。	2021-04-07 06:22:04.293264	f
1658	841	Issue	5		2021-04-10 13:10:04.324762	f
1660	842	Issue	5		2021-04-10 14:38:21.562454	f
1663	829	Issue	5	强者很多，善者也很多，但是在真善美下还强的人不多。世上圣人，贤人少。而霸者，权者，虚伪者多。\r\n这世上少有人对善恶有明确的感知，大部分人是麻烦和跟随者。 美丽下面藏着丑陋与邪恶。\r\n丑恶中也蕴藏着真善。程度不一样而已。\r\n\r\n很多人等不了，没法等到自然成长，耐心不够，根基不稳。\r\n君子至强，不断的去改进完善自己，但如果达不到，也不必强求。\r\n这是我的选择，因为对于真善美的热爱强于对于强权财色等的热爱。\r\n\r\n选择光明，但也对黑暗有着清醒的认知。\r\n	2021-04-14 08:10:34.962187	f
1667	848	Issue	5	所以我目前问题不在于广度不够，而在于深度不够	2021-04-15 07:08:12.437262	f
1668	848	Issue	5		2021-04-15 07:29:11.929429	f
1673	760	Issue	5	http://blog.cleancoder.com/uncle-bob	2021-04-17 17:58:55.376188	f
1674	646	Issue	5	高远球的变化：\r\n1，平高球打法\r\n   如果球速快，左手往前驾而不那么高，因为右脚拉的比较开，要保持平衡。\r\n2，打出速度变化，混乱对方的节奏。\r\n   但这个变化区间来自自己的实力，完整动作3s。最小动作能否0.3s完成？    	2021-04-18 04:03:32.356257	f
1675	658	Issue	5	Undo Bob：programmer，speaker，teacher。\r\n我：programmer，speaker。	2021-04-18 04:24:44.370272	f
1654	658	Issue	5	驭物万千，驭人百十。驭并非控制，而是深度了解后的交互方式。	2021-04-09 07:30:35.32364	f
1677	847	Issue	5	OLAP本质就是维度之间的相关性分析。这是行为。\r\n\r\nOLAP还有2个特征是数据批量写入以及稳定性与时间维度，这为cube等预计算技术提供了基础。\r\n如何存储维度数据：列存\r\n如何进行维度计算：向量化执行。\r\n\r\n从此维度去理解数据分析领域的技术树。\r\n\r\n\r\n	2021-04-18 19:53:32.746544	f
1678	847	Issue	5	数据分析服务，首先得有数据，然后提供各种服务。比如得到某个知识-某个分析结果。	2021-04-18 20:15:58.013805	f
1679	829	Issue	5	强是为了保护自己，阻止恶，恶通常都有执念，枯槁坚硬缺乏生机。	2021-04-19 05:57:37.344997	f
1671	845	Issue	5	rlog写一个通用的journal模块。输入是字节流。支持append，read，trim，flush等。\r\n支持主动或被动flush。\r\n\r\n关于句柄缓存\r\nceph保存了对象句柄，每次操作时seek然后rw。\r\n这样没问题是因为ceph在上面加了对象锁，读写不会在同一个对象上并发。\r\n如果2个线程都打开一个句柄读就存在问题。先不考虑共享。\r\n\r\n读取数据时如何正好在逻辑边界以方便上面对齐处理？\r\n\r\n读取日志的接口是否应该感知日志条目的边界，给上层返回对齐的日志？\r\n问题是日志的写入是否有边界？每个对象上的操作作为一条。\r\n日志以8K作为边界。\r\n\r\n一条日志可能很大。\r\n1，日志有多大？\r\n2，日志是单条存，还是整体存？\r\n3，日志文件是流式还是页式？\r\n	2021-04-16 13:15:45.295015	f
1681	845	Issue	5	一个根本性问题是到底是采用流式还是block方式来使用文件？	2021-04-20 14:56:26.704528	f
1693	864	Issue	5	或者说再见了那些虚幻的我	2021-05-07 11:46:55.38479	f
1682	707	Issue	5	4级：学会局部鞭打动作，学会基本的并发，能到位接球。\r\n     到4级能体会基本的羽毛球乐趣了。开始有动力去球馆。\r\n5级：学会蹬地移动，学会高远动作，核心是转身带动手臂到位后，甩小臂动作。\r\n     之所以认为到5级是因为此动作是羽毛球运动的核心特征体现，不是整体发力，而是鞭打。\r\n     蹬地移动是步伐的核心。\r\n6级：步伐，身体，手臂都能轻松的调整为小臂击球服务。\r\n     身体始终能维持平衡且动作优美。\r\n     6级之后技术动作完全没问题了。会甩小臂，会步伐连贯，身体姿态调整，6级是技术的基本达成。\r\n7级：熟悉各种业余技战术，能针对性的打球。	2021-04-23 05:33:22.971934	f
1684	858	Issue	5		2021-04-25 07:31:55.352869	f
1685	649	Issue	5	复杂度，抽象是软件的核心，没用抽象人什么都做不了，封装(可见性)和约束使得世界得以运转。\r\n想象下人出门看到的都是原子，光子。树木的内部构造，那将是怎么样的一个世界。\r\n你看不见，是因为看见了会迷惑你。\r\n你做不到，是因为做到了会伤害你。\r\n你看到了，做到了，是因为你成长了，能否驾驭它了。	2021-04-25 08:24:01.279387	f
1689	862	Issue	5	5.30计划：实现好libcoral，准备对接入anchorBase。\r\n          libcoral支持在本地生成大量slice，并且能支持slice的查询。\r\n\r\n疯狂优化代码。\r\n\r\n6.30：anchorBase上支持coral表的批量写入和读取。\r\n      支持多DN。	2021-04-26 17:55:00.289244	f
1752	206	Issue	5	IP： 119.23.14.122	2021-06-14 17:31:09.491183	f
1753	841	Issue	5	1，意图驱动\r\n2，智力发展，分化的系统\r\n   如何分化，稳定性和可扩展性的关系\r\n   更好的行为\r\n   可以积累的成果，很方便基于他人工作的改进（尝试的代价有时候只有先行者才能承担）\r\n3，连接\r\n   接口，可理解性非常关键。\r\n   不可理解，则不可表达。	2021-06-15 06:33:47.043274	f
1686	825	Issue	5	程序就是由很多抽象实体在水平和垂直上组织而成的。\r\n保持抽象的完整性，相同层次性。\r\n封装可见性，封装约束。\r\n从接口出发编程本质上就是从抽象出发，因而能写出抽象更好的程序。\r\n\r\n跟我一起读：面向实体行为编程\r\n三大要点：抽象，隐藏，约束	2021-04-26 07:18:53.598523	f
1687	573	Issue	5	学习是一个递进的过程，刚开始我不会手法，打球的时候注意力全部在手法上。\r\n然后等手法好一些，我注意力在步伐和身体姿态上。\r\n\r\n编程也是如此，开始我们纠结于语言，然后纠结于抽象，封装，设计。\r\n再然后我们开始关注业务，行业。	2021-04-26 07:25:30.160006	f
1688	862	Issue	5	1，熟悉crab，定义好接口\r\n2，实现schema/type转换，以及reader/writer适配。\r\n	2021-04-26 17:42:08.481756	f
1690	862	Issue	5	1，熟悉parquet并用起来\r\n2，熟悉crab格式\r\n\r\n确定schema/type转换原则等。	2021-04-26 18:52:50.288885	f
1691	818	Issue	5	https://zhuanlan.zhihu.com/p/91625630\r\n\r\n<pre>\r\n蹬地之力的妙用在羽毛球运动中无处不在，在你移动中的启动、急停的每一步，都应该能够感受到这种蹬力的作用。例如上网步法中，如何完成击球动作后及时回位呢？ \r\n及时回位这一关键性的衘接环节，就是急停，而急停的关键就是最后一步时靠腿部的蹬力，脚跟先着地，再过渡到整个脚掌，然后借助蹬地之力回位。\r\n\r\n借助蹬地之力，在很多情况下很好的借势使力，能让你在场上更轻松自如的享受羽毛球带来的乐趣。\r\n</pre>	2021-04-27 05:42:32.091636	f
1683	707	Issue	5	羽毛球三大定律：\r\n1，蹬地移动快，散步好变节奏。(曲腿蹬地，借力回动)\r\n2，鞭打速度才快，捻动好控球。（转体鞭打）\r\n3，身体姿势不对则发力不畅，连贯不好 （攻防正反转换）\r\n\r\n在这三大定律基础上不断练习，1年左右应该能到6级水平。	2021-04-23 05:56:44.776138	f
1692	862	Issue	5	coral的format层的职责：\r\n适配不同的文件格式，定义通用接口\r\n做parquet的reader/writer包装\r\nschema和数据类型转换。\r\n\r\n通用接口定义：使用crab的元数据/数据模型。\r\n1，crab的元数据模型是怎样的？\r\n   是一个Field的vec，Field包含名称，类型，是否可以为空。\r\n   DataType与anchorBase对应，有近20种。\r\n   schema与读写的关系。如何生成一个crab的数据集。\r\n   crab如何表示一个数据集。\r\n   ColumnSet结构。\r\n2，crab的数据模型是怎样的？\r\n3，有哪些接口\r\n   根据需要字段从文件中的schema生成crab的schema\r\n   定义一个类型转换器。\r\n   crab的schema生成parquet的schema。\r\n   \r\n   暴漏的就2接口：\r\n   1，读：读一个buf流片并将其数据转换为ColumnSet。\r\n          读的参数有project和filter。\r\n   2，写：将ColumnSet写成buf流\r\n   注入读写器还是使用内存？\r\n   parquet如何实现过滤？读接口没看到过滤参数？\r\n   莫非文件仅提供统计信息，过滤要在上层实现，目前都没看到过滤的实现。\r\n   在parquet与coral对接层需要实现filter。\r\n   \r\n   使用文件级别的统一statistic有个好处是可以加速过滤，否则每个文件都得读取。\r\n   还有一个问题：parquet是以文件方式使用还是以buf方式使用数据？\r\n   能否上层给一个buf，告诉其是rowgroup，然后进行格式处理？\r\n   parquet实现了一个抽取数据的模型。以chunk即数据片段方式抽取数据，这个正符合我们的预期。\r\n   可以与cache模块配套起来。\r\n   \r\n   \r\n4，每个接口的定义\r\n\r\n\r\nlibcoral接口\r\nschema, primary_key, columnset\r\ninsert()\r\n\r\naccessor\r\nselect(pool,project, filter)-> columnset	2021-04-27 13:48:27.465131	f
1694	867	Issue	5	没啥文章介绍parquet的字段id。\r\n从ORC看，id就是个唯一编号，用中序遍历生成。\r\nid用起来，这样才能根据列id来确定要查询的列。\r\n而且列id是与数组编号一致的。anchorBase列id从0开始。\r\n\r\ncoral使用列id运作。但crab的schema中没有列id，\r\n要映射是不是得拿column attr。即保证了列id一定是对的上。\r\n\r\nparquet空列的代价。\r\n三种形态：\r\n1，一一映射\r\n2，根据id映射\r\n3，根据名称映射。\r\n\r\n定义schema并映射。\r\n从数据列挂数据到dataset。dataset使用的是列id。\r\n\r\n使用rust版本的dataset，然后与C版本进行转换。\r\n\r\n方案1：\r\ncrab和anchorbase cursor接口之间使用columnId作为name。\r\n读取时输入的是columnId，相当于利用id查找。\r\n然后不必存删除列。\r\n\r\n方案2：\r\n接口使用id作为name(或提供回调函数让下层拿到列名，id填充到type的id字段)。\r\n读取时使用列id下标。\r\n存储包含所有列，包括删除列\r\n\r\nparquet没有标记删除列能力，crab也没有。其上层使用者如果想用id，需自己知道对应关系。\r\nslice meta: delete_col_map.\r\n\r\ncoral的全局元数据中保留delete_bit_map信息。\r\n来实现读取列与parquet中列的映射。\r\ncache最新版本的schema以加速生成。\r\n可以通过dc生成crab格式的schema。并在dc中缓存起来。\r\n写入时将crab格式schema转换为parquet等具体schema。\r\n读取时根据dataset中的columnId，以及delete_bit_map位图，计算出实际的columnId来读取parquet。\r\n\r\nmeta: 分为entry / slicegroup, entry记录有多少slicegroup，每个slicegroup存放一定量的slice。\r\n      entry存在主要是解决，slicegroup删除的情况，不调用list功能。通过元数据模块提供能力保证一致性。\r\n\t  slice的索引信息也存放于slice元数据中。\r\nslice.data：slice数据。\r\nslice.del: slice的删除位图。\r\n\r\n\r\n类型转换，必须有类型能表示crab类型，否则无法实现反转。\r\n要么就使用metadata属性。写入时关心类型，读取时使用编码。\r\n条件下推是必须支持的，应该打通这条路，在下层实现回调。\r\n\r\n存储引擎上层以使用回调的方式来进行过滤，其感知数据类型。\r\n存储下层只感知行列，数据长度等。\r\n在coral中更需要以回调方式注入。filter，等到取出数据再过滤就晚了。\r\n给数据类型注入比较函数。\r\n表达式以一种内部形式表现出来，这是需要的。\r\n\r\n任何存储结构都涉及：\r\n1，数据类型与表达式计算，filter。\r\n但这不一定跟向量化有关系，可以参考索引的做法。\r\n只是在rust代码中使用以rust实现的比较接口。\r\n\r\n问题：为什么要将parquet的schema转换成crab？\r\n      在数据读取时上层是知道schema的。实际需要的是数据集。\r\n\t  \r\n\t  存储关系列的名称吗？不，parquet有提供根据列名称读取的接口吗？\r\n\t  \r\n\t 1，根据定义拿到具体格式的schema。\r\n     2，存储maxColumnId\r\n     3，将比较函数\t \r\n\r\n为什么parquet使用name而不是id来表示一列？而读取时又根据id，这要求上层提供columnid？\r\nR、D信息需要在client填充吗？为什么其计算不作为parquet的util部分？\r\narray是干啥的？arrow只写了一个rowgroup，实际上会拆分成多个rowgroup。\r\nrowgroup大小也是客户端控制的。\r\nparquet如何表示空值？需要占位符吗？\r\n\r\nlevel外部感知，R/D信息本质上是描述重复和option的，parquet对于null的表达。\r\nArrow Reader的代码框架：\r\n对外的是一个Record Reader能按列，以及batch size读取arrow格式记录。\r\nRecord Reader实现了单列从parquet读取数据。可以跨页读取。\r\narray reader必须是一个struct reader，遍历页面得到page reader给RecordReader使用。\r\narray reader还实现了列格式转换。包装成一个动作执行器(封装)，然后提供动作。\r\n使用ArrayDataBuilder生成，依赖很深，还有对计算能力的依赖。cast函数。\r\n这取决于类型兼容性，如果parquet的类型与内存格式不兼容，则不能直接使用字节流。\r\n还是尽量保持兼容，否则代码太大。\r\n而且即便D为0，我们也可以不剔除该值，从而避免转换。\r\n\r\n单列读取会根据列描述符来处理，如果是required且不重复，则不会读取R/D列。\r\n如何读取下一个rowgroup？如何处理value长度变化？读取的单位是chunk？\r\n返回给上层切片？\r\n\r\nFilePageIterator实现了segment式的遍历，可以读取整个列。\r\n\r\n最外层是一个struct结构。arrow支持嵌套格式吗？支持\r\nparquet必须使用嵌套格式吗？应该未必\r\n\r\n先摸清楚代码架构，不要盲目开始模仿拷贝代码。\r\n\r\n存储是弱类型的。没法像上层一样表达各种类型。\r\n存储对于类型感知的能力，如何给decimal注入比较函数？支持用户自定义类型？\r\n让上层注入函数，底层元数据需存储具体类型。\r\n简单条件下推。\r\n\r\n为什么不直接使用arrow呢？不兼容的格式就直接使用byte流。\r\n不能，额外引入了依赖。\r\n先把arrow的逻辑看明白。\r\n1，writer剔除null值，通过definition实现\r\n2，实现类型转换\r\n\r\nRecordBatch等价于ColumnSet，一个columnSet写入到一个rowgroup。\r\n读取时同样如此。\r\n有办法知道chunk边界吗？写入的时候。读是按页为粒度吗？读取的单位是page。看SerializedPageReader便知道。\r\n但是从最下面读取应该是按照chunk，参考：SerializedRowGroupReader::get_column_page_reader.\r\n只是parquet中封装了页式访问能力。\r\n\r\nR/D/V都放在一个页面内，如何知道该写多少呢？内存格式与实际格式可能有差异。\r\n内存中不必关系写到哪。\r\n\r\nparquet通过schema创建下层读取对象，逐层往下。\r\nSerializedRowGroupReader提供了单行遍历能力，另外就是SerializedPageReader。\r\n\r\nschema由上层来确定。最底层存储实际只有3种类型，bit，bytes，var bytes。三种编码方案。\r\n再往上就有更多类型了。\r\n\r\nparquet类型到内存类型转换代价很大，都是采用拷贝方式的。\r\n\r\n类型兼容：\r\nparquet bool类型，没有bit类型。\r\n如果不转换，非4字节对齐类型长度都不一致。\r\n将buf转换成parquet想要的格式。\r\n\r\nD支持按需存在么？同一列，有些记录有D，另外一些没有？\r\n\r\ncovert，定义好格式进行互转。\r\nutf8和bytes流之间互转。\r\n\r\n	2021-05-08 15:34:41.159093	f
1695	868	Issue	5		2021-05-08 20:33:16.314461	f
1697	852	Issue	5	为啥说修身齐家治国平天下。\r\n\r\n修身就是生活，不断完善自我的过程。如果你自我完善了，那么在家庭中去帮助家人成长。\r\n在企业中帮助其他人成长，这样就是管理者，领导者。	2021-05-10 03:45:05.804737	f
1698	867	Issue	5	#Schema\r\n物理类型与逻辑类型\r\n\r\n#元数据组织\r\n## 空间管理元数据\r\n## 列元数据\r\n\r\n#类型编码\r\n\r\n## 字典编码\r\n\r\n每种编码方式都有适用类型，但是一种类型可以有多种编码方式。\r\n如何指定使用字段编码？\r\n\r\n#索引\r\n\r\n## 稀疏索引\r\n## bloom filters \r\n## column index\r\n   如何指定使用？底层如何对列进行排序，排序是否在上层做好？\r\n\r\n#接口\r\n## filter & project\r\n## 按rowid查询\r\n## 插入\r\n## 批量插入\r\n## 更新，删除\r\n## scan\r\n## bitmap scan\r\n\r\n#对接\r\n编码兼容性\r\n字段批量数据的表示	2021-05-10 05:47:40.014198	f
1699	852	Issue	5	能接受自己的平凡，也能接收失败。不以自己以为别人自己应该具备的角色而生活。不设定不切实际的目标。\r\n但是每天都在提升自己，每天都增强自己处理事务的能力。\r\n\r\n不焦虑不内卷。同时也积极增强自己。\r\n\r\n平衡思考与行动。\r\n平衡目标和能力。	2021-05-10 07:02:55.527567	f
1755	841	Issue	5	软件的主动行为是新的潘多拉魔盒。\r\n当下软件的行为基本都是被动的，人编写的逻辑，行为都是人来触发，或定时触发的简单任务。\r\n后面必然会演化出行为调度，即在非人触发下期间的自动调度。\r\n最终演化下更高行为度的软件，甚至自我编程。\r\n\r\n\r\n	2021-06-15 07:00:08.33345	f
1704	866	Issue	5	https://docs.fileformat.com/word-processing/docx/#:~:text=DOCX%20is%20a%20well-known%20format%20for%20Microsoft%20Word,to%20a%20combination%20of%20XML%20and%20binary%20files.\r\nhttps://blog.csdn.net/u012878073/article/details/85229558\r\n\r\ndocx格式说明。	2021-05-11 17:33:43.865064	f
1705	818	Issue	5	羽毛球的步伐基础是蹬地发力，这与平常走路的抬腿发力有根本区别。\r\n走路抬腿是向上发力，蹬地是向下发力反弹。而且蹬地时身体应该收紧，即整个身体都能收到来自地面的力，然后借力出去。\r\n有点像跑步但还不一样。这样步伐才能快起来。所以打球之前如果腿软，没休息好，腰腹核心需休息那肯定打不好。	2021-05-12 06:13:08.751523	f
1706	871	Issue	5		2021-05-12 08:05:43.754967	f
1707	871	Issue	5		2021-05-12 08:42:06.024216	f
1709	872	Issue	5		2021-05-13 08:58:48.264177	f
1701	811	Issue	5	1，世界观，以及事物上的方法论\r\n2，将事物的认知接入自己的大脑，融入体系，接受它\r\n   要观察是否融入，可以尝试给自己或别人讲下，如果能讲明白说明融入了。\r\n   融入肯定得是经过大脑再组织的体系化知识。 碎片没法被大脑接收。容易遗忘。\r\n3，大量练习，达到熟练运用。\r\n\r\n这三个步骤都是反复练习，不断优化精进的。\r\n时间投入比例：1:3:6\r\n\r\n1，从问题入手\r\n2，掌握概念\r\n3，从方法或结构的大处入手，这是人脑决定的。	2021-05-10 07:28:08.895218	f
1758	887	Issue	5	python下对windows ddl的依赖是个头痛的问题，没有一个好用的打包工具。\r\n非开源系统从一出生都是隐蔽的，难以理解的。 其分化生长过程对外是不可见的。	2021-06-15 07:06:31.268489	f
1724	877	Issue	5	据宜顺说他们实现了一个coderror的trait，io错误码在每个模块单独映射。没有映射到公共区间。	2021-05-23 05:46:40.034577	f
1726	852	Issue	5	世界观：总是从事实出发，从人的平等自由性出发。否则我们不对，在现实世界就会遇到瓶颈。世界是分化发展的，不因个人意志而变，停不下来。\r\n人生观：人生就是一场自我提升的修行，体验自我，他人与外在世界的过程。\r\n	2021-05-23 05:57:24.980092	f
1696	852	Issue	5	1,学会如何面对恶，面对困境。\r\n  面对恶，但不要被恶所困扰。以善处理恶，如果实在处理不了，就以直面对。\r\n  我们变得更强，更智慧也是能更好的面对恶。\r\n  以善处理恶是看到恶人本身也是弱者，去接受并解决他们的问题来达成我们的目标。\r\n\r\n2，学会如何在提升自己的过程中去体会快乐。幸好人的快乐是来自于自我的改变，而不是外物。\r\n  这是别人没法拿走的。\r\n  喜欢施恶之人自然是远离这种快乐的。\r\n  探索认知事物，学会如何处理事务，这些都很好玩的。\r\n\r\n3，以本我和自我来生活，而不要生活在各种角色里。\r\n  这区别是我们能否完完全全的接受自己，接受就是善，接受自己是善之首。\r\n\r\n4，相信别人，不要自负，学会聆听\r\n  不要什么事情都自己搞，把任务交给其他人，发挥他们的能动性。\r\n  人都是差不多的，尤其是聪明人，搞清楚自己的定位，锤炼自己的核心能力。不擅长的事就交给别人。	2021-05-09 15:05:08.264666	f
1700	852	Issue	5		2021-05-10 07:04:37.38795	f
1702	867	Issue	5	/// write slice data to parquet format, slice data only include columns that is not deleted,\r\n    /// so use field_map to record it. we can calculate the actual columns in parquet by field_map and given table columns.\r\n    /// it is needed because columns may delete after slice write. then we can not calculate by the latest schema.\r\n    /// for example: \r\n    /// 1, write slice include column 0,1,2,3,5\r\n    /// 2, table delete column 3\r\n    /// 3, access slice with project columns 0,2,5\r\n    /// with filed_map: 111101, the read columns in parquet should be 0,2,4\r\n\r\n显然slice读写器不必感知 table和slice字段的映射，该功能可以上提到slice mgr中完成。	2021-05-10 08:04:03.414563	f
1703	871	Issue	5		2021-05-11 07:07:22.377026	f
1708	871	Issue	5		2021-05-12 09:05:35.926417	f
1710	866	Issue	5	word 自动为尾部空格添加下划线  似乎无法自动，或许新的标准已经淘汰，不需要弄的	2021-05-14 21:00:18.621023	f
1712	874	Issue	5	熟练的掌控并运转我们的智力系统。我们并非总是在运用它，不是吗？	2021-05-18 12:26:54.678079	f
1713	876	Issue	5		2021-05-18 13:04:03.307778	f
1715	874	Issue	5		2021-05-19 05:04:11.481198	f
1727	875	Issue	5	OLAP：联机分析处理，是计算机技术中快速解决多维分析问题（MDA）的一种方法。\r\nOLAP与OLTP对比：\r\nOLAP通常与OLTP（联机事务处理）形成对比，OLTP的特点是查询的复杂性要小得多，而且查询量要大得多，以处理事务，而不是用于商业智能或报告。OLAP系统主要针对读取进行优化，而OLTP得能处理各种查询（读取、插入、更新和删除).\r\n\r\nOLAP技术特点：\r\n1，多维数据\r\n2，join优化的事实表，why需要维度表？\r\n3，涉及的数据量，向量化执行\r\n4，聚合计算\r\n特别优化：\r\n1，join优化\r\n\r\nhttps://zh.wikipedia.org/wiki/%E7%B7%9A%E4%B8%8A%E5%88%86%E6%9E%90%E8%99%95%E7%90%86	2021-05-25 04:42:55.19568	f
1718	875	Issue	5	数据类型：大小(定长与变长)，编码\r\n列式数据类型以及编码\r\n\r\n列存基础：\r\n\r\nswf空间管理：树形结构\r\n          堆结构\r\n\r\nswf存储结构：关系数据库的数据在逻辑上就是一个二维数组，行式存储甚至可以理解成一个一维数组。\r\n 行的表示\r\n rowid\r\n 列存形式，列与segment\r\n\r\nswf批量处理\r\n压缩\r\nswf变长存储\r\n\r\n扩展部分(执行优化)：\r\n延迟物化\r\n条件下推\r\n\r\n\r\n	2021-05-19 07:23:17.558538	f
1723	875	Issue	5	\r\nOLAP与列式存储：\r\n  1993：OLAP概念的提出\r\n  \r\n  OLAP描述了分析的本质就是在计算维度相关性,侧重查询。\r\n  即通过Cx,Cy 得到函数 f(z) = f(y/x)\r\n  分类，统计，\r\n  数据模型\r\n  OLAP函数\r\n  为什么数据分析仍然回归到使用SQL?\r\n  \r\n  \r\nOLTP本质 z = f(x,y)\r\n  其中f是业务逻辑，x，y是当前状态，z是计算结果。 \r\n  业务表\r\n  有2个根本性区别：\r\n  1，一次涉及的数据量\r\n  2，涉及的列数\r\n  3，AP侧重查询，数据导入，TP各方面比较均衡。\r\n  这也导致了组织数据方式上的差异：\r\n  1，OLAP数据模型：事实表与维度表。OLTP都是业务表。\r\n  2，存储格式的差异，OLTP涉及数据少，关心的是事物的某个实例，因而适合行式。\r\n   \r\n  \r\n数据类型：大小(定长与变长)，编码\r\n物理类型(primitive types )\r\n逻辑类型\r\n列式数据类型以及编码,null值编码，变长编码\r\nschema：\r\nmetadata(空间管理，空闲空间管理)\r\nVirtual IDs(offset index)\r\n列存形式，列与segment\r\n   \r\n事务支持(记录的多版本)\r\nIndex支持\r\nswf批量操作\r\n并行执行\r\nEfficient modify	2021-05-22 15:18:50.188607	f
1729	867	Issue	5	如何理解类型编码与兼容性的矛盾，记录可变性与压缩的矛盾	2021-05-26 07:13:56.732054	f
1732	818	Issue	5	双脚要站开一点，这样明显移动会快些。 \r\n把基本动作都练成习惯，然后意识就在每个球的落点上，就能控制全场。也能全速计算球应该打到哪里。\r\n	2021-05-29 15:39:22.223663	f
1737	882	Issue	5	以名称作为地址，比如编程语言的变量名，kv系统的key，表的索引。\r\n以逻辑地址寻址，比如操作系统的内存管理，有一个逻辑地址到物理地址映射的表。\r\n以物理地址寻址，比如行存的rowid，使用该地址可以直接找到记录。\r\n\r\nswordfish需使用逻辑地址，因为单一rowid无法找到一行的所有列。	2021-06-02 04:40:56.45679	f
1734	881	Issue	5	行动力：不断推动事情进步的能力。困难都会遇到，不会每个人都得经历，但总得往前走吧。\r\n        利用最小系统推动事情进步，利用最简单的方法先行动起来，因为行动本身会带来改变。房子不是一天建成的，然而最初的房子如今有些地方仍然可以借鉴，这就是软件架构。\r\n管理能力：当意识到别人与自己有相同能力时，就明白综合效率是怎么回事。\r\n沟通能力：当明白每个人只能看到自己看到的世界时，就可以理解沟通的重要性。\r\n	2021-05-30 20:14:07.712129	f
1739	881	Issue	5	编程的内功就是认识方法论，是理解和认识复杂事务的方法。\r\n天才就是用这方法，纯然于心而不觉。 笨人就是循着方法一直练习，同时不断总结方法。	2021-06-04 04:30:07.127302	f
1740	852	Issue	5	仍然很难做到，焦虑根本上是认为自己能力不足。这里面有很大的主观因素，也有客观因素。\r\n	2021-06-04 04:34:48.234451	f
1742	882	Issue	5	补图，以图方式讲解，以伪代码讲解。	2021-06-04 15:47:06.855108	f
1744	882	Issue	5		2021-06-09 21:15:24.186133	f
1745	886	Issue	5		2021-06-11 15:08:27.158043	f
1711	874	Issue	5	关于自由意志：https://zhuanlan.zhihu.com/p/37596233\r\n人脑比动物脑多出的就是这部分，人有一个思维空间去认知其感受到的一切。\r\n\r\n如果说人是一个非常复杂的生物机器，感觉只是思维空间提供的一种刺激。\r\n被感觉控制会极大限制机器的运算，智力和创造性。\r\n良好的感觉会让人产生美好的体验从而做出选择。而不好的感觉会抑制人去选择。\r\n\r\n如果说信仰是根认知，那找到根本认知就能更好的了解机器。\r\n比如真实，善良，美丽。\r\n当我们大脑说真实的意思是它符合运行规则？\r\n我们说善良的意思是它更容易接受和改变？\r\n我们说美丽是因为它能给我们带来好的体验？或者说事物更符合完善结构？\r\n\r\nso，我们对事物更确信不疑是因为我们看到了一些什么？以致于加重了在某方面的权重。\r\n\r\n	2021-05-18 11:51:06.95626	f
1714	874	Issue	5	有种说法是自由意志并不存在，人脑本身就是神经元，只是结构更复杂而已。\r\n如果说人最有趣的事情是什么，现在而言肯定是训练大脑了。它的能力能从无机物到接近神。\r\n\r\n心智还很有趣是每个人都有自己的思维空间，都和现实世界非完全对应。\r\n人只能看到自己能看到的。	2021-05-18 18:30:00.803997	f
1717	874	Issue	5		2021-05-19 05:24:54.492128	f
1716	874	Issue	5	大脑的工作模型。大脑是一个多路输入输出的生物机器，其在感觉以及思维空间模拟了外在世界。所见即所得，我思故我在。\r\n优化其运作，启动，暂停。\r\n人最神奇的就是智力和创造力。有此两边让我们勇闯黑暗森林吧。\r\n只要人愿意面对自己的意识和情感，并且深入到自我意识中观察，就有可能改变，体验思维空间的逍遥游。	2021-05-19 05:24:23.364796	f
1719	853	Issue	5	腰腹不直接发力，但是要绷紧，即手臂还是需要从其获取瞬间的反作用力。\r\n稳定快速诀窍：\r\n1，始终记住力从地起，这是身体稳定的前提。\r\n2，双脚尽量略有前后站位，这样更方便启动。对方击球瞬间下蹲启动。\r\n3，不要随便换手，快的秘诀就是不用准备。同时要看清队友的准备。	2021-05-21 06:33:23.070818	f
1725	852	Issue	5	提升一倍计划：\r\n1，梳理并分享100个技术点\r\n   训练知识整理以及表达能力\r\n2，提升进货渠道，能跟人进行日常技术交流\r\n3，领导力提升，多阅读论文，掌握技术迈络方向。\r\n4，用脑能力提升，善于休息，破除心结，提升效率。	2021-05-23 05:51:08.153631	f
1728	867	Issue	5	支持向量化类型转换？\r\n只要2系统类型表示不一致，就存在转换问题，这是必然的。\r\n\r\n而parquet要支持索引，过滤就必须支持类型，以及其运算。那问题是parquet实现支持类型后，还能与其他系统兼容吗？	2021-05-26 05:19:39.06963	f
1720	221	Issue	5	考察人无外乎2点：\r\n1，能力，2，品德(埋藏在深处的自我意识，价值观)\r\n\r\n能力可分6大块：思考能力(逻辑思维，批判思维，思考的速度，做事方法论，核心能力)，认知力（知识管理能力，记忆力，学习能力），沟通能力，执行能力，意志力，领导力。\r\n\r\n品德：是否善良，是否真实，是否向往美好。品德评价不好是直接干掉的。\r\n      品德决定了人的成长性，因而一项就占了一半。\r\n\r\n按上述思路涉及如下环节：\r\n1，挑选简历\r\n2，排除\r\n3，经验评价\r\n4，设计能力（50个题中挑选）\r\n5，编程能力环节（100个题中挑选）\r\n6，可塑性(在经验不完全匹配时) （观察人内在的可变性，他做了哪些事情改变自己? 用工作改变自己）\r\n7，可接受性(在经验不完全匹配时) (是否接受其当下的工作，是否能接受未来的工作，混日子？赚钱？为什么选择这段经历)\r\n\r\n问题需要有延展性，可以浅也可以很深。\r\n	2021-05-21 12:35:41.119236	f
1721	875	Issue	5	列存理论基础：\r\n\r\n数据类型：大小(定长与变长)，编码\r\n物理类型(primitive types )\r\n逻辑类型\r\n列式数据类型以及编码,null值编码，变长编码\r\nschema：\r\nmetadata(空间管理，空闲空间管理)\r\n列存形式，列与segment\r\n   \r\n事务支持(记录的多版本)\r\nIndex支持\r\nswf批量处理\r\n并行执行\r\n可修改的变长存储	2021-05-22 12:20:13.124326	f
1722	274	Issue	5	OLAP与OLTP在sql上区别真的很大么？并非如此，这也是sql回归的原因。\r\nOLAP和OLTP本质上都是输入f(),x, 得到Y。\r\n区别是OLAP聚焦在列的相关性分析，统计等操作上。\r\nOLTP则聚焦在业务的增删改查操作上。\r\n这引申出来了一些其他差异：\r\n1，OLAP是部分列上的批量操作\r\n2，OLAP应该尽量优化查询，因而引出了雪花模型等\r\n3，OLAP数据量通常很大，延申出大数据。\r\n\r\nAI则完全输入x，y等到f，是一个全新的领域。	2021-05-22 15:07:51.819531	f
1730	879	Issue	5		2021-05-27 07:53:14.995014	f
1731	880	Issue	5		2021-05-27 12:01:46.697228	f
1735	881	Issue	5	程序=算法+数据结构\r\n墨菲定律\r\n奥卡姆剃刀法则：\r\n海拉姆定律：all observable behaviors of your system will be depended on by somebody. \r\n无名，天地之始\r\n帕金森定律：在预算之内，支出的需求会一直增加，直到所有资源被用完为止\r\n	2021-06-01 06:59:49.044196	f
1738	881	Issue	5	在每一个领域都是不断分化和积累的，没有积累不可能轻易达到别人已经做过的分化，这就是经验的价值。\r\n比如做游戏，你可能从头开始做吗？ 不会别人技术已经很先进了。	2021-06-04 04:13:20.281746	f
1743	882	Issue	5		2021-06-08 04:03:45.664637	f
1733	880	Issue	5	2，parquet支持order吗？\r\n  支持，但是读写和排序得上层实现。\r\n\r\nparquet确定了数据存储格式，这决定了数据的语义，包括比较方式。这是parquet兼容性前提。\r\n\r\n如果我们自己实现格式，同样也得定义存储格式，定义比较函数。其他系统对接上来也得转换。\r\n也因此，parquet的sort应该在其writer中实现，过滤也得在其中实现。\r\n\r\nsort不能在上层做，否则对于parquet不兼容类型，按照其排序特征过滤可能会出错。	2021-05-30 07:06:24.437235	f
1736	880	Issue	5	3，spark等如果兼容parquet类型？\r\n	2021-06-01 14:53:21.060306	f
1746	884	Issue	5	不写详细设计文档，要把代码写成文档。\r\n除非极其复杂的部分，辅助以图片文档加强理解。\r\n可注释性，如果一个函数不能用其名称或注释很简明的说明其功能，那么该函数可能是不合适的。\r\n要么夹带了私货，要么东扯西拉，这都不是好的函数。\r\n\r\n注释和测试来驱动设计和编程。\r\n概念实体\r\n行为\r\n可见性\r\n约束\r\n\r\n	2021-06-11 15:10:24.101078	f
1759	841	Issue	5	人脑也是一个系统，如果工作不能提升该系统。\r\n那么从该维度看就是在做无用功。在根本上我们是让大脑系统变得更强，从而生产出其他系统。\r\n\r\n工作应该能改变我们的大脑。	2021-06-15 07:12:17.426831	f
1801	852	Issue	5	我想要强大的身体\r\n我想要强大的办事能力\r\n我想有精力尝试各种事情，用广度深度来丈量我的人生。\r\n\r\n研究形式化系统，限定范围：如果提升人与计算机的表达能力。性能提升并非目的，尤其是用cache，并发，并行堆积的性能提升。	2021-08-01 19:53:16.597232	f
1747	884	Issue	5	有哪些模块，每个模块的职责。\r\n\r\n类型-约束-未定义行为-安全。\r\n可见性\r\n层次分解的时候需注意可见性。将复杂度对外屏蔽。\r\n分解的稳定性，行为的稳定性。没有稳定性就没有扩展性，就是一个矛盾。\r\n系统的稳定性指其不需改变的部分，系统的扩展性指其需改变的部分。\r\n\r\n如果模块可以独立对外使用，那就应该分离出仓库。\r\n如果模块无法独立对外，那么只能视为内部的子模块。\r\n\r\n每个模块都应该给其明确含义，是独立完整的个体。\r\n为什么垃圾软件遍地飞，因为没有人去关心那些小小的模块。\r\n这样的模块积累多了系统就既不稳定也不能扩展。 无序且无法被理解。\r\n\r\n每个模块都应该考虑：\r\n1，稳定性，稳定的行为\r\n2，安全性，未定义的行为\r\n3，扩展性，扩展的行为\r\n4，性能，更好的行为\r\n5，并行性，可以并行的行为	2021-06-13 06:46:24.80613	f
1748	884	Issue	5	软件开发的另一个维度是正确性，即提出新的实现方案，并论证其正确性。学术界研究的主题，论文都是这类。\r\n这块是必须提前想清楚的，否则就得进行论证。\r\n\r\n不要把猜想当证明，把尝试当结论。软件的根本性失败源于此。	2021-06-13 06:48:53.786809	f
1749	887	Issue	5		2021-06-13 19:34:25.505793	f
1750	885	Issue	5	系统已经启动，只能往前发展，重构，不断变得更好。演绎属于该系统的序章。\r\n我想变成一个无比强大的人，懂得选择，懂得他人，懂得真，善，美	2021-06-14 04:51:08.870097	f
1751	887	Issue	5	解决生成速度问题，table cell下划线问题。\r\n\r\n但是新生成的打包无法运行。	2021-06-14 16:49:02.196411	f
1754	841	Issue	5	设计，文档，代码，测试的关系：\r\n\r\n设计即文档，代码即文档。\r\n设计即代码，代码即设计。\r\n测试是对代码的校验，也是对设计的校验。	2021-06-15 06:36:54.405276	f
1756	841	Issue	5	团队管理就是一个分布式系统，分布式系统受限于"CAP"理论。\r\n副本多则一致性就有代价。	2021-06-15 07:01:17.74666	f
1757	841	Issue	5	终有一天，我们看待编程就如同看待生活一样。\r\n我们当下的极限在于对真实世界系统的理解上。	2021-06-15 07:03:42.178146	f
1769	852	Issue	5	利益刺激的坏处在于它不能帮助我们构建一个最高效的系统。\r\n我们成为一个高效有趣有内涵的系统的本身的吸引力才是稳定的。\r\n	2021-06-20 12:37:25.269635	f
1762	886	Issue	5	将逻辑日志记入redo是保证逻辑日志一致性的需要。\r\n准确的说也不是换执行器，执行器还是按对象执行。\r\n更换的是本地持久化机制。由于DN最新数据可以从本地读取。\r\n不，在原设计中本地存储是非必须的。通过逻辑日志+远端可以恢复元数据。\r\n\r\n备DN在此时主要目的是维护逻辑日志。\r\n\r\n在无远端的情况下，MPP下本地元数据存储才是必须的。\r\n\r\n多版本是实现的对象内的版本可见性。比如我增加一个slice，会修改group对象。\r\n有2种方式处理可见性：\r\n1，group对象有版本\r\n2，slice本身有版本\r\n\r\n对象多版本提供了闪回能力。\r\n但是要读取某个时刻的版本，需元数据支持。\r\n\r\n	2021-06-16 13:40:10.505869	f
1763	886	Issue	5	在根本上还是要想清楚锁和多版本该怎么弄?\r\n复用undo则受限于undo清理机制。\r\n\r\n\r\nhandle提供rollback能力，rollback就是把所有数据文件干掉。\r\n此时元数据尚未写入。\r\n元数据多版本支持。在空间足够的情况下，不会随便snapshot too old.\r\n区别在于本地Cache的实现。执行器基于Cache。如果是一个全量的cache，\r\n那就相当于存到了本地，如果以本地为准，就要本地支持多版本。	2021-06-16 14:04:21.852531	f
1764	885	Issue	5	将思考的过程具象化，用一种方式来表达它，然后才能推导验证。\r\n\r\n伪代码技术仍然很有用。	2021-06-18 07:04:28.180143	f
1766	852	Issue	5	就像很多人对善有误解一样，人们对于善良也有普遍的无解，不作恶并非就是善。\r\n未能接受并改变自己者也非善。善然后做一个烂人？除了善还要贵。物依稀为贵，去成为一般人不能成为的人，达到别人达不到的修为。\r\n这就是贵。人自贵而他人贵之。为什么贵，你还不懂吗？因为这就是前进的路。必须要走的。\r\n\r\n一定要立志：不立志则不成系统，没有稳定性，也就无法达到一定高度。\r\n            虽然系统可能过时，但我们必须做出选择。否则会一事无成。\r\n良知就是人生啊，在事业中磨砺。在绝望中看见曙光，在奋进中看到极致的真和美。	2021-06-20 07:30:20.314239	f
1771	891	Issue	5	如果说搭建的redmine是第一代自我管理系统。\r\n这个App就是第二代自我管理系统，其设计为更加主动，使得人的生活的很多部分可以自动运转。\r\n让人把核心注意力放在精神，意图，以及方法论上来。	2021-06-20 14:31:38.7725	f
1767	852	Issue	5	人的力量来源：精神力量，情感力量，身体力量。\r\n              精神力量就是一种心向往之的力量，没有精神生活的人就是心灵迷失的人，这样怎么会有力量。\r\n\r\n有些人工作是为了让自己舒服，有些人工作就是挑战自己。\r\n\r\n我希望我们能成为新时代的儒侠，追寻心之所向的精神力量，强大的生存能力，超过常人的付出，独立自主，生机畅达的生活。\r\n儒人之所需，是良知，中庸变化，生机畅达。\r\n侠是独立自主，是超人的能力。\r\n\r\n              	2021-06-20 07:38:58.026667	f
1768	890	Issue	5	9.30 聚焦在MPP，计算存储分离上。 PN后面再实现，但设计上要考虑。\r\ncoral二期的整体规划。\r\n1，anchorBase\r\n1.1 支持新的表类型\r\n1.2 支持pool管理\r\n1.3 支持coral am/metadata\r\n\r\n2，coral库\r\n2.1 parquet格式的支持完善\r\n2.2 s3的支持，cache（先做对象cache）\r\n	2021-06-20 09:00:03.82105	f
1775	894	Issue	5	正确性和大的选择，这是体现设计功力的地方。\r\n\r\n没有方法论情况下做事就如同黑夜中摸索，思考如蜗牛一般的速度。	2021-06-24 06:31:25.088168	f
1776	852	Issue	5	我以前总觉得程序化会让人变弱，但是无序系统感觉更弱，不选择是最差的选择。\r\n选择了出错可以总结修正，系统还在不断完善。\r\n\r\n系统选择：to be or not to be。要么全身心投入，要么不做。	2021-06-24 06:40:34.56283	f
1781	897	Issue	5	接受现实，直面问题。不强求公正，合理。\r\n拒绝情绪化，人应该算在问题之内。\r\n拒绝依恋，过度依赖。迎接变化和未知。\r\n拒绝麻木，热情让自己有无限可能。\r\n成熟从分清依赖和约束开始。对个体和组织的依赖，让人不做选择，放弃部分思考。\r\n对世界约束的模糊与否定，让我们跌跌撞撞。\r\n成熟让我们成为独立人格的人。	2021-07-01 06:34:04.56821	f
1760	886	Issue	5	1，在拿到scn之后，再执行。\r\n   这个太晚了，如使用anchorBase，执行时间不宜很长。\r\n   应该在拿scn之前submit，但这样对象版本就不能直接使用scn编号。\r\n   \r\n   对象不需要版本号，逻辑日志需要，同步也需要。\r\n   读取的时候给定SCN，从存储读取到对应版本。\r\n   这个存储可以是本地的，也可以是远端的。\r\n   \r\n2，rlog作为逻辑日志，怎么跟物理日志保持一致性？\r\n   能做到MPP模式不需要逻辑日志？\r\n3，rlog是带版本号的逻辑日志   \r\n4，数据库中保存对象如何做并发控制？\r\n   大家都去插入一条记录？\r\n   还是在外部做并发控制？\r\n   \r\n5，MosDerive\r\n   驱动结构体，使其成为一个对象。\r\n   或者叫驱动逻辑日志。\r\n   \r\n6，对象超过64k怎么在anchorBase中存储    \r\n\r\n说不清楚的原因在于逻辑日志和物理日志的混合使用。\r\n本地执行不需经过逻辑日志。还是分离清楚比较好。\r\n本地执行是需要一个支持事务的系统，且该系统能接入\r\n\r\n7，谁来写远端？\r\n\r\n8，让anchorBase实现ObjectStore接口，将执行改为同步执行。\r\n   ObjectStore提供锁定对象能力。\r\n   同步执行和异步执行并非关键，主要是锁定。\r\n   以及提交操作的位置。比如二阶段提交怎么搞，比如回滚等。\r\n   \r\n\r\n流程：\r\n1，在本地修改，持有锁\r\n2，修改完成后提交对象上修改。(也可给对象提供写入接口，由用户控制写入时机)\r\n3，将修改写入数据库\r\n4，对象不具备scn版本，\r\n\r\n\r\nPN和远端以对象方式存储。\r\nPN也可以用DB存，但是执行的是逻辑日志？\r\n\r\n\r\n\r\n\r\n	2021-06-15 18:49:16.984842	f
1761	886	Issue	5	所有在提交之前的修改都是本地修改，这是原实现不需要undo的原因。\r\n对应的redo也都是本地修改，只有finish之后才进入全局队列，并释放锁。\r\n也由于此，没有undo提供的多版本能力。\r\n即submit的时候仍然没有scn，只有finish的时候产生scn。\r\n\r\n更换执行器：\r\n1，加锁                       1，加锁\r\n2，记录redo，本地修改\t\t  2，记录undo\r\n3，提交                       3，直接修改，记录redo\r\n4，释放锁                     4，提交\r\n5，实施全局修改               5，释放锁\r\n\r\n多版本读： \r\n原实现中并没有保留多版本，当然这并非绝对，可以通过多版本对象来管理。\r\n在数据支持的情况下，可以查询到任意时刻的数据。\r\n\r\n使用anchorBase带来的变化：\r\n1，可以利用其锁实现\r\n2，可利用其undo实现多版本读\r\n\r\n逻辑日志这块并无变化。仍然记录，并通过redo保证一致性。\r\n但这里逻辑日志是可选的。比如MPP下，无PN时并不需要。\r\n\r\n另外一个大的点是究竟是否需要使用对象？\r\n是否在anchorBase中使用一行存slice信息，而不使用group概念？\r\n\r\n在submit之后，handle接口，\r\nkernel	2021-06-16 13:38:23.214402	f
1741	852	Issue	5	我接受这一切，解除心灵的枷锁，我将如不死鸟，生生不息.\r\n\r\n高手只要还能动，还能思考，就有信心在。 跟物质有何关系，这就是实力。\r\n另外就是要会用脑，善于在不用的地方节省，把思考力真正用于处理实现问题上，发挥其能力。这不就是社会必然分化的原因吗。	2021-06-04 04:47:15.295998	f
1765	885	Issue	5	coral中维护了group列表，但具体内容可以在obs中。obs中的对象也用于给远端和PN同步。\r\n\r\n\r\n1，在anchorBase中增加元数据记录，元数据记录不包含内容，只包含其描述，以及元数据对象位置信息等，删除位图对象信息。\r\n2，元数据对象的内容以文件形式存放，其同时用于本地元数据服务，也用于给远端和PN同步。\r\n3，anchorBase修改元数据步骤:\r\n   1，写undo，这里undo除了清理之外，还有判断冲突的作用。\r\n   2，写redo\r\n   3，写元数据对象(每次产生新版本)\r\n      2.1 写逻辑日志\r\n   4，按需刷新anchorBase元数据记录\r\n4，逻辑日志最终也被写入redo，通过物理复制保证逻辑日志的一致性。   \r\n\r\nredo的replay也是生成新版本对象，以便于备DN同步。\r\n元数据的一致性在anchorBase上维护。\r\n\r\ncoral提供了数据对象和元数据对象操作能力，提供逻辑日志。\r\n调用逻辑从anchorBase到coral，不反向操作。\r\n\r\n问题PN怎么办？\r\n删除怎么并发？不能以记录来判断冲突，否则范围太大。\r\n对象的同时修改：需要latch保护。但只要涉及同时修改一个对象，对象内又没有版本，如果保证可见性？\r\n通过undo。undo能否支持多个事务修改不同部分？	2021-06-18 16:51:47.375728	f
1770	892	Issue	5		2021-06-20 14:28:35.800681	f
1772	893	Issue	5		2021-06-20 15:31:00.397679	f
1773	881	Issue	5	系统就是不断分化的，真正要做好一件事情，都是细节。这是李宇轩教给我的。	2021-06-20 15:32:05.796335	f
1774	852	Issue	5	人生就是在修炼自己这个程序，核心是基本面，是人的精力和体能。\r\n中层是情绪，情感，认知。 高层是人的技术技巧行为。	2021-06-24 06:30:41.163327	f
1777	896	Issue	5	还有Clion Cmake有时候需要reload下\r\n	2021-06-25 07:46:17.586909	f
1778	882	Issue	5		2021-06-27 15:38:50.975072	f
1779	882	Issue	5		2021-06-27 15:59:38.329536	f
1780	897	Issue	5		2021-06-30 19:43:08.928577	f
1784	892	Issue	5	2个原因不能回调：\r\n1，anchorBase不能支持非自研代码。\r\n2，coral库用rust实现，没必要走一通anchorBase	2021-07-01 15:02:47.248719	f
1786	881	Issue	5	思考语言等的核心就是精神幸福的状态，\r\n就像运动的核心是放松	2021-07-02 08:31:12.053527	f
1790	902	Issue	5	然后自己好了，莫名奇妙。注意可以看下service sshd status其会报一些错误信息。	2021-07-05 17:21:22.183946	f
1791	904	Issue	5		2021-07-05 18:29:47.225319	f
1793	841	Issue	5	程序的三驾马车：复杂度(封装)，可变性(结构分化，优势行为，进化(多态))，性能（选择偏好，完成度）。\r\n感知到每一个结构体，增加一个变量，子结构。最细微的感知力来自于对系统最深入的理解。\r\n\r\n最近对于dataset的分化又让我深入的理解了这点，尤其是底层系统对于资源的封装是非常重要的。\r\n	2021-07-22 06:34:01.341631	f
1798	852	Issue	5	管理者需要一心多用的能力\r\n管理者更需要第三视角\r\n修身齐家治国平天下是自然的，是人能力提升过程的必然结果。\r\n\r\n闭环，对称性在软件安全上的作用。\r\n在周六的早上起来，没有人限制我们的行为，这时我们的选择就是其信仰和目标所在。\r\n而且越是自发自愿的就越持久，能量就越强大\r\n\r\n关键不是于生活赋予你怎样的意义，而在于你是否主动将生活变成自己价值取向的载体。\r\n我称之为进化，不进化就达不到一定高度，体验不到进化过程的乐趣。也不会变得强大。	2021-08-01 19:48:45.038146	f
1800	926	Issue	5	计划：早上下蹲30个，平板撑3分钟，慢跑20分钟，一共半小时	2021-08-01 19:51:07.952179	f
1805	908	Issue	5	能走少有人走的路\r\n选择怎么样去过一生	2021-08-07 14:41:10.305378	f
1826	947	Issue	5	字典编码讨论纪要：\r\n1. 存储在dataset上提供字典编码的接口\r\n2. DDL增加对字典编码字段的属性描述，如varchar(10) dictionary\r\n3. 对于LSC表，需要从slice文件中提取局部字典描述信息，挂到dataset上\r\n4. 字典特性对计算的优化，优先提供非排序的字典，优化等值比较场景，再考虑提供排序的字典。优先考虑字符串的优化\r\n5. 优先提供局部字典方案，再提供全局字典方案\r\n\r\n字典的可变性可以在字典内维护，比如有10ge字典项，外部通过position标识，字典不根据position有序，但是字典项可以有一个排序值。\r\n该值可以维护，也可以不维护，计算时进行维护。	2021-09-08 17:33:27.223819	f
1782	852	Issue	5	接受现实，直面问题。不强求公正，合理。\r\n拒绝情绪化，人应该算在问题之内。\r\n拒绝依恋，过度依赖。迎接变化和未知。\r\n拒绝麻木，热情让自己有无限可能。\r\n成熟从分清依赖和约束开始。对个体和组织的依赖，让人不做选择，放弃部分思考。\r\n对世界约束的模糊与否定，让我们跌跌撞撞。\r\n成熟让我们成为独立人格的人。\r\n\r\n人是通过成长去面对世界，社会，以及塑造自我的。依恋依赖解决不了任何问题。	2021-07-01 06:34:18.02228	f
1783	892	Issue	5	squid执行数据直接与coral库打通，不必经过anchorBase绕一次。\r\n仅借助anchorBase的事务能力，做元数据管理。\r\ncoral在anchorBase部分需提供：\r\n1，增删slice\r\n2，遍历slice\r\n3，标记删除\r\n4，按group查询slice\r\n5，按slice删除delete信息\r\n等能力，数据从squid直接到coral库。	2021-07-01 12:26:16.886215	f
1785	894	Issue	5	思考的步骤：\r\n1，定性问题，搞清楚本质\r\n2，了解已有解决方案\r\n3，选择使用已有方案或创新\r\n4，论证新方案正确性	2021-07-02 08:21:50.596962	f
1787	891	Issue	5	需求是能统计做了哪些事，并在具体做的事上去完善。\r\n比如打球的时候提醒自己热身，打完提醒自己拉升。\r\n打的过程中提醒自己注意哪些事项，开始之前提示自己做些什么。\r\n\r\n准确的说就是程序，那些在注意力之外的步骤。	2021-07-03 19:48:34.529417	f
1788	882	Issue	5		2021-07-04 13:15:32.469608	f
1789	882	Issue	5		2021-07-04 13:15:52.183984	f
1792	907	Issue	5		2021-07-08 07:35:15.322452	f
1794	852	Issue	5	以直报怨即可，愤怒是可以提到执行力，但不是最优解。\r\n只有纯粹的伴随自身的快乐是持续长久的，比如旺盛的精力和体能，知识智慧。\r\n所以专注于提升自我，不要做投机者，圈养者(被喂食)，做开拓者，做游侠。在自然及社会规则下，有实力以直报怨，有实力生存，也有实力快乐。	2021-07-22 06:37:59.945257	f
1795	910	Issue	5		2021-07-25 19:40:55.722937	f
1796	914	Issue	5		2021-07-27 06:38:12.755022	f
1797	914	Issue	5		2021-07-27 06:38:39.986621	f
1799	925	Issue	5	完成羽毛球运动一次\r\n晚上下蹲20个，跑步1小时	2021-08-01 19:49:54.922391	f
1802	915	Issue	5	事情并非我完成，而是交给合适的模块去完成。	2021-08-01 19:58:01.685325	f
1803	928	Issue	5		2021-08-01 20:00:12.526672	f
1804	705	Issue	5	鞭打的关键在于腿和腰腹力量传递，只要腿没有蹬地，那么力量只能来自甩臂。\r\n所以打球时很明显，只要腿上没感觉，状态就不行。\r\n\r\n反手也是如此，反手脚蹬地意识更差，反手另一个问题就是拍面的掌握。\r\n不过这也不仅是反手，很多其他球拍面也是关键。随着我们快速蹬地发力的提升，拍面控制感觉的提升，反手便是自然了。\r\n\r\n短促的蹬地发力传导。\r\n	2021-08-06 06:23:16.934809	f
1807	930	Issue	5		2021-08-07 15:04:48.192963	f
1811	705	Issue	5	羽毛球跟树甩枝条一样，腿的蹬地是树根，腰腹传导是树干。手臂是枝条，球拍是叶。\r\n讲究瞬间发力，突然由放松到紧的过程，不像其他运动的持续发力。	2021-08-13 06:23:02.484412	f
1814	934	Issue	5	人的第三次转型。\r\n以前体力劳动者受欢迎，如今快被淘汰。\r\n后面机械的理性和逻辑工作也将被淘汰。\r\n留下的将是创新型的，艺术型，探索型的。	2021-08-14 16:43:28.861207	f
1821	934	Issue	5	高质量生活指南：\r\n1，热爱身边的人，不排斥憎恨身边的人。就像阿甘一样把每个人当作独立的个体人而存在。\r\n2，热爱自己从事的工作，其实真的找不到任何原因人能长期从事工作，唯有热爱。\r\n3，简化自己的生活，生而精简，体验弥足珍贵的事物。\r\n   看到的越来越多，记住的越来越少，记得西部世界的景象么，太阳初升。\r\n   看很多遍，在脑中重复画面，日久弥新。\r\n\r\n4，制造美丽的瞬间，让人永生难忘的画面以及体验是人的动力源泉。\r\n5，热爱他人和工作可以降低内耗，提升带宽。没那么复杂。\r\n   我不管别人怎么想，也不管其他事。\r\n   吾道一以贯之，长此以往，改变人的精神和灵魂。\r\n	2021-08-30 06:31:40.659766	f
1822	934	Issue	5	逍遥游：\r\n如我在于名利，则我担心名利被损。\r\n如我不接受当下，则身心俱疲。\r\n任何事物都是在受限环境下，接受约束喜欢当下的活动方得自由。而不是构造乌托邦环境。\r\n于事，就是单纯的喜欢做这个。\r\n于人，就是单纯的喜欢与这个人打交道。\r\n于我，留下美好而深刻的记忆，仅此而已。	2021-08-31 06:39:12.951461	f
1828	948	Issue	5	这锅不能让先人背，没有好坏对错和标准。 需要的是我们的抉择。\r\n孔子背整个儒家的锅？时代环境都在变化，跟随自己的灵魂去选择。\r\n	2021-09-11 14:58:07.78128	f
1830	888	Issue	5	孔子和苏格拉底都点明了这点，不管是生机畅达还是灵魂的无碍	2021-09-13 17:27:56.189485	f
1831	950	Issue	5	https://www.zhihu.com/question/24301047\r\n\r\n1，使用MESI + Memory Order能否保证 内存操作的原子性？\r\n2，多个变量修改的原子性是否必须用锁？\r\n3，原子性与一致性的关联关系，如果一个写立刻对另一个写可见，那么可能破坏原子性。\r\n   原子性要求要么是 op a + op b，或op b + op a，不存在中间状态。	2021-09-23 11:53:09.854411	f
1833	950	Issue	5	https://zhuanlan.zhihu.com/p/348355186	2021-09-23 17:35:10.82482	f
1834	951	Issue	5	改进行为是最初的动机	2021-09-24 07:15:01.993477	f
1835	952	Issue	5	1，翻译助手\r\n2，阅读助手\r\n可以阅读的助手	2021-09-24 07:22:14.244267	f
1836	951	Issue	5		2021-09-24 07:26:23.248805	f
1839	950	Issue	5	1，原子操作本质上是一个同步点。即不能有多个人同时做这件事，如果有，则其他人需等待。\r\n   因而原子操作必然绕不开锁。\r\n2，内存屏障指的是对于单线程内指令顺序调整的限制，不仅限制CPU，编译器也需遵守。\r\n3，内存序是指load store指令顺序调整的限制。 	2021-09-24 10:20:32.977735	f
1840	954	Issue	5	有办法配置ssl不使用证书吗？	2021-09-24 18:28:20.013519	f
1806	908	Issue	5	这世界上有很多依存于特定环境而获取收益的人，\r\n还有热衷于赌，期盼幸运女神的人。从社会世俗角度看他们或许很成功。\r\n但其实很多人忘了2个基本事实，一是依赖的环境的可变性，\r\n二是世界存在随机概率，可能好运也可能坏运。人们只看到自己期望看到的，\r\n有幸存者偏差。\r\n\r\n终究人应当生活在一个真实的世界上，\r\n拥抱不确定性，\r\n认识到自己的愚昧，\r\n接受自己作为人的情感，\r\n可以失败\r\n保持进取，积极调整\r\n\r\n否则当现实变化时，可能自己无法承受。\r\n\r\n终究我们每个人都是在自我修行，谁也无法预测成功，而人生总是在与各种问题打交道。\r\n但我们可选择积极生活。	2021-08-07 14:41:21.420498	f
1808	930	Issue	5		2021-08-07 15:06:58.922181	f
1809	931	Issue	5		2021-08-07 19:30:24.199992	f
1810	931	Issue	5		2021-08-12 05:49:33.942341	f
1812	934	Issue	5	因为“思考生活的意义”其实不是必要的，必要的是“带着热忱去生活”，你去做一件事，不一定需要它有什么意义，而是你对它感兴趣。\r\n\r\nhttps://www.zhihu.com/question/20274183\r\n这一句道明了真相。	2021-08-14 15:16:56.708753	f
1813	934	Issue	5	精致的利己主义者。\r\n理性而冷漠的旁观者。\r\n      可能很多人没区分理性感性，热情和冷漠。理性的人不一定冷漠，理性而冷漠是莫入歧途。\r\n	2021-08-14 15:24:02.777885	f
1815	934	Issue	5	分化，以及有难度的事情可能带来的快乐更弥久。\r\n通过什么事情获得快乐是我们需要不断尝试和选择的。\r\n\r\n很多人认为的有用，即有价值，即强调我们做事的利它性和分享性。\r\n当然这是社会规律的部分。\r\n\r\n良好的人际关系就跟爱情一样对人非常重要。\r\n\r\n多巴胺掌握了动力，生机畅达的含义就是让我们保持长期的愉悦和热忱。\r\n有几个重要的点：\r\n1，要知道自己是独立的，不必过于关注他人期待。\r\n2，要知道人生的系统是长期运行的，允许失败。\r\n3，接受上述2个的前提是保持持续的改进热情。\r\n4，保持适当的压力训练让人成长，保持总结领悟让知识更加精确。\r\n\r\n选几个项目形成自己的生活项目，然后持续训练以及体验让大脑对该行为产生动力。\r\n这就像系统的分化一样。\r\n\r\n对抗不良习惯带来的刺激，总之一点让自己成为主人，明确自己的选择，自己所见。\r\n而不要让大脑被劫持。被集体，虚荣感，依恋等控制。\r\n想想事情或人本身是否能给你带来快乐。带来真善美的体验。\r\n这才是事业，朋友和爱好的本质。其本身是为我们提供了一个修行道场。\r\n\r\n比如说玩游戏，人通常对最初的那个游戏是怀念，经常想去玩下，但是上去玩一会就退出了。\r\n为什么这样呢？ 最初游戏形成的持续刺激在大脑还在，那会做一个新任务，打一个怪都很新奇，而且还有伙伴一起完成。\r\n而如今再去玩，这2点都没了。游戏还得继续发展，不断分化。\r\n最终其系统超越了我们的学习时间阈值，以至无法短期内获得刺激。 对，准确的说是因为我们需要短期的刺激，就像性和毒品一样。\r\n然而当初那快乐并非短期构建的，所以问题在于如何切入。\r\n游戏系统的快速更新让人无法适从，只有卷得特别厉害的人才能跟上节奏，\r\n但系统又没法停下脚步，否则最前面的人无法探索新鲜事物。\r\n\r\n外界刺激就像开挂一样，高潮来得快但去得也快。\r\n\r\n这世界就是很多这种系统组成的，子系统之下有几个大系统，不在大系统范围内的子系统可能被边缘化抛弃。\r\n玩人数适中的系统可能更有意思。	2021-08-14 19:19:46.855598	f
1817	920	Issue	5		2021-08-23 12:21:00.166341	f
1818	942	Issue	5	1，需要尽早决定的事项，约束决策论。\r\n2，后期变化成本高的部分，演化原则。 进化论。\r\n3，降低软件的复杂度，那些需要尽早众所周知的部分。管理沟通论。\r\n\r\n架构涉及的层面：\r\n1，系统\r\n   系统讲究可变性，复杂度，约束\r\n2，工程\r\n   工程讲究人力，资源，沟通，约束，执行器。\r\n\r\n	2021-08-24 06:27:53.278154	f
1819	839	Issue	5	封装让实体不是被操控，而是通过暴漏接口的方式来与外部交互，从而保证内部的可演化性。\r\n封装还有一点好处是可见性，外部不可见降低了软件的隐式依赖，降低软件复杂度使得正确性更容易保证。	2021-08-24 06:32:26.957842	f
1816	940	Issue	5	5分做事，3分计算，2分思考。每天都能进步，看看1年后是啥状态。	2021-08-23 07:13:26.981988	f
1820	871	Issue	5	预读：\r\n1，异步预读下一批页面\r\n2，row id set时，异步预读离散页面\r\n3，读前面的列时，预读其他后面的列\r\n\r\n字典压缩	2021-08-30 06:21:25.227565	f
1823	934	Issue	5	个人的生机畅达\r\n亲友的真情实意\r\n自然的灵感链接\r\n行为的落到实处，虚假与踏空让效率成为泡影。	2021-09-07 16:44:16.973545	f
1842	957	Issue	5		2021-09-26 10:39:32.238855	f
1824	945	Issue	5	知识均来源于自然这个系统，然而如果探知真相实在却并非易事。\r\n抓住了实在根本的东西就能掌握事物并加以改变。\r\n\r\n诸子百家莫不如此，均从不同维度去探知真相，从而掌握了一些实在实质的东西。这就是有点真东西。\r\n搞些虚无缥缈的东西，如命运之浮萍。好玩首先得是真的，什么是真的，对于现实中的人，没有什么比我们生活所在的系统更真实了。\r\n形式主义的危害就在于此\r\n聪慧的人就是与自然连接好的人，能感知这个系统的一些真相。	2021-09-08 06:36:43.817335	f
1825	946	Issue	5	问题的根本在于业务特征：\r\nCRM，ERP等场景就是从不同字段来处理数据的，不同维度来处理数据的，如何高效。\r\n\r\n从另外一个角度看，为啥不搞单机的，可能70%场景用单机和复制就能搞定。	2021-09-08 06:41:11.186929	f
1827	934	Issue	5	这问题苏格拉底已经回答了。\r\n真相其实就是灵魂，是人与整个大系统的连接，对其的理解。\r\n野马也，尘埃也，生命之以息而相吹也。\r\n\r\n未经审视的人生不值得过，这或许也是苏格拉底爱追问的原因	2021-09-09 06:54:22.886459	f
1829	888	Issue	5	过度游戏就会疲惫，这并非最优解。这是低水平玩家。\r\n工作要恰到好处。	2021-09-11 15:00:34.619718	f
1832	950	Issue	5	MESI协议实现内存/Cache操作的coherence,coherence指多处理器看到的是完全一样的操作顺序。\r\n内存屏障可以实现consistency，即保证读写顺序。\r\n\r\n	2021-09-23 17:04:33.524785	f
1837	951	Issue	5		2021-09-24 07:29:11.335489	f
1838	951	Issue	5	这个世界如何用数学，离散数学语言来表达，又如何用计算机语言来表达，怎么样的方式表达。\r\n集合，元素，关系。只有有了这些理解，一个技术出来就知道它在根本上是解决什么问题的。	2021-09-24 07:32:18.748068	f
1841	954	Issue	5	https://blog.csdn.net/w1781806162/article/details/46358747?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.no_search_link	2021-09-24 18:46:57.939545	f
1843	954	Issue	5	[gpadmin@server11 ~]$ curl -vvI  https://mirrors.tuna.tsinghua.edu.cn/rustup/dist/2021-09-15/channel-rust-nightly.toml.sha256\r\n* About to connect() to mirrors.tuna.tsinghua.edu.cn port 443 (#0)\r\n*   Trying 101.6.15.130...\r\n* Connected to mirrors.tuna.tsinghua.edu.cn (101.6.15.130) port 443 (#0)\r\n* Initializing NSS with certpath: sql:/etc/pki/nssdb\r\n*   CAfile: /etc/pki/tls/certs/ca-bundle.crt\r\n  CApath: none\r\n* SSL connection using TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\r\n* Server certificate:\r\n* \tsubject: CN=tuna.tsinghua.edu.cn\r\n* \tstart date: Jul 05 03:00:58 2021 GMT\r\n* \texpire date: Oct 03 03:00:57 2021 GMT\r\n* \tcommon name: tuna.tsinghua.edu.cn\r\n* \tissuer: CN=R3,O=Let's Encrypt,C=US\r\n\r\n\r\n[root@localhost certs]# curl -vvI  https://mirrors.tuna.tsinghua.edu.cn/rustup/dist/2021-09-15/channel-rust-nightly.toml.sha256\r\n* About to connect() to mirrors.tuna.tsinghua.edu.cn port 443 (#0)\r\n*   Trying 101.6.15.130...\r\n* Connected to mirrors.tuna.tsinghua.edu.cn (101.6.15.130) port 443 (#0)\r\n* Initializing NSS with certpath: sql:/etc/pki/nssdb\r\n*   CAfile: /etc/pki/tls/certs/ca-bundle.crt\r\n  CApath: none\r\n* Server certificate:\r\n* \tsubject: CN=tuna.tsinghua.edu.cn\r\n* \tstart date: Sep 25 08:02:10 2021 GMT\r\n* \texpire date: Sep 25 08:02:10 2022 GMT\r\n* \tcommon name: tuna.tsinghua.edu.cn\r\n* \tissuer: E=Public Certificate,CN=Public Certificate,OU=Public Certificate,O=Public Certificate,L=ChaoYang,ST=BeiJing,C=CN\r\n* NSS error -8172 (SEC_ERROR_UNTRUSTED_ISSUER)\r\n* Peer's certificate issuer has been marked as not trusted by the user.\r\n* Closing connection 0\r\ncurl: (60) Peer's certificate issuer has been marked as not trusted by the user.\r\nMore details here: http://curl.haxx.se/docs/sslcerts.html\r\n\r\n	2021-09-26 13:50:18.049624	f
1844	954	Issue	5	很可能是nss版本的问题	2021-09-26 15:06:13.468286	f
1845	904	Issue	5	步骤：https://www.softwarecollections.org/en/scls/rhscl/llvm-toolset-7.0/	2021-09-26 19:49:26.587094	f
1846	957	Issue	5	有偶然性，同时也有长期努力的必然性。\r\n科学不是一世之功，在这点上也让中国出现科学大发展的概率变得很低。	2021-09-27 06:36:49.253781	f
1848	958	Issue	5	连接自然系统中的生活经验和推理，以及其他系统中得到的概念，然后建立自己的系统。\r\n我不知道第四种境界如何达到，但第三种能用我们心灵去思考观察事物，并形成自己的体系是可以做到的。\r\n\r\n认知方法论：\r\n第一性原理，树状的公理集合，生长的系统，软件可以用一句话（自然语言）或一个公式（数学语言）或计算机语言来表达。\r\n三段论，推理\r\n归纳总结\r\n\r\n批判性思维：关注认知过程的认知，觉知，自我的观察者。\r\n            何为德，生机畅达，自由意志，抉择，能动性。\r\n\r\n	2021-09-27 16:44:33.649094	f
1849	960	Issue	5	所以问题关键在于如何理解唯物辩证法，演绎和归纳	2021-09-28 06:17:20.860236	f
1850	960	Issue	5	唯物辩证法是根子，然后有不少基本概念，机器系统？计算？推导？\r\n\r\n没有哲学的思维方法，就没有统一的正确标准，没有可延续性，因而没有科学繁荣。	2021-09-28 06:25:23.240154	f
1851	957	Issue	5	https://zhuanlan.zhihu.com/p/19958220\r\n对于语言的讨论也很有意思，可以作为参考，语言或许也是人认知的一个天花板。（这也是解释科学无法大发展的一种方式）\r\n名可名，非常名，人就是一个形式系统，任何形式系统可能都无法完全描述自然，本质上就是抽象概念。	2021-09-30 06:54:39.272624	f
1853	966	Issue	5		2021-10-04 13:16:02.517777	f
1854	966	Issue	5	真相关乎自由，真才有善美，你明白它有多么重要吗？	2021-10-04 14:26:55.955927	f
1855	969	Issue	5		2021-10-07 06:01:44.45311	f
1856	969	Issue	5		2021-10-07 07:15:06.733574	f
1857	967	Issue	5	coral定位还是一个历史数据存储，即保持数据不可变，但是数据有可见性，即版本。\r\n数据的有效性需通过另外来标识。\r\nlambda架构的核心就是数据不可变，数据不可变，则相同计算结果不变(View),视图。\r\n数据系统应当如此构建，这样知识可以积累。人不也是这么处理问题的么，利用历史经验数据和最新的数据进行近似计算。\r\n	2021-10-07 07:42:19.105359	f
1859	934	Issue	5	人的意义：于世间争得一点活力。\r\n争这里并非狭隘的竞争，而是遵守最基本规则下的改进。\r\n战争正是没有解决方案的下下策。\r\n注意重心在于活力，不可舍本逐末。	2021-10-07 08:10:17.758673	f
1860	970	Issue	5		2021-10-10 18:48:26.806372	f
1865	972	Issue	5	本质上想要精通一个事物，最好的办法或许是写一个测试系统。\r\n把自己的认知加入到这个系统，然后运行起来，并不断改进。\r\n\r\n把我们代码review需要做的事情都自动化，比如发现代码不合理需重构，发现逻辑错误。	2021-10-12 08:32:52.564826	f
1868	973	Issue	5	出现一个loader比4个效果好的情况\r\n分析：如果loader一次加载太多，可能引起任务排队，因而并非一次性丢入队列是最优的，虽然整体吞吐量效果好。\r\n\r\n给磁盘减速也不能体现预读优势\r\n分析：\r\n     	2021-10-13 18:19:43.278935	f
1869	973	Issue	5	total row count 119994608 cost :18911 ms（不预读，压缩，文件系统预读调整为32kb）\r\n file read use 4113 ms\r\ntotal row count 119994608 cost :13242 ms（预读1线程，压缩，文件系统预读调整为32kb）\r\n file read use 74 ms\r\n \r\ntotal row count 119994608 cost :16205 ms（不预读，压缩，文件系统预读调整为256kb）\r\n file read use 1711 ms\r\ntotal row count 119994608 cost :13501 ms（预读1线程，压缩，文件系统预读调整为256kb）\r\n file read use 92 ms\r\n\r\n total row count 119994608 cost :17367 ms（不预读，不压缩，文件系统预读调整为32kb）\r\n file read use 4545 ms\r\ntotal row count 119994608 cost :13299 ms（预读，不压缩，文件系统预读调整为32kb）\r\n file read use 109 ms\r\n \r\n \r\n total row count 119994608 cost :13930 ms（预读，不压缩，文件系统预读为256kb）\r\n file read use 0 ms\r\ntotal row count 119994608 cost :14255 ms（不预读，不压缩，文件系统预读为256kb）\r\n file read use 1677 ms	2021-10-13 18:55:25.741124	f
1870	973	Issue	5	cache的意义在于命中的情况下，不需要从文件系统内存拷贝到应用缓存。更不需要读磁盘。	2021-10-14 09:05:30.510454	f
1871	956	Issue	5	对应的有4种人：\r\n1，没太多想法的人\r\n2，把他人想法作为自己想法，而未形成自己体系的人。\r\n   典型特点是逻辑不完善，容易卡壳\r\n3，有了自己想法体系的人\r\n   达到这个境界的人说话不会随便引用别人的观点，或者引用但会加以区别。\r\n   如果别人再引用观点，也能觉察，并引导他们进行独立思考。\r\n4，采用自然体系的人，即不断以现实修正自己的体系。	2021-10-24 07:02:39.851177	f
1909	1001	Issue	5	存储引擎的细节优化还是得用C搞，rust要搞也是不安全，跟c没啥区别。\r\n用C搞，比较麻烦的就是内存安全，以及并发问题。 这些可以通过包装来减少出问题的可能性。\r\n比如MemoryContext, session上下文的stack式内存管理，还有就是某些资源预分配的方式。\r\n\r\n并发除了锁带来的问题，还有各种cache，数据副本造成的并发一致性问题。\r\n作为持久化数据的在内存形态的代表的元数据，即dc尤其需要考虑一致性。\r\n\r\n数据库比存储另外不一样的地方在于数据类型，理解数据类型对于数据库各个方面的影响是个重点。\r\n数据类型的本质是什么？存储引擎需要在哪些地方感知数据类型。	2022-01-17 06:44:58.860286	f
1911	1003	Issue	5		2022-01-20 06:51:54.992893	f
1914	1001	Issue	5	其实这些不仅是存储数据库遇到的问题，所有涉及计算的系统都会遇到的问题。\r\n存储批量化，向量处理，计算也有。\r\n在cpu上，也得考虑数据类型，编码，并发，资源管理，cache等问题。	2022-01-21 10:39:55.341357	f
1916	972	Issue	5	先写一个软件，生成结构体依赖图。\r\n规则系统。\r\n\r\nhttps://blog.csdn.net/peterbig/article/details/74614949	2022-01-26 19:11:15.488016	f
1917	1005	Issue	5	数据组织：\r\n1，IO单位，压缩解压缩单位\r\n2，编码单位\r\n3，过滤单位，不解码过滤可能是跟CK性能差距的核心\r\n4，排序粒度\r\n\r\n	2022-01-27 12:36:13.202228	f
1919	982	Issue	5	算法本质就是做事的方法。\r\n通用的数据结构与常见算法是很多问题的解法。\r\n\r\n学习的关键在于通过学习这些算法，适当的变化运用于各种现实问题的处理中。	2022-02-09 05:47:41.604166	f
1921	981	Issue	5	辅助实体：\r\n在运行过程中辅助实现的实体。在实现结构后其生命周期就结束了。\r\n\r\n新的发现，DataSet结构设计的教训：\r\n作为自由实体，DataSet的内存资源依赖于扫描这是不合适的，限定了其存在周期不能超过扫描ctx。\r\n自由实体的生命周期应该是自行管理的，要么其跟结构实体相关，也存在可能是整个软件生命周期(跟malloc一样)。\r\n不应该依赖于辅助实体。\r\n\r\n	2022-02-09 09:29:50.393543	f
1873	976	Issue	5		2021-10-24 07:47:03.005657	f
1852	706	Issue	5	从动机和思维能力来给人的状态做划分。\r\n1，贪婪的人  2，恐惧的人， 3，成就型的人， 4，自由抉择的人。\r\n从思维能力来说：\r\n1，愚昧的人  2，知物的人， 3，知己的人(开始塑造自己的认知体系)， 4，无物无我的人。\r\n\r\n但根本的是人的心灵归属来看人：\r\n1，坠落的人，是痛苦的。 看见的是深渊与沟壑，陷于其中。 \r\n2，流浪的人，是麻木的，是无助的。 看不见灯塔，望不见高山。或心不在此。\r\n3，搏击的人，与命运抗争，努力前行。 劳心劳神，事倍而功半。\r\n4，逍遥的人，与海水同行，安之若素。 \r\n	2021-10-04 12:40:30.693565	f
1858	969	Issue	5	真相->数据\r\n逻辑->计算\r\n自由抉择->行为选择	2021-10-07 07:57:41.397254	f
1861	970	Issue	5		2021-10-10 18:50:13.916677	f
1862	970	Issue	5		2021-10-10 18:50:42.417453	f
1863	719	Issue	5	进攻：\r\n1，速度\r\n2，超出别人防守范围\r\n   这范围包括物理的和意识的。\r\n\r\n防守：\r\n1，积极提升防守范围\r\n2，限制对方的进攻\r\n   斜线摆脱。不起球。	2021-10-10 20:23:23.117226	f
1864	905	Issue	5	git submodule 使用git方式获取总是提示输入密码？(在ssh key已添加的情况下)\r\nhttps://stackoverflow.com/questions/21095054/ssh-key-still-asking-for-password-and-passphrase\r\n\r\n解决办法：\r\n1，启动ssh-agent bash\r\n2，加入key ssh-add.exe /c/Users/xier/.ssh/id_rsa\r\n就搞定了，根本上还是得搞明白这套机制\r\n\r\n\r\n	2021-10-12 06:44:10.216373	f
1867	968	Issue	5	但是不论是自然语言，还是图表，流程图都不如直接写伪代码来得更细节。\r\n所以推荐采用伪代码方式，然后可以通过伪代码来刷新架构图。\r\n而且从某种程度来说，这个伪代码如果能运行就更好了。可以有最基本的逻辑。\r\n从这种程度来说，如果编程语言本身能提供跨网络的虚拟能力就非常棒了 	2021-10-13 07:36:03.349005	f
1874	945	Issue	5	设计本质上就是系统化的认知。\r\n开发本质上就是用计算机语言表达认知。\r\n所以共识有多么重要	2021-10-24 07:51:26.154538	f
1866	968	Issue	5	*设计的根本：设计是对于一个系统的上层认知。\r\n这也是设计之所以难的原因。同时也揭示了设计方法的根本在于使用抽象语言来描述系统。*\r\n\r\n往往我们做一个软件通过可以用一句概括的话来描述，这是自然语言描述。\r\n或者用一个符号化的表达式来描述。\r\n设计就是对其展开的过程。\r\n\r\n设计的检查：\r\n1，实例的接口合理吗？行为属于该实体吗？\r\n2，实体行为的接口参数合理吗？是否看见了不该看见的实体？\r\n   从实体角度看，我看到了我不想看到的东西吗？\r\n3，实体关系合理吗？除了基本类型系统外能否做到单一依赖？\r\n   实体关系分为水平关系和垂直关系，最好是只有垂直关系。即A->B->C.	2021-10-13 06:53:53.099467	f
1878	798	Issue	5		2021-11-12 06:43:24.747019	f
1880	945	Issue	5	软件是一个系统，软件的主体是数据结构与算法。\r\n但是作为一个系统的软件还有工程部分，除了产出结果的软件，还有组织结构，共识与沟通。\r\n要成为一个系统问题解决者得从整体去看待问题。\r\n\r\n软件开发=数据结构+算法+系统工程	2021-11-12 06:50:43.787754	f
1881	798	Issue	5	1, 动作的子序列\r\n2，动作的对称性\r\n3，动作的并发性\r\n4，动作的持久性\r\n5，多个动作的一致性要求\r\n   可见性，可回滚性。\r\n\r\n动作之间存在语义一致性，以及因果关系。这种关系会对可见性，原子性产生要求。\r\n	2021-11-13 20:12:13.540501	f
1885	945	Issue	5	从自然语言或表达式，翻译成实体结构的过程就是设计。\r\n实体结构包含内存结构与持久化结构。\r\n\r\n注意这过程中很多实体是因为行为而引入的。\r\n比如写入时要能连续写入不轻易中断，因而在转换期间需要其他vgd继续写入。\r\n又比如要同时写入一个vgd，因而vgd需要状态控制。\r\n虽然都是写入动作，但是多个动作引入后有了不一样的场景，为了解决这些场景的问题\r\n而引入新的结构。\r\n\r\n语言描述-> 行为识别 -> 场景扩展 -> 实体设计	2021-12-06 06:22:56.430915	f
1888	945	Issue	5	Get your data structures correct first, and the rest of the program will write itself. —— David Jones\r\nhttps://www.zhihu.com/question/19710524\r\n这就是我对结构的理解。	2021-12-08 07:37:07.215873	f
1893	981	Issue	5		2021-12-08 10:37:03.979835	f
1889	981	Issue	5	https://www.zhihu.com/question/19710524\r\nGet your data structures correct first, and the rest of the program will write itself. —— David Jones\r\n这也是我对软件结构的理解，内存结构有了，行为就有了，并发控制就有了,持久化也有了。\r\n我们就不会再犯是人推动门，还是门有一个方法是转动的问题了，\r\n\r\n但是结构从何而来：\r\n1，对于现实实体的抽象\r\n2，行为对于实体的影响和约束。\r\n	2021-12-08 07:38:19.966138	f
1891	945	Issue	5	软件开发主要的点就是正确性，复杂性和性能。	2021-12-08 08:49:42.250572	f
1896	991	Issue	5		2021-12-08 16:32:15.836901	f
1898	991	Issue	5		2021-12-09 07:08:09.903239	f
1899	962	Issue	5	精细化管理，比如针对每个表，每列根据其特征选择更合适的编码。\r\n上层优化比底层优化见效更快。\r\n优化通常需要全路径综合考虑。比如像select count(*),有统计信息的时候跟扫描对比那就是降维打击。	2021-12-09 09:30:58.426517	f
1890	981	Issue	5	实体按生命周期分类：\r\n1，资源实体\r\n2，结构实体\r\n3，参数实体\r\n\r\n区别生命周期是为了方便管理实体。比如查询的结果和查询上下文本身的生命周期是可能不一致的。\r\n   经验教训：\r\n不可把不同来源，不同生命周期的实体捆绑在一起。否则后续出现嵌套与复用时发现还得拆开。	2021-12-08 08:31:04.960816	f
1901	992	Issue	5	结论还是能否考虑固定dict长度，在上层进行复用。	2021-12-13 06:40:15.620485	f
1903	996	Issue	5		2021-12-20 14:41:22.758002	f
1904	573	Issue	5	在个体的形式系统中建立外部概念体系，以及形式规则。	2021-12-22 19:42:49.778848	f
1908	1000	Issue	5		2022-01-11 19:11:40.246698	f
1922	942	Issue	5	软件架构的目的是为了使用尽可能少的人来完成一个系统。 当软件发展到开发效率极其低下时，说明架构失败了。\r\n程序员负责把事情做漂亮，架构师负责用最小的资源完成系统，还有一个是角色是确定该系统的思路，就是怎么做这个事，这通常是科学家或领域专家了。\r\n	2022-02-11 06:20:04.242676	f
1924	1010	Issue	5		2022-02-11 07:12:43.500491	f
1926	1009	Issue	5	被到处使用的底层模块，以及在软件中流通的公共结构都是比较难改动的。\r\n越是被广泛使用，越应该最非常好的抽象，抽象层度高->稳定性好->改动代价低。	2022-02-14 05:20:25.868067	f
2156	705	Issue	5	1,身体完全放松，脚步随时启动。保持蹬地感。\r\n   身体的心法居然与大脑如此一样。看来事物变化都是如此啊。一张一弛，满而亏。\r\n2，带动出引拍，出鞭打\r\n3，保持身体平衡	2022-10-23 12:22:03.620453	f
1875	976	Issue	5		2021-10-24 08:04:36.411307	f
1876	958	Issue	5	哲学的意义在于从宏观上认知世界。\r\n理清界限，描述问题。 哲学家就是一个仰望星空，描述这个世界的孩子。\r\n\r\n但人的认知边界或许决定了没有统一答案，也无法回答意义，存在等问题(参考维特根斯坦)。\r\n世界的边界 > 思维的边界 > 形式系统的边界 > 语言的边界\r\n\r\n人或许不得不承认有些问题是不可知的，就像死亡无法避免一样。\r\n但这并不影响生活，相反或许正是这样的设定才让人生旅途变得有趣。\r\n哲学让我们更好的看清这个世界。	2021-10-26 07:17:21.870817	f
1877	971	Issue	5	恐惧带来的效果就是需要面子，博得关注，寻求安全感等。\r\n这些都妨碍我们理性的看待事物，处理事情。\r\n作为系统中的人也在事情考虑范围之内	2021-11-12 06:42:03.214913	f
1879	798	Issue	5		2021-11-12 06:45:58.69972	f
1882	985	Issue	5	1，行为依附于结构，锁也依附于结构，因而结构锁就能限制行为。\r\n2，无法回滚的操作使用自治事务，如果多个动作中部分可以回滚，那么其他可能也需要回滚。\r\n   研究动作依赖的数据的读写关系，进而得到动作的因果关系，决定将哪些动作放在事务内，而另外的动作放在事务外。\r\n3，锁总是在内存中\r\n4，哪些数据该持久化？只有其状态需要跨越掉电，且无法通过其他数据恢复的状态需要持久化。\r\n5，哪些动作要记录undo？如果动作修改的数据具备因果性(即别人对其有依赖)，且无法通过其他动作回滚，就需要记录undo。 	2021-11-22 19:29:09.853286	f
1883	962	Issue	5		2021-11-27 13:22:38.860398	f
1887	962	Issue	5	存储性能优化\r\n内存优化：\r\n1，减少拷贝，减少数据转换，直接映射内存\r\n2，批量化\r\n\r\nIO优化：\r\n1，预读\r\n2，cache\r\n3，合并读，大块读\r\n4，过滤\r\n	2021-12-07 16:48:31.466207	f
1884	945	Issue	5	读写相同变量构成因果\r\n使用构成依赖，因果是更强的依赖。但是依赖又是必须的，没有依赖成不组织结构。\r\n冗余会造成不一致，但是提升了可靠性。这就是CAP理论的核心。\r\n约束限制了功能，但是有了保护。\r\n隔离会增加动作，但是降低了影响范围。\r\n对称貌似没啥副作用。\r\n文档是隐式约束，文档是使用自然语言对系统的描述。\r\n\r\n软件第一次运行在人脑中，这次至关重要，一切错误皆有可能。每个地方都很重要。\r\n分工的前提必然是隔离，而C语言并不满足隔离性，这是C的大弊端。\r\n\r\n现在就差一个问题：对于一个大型系统，如何实施设计-RPC-分解-接口定义-测试-开发-迭代过程。\r\n\r\n对于一个系统而言，每步都至关重要。但是其中设计与RPC步骤决定了大方向。走错了可能就难以回头。\r\n任何系统都需要一个足够好的基石，然后再此基础上生长。关系数据库codd，jim等奠定了基石。\r\n从另外一个角度说，如果一个系统只剩性能改进，成本节省，那这个系统就到了瓶颈期。缺乏理论创新。\r\n\r\n	2021-12-03 06:32:30.373368	f
1886	937	Issue	5	靠迭代和重构。实践是检验真理的唯一标准。\r\n而做事很关键的一点就是确定验收标准。	2021-12-06 06:25:45.347319	f
1892	991	Issue	5	感谢rust对于对称性的理解。\r\n凡是隐含动作都应该显示化，最好是利用对称的方式自动调用，这就是rust的解决之道。	2021-12-08 08:50:41.965806	f
1894	981	Issue	5	https://zhuanlan.zhihu.com/p/31391535\r\n\r\n从实体关系角度看，软件依赖的根源在于实体依赖。尤其是结构实体。\r\n结构实体的依赖决定了函数依赖。	2021-12-08 10:38:59.062038	f
1895	991	Issue	5		2021-12-08 16:28:33.39404	f
1897	991	Issue	5	公理：\r\n1，所有意识之外的因果关系都很可能成为bug。\r\n2，测试只能证明程序有错误，而不能证明程序没有错误。\r\n3，越早发现并修复问题，代价越低。\r\n	2021-12-08 18:10:16.129795	f
1900	945	Issue	5	为啥你的代码一再修改：因为程序员通常不是面向用户编程。\r\n   面向用户编程要求接口优先，自顶而下，快速响应，积极沟通。\r\n\r\n面向客户恰恰是我们独立自主的表现，而一意孤行，以自我为中心则是在逃避现实环境。而成长需要我们去直面问题，经历风雨。	2021-12-12 07:57:29.628932	f
1902	934	Issue	5	一切都没有了标准，只是事物本身有差异。\r\n一切需由自己去赋予其意义，自己根据个体目标作为选择。\r\n这就是自由，没有了恐惧，但我们并非没有任何约束。\r\n天行健，人会面对各种困难。人要做的是善于利用自己的所拥有的，去解决困难。\r\n\r\n竞争必然带来敌人，斗争意味着有复仇。	2021-12-20 07:51:12.000585	f
1905	151	Issue	5	爱因斯坦：西方科学的发展是以两个伟大的成就为基础，那就是：希腊哲学家发明形式逻辑体系（在欧几里得几何学中），以及通过系统的实验发现有可能找出因果关系（在文艺复兴时期)。\r\n亚里士多德起头的逻辑学至关重要。也是认知的起源。\r\n	2021-12-22 19:46:08.801201	f
1906	998	Issue	5		2021-12-24 06:59:58.027288	f
1907	984	Issue	5	阿德勒之路：\r\n始终焦距于自己当下的目标上。这目标并非需具备普遍的意义，只有一个人的意义也可以。\r\n心理问题本质上是人采取了不正确的处理方法引起的。	2021-12-24 10:42:58.353742	f
2157	1132	Issue	5		2022-10-25 08:00:30.326566	f
1910	1001	Issue	5	1, 存储技术-资源自己管理，增强系统的鲁棒性。防止内存碎片化，磁盘碎片化。\r\n2，存储技术-列存核心向量化计算，考虑的是向量与单值，向量与向量之间的计算优化。\r\n3，针对具体场景的优化，分化。这些就是在考虑怎么更好的做事情。就是算法的精髓。\r\n4，存储技术-buffer管理，作为内存结构的核心，buffer如何lru对性能至关重要。\r\n5，存储技术-数据类型，类型的本质是计算规则，存储规则。不同的语义附加于类型之上。\r\n                      不同类型存储组织方式，存储效率，计算效率都不一样。\r\n\t\t\t\t\t  存储引擎如果不做数据过滤，是不必感知类型的，只要知道物理存储长度即可。\r\n6，存储技术-数据对齐，持久化数据应该避免由编译器对齐。\r\n7，存储技术-字符编码，字符集的字典序，英文只是刚好跟utf8序一致，但其他文字不一定。\r\n8，存储技术-dc\r\n9，存储技术-列存结构	2022-01-19 07:20:13.615416	f
1912	1001	Issue	5	c的本质是其是硬盘数据的副本，凡是副本就涉及一致性问题。\r\n举例：\r\n1，判断segment可见性\r\n2，拿dc\r\n3，查询\r\n这个逻辑就有问题，可见性判断完，可能dc被人刷了，本来应该扫老的segment，结果直接扫到新的segment。	2022-01-20 07:02:43.91609	f
1913	1001	Issue	5	资源需要考虑是否膨胀，能否收缩，是否碎片化，分配效率等等问题。\r\n	2022-01-21 10:32:02.359933	f
1915	1001	Issue	5	物理类型侧重存储属性，数据的存储属性主要就是长度。运算就看包含哪些了。比如简单的同类型比较运算物理类型也可支持部分。\r\n逻辑类型就涉及更多了，比如各种时间函数，类型转换等。\r\n	2022-01-21 11:59:00.726055	f
1918	984	Issue	5	2022读K神文章有感\r\n在过去的2021年中，个人遇到的挫折不少。幸好我已不是从前的我。\r\n不会被别人和困难压死。只要压不死，困难就是改变自我的机会。\r\n\r\n人应该去理解社会是如何运转的\r\n人的命运应该掌握在自己的手上，这是显然的，除非是小孩。\r\n这是独立自由的必经之路。有些人自己看不到自己的幼稚和愚昧。\r\n独立自由的好处在于不受压制，拒绝愚昧无知。\r\n\r\n人要做事这是显然的，但是如果没有对于基础框架的理解，怎么做好事呢？\r\n别人的镰刀都架在那里了，还天真的幻想有明君，侠客。真他妈sb，而且还傻了那么多年。\r\n所以2021年的困难是我自找的，我认了。\r\n\r\n有什么比不让你知道真相还恶的？还他妈天真！\r\n凡涉及最大利益的地方，国家队权贵必然介入。然后把民营资本赶到更艰难更需要开拓的地方。\r\n所以互联网，民营房地产商都会被搞掉或打压。对于打工者而言只是去谁家卖长工的区别。\r\n所以创业就是搞一波钱滚蛋，而且还得和上面搞好关系钱才能到。\r\n\r\n权贵也要抓紧时间变现，否则他们自身难保。\r\n\r\n这种体制的根本性就是人治，精英权贵。没有自由，当然也不会出现科学的繁荣。\r\n哪怕再怎么呼唤基础科学，也出不来啊，没有自由真相个人可能正确的世界观都建立不了还谈啥科学。\r\n\r\n所以科研成果在国内是绝对的稀缺资源。\r\n\r\n没有大架构的认知，做事必然受阻。\r\n\r\n\r\n自己的定位\r\n个体打工者，小白领就是被收割最严重的群体，相当于以前打长工的，生老病死都是自己的事。\r\n而且会被其他打长工的排挤。\r\n\r\n这种环境下去拼命工作不是sb么，策略只能是适度工作，提升能力，有机会捞一把。\r\n好在生活不仅仅是经济方面，还有体育，文化，科学等等。\r\n\r\n打长工的只能不断提升自己做事的能力，然后寻找机会构建自己的堡垒或庄园。\r\n任何时代都需要有能力的人处理问题，所有人都有约束。\r\n\r\n对系统的认知：\r\n系统中的既有关系就是数据结构。\r\n系统中进行的事物就是算法，行为。\r\n有的行为不会改变结构本身，但有的行为会。\r\n系统从出生就开始了分化过程，帝国如此，公司如此，软件也如此。\r\n\r\n系统内个体局限性：\r\n只能基于当下结构行事，幻想，错误的认知必然会导致自己的行为受阻。\r\n个人不认知到自己其实没那么受关注，别人并不了解自己等就会遇到一些问题。\r\n没有人针对你，其实压根就没人关注你。除非你扼住他们的喉咙，骑在他们身上拉尿。\r\n\r\n怎么读历史：\r\n有了上述背景后，我们知道其实古人与现代人是一样的，他们缺乏科学知识，但是并不妨碍绝大部分事件的开展。\r\n比如梳理人之间的关系，目的论，计划，执行，推动等等做事的方法还是一样的。\r\n我们无法经历各种不同的场景，但是我们可以从其他人身上观察。就像观察一个细胞的一生，当然不是盯着一个细胞慢慢等。\r\n而是观察很多细胞，可能他们本身处于不同阶段。\r\n所以读历史可以学到几点：\r\n1，某些事情怎么做的案例\r\n  总结做事的逻辑，技巧。\r\n2，不同境遇下人可能遇到的问题，以及处理方法。\r\n\r\n  	2022-02-09 05:44:31.303602	f
1923	1009	Issue	5		2022-02-11 06:23:38.9004	f
1925	1009	Issue	5	1，接口中传递参数，要么拷贝，要么引用。\r\n2，接口中传递的结构，使用构成依赖，如果要在接口中传递参数应该非常慎重。\r\n   尽量保证该结构的独立性，以及不变性。结构即协议。\r\n3，编程中不应该去改变数据的类型或结构，而应该扩展他们。使用新的成员，或重命名。\r\n   如果代码不可重构式修改，说明设计有问题，意味着代价非常大。   	2022-02-14 05:18:47.626036	f
1927	1009	Issue	5	发散式修改，涉及多人的修改代价都是大的。\r\n依赖越多修改越难，人是一个重要因素	2022-02-15 13:37:18.970377	f
1929	1009	Issue	5	拓展：软件的五边形\r\n友好性\r\n算法竞争力\r\n稳定性\r\n架构良好性\r\n成本	2022-02-15 17:08:27.702572	f
1932	1011	Issue	5	5，clippy，format在ci构建中检查非常有必要。耗费时间很多。\r\n  共识应该由程序来执行。	2022-02-17 13:26:15.997106	f
1933	972	Issue	5	问题描述：\r\n     实际开发中，很多时间都是在处理格式，命名，规范之类的Review意见，这些属于团队内的共识，或者说规范\r\n        但是由人来执行会耗费不少时间。能否提供一个工具来搞定这些问题，提升效率。\r\n     另外除了这些浅层次的，还可以针对代码写法，结构定义，头文件顺序等进行规范，甚至对代码架构，以及其坏味道做出提醒？\r\n\r\n     rust语言做了不少这方面尝试，看看能否基于clang搞出来。\r\n	2022-02-18 07:19:01.130279	f
1937	1011	Issue	5		2022-02-20 09:34:22.293327	f
1938	968	Issue	5	软件开发的隐喻：\r\n就像一行人穿越森林，达到某个目的地一样。\r\n这其中有客户，有用户，各种人员。大家沿着不同的线路出发。\r\n先达到某个阶段点碰头，\r\n然后再达到另外一个点，\r\n最终在目的地汇聚。\r\n\r\n目的地明确，如何分队，每队的任务，如何推进协作等等一系列问题。	2022-02-21 06:31:43.691425	f
1939	945	Issue	5	为了更好的做事，我们衍生出一些结构，而结构本身也在分化改进。	2022-02-21 07:04:37.864283	f
1940	1018	Issue	5		2022-02-23 09:43:43.476946	f
1942	1019	Issue	5	几乎每个修改都需要设计，不然反复再所难免。	2022-02-24 16:00:43.698753	f
1943	1020	Issue	5	Clion安装非常简单，直接在远程桌面内打开terminal，然后执行clion.sh就可以了。\r\n	2022-02-27 16:32:47.3943	f
1947	871	Issue	5	另外perf是内存和cpu分析的神器，rust需加 "-a --call-graph dwarf"	2022-03-02 17:20:41.138111	f
1948	1011	Issue	5	linux下的Clion才香，CPU占用低很多。很爽	2022-03-02 20:05:50.236204	f
1950	912	Issue	5	火焰图的空白部分意味着什么	2022-03-06 08:04:11.55264	f
1951	912	Issue	5	perf命令，rust需加 "-a --call-graph dwarf"	2022-03-06 08:05:48.814289	f
1954	996	Issue	5	存储结构介绍： https://zhuanlan.zhihu.com/p/398187357	2022-03-07 20:28:13.525885	f
2027	984	Issue	5	人应该回到构建自我的世界这个目标上来，我们想要构建的自我世界也是我们的意义所在。\r\n但这个世界的构建可以随心所欲，但是这世界如果没用很好的净化重生的能力，那么或许这个世界就会很快坍塌，而我们一不小心也将被囚禁于其中。\r\n\r\n这也是我们需要知识的原因，你的世界丰富了，还有什么比这更有意义更加美好的事情么。	2022-06-06 17:16:46.994051	f
1959	945	Issue	5		2022-03-13 19:42:34.542	f
1960	1013	Issue	5		2022-03-13 19:52:20.995456	f
1966	1017	Issue	5	对象编程的一个形象比喻：比如人推门，用结构编程可能写一个方法pushDoor(person, door)\r\n而对象编程的方法是在person的intoRoom方法中执行了door.revolve(支点，力度)\r\n\r\n核心区别是什么？ 明确了行为是归于对象的。这样还有个好处区分了意图和行为。 意图是抽象的，但编程基于的是行为。	2022-03-20 06:48:53.366374	f
1969	950	Issue	5		2022-03-20 07:22:49.382715	f
1970	950	Issue	5	并发性：动作被进程，多线程执行\r\n原子性：多个动作的关系，即满足同时发生或都不发生。\r\n一致性：这里指行为一致性，指的是读所能看到的数据的版本，在实体副本层面看还有数据一致性。	2022-03-20 07:28:19.582161	f
2028	1068	Issue	5		2022-06-09 07:29:17.8761	f
1971	945	Issue	5	在实体森林中算法被弱化，在群体中算法被强化，某种意义上算法就是在做群体关系计算，所以这里有时间复杂度和空间复杂度概念。	2022-03-20 07:29:45.046569	f
2031	1067	Issue	5	starRock设计的优点：\r\n1，可以严格控制页面大小。按行对齐的通常难做到这一点。\r\n2，segment可以很方便的一次性读取。\r\n  如果每列都可能很大，那么就难以一次性读取，如何优化io就成了问题。\r\n  segment限制128MB，可以在过滤后，一次性完成所有列的读取，然后解压是另外一个步骤。	2022-06-15 14:32:25.575467	f
2032	1073	Issue	5	read_ahead_kb会限制buffer io的大小，导致avgrq-sz超不过256.\r\n可通过echo 1024 >  /sys/block/dm-2/queue/read_ahead_kb  或 blockdev --setra /dev/dm-2 来设置。\r\n注意不是在主盘上，分区盘得设置。	2022-06-16 15:19:40.385581	f
1930	1008	Issue	5	关于接口中结构的位置：\r\n\r\n1，跨组件公共结构\r\n   包括协议，基础子模块，组件间接口结构等\r\n   可以独立组件\r\n2，模块间公共结构\r\n   组件内模块间公共结构，模块内的公共子模块\r\n   公共子模块\r\n3，模块内公共结构-对外\r\n   公共子模块\r\n4，模块内公共结构-对内。\r\n   内部公共子模块\r\n\r\n公共结构的使用方式：\r\n1，引用\r\n   要确保生命周期是合适的\r\n2，转移\r\n   内存管理要一并处理，交给其他模块。这要求结构具备可转移性。\r\n3，复制\r\n   复制耦合最低，但性能最差。   	2022-02-17 06:55:13.104308	f
1934	1009	Issue	5	如果将软件看成是实体图或树，我们就明白了设计模式的本质就是在研究如何组织实体更合适。\r\n而重构的本质就是以一种建设性的方式调整实体图或树。\r\n\r\nMatin Fowler给出的重构的目标: 1. 不改变软件可观察行为 2. 提高软件可理解性 3. 降低软件修改成本 	2022-02-18 07:28:57.12504	f
1935	1012	Issue	5	而个体最好的找到自己搭建平台的方法，或者在一个高效平台上工作，这样才能节省自己的时间。	2022-02-18 07:35:15.498892	f
1928	1009	Issue	5	软件架构设计就是一个不断分解分化的过程。\r\n从一句话扩展成一个有向无环图。或者一颗树。在这颗树的顶端是变化最快的，越往下应该越稳定。\r\n组件是图分割技术，模块也是图分割技术。\r\n\r\n软件设计的目的：达到软件修改，维护的代价最小化。\r\n软件修改维护的成本来自于：\r\n 1，沟通，需要多人修改的代价比单人多很多。\r\n 2，重写，垃圾代码会重写无数次\r\n\r\n架构就是分解的艺术，也是划分边界的艺术。\r\n分解原则：\r\n1，单一职责，不同职责的人负责的模块应该分开。\r\n2，接口隔离原则，如果使用者的用法差别很大并可以分割，那应该进行分割。\r\n3，开闭原则，不应该随便修改类型，而是扩展它。重构也是如此，没有修改类型的重构方法。\r\n4，依赖反转原则：依赖的接口本身作为公共结构而存在，然后利用公共结构稳定性抽象原则来处理。\r\n   因此凡是无法作为公共结构而有存在极大可能性的地方，应该进行抽象。如不同的编码方法，压缩方法等。\r\n5，何时引入中间层，要知道软件中的所有移植，扩展性问题都可以通过增加中间层来解决。\r\n6，哪些东西可以作为插件而存在。\r\n\r\n分解的制约因素：\r\n过大的分割依赖关系可能理不清楚。\r\n过小的分割会增加模块数量，引发规模问题。	2022-02-15 16:58:45.060455	f
1944	1020	Issue	5		2022-02-27 16:33:26.146178	f
1936	968	Issue	5	为啥模仿很容易？\r\n因为最底层的架构已经有了，有人趟过了。\r\n就像程序员在处理图的细枝末节，架构师要抉择的是树干，科学家要抉择的是树根，企业家要搞的是森林，国家要搞的是生态。\r\n难易程度一看便知。	2022-02-20 08:48:57.359831	f
1945	984	Issue	5	有一天我不在以自我为中心看待世界。\r\n不再觉得自己内心的平静和安宁是首要的。我接受当下的世界，不再妄图回到过去。\r\n我收起自己的清高和傲慢，尊重自然，以及他人。融入社会和组织。\r\n\r\n做事也是一样，总想按自己节奏来。慢慢磨\r\n	2022-03-01 06:58:58.004002	f
1946	871	Issue	5	1，磁盘\r\n  预读，预读的上限应该是磁盘性能\r\n2，cache\r\n  尽可能高的命中率，要考虑大量非热数据冲击。\r\n3，内存拷贝\r\n  内存管理是性能的灵魂，zero copy技术。\r\n4，批量化\r\n  直接成几十，百倍的减少\r\n5，并行	2022-03-02 17:18:14.772402	f
1920	968	Issue	5	软件分解分化设计法。\r\n分解是指在某个层次需要某个功能，这是从最初的语句逐步分解而来的。\r\n分化是指某个实体会有很多有差别的不同类型个体。\r\n\r\n比如一个读写器。\r\n从分解角度来说，可能需要编码，压缩，投影，过滤，缓存等功能。\r\n从分化的角度来说，数据分为不同类型的列，列可以有各种不同类型的编码，压缩方式等。\r\n\r\n网络，分布式可以看成把部分组件分离到了。其实并不影响整体的逻辑视图。\r\n而且我们明白了组件间接口的含义，其应该作为组件间公共结构而存在。只不过以协议方式而存在。\r\n\r\n持久化，持久化也并非设计的重点，任何持久化的数据必然有其内存形态，持久化是内存形态的扩展。\r\n        持久化解决的是掉电问题。\r\n\r\n架构设计：架构就是树干，一方面分解粒度更大些，另外一方面可以不考虑具体的分化。\r\n          但有了架构大概长成啥样也有了感觉，而这部分代码估计20%都不到。\r\n需求：是关于目标的描述。\r\n\r\n	2022-02-09 09:23:07.937049	f
1941	1018	Issue	5		2022-02-23 09:44:49.044587	f
1949	1018	Issue	5	越多人参与代价越大，复杂度越高\r\n问题越晚发现代价越大\r\n越能从大处设计把握整体，减少返工，效率越高\r\n目的论：没目的达不到，推论：引牛喝水，但水得牛喝\r\n	2022-03-04 16:46:58.691415	f
1953	1023	Issue	5	最好的模型是单个文件足够大，每个并发都像在串行？	2022-03-07 20:27:31.763203	f
1955	1013	Issue	5	即为分化设计出接口。这些接口应该明确完备，指导后续分化	2022-03-09 19:21:26.525777	f
1956	818	Issue	5	第一步永远都是启动，启动的要义是打开向下发力，从而获得移动力量。\r\n第二步取决于是什么球，可能是垫补，也可能是并步，取决于人和球的方向。\r\n       只有右侧及右前方是直接并步，其他垫步或蹬转步(也算垫步吧)或终止步。\r\n第三步如果前面有垫步，第三步就是并步或终止步。\r\n第N步交叉步或终止步。\r\n\r\n终止步:低手位是弓箭步，高手位是确认步。\r\n\r\n垫步的目的是改变方向，因为并步只能平移(螃蟹步)，交叉步只能前后(指相对身体的正前方)  龙虾步。\r\n\r\n没了，步伐就是上述流程。\r\n	2022-03-10 06:52:31.346056	f
1958	945	Issue	5		2022-03-13 19:25:30.052076	f
1957	981	Issue	5	软件内的自由实体，运行实体如果需要资源应该依赖于结构实体。在结构实体上处理并发问题。\r\n资源是由结构实体管理的。\r\n\r\n软件这样划分：\r\n1，运行实体。 包含运行资源，运行统计，运行日志等。需要处理并发问题。并发当然是资源管理手段，而非方法上的限制。\r\n2，会话实体，负责完成软件功能。\r\n3，公共实体，可以出现在其他实体树的树干枝叶上。\r\n4，参数实体，交换的数据，这部分与接口一起体现了实体之间的依赖。\r\n5，辅助实体，通常也作为参数，但也可能出现在其他地方。这类实体没有方法，仅仅是把多个变量包装起来。\r\n             其名字通常是cfg,option,env,assist，ctx等	2022-03-13 18:33:21.469678	f
2033	1074	Issue	5		2022-06-19 20:16:15.933645	f
2034	1066	Issue	5		2022-06-19 20:19:19.973828	f
2036	1074	Issue	5		2022-06-22 06:42:25.971394	f
2180	1139	Issue	5	行为一致性：\r\nhttps://zhuanlan.zhihu.com/p/559916992\r\n\r\n这里讨论的一致性与“读取时元数据和数据强一致”这种有明显的区别。\r\n读取时不论当前发生了什么，都不允许元数据与数据不一致，否则就存在逻辑错误。	2022-11-09 17:31:10.192844	f
1962	1013	Issue	5	概括一下：\r\n开闭原则 教我们应该怎么写代码，怎么重构代码。\r\n依赖倒置教我们怎么处理不同层次接口的关系。\r\n里氏替换原则教我们如何进化。也可以叫进化原则。\r\n单一职责，最小知识，接口隔离都是教我们如何划分模块。\r\n\r\n	2022-03-13 20:15:52.610791	f
1963	1019	Issue	5	分解是水平方向的，分化是指纵深的。\r\n还有一种是进化，是升级，一类事物中出现的新品种。	2022-03-13 20:18:52.03929	f
1964	1026	Issue	5		2022-03-13 20:35:57.574723	f
1965	1004	Issue	5	顺序是时间，其中存在依赖的就是因果。\r\n使用产生依赖。\r\n读写是因果关系	2022-03-19 06:51:09.701314	f
1967	945	Issue	5		2022-03-20 07:18:34.952832	f
1968	942	Issue	5	架构整洁之道，一书就讲清楚了	2022-03-20 07:19:47.39499	f
1972	1027	Issue	5	变量或函数声明：声明是空的，只是告诉编译器就有这个类型存在。\r\n定义：定义是实体，是真有代码，变量真分配空间的。\r\n\r\n1，首先如果函数或变量定义在头文件，那么就会产生多份。\r\n2，static是让函数局部可见\r\n   这样可以推论：如果函数在文件头，不加static，那么就会报重复定义。\r\n                 如果函数在头文件，但是不使用，就会报未使用的函数。\r\n2.1 static修饰变量则其存储是静态的，其作用域是局部的。\r\n    推论：不可extern static变量\r\n3， inline修饰函数的作用在于内联，即有宏一样的效果。并且不会出现上述错误，即不存在定义而未使用，因为没有函数实体。\r\n\r\n4， extern关键字用于声明，在没有直接include的情况下，也可以声明变量或函数，让编译器在后续链接时再去查找其定义。\r\n    另外extern关键字还可以定义声明风格， extern c。\r\n\r\n5， 有类似效果的还有前置声明\r\n    typedef struct StXX XX; 这里也不需明确定义StXX是什么结构，反正前置了。\r\n    前置声明解决C语言中没有可见性控制的能力。\r\n  \r\n\r\nC里面声明和定义搞得有点混乱：\r\n1，extern和前置声明这种虽然带来编程得方便，但也使得依赖关系混乱。\r\n2，关键词有多功能，搞得理解复杂度提升。\r\n	2022-03-23 05:41:28.331521	f
1961	1013	Issue	5	依赖反转原则：接口不依赖实现，实现依赖接口。不稳定的依赖稳定的。\r\n        推论：自由结构以及公共模块是非常重要的，应该具备稳定性。\r\n              软件的架构，接口，公共结构和自由结构都应该都核心程序员来编写。\r\n              而具体实现，以及实现的变种可以由中初级程序员来编写。\r\n\r\n单一职责原则：软件模块应该按参与的角色来划分模块，其理论基础是软件的可变性或者成本在很大程度上取决于沟通的人的数量。\r\n              一旦人数增加则效率必然降低。\r\n              另外从侠义上理解，\r\n                      一个函数应该只执行一个动作，\r\n                      一个变量应该只有一种含义，\r\n                      一个关键词只区分一种维度(比如c的static就很迷惑)\r\n最小知识原则：同上，需要沟通的信息越少，效率越高。\r\n接口隔离原则：同上，不同功能或使用者的接口可以分开。\r\n\r\n\r\n开闭原则： 开闭原则确定了写软件的基本原理，修改代价昂贵，软件应该以扩展的方式进行变更。\r\n           由于可以演化出很多细则：1，类型和结构都应该含义明确经得起推敲，不应该是可有可无，含义不明确的。\r\n                                   2，函数应该有很好的名字，否则可能边界不清。很可能后续会修改。\r\n                                   3，不应该改变类型或减少结构体成员，可以增加。\r\n                                   4，不应该去掉函数，或去掉函数参数。可以增加参数或增加新的函数。\r\n                                   5，可提炼子函数或子结构当他们生长的时候，这是重构，符合开闭原则。\r\n                                   如有违背，说明之前设计不好。\r\n\r\n\r\n\r\n	2022-03-13 20:12:51.998492	f
1976	1030	Issue	5	不必通过霸道压制人，而是通过天道让人保持痛感，实现个体的自强不息。\r\n不用人来管理，人是平等的。直接让人与运行机制打交道。这其实也是区块链的思想。也是扁平结构的道路。\r\n流程也是自动运行，可能代码和设计的review都是机器完成的。\r\n\r\n现在人不断变弱，靠皮鞭抽不出效果。	2022-03-24 06:54:20.980856	f
1979	912	Issue	5	火焰图可能显示不出堆栈，有2原因：\r\n1，文件权限不对\r\n2，release版本，没有带上述参数"-a --call-graph dwarf"	2022-03-24 07:47:14.633625	f
1981	1033	Issue	5		2022-03-31 18:44:04.645599	f
1984	985	Issue	5	并发问题把握几点：\r\n1，存在性保护,引用计数\r\n2，不加锁除非是只读的，其他情况都得考虑是否存在一致性问题。\r\n  volatile, atomic, spinlock各种锁搞起来。\r\n3，凡是可变且并发，都加锁。\r\n4，按层次加锁，锁是保护结构的。绝非行为。	2022-04-01 19:53:45.141094	f
1985	1036	Issue	5	软件公司的成果是一行行代码，这些代码可能是在压迫追赶下生产的。\r\n也可能在探索与追求中生产。\r\n软件工程师也是人，并且跟随社会在发生变化，体能，身体素质等等。\r\n适应其规律，提供合适其生产的环境才是最终出路。\r\n\r\n架构的目的难道不应该是让人的工作最小化，相关度最低化么。为何让人疲于交互？\r\n构建一个高度耦合，信息需要全流通的产品是多么难：\r\n1，相关代码有文档吗?\r\n2, 知识和隐藏的依赖能达成共识吗？\r\n\r\n加一个数据类型或一种结构变得异常复杂，到处都得适配且没人知道是否绝对全面了。\r\n	2022-04-06 06:52:04.159073	f
1986	937	Issue	5	当软件开发团队中有很多新员工时，那些隐含约束怎么办？\r\n靠人来执行么？	2022-04-06 07:39:18.507585	f
1990	979	Issue	5	自治事务使用场景：一系列在完成后不能进行回滚的操作。其中部分动作原本可以回滚，但是由于语义（会立即对其他线程可见）要求整体在完成后不可回滚。\r\n注意：如果这些动作本身就不可回滚，那么也没必要使用自治事务。通常这类操作必须保证原子性。否则系统可能处于语义不一致状态。	2022-04-08 11:55:54.365608	f
1992	1041	Issue	5	列表：\r\n1，控制文件\r\n2，redo\r\n3，undo\r\n4，事务\r\n4.1 undo\r\n4.2 savepoint\r\n4.3 lock\r\n4.4 事务状态表   \r\n5，表空间\r\n6，空间管理\r\n7，block/buffer\r\n8，持久化\r\n   双写，检查点\r\n9，heap\r\n10，btree\r\n11，字典\r\n12，系统表\r\n13, 分布式事务\r\n14，分区\r\n15，接口封装	2022-04-10 08:42:17.911896	f
1993	950	Issue	5	原子性有2层含义：\r\n1，动作要么成功要么不成功\r\n   这点要求失败的动作能够回滚， 或一定保证可以成功。\r\n2，动作涉及的实体不被其他动作影响\r\n   这点在并发资源冲突时必须有锁。\r\n\r\n可见性：\r\n1，不同动作下看到的实体是否一样？\r\n\r\n并发语义：\r\n1，动作只能由一个人去做。\r\n2，必须先做什么再做什么(内存屏障, volatile也有内存屏障效果)\r\n3，这个实体或状态其他人是否可见(volatile)\r\n\r\n   \r\n	2022-04-12 17:50:02.584235	f
1994	1042	Issue	5	https://zhuanlan.zhihu.com/p/33074506	2022-04-12 17:50:56.203983	f
1973	1029	Issue	5	等值比较优化，之前没有专门的等值函数。与< >等混在一起\r\n字典使用dictId做等值比较，不用转为sortId\r\ndict编码 in优化，超过一定数量等值，启动hash或排序，减少block值比较数量\r\nbit操作优化，直接使用异或运算\r\n验证tightly block效果， 肯定有效果，当满足的记录数非常少时，只用拷贝很少的列。\r\n验证dict和dict plan对比效果， plain更快，且浪费空间不大。当然rle比较可以优化\r\n在in优化过程中如果发现有条件不在字典中，可在mask中标记为无效。\r\n验证布隆过滤器\r\n从投影列中去掉完全下推的过滤列\r\n利用排序键\r\n\r\n跳过完全不满足的slice/block， 不在dict中的条件可以跳过。 \r\n验证启用simd           比较速度提升一倍   \r\ndict编码下使用bitEqXX函数进行比较并优化其中bit操作\r\n并行度线性度问题\r\nSQL8的CK结果比YashanDB差很多，重测CK数据\r\n分批排序写入slice，\r\nnumber性能优化\r\ncount(*)优化，比单字段慢非常多，CK两者接近\r\nselect count(*) from ads_upc_online_store_sales_detail WHERE district = '乳源瑶族自治县';\r\nselect count(district) from ads_upc_online_store_sales_detail WHERE district = '乳源瑶族自治县';\r\n	2022-03-23 07:40:17.859413	f
1974	1029	Issue	5		2022-03-23 07:58:49.789296	f
1975	1016	Issue	5	应该能识别日志中的语句不通顺。\r\n命名就按照主语 谓语 宾语风格来弄。\r\n\r\n某些写法就是不允许来倒逼设计合理化。	2022-03-24 06:39:48.033194	f
1977	706	Issue	5		2022-03-24 07:03:43.877787	f
1978	706	Issue	5	看一个一级的程序员，连通顺表达含义正常的句子都不会写：\r\n\r\n谢锐 3-23 21:18:09\r\n之前加的review意见你自己关下\r\n\r\n谢锐 3-23 21:25:09\r\n我加了一个意见 你看怎么改合适\r\n\r\n谢锐 3-23 21:26:09\r\n写代码 函数变量名字要起准确，句子要通顺\r\n\r\n谢锐 3-23 21:26:41\r\nspfSliceResetScanRange 为啥叫Reset\r\n\r\n谢锐 3-23 21:27:30\r\n推荐代码大全 私下多看下  \r\n\r\n叶子 3-23 21:32:05\r\n好的\r\n\r\n谢锐 3-24 09:25:37\r\ncompression type %u is not support in compression/decompression\r\n\r\n谢锐 3-24 09:26:00\r\n如果你再改进这个句子 你有哪些改法\r\n\r\n谢锐 3-24 09:26:49\r\ncompression type 10 is not support in compression/decompression\r\n\r\n谢锐 3-24 09:26:52\r\n比如这个\r\n\r\n谢锐 3-24 09:28:12\r\n定语  in compression/decompression 在表达什么？ 在压缩和解压的时候？ 这是废话吧 肯定是在压缩或解压的时候\r\n\r\n谢锐 3-24 09:29:05\r\ncompression type 10 又是什么？\r\n\r\n谢锐 3-24 09:30:25\r\nis not support 意思是不支持对吧，那这种压缩以后会支持吗？ 这种压缩具体是什么呢 \r\n\r\n叶子 3-24 09:33:38\r\ncompression typeId 10 is not implemented\r\n\r\n谢锐 3-24 09:36:44\r\n我会写 compression type is invalid  或者  compression type %s is not support/implemented  第二种前提是这是预期存在的类型，只是暂时没实现或没支持	2022-03-24 07:09:07.726854	f
1980	968	Issue	5	设计从何而来：\r\n1，需求分解，行为的分解\r\n1.1 实体分解，精细化管理\r\n1.1 未被展开的部分可能导致设计失败，或进度延期。\r\n\r\n2，环境约束，实体约束。\r\n  比如被持久化的实体需要放在哪里？\r\n\r\n行业经验说的就是这个。如果不理解行为的要求以及实体的关系，实体的细分就如同到一个陌生的地方。\r\n	2022-03-28 19:39:03.503555	f
1982	968	Issue	5	设计如果说是已经明确了要有什么动作行为，以及需要什么样功能的实体，以及决定实体之间如何配合才能有高级功能。\r\n    这样是一个启发式过程。不断有输入以及环境约束，使得软件成长为某个样子。\r\n    但软件设计似乎并没此限制，软件的设计或许只能说是发现。  \r\n\r\n\r\n这个过程与发明创造有根本性区别，在没有了解某个原理时，某些发明创造无法进行。\r\n\r\n设计仅仅是发明新的实体结构，以及配合方式，形成某种功能吗？或许从某种程度来说的确如此。\r\n    软件设计者是魔法师。如果将bit视为原子，可以说软件工程师创造了一切。但这一切终究只能表达现实世界的部分。\r\n    那由此来看软件从业者的能力是什么？ 就是明白某些子结构以及其具备的功能特性，并借助这些已有实体构造出更优或者更特别行为的实体的能力。\r\n   \r\n    这涉及几个方面：\r\n1，目前已经掌握的实体，知识与经验来承载\r\n2，实体组合配合以达成功能的技巧， 设计和编程能力\r\n3，保证正确性的能力， 测试以及验证能力\r\n4，管理能力， 大型实体多人目标分解，合作的沟通与协调能力\r\n5，执行能力， 目标达成的能力。\r\n\r\n    	2022-04-01 13:10:59.184116	f
1996	950	Issue	5	一致性：其实说的是副本问题，cache也是副本的一种特例。\r\n可见性：其实也跟副本有关系，历史版本也算一种副本的话。\r\n顺序性：这才是软件正确性的基石。软件中存在潜在的顺序语义要求，如果不满足则语义无法保证，正确性就无从谈起。\r\n原子性：也是语义要求，有些资源只能独占访问，中间插一腿就可能出错。	2022-04-12 17:56:17.789804	f
1999	910	Issue	5	1，dataset是一个传递结构，build过程和传递过程的接口应该分开。\r\n2，dataset上的列数据是有所有权的，即其应该拿到列数据对应的allocator，当然可以和dataset自身共享。\r\n3，公共数据结构应该支持传入allocator来构建，因为其生命周期存在可变性。尤其是返回给上层的公共结构。\r\n4，allocator本身应该由更长生命周期的对象来管理，当然不能由cursor，因为数据生命周期可能长于cursor。	2022-04-13 13:01:00.131086	f
2002	996	Issue	5	https://zhuanlan.zhihu.com/p/339464231	2022-04-28 12:35:40.925792	f
2037	881	Issue	5	三流程序员在解决问题，制造问题。靠体力,耐心，各种缩小范围，使用工具等来解决掉问题。\r\n二流程序员在做功能，确定接口，对接用户。靠的是系统工程学。\r\n一流程序员在思考解决方案，主要靠数学	2022-06-30 08:13:58.233496	f
2038	1078	Issue	5	很多人有思维误区，以为变强就得拼命努力，这与活泼的生活矛盾。\r\n因而去选择躺平。这并非高手状态，庖丁解牛的故事懂吗？高手是以极低的消耗来做成事的。	2022-07-01 07:37:30.357601	f
2039	984	Issue	5	问苍茫大地，何所处？\r\n天道人纲\r\n解释：天道即按客观规律办事，人纲即目的在于人的生机畅达，自然活泼，真诚善良，快乐。\r\n古代人搞天道就是靠觉悟，即观察，归纳，实践，总结。\r\n现代人可以靠数学，逻辑，归纳与实验验证等手段 --- 这就是方法论。\r\n\r\n没有方法的人就是经验人，能否成功全靠运气。	2022-07-03 12:38:02.620702	f
1987	996	Issue	5	Clickhouse常用命令：\r\nshow create table ads_store_sales_detail_new;\r\nset max_threads=1;\r\nselect getSetting('max_threads');\r\nset send_logs_level = 'trace';  查看执行计划。\r\n\r\n加索引：\r\nalter table ads_upc_online_store_sales_detail add index idx_district district TYPE minmax GRANULARITY 1;\r\nalter table ads_upc_online_store_sales_detail MATERIALIZE INDEX idx_district;\r\n\r\n\r\nCK的trace日志很棒，可以打出每个索引的选择率，以及最终查询的记录数：\r\n[AchorBase] 2022.04.06 17:21:12.621662 [ 22406 ] {67378888-26b7-41f4-adcf-198abd124b20} <Debug> default.ads_upc_online_store_sales_detail (SelectExecutor): Index `idx_district` has dropped 2220 / 3884 granules.\r\n[AchorBase] 2022.04.06 17:21:12.623856 [ 22406 ] {67378888-26b7-41f4-adcf-198abd124b20} <Debug> default.ads_upc_online_store_sales_detail (SelectExecutor): Index `idx_store_brand_name` has dropped 36 / 1664 granules.\r\n[AchorBase] 2022.04.06 17:21:12.625141 [ 22406 ] {67378888-26b7-41f4-adcf-198abd124b20} <Debug> default.ads_upc_online_store_sales_detail (SelectExecutor): Index `idx_sls_amt` has dropped 0 / 1628 granules.\r\n[AchorBase] 2022.04.06 17:21:12.626426 [ 22406 ] {67378888-26b7-41f4-adcf-198abd124b20} <Debug> default.ads_upc_online_store_sales_detail (SelectExecutor): Index `idx_unit_price` has dropped 0 / 1628 granules.	2022-04-06 19:01:16.442655	f
1988	194	Issue	5	XXX Design（XXX方案设计）\r\nJIRA：BEAS-XXX\r\n\r\n1. Overview（概述）\r\n说明本设计方案的背景、需求。\r\n\r\n2. Features（功能特性）\r\n说明本方案的功能特性。\r\n\r\n3. Interfaces（接口）\r\n列出本方案对外提供的接口、配置参数、API等。\r\n\r\n4. Limitations（功能限制）\r\n说明本方案对外的功能限制或约束。\r\n\r\n5. Detail Design（详细设计）\r\n方案设计的详细说明，包括但不限于方案选型、方案所依赖的技术/第三方组件的原理或背景介绍、关键技术点、方案折衷的考量、可靠性分析、兼容性分析。可以根据需要增删小节。\r\n\r\n5.1 Architecture（架构）\r\n说明方案的总体架构，优先考虑通过架构图进行描述。\r\n\r\n5.2 Data Structures & Flow（数据结构与流程）\r\n设计主要数据结构、工作流程、序列图等。\r\n\r\n6. Testcases（自测用例）\r\n设计开发人员自测用例（文字描述）。\r\n\r\n自测关注点：\r\n\r\n覆盖全面\r\n避免重复测试\r\n测试用例的可维护性\r\n自测用例设计方法：\r\n\r\n边界值\r\n等价类\r\n正交\r\n7. Document（资料）\r\n8. Workload（工作量）\r\n评估代码量KLOC、工作量（人天）。\r\n\r\n9. TODO（遗留问题）\r\n说明本方案遗留的问题或下一步需要解决的问题。	2022-04-07 14:22:17.657474	f
1989	984	Issue	5	从矛盾说起：\r\n我有一个矛盾，是像华为那种压迫恐惧式管理合适，还是一种活跃鼓励错误与激励式的管理合适？\r\n或者说是集权统治好，还是分权好？\r\n问题或许根本在于目的是什么？组织的目的在于生存并复制。\r\n其实从<中国是部金融史>来看这两种模式各有利弊。\r\n并且适用于不同时期。在有很多强敌的情况下分权模式弊端更大。\r\n极其容易被颠覆，在没有外敌的情况下分权更好。当然都是有度的。\r\n\r\n但管理其实只是组织的一个问题，组织最大的问题在于如何发展？\r\n不发展则矛盾就会堆积，生存环境恶化。如果找不到出路最终就是衰落与灭亡。\r\n这可能是大规模组织的发展规律。\r\n\r\n然后再看个人：\r\n个人其实根本上还是要提升自己的实力，要把自己的主张，自己的目标，\r\n对于发展的理解展现出来。然后走出自己的道路。\r\n	2022-04-08 05:51:28.338059	f
1991	1041	Issue	5	<pre>\r\nrule：\t\r\n\t必须前滚完成才能提供读写服务，因为要基于最新的版本来操作。\r\nrule：\t\t\r\n\t不论是自治事务还是普通事务，其内的动作要么能回滚，要么动作是完全无害的。\r\n\t\r\n\t自治事务与原子操作的区别：自治事务是事务，事务中的修改存在失败的可能性，其中的操作必须具备可回滚性。\r\n                             原子操作是一批必须一起完成的操作，由redo batch保证，不必回滚。\r\n    一个例子是自治新增了列segment以及segment meta页面，如果segment meta页面不具备回滚能力，那么就存在bug。\r\n    表面上看将上述操作包装成自治事务，然后在内存中使用锁不让多个修改操作触发创建列。好像也没问题。\r\n    但是故障之后呢？如果自治事务失败，但是segment meta已修改。\t\r\n\t\r\nrule：\r\n    事务可能因为资源不足或掉电或bug而失败，理论上运行到任何地方都可能挂掉。\r\nrule：\r\n    必须要有内部原子性操作，因为有些动作难以回滚。\r\nrule：\r\n    锁都是用来保护数据的，锁只会存在于内存中。 当然可以通过内存锁+资源行为控制扩展对外部资源的锁定。\r\n    一定要使用对应范围的锁，不可用错，也不可少用，混用。\t\r\nrule：\r\n    写写并发只能通过锁保护，读可以使用历史版本。\r\nrule：\r\n    在没有redo,undo的时候，原子性只能由系统提供。可以通过写多份的形式处理控制文件的一致性问题。\t\r\n</pre>	2022-04-10 08:36:42.232857	f
1995	950	Issue	5		2022-04-12 17:51:58.019029	f
1997	1043	Issue	5	关于Atomic与内屏屏障的关系的描述：\r\n\r\n作者：文礼\r\n链接：https://www.zhihu.com/question/24301047/answer/1193956492\r\n来源：知乎\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\r\n看了一下，觉得没有触及实质的回答，所以补充一下。这个问题的难点在于，很多人以为它们是限制多线程之间的执行顺序（包括我写这篇回答时的最高赞回答看起来也是这么认为的），然而其实不是。事实上，Sequentially-consistent ordering是目前绝大多数编译器的缺省设置。如果按照高赞回答的意思，那么多线程如果使用了atom操作，貌似就几乎变成了单线程（或者回合制）？真的吗？既然是多线程，那么线程之间的执行顺序就一定不是确定性的（你只能在某些点同步它们，但是在任何其它的地方是没有办法保证执行顺序的）。C++11所规定的这6种模式，其实并不是限制（或者规定）两个线程该怎样同步执行，而是在规定一个线程内的指令该怎样执行。是的，我知道这部分的文档（规定）以及给出的例子里面，满屏都是多线程。但是其实讨论的是单线程的问题。更为准确地说，是在讨论单线程内的指令执行顺序对于多线程的影响的问题。首先，什么是原子操作？原子操作就是对一个内存上变量（或者叫左值）的读取-变更-存储（load-add-store）作为一个整体一次完成。让我们考察一下普通的非原子操作：x++这个表达式如果编译成汇编，对应的是3条指令：mov（从内存到寄存器），add，mov（从寄存器到内存）那么在多线程环境下，就存在这样的可能：当线程A刚刚执行完第二条指令的时候，线程B开始执行第一条指令。那么就会导致线程B没有看到线程A执行的结果。如果这个变量初始值是0，那么线程A和线程B的结果都是1。如果我们想要避免这种情况，就可以使用原子操作。使用了原子操作之后，你可以认为这3条指令变成了一个整体，从而别的线程无法在其执行的期间当中访问x。也就是起到了锁的作用。所以，atom本身就是一种锁。它自己就已经完成了线程间同步的问题。这里并没有那6个memory order的什么事情。问题在于以这个原子操作为中心，其前后的代码。这些代码并不一定需要是原子操作，只是普通的代码就行。什么问题？比如还有另外一个变量y，在我们这个原子操作代码的附近，有一个y++那么现在的问题是，这个y++到底会在我们的x++之前执行，还是之后？注意这完全是单线程当中指令的执行顺序问题，与多线程风马牛不相及。但是，这个问题会导致多线程执行结果的不同。理解了这个，就理解了那6种memory order。为啥？因为我们对x进行原子操作的地方，锁定了线程间的关系，是一个同步点。那么，以这个点为基准，我们就可以得出两个线程当中其它指令执行先后顺序关系。比如，A线程先对x进行了自增操作。因为对x的访问是原子的，所以B线程执行该行代码（假设代码当中对x的访问只有这一处）的时间点必然在A完成之后。那么，如果在A线程当中，y++是在x++之前执行的，那么我们就可以肯定，对于B线程来说，在x++（同步点）之后所有对y的参照，必定能看到A线程执行了y++之后的值（注意对y的访问并非原子）但是有个问题。如果在程序当中y++紧靠x++，那么其实它到底是会先于x++执行（完毕），还是晚于x++执行（完毕），这个是没准儿的。为啥呢？首先编译器对代码可能进行指令重排。也就是说，编译器编译之后（特别是开了优化之后）的代码执行顺序，是不一定严格按照你写代码的顺序的。但是如果仅仅如此，也只是二进制（机器码）的顺序与源代码不同，还不至于导致A和B当中的指令执行顺序不同（因为A和B执行的是相同的机器码程序）。但是实际上，在非常微观的层面上，A和B也是可能不同的，甚至于，A每次执行到这里顺序都不见得一样。啥？...还真的是这样。原因在于当代CPU内部也有指令重排。也就是说，CPU执行指令的顺序，也不见得是完全严格按照机器码的顺序。特别是，当代CPU的IPC（每时钟执行指令数）一般都远大于1，也就是所谓的多发射，很多命令都是同时执行的。比如，当代CPU当中（一个核心）一般会有2套以上的整数ALU（加法器），2套以上的浮点ALU（加法器），往往还有独立的乘法器，以及，独立的Load和Store执行器。Load和Store模块往往还有8个以上的队列，也就是可以同时进行8个以上内存地址（cache line）的读写交换。是不是有些晕？简单来说，你可以理解当代CPU不仅是多核心，而且每个核心还是多任务（多指令）并行的。计算机课本上的那种一个时钟一条指令的，早就是老黄历了 （当然，宏观来看基本原理并没有改变）看到这里还没有晕的话，那么恭喜你，你快要理解什么是memory order了。所谓的memory order，其实就是限制编译器以及CPU对单线程当中的指令执行顺序进行重排的程度（此外还包括对cache的控制方法）。这种限制，决定了以atom操作为基准点（边界），对其之前的内存访问命令，以及之后的内存访问命令，能够在多大的范围内自由重排（或者反过来，需要施加多大的保序限制）。从而形成了6种模式。它本身与多线程无关，是限制的单一线程当中指令执行顺序。但是（合理的）指令执行顺序的重排在单线程环境下不会造成逻辑错误而在多线程环境下会，所以这个问题的目的是为了解决多线程环境下出现的问题。	2022-04-12 18:05:41.664512	f
1998	1044	Issue	5	但是正常按自然长度对齐，是落入同一个cacheline的，但是手动pack就没法保证了。	2022-04-12 19:26:38.618545	f
2000	984	Issue	5	终极目标：作为独立组织生存与发展。\r\n认知到战争形态的变化，暴力，权力，财富都是战争形态。\r\n\r\n组织形态：\r\n1，文化\r\n2，政治\r\n3，经济\r\n各方面都需要发展。\r\n\r\n1，选择变得更强，让自己的身体系统与大脑都变得更强。\r\n   选择变强并非因为达到他人预期，也并非向别人证明自己，也并非因为恐惧，是因为天道如此。\r\n   感受真实和热爱，真实可能是痛苦且残酷的。也有温馨和美好的。不虚荣不恐惧\r\n    \r\n2，以科学的方式变强。要形成自己的认知体系。以及训练计划。\r\n\r\n对比最初我目标没变，但是对于目标的理解更加深入了。\r\n从实体，关系，行为的角度去理解这个世界。\r\n\r\n组织的目标当然是生存和发展。只是生存发展会涉及一些列问题，政治，权力，经济，文化等等。\r\n由此可以去观察很多东西。\r\n\r\n科技推动的变革是组织发展最大的推力。	2022-04-17 14:47:19.754594	f
2001	962	Issue	5	另外就是预计算技术，还有近似计算技术	2022-04-26 06:22:49.01996	f
2014	984	Issue	5	人生当有目标，如同设计一样，没有目标的人生，就容易像低水平的选手拼积木一样，看到了什么就拿来用了，\r\n最终被陷入各种细节之中，沉寂于实现中的各种约束。有如在泥泞中挣扎，或躺平如自由落地。\r\n\r\n没有目标的人生，也很容易分不清自己和他人，没法独立行走，当然就理解不了合作的意义。\r\n\r\n人不应该被细节限制住，否则可能永远无法逃脱，我应该思考的是目标，去向哪里。 而不是想着当下如何我能到哪里？\r\n资源和当下状态不是软件设计的出发点， 人生设计也是如此啊。\r\n\r\n现在应该能理解房子资产对于个人而言应该只是积木而已，而非设计本身啊。\r\n人当追寻自己真正的目标啊。\r\n\r\n\r\n\r\n\r\n	2022-05-08 14:39:00.433199	f
2016	1056	Issue	5		2022-05-10 07:44:12.646701	f
1983	985	Issue	5	事务内涉及各种内存操作，有的是修改页面，有的是修改dc。\r\n修改页面的操作通常我们会记录redo/undo，而修改dc的操作不会。\r\n但是要注意：\r\n1,放在事务内的操作必须具备回滚能力，要么动作不具备副作用(其对其他事务没有任何).\r\n2，如果动作要求与事务一致，但是又放到事务外，那么除非这个动作必然成功。否则一致性就无法保证。\r\n   比如修改dc，必然要放在事务内，万一内存分配失败，表已经修改而dc未改就出现一致性问题。\r\n3，不能回滚的操作(且其一致性决定不必在事务内)，就必须在事务外。且这些操作必须执行，虽然不要求跟事务一起执行。\r\n   一种处理方法是在事务内记录purge op(就是要清理的动作)，事务成功，则由清理任务完成清理或\r\n   在事务的第二阶段清理(或另起一个事务)。 事务如果失败，这些一起回滚也没一致性问题。\r\n\r\n补充：元数据的一致性问题。\r\n如果元数据的读和修改会并发，那么同样涉及到一致性问题。\r\n由于回滚并不考虑元数据，因而元数据本身需要支持多版本。\r\n（存储结构中的元数据需要考虑这种并发，元数据本身存入系统表就提供了一致性读能力（读到的就是最新的））。	2022-04-01 19:49:16.625808	f
2005	1050	Issue	5		2022-04-29 17:54:04.327925	f
2006	945	Issue	5	实体行为的角度理解软件：\r\n1，算法本质上就是处理大量相同实体的行为。\r\n2，向量化本质上就是将一组实体进行运算。\r\n3，锁本质上在保护多线程下的实体。不要用锁保护行为，行为千变万化，通过保护好实体，然后分析行为来确定是否存在并发问题。	2022-04-30 04:45:37.057604	f
2007	984	Issue	5	这个世界属于那些能解决人们生存和发展问题的人，华为的奋斗者文化虽然解决了生存问题但并没解决发展问题，而且在一定程度上压制了生命的活力，让生命走向另外一种意义上的死亡。\r\n不要用燃烧自己生命的方式去生存。不要以损坏身体的方式让自己变强。 这样是走火入魔。\r\n\r\n如果你没能力让人们生存和发展，也别担心，总会有人继续这条路。\r\n\r\n践踏弱者是因为你还不够强。但人的生机畅达与人的懒惰享乐，以及那少有人走的路该如何看呢？\r\n\r\n如果说华为是通过体制让人克服自己的懒惰，从而保持组织的成长。\r\n\r\n\r\n我们选择自强不息是因为热爱，天道如此啊。 柔弱者被桎梏者所伤，而强者解除桎梏。\r\n	2022-05-01 23:03:02.774874	f
2004	968	Issue	5	功能设计的本质是要打通系统中的所有实体以及行为。\r\n怎么讲：\r\n1，系统中存在非常多的实体，这些实体本身有区别，可以分类。比如之前的参数实体，自由实体等。\r\n   还会分层，有些实体属于模块内，有些是其他人提供的。\r\n   实体关系搞不对，存在反向或不合理依赖，从而导致软件复杂度上升，稳定周期拉长。\r\n   比如关系is a, 强行把实体1 套入 实体2的类型，最终可能搞得很多行为混乱。\r\n\r\n2，每个实体都有行为，而且实体的行为依赖于其他实体的行为。\r\n   所以要论证实体的行为能否被其他实体所支持。\r\n   不然就会出现设计了一个实体行为，结果发现相关实体没法支持的情况。比如表的部分要truncate，但是其子结构无法支持truncate（由于存在与其他子结构的关系）。\r\n3，实体以及行为约束的传递性。\r\n\r\n4，行为的对称性，幂等性\r\n   幂等性是指行为可以重复执行，其效果与执行一次是一样的，即具备防范重复执行的效率。	2022-04-29 08:27:18.565513	f
2008	985	Issue	5	并发的彻底研究\t\r\n\t\r\n并发的三个问题：\r\nhttps://zhuanlan.zhihu.com/p/64988344\t\r\n\r\n加锁可以解决上述三问题\r\n\t\r\n加锁三要素：\r\n1，范围\r\n   实体通常都是树状存在，有些动作影响范围广，需要在上层加锁。\r\n   有些范围小，需要在底层实体加锁。\r\n   比如表和记录，删除或truncate表的行为会影响在记录上的行为。\r\n   因而需要在插入时对表加共享锁。\r\n   即对于树状的实体系统，我们要搞清楚当前实体上的行为对于上层实体的访问模式，\r\n   从而决定是否需要加锁。实体行为分析法可以分析清楚锁问题。\r\n   \r\n2，时间\r\n   要达成原子性语义所需的时间，事务锁还是latch，还是短暂spinlock。\r\n   \r\n3，对象\r\n   对实体加锁而非行为。\t表锁，行锁，页锁等。\r\n   锁是加在内存实体上，而非持久化实体。\r\n   比如想保护一座山，则锁应该在山上，而非路上。\r\n   应该明确的是不准上山，而不是说不准走这条路。\r\n   \r\n4，实体的多版本\r\n   多版本可以解决只读行为的并发问题。\r\n   但是要注意相关的坑，有些动作没法使用老版本的对象。\r\n\r\n5，实体复用\r\n   就是实体已经改变了，这时要注意不要把锁加载错误的对象上。\r\n   通常来说已经加锁的实体是不可复用的。\r\n   引用的时候也需要注意。如何保证引用还是曾经那个实体？   \r\n\r\n实体行为分析法：\r\n1，要理清实体关系，以及所有行为。\r\n2，搞清楚行为之间的并行性，即行为可能存在对实体树的操作及相互影响。	2022-05-02 13:59:22.091777	f
2009	985	Issue	5	事务内操作的常见问题：\r\n1，应该回滚的没提供回滚能力。\r\n2，没法回滚的操作放在了事务内\r\n   比如删除目录，清理锁。应该放在提交后的清理步骤。\r\n3，应该考虑多版本的没提供多版本读能力\r\n    常见的有元数据多版本。\r\n4，内存操作的回滚能力\r\n    内存操作失败了不回滚，导致内存与持久化不一致。\r\n5，应该放在原子操作，或自治事务的动作没放在一起。而引起一致性问题。  \r\n\r\n原子性即要求全部成功或全部回滚，没有例外，包括内存操作和持久化操作。\r\n多版本，元数据和数据都要考虑。 	2022-05-06 15:33:35.049253	f
2013	968	Issue	5	设计必须自顶而下，即先有大框架才有小事物。 先有抽象后有细节。\r\n就像必须先有what，有了定义，才能继续问how，why，when，where之类的。\r\n对于设计很多少书介绍设计是什么？ 上来就是设计原则，设计模式这类 how相关的介绍。\r\n\r\n《记一次失败设计的案例》\r\n在xxDB的lsc表引擎的开发上，上来虽然搞出了一个vgd概念，用于表示前端用于少量插入缓存的结构。\r\n但是代码实现的时候，却没有按顶层概念来。模块混乱，甚至分不清楚那些是vgd的能力，vgd有些功能在spf_meta（spf的元数据segment）中实现，有些有独立出来了。\r\n即变成有概念却没有边界，想划个模块图都画不出来。虽然vgd的元数据页面vbu存在spf元数据segment，但是spf_vbu显然不应该和meta放在一起。\r\n*即存储或资源上的依赖不应该影响模块依赖关系，存储或资源的关系是具体细节的。*\r\n\r\n这样带来的问题还有并发控制的混乱，到底并发控制在vbu上，还是在vgd的内存结构上？ 这也是实现关系混乱带来的问题。\r\n\r\n\r\n按理说lsc表是slice的集合，其中分为vgd 和stable slice。\r\n那么设计的核心应该是vgd作为一个独立结构应该展示的东西。\r\n\r\n而spf作为lsc表引擎的模块名，提供不同类型的slice处理能力。\r\n\r\n\r\n	2022-05-08 14:22:25.974865	f
2010	1043	Issue	5	memory order：这种限制，决定了以atom操作为基准点（边界），对其之前的内存访问命令，以及之后的内存访问命令，能够在多大的范围内自由重排（或者反过来，需要施加多大的保序限制）。从而形成了6种模式。它本身与多线程无关，是限制的单一线程当中指令执行顺序\r\n\r\n此说法仅在一部分语言中有体现。很多语言可能不支持，或存在一种缺省memory order。\r\n	2022-05-06 20:24:39.775178	f
2011	985	Issue	5	锁能解决的问题：\r\n1，通常上层锁可保护跨下层多个对象的行为。\r\n   保护这里指 多个下层对象的存在性，以及其关系。\r\n2，锁解决多个行为的原子性问题\r\n3，锁可推迟可见性，从而解决可见性问题。\r\n   也解决了cpu cache可见性问题。\r\n4，锁具备单一性，可以实现单一操作者，即单例模式，单行为模式。实现幂等操作。	2022-05-06 20:39:32.894089	f
2012	1015	Issue	5	人该如何自处，以及与他人相处：\r\n\r\n1，人生很多事看似在与别人比赛，对比，实际上主要是自己该怎么做。\r\n   比如多线程并发控制一般，其实控制的是线程自己的行为。而不是限制别人的行为。\r\n   工作也是如此，打羽毛球也是如此，只是人们共享了一些环境而已。\r\n   但是怎么做，做到什么样，都是自己身上下功夫。\r\n   独立，自由，朝着自己的目标前进。\r\n\r\n2，人会有自己的目标，人身处集体之中，集体也有其目标。\r\n   而且人可能和集体节奏不一致，如何处理好这个关系呢？\r\n   我理解只有通过建立横向关系，通过合作来达成目标。\r\n   对小孩也是如此。责任义务是人生谎言，是很强的纵向依赖关系。\r\n   其实人和其他人之间需要更多的是合作。\r\n   伙伴，信任他人(但他人信任是别人的课题)，完成大家的公共目标。	2022-05-08 13:59:53.454605	f
2015	984	Issue	5	我回看了下上面写的目标：\r\n生机畅达，生存之类的。 但是这些实际不能算目标，如果你已经在那里了，又怎么能算目标呢?\r\n生机畅达是一种状态，生存这个目标很虚，看不出来要如何达到？\r\n\r\n我想成为一个什么样的人？\r\n我想成为一个虚拟世界的构建师，造物主，构造属于我的美丽世界，同样也属于我的伙伴，我的用户。\r\n就像头号玩家的哈利迪一样，感谢你们来玩我的游戏。\r\n\r\n编程的硬件及系统知识就像步伐，算法数据结构基础，设计和开发像发力技术， 需求业务精通像战术\r\n而我要做六边形选手。\r\n	2022-05-08 14:52:58.542473	f
2018	687	Issue	5	高远球的核心在于鞭打集中发力，集中发力有两层含义：1是要放松，降低内耗，用小臂甩腕，挥拍速度快。 2是最后时刻的碰撞，要在拍杆最大形变后握紧，利用杆的弹性，拍的弹性把球击出。\r\n球是弹出去的，并非打出去的	2022-05-12 04:30:21.978557	f
2020	778	Issue	5	1，侧身后先动左脚再转体\r\n  左脚是否拉回是连贯的根本。\r\n2，右脚上台\r\n   方便回位，不可前蹬，会影响发力的稳定性。\r\n3，身体带动肘\r\n   此时肘时放松，手腕放松，莫蓄力。\r\n4，肘到位小臂带动手腕鞭打	2022-05-13 04:46:22.402334	f
2024	687	Issue	5	再论反手鞭打：\r\n注意握拍的角度，应该能让小臂手腕很好的完成外旋动作，注意不是大拇指压，而是后三指握紧，区别在于大拇指压需要大拇指顶宽面，而外旋不需要。\r\n\r\n即高远发力与中前场利用拇指和食指发力有根本区别。中前场拇指食指发力是弹且拍子一般不会挥下去。但高远内外旋必须随挥。	2022-05-20 06:36:52.110032	f
2026	1061	Issue	5	算子并行化，其本质就是算子本身的输入特性（分片分区等）决定了其输出特性。然后输出是否能做join保持等价性。\r\n	2022-05-24 06:48:37.236355	f
2019	687	Issue	5	三个问题：\r\n1，左脚没让好位置\r\n2，没彻底转过去\r\n   这样会导致无法完成挥拍，是不可能打好反手的\r\n3，提前蓄力，不够放松。	2022-05-13 04:27:52.119084	f
2047	1091	Issue	5		2022-07-20 07:22:06.476088	f
2017	1050	Issue	5	CheckList：\r\n逻辑正确性\r\n1，行为步骤\r\n   步骤正确性，完整性，以及全面性(涉及的所有实体)，以及其影响的其他行为调整。\r\n2，边界处理，错误处理\r\n3，代码规范与规则\r\n   书写，注释，接口约束，日志，错误码，告警，安全\r\n4，行为遗漏\r\n   资源未释放？未对称使用接口？指针没置为空？\r\n   函数非幂等不可重入？\r\n5，隐含假设   \r\n   未显示的表达隐含假设\r\n6，隐含的顺序依赖\r\n7，任意时刻的挂机\r\n8，并发下的正确性\r\n9，某些场景下的不可用\r\n   比如资源开销过大\r\n\r\n\r\n效率\r\n1, 整洁代码\r\n   实体，变量，行为是否整洁干净。\r\n   是否符合森林结构，具备局部性\r\n   是否符合主谓宾结构\r\n   是否符合局部性原理：代码应该尽量高内聚，保持局部性。\r\n2，性能\r\n   内存拷贝，指令重复，多余IO，缺乏并发，没用批量化。\r\n3，资源消耗\r\n4，兼容性\r\n   持久化兼容，协议兼容\r\n5，可扩展的编码\r\n   接口合理性，依赖关系，是否考虑了可预见的变化\r\n   \r\n友好编程\r\n1，对外接口好用吗\r\n2，出问题可以观测吗，能快速解决吗？\r\n3，用户容易犯错吗，有合适积极的引导吗\r\n4，有不必要暴露的接口吗？增加了使用复杂度吗？ 	2022-05-11 08:40:12.090374	f
2022	1050	Issue	5		2022-05-16 18:17:14.421723	f
2023	646	Issue	5	左边收回，右脚蹬地(跳不跳起没关系)发力，带动胸肩部，把手臂甩出去，然后小臂内旋。\r\n没有此带动就是抡大臂。\r\n\r\n切记：大发力不要用拇指食指，直接握紧即可。手指动作很小。否则力传到手腕容易受伤。\r\n	2022-05-20 06:31:59.817594	f
2021	962	Issue	5	性能优化公式：\r\n\r\n流水线(并行(批量化(预处理(减少指令+编码+减少拷贝转移+减少IO))))\r\n预处理包括预计算，缓存，预读等.\r\n\r\n硬件基础：\r\nhttps://zhuanlan.zhihu.com/p/342417356	2022-05-13 12:59:49.862011	f
2025	968	Issue	5	软件设计教训：\r\n1，软件中有两类实体，一类是结构，另外一类是资源。结构与资源应该分离。\r\n  比如内存资源，存储资源，网络资源，cpu资源。这些应该被封装然后注入。\r\n2，多个实体应该单独作为一层。\r\n  比如vgd有很多个，那么应该增加一层。就这是结构啊，数组跟单个实体当然不一样。	2022-05-23 19:07:38.84051	f
2029	1067	Issue	5		2022-06-10 07:23:11.813406	f
2030	1023	Issue	5	磁盘IO优化：cache，局部性，连续性。	2022-06-15 12:59:35.824236	f
2035	705	Issue	5	1，旋转鞭打是手上的核心，要鞭打必须放松且做到架拍动作等。\r\n2，全身传导\r\n3，步伐就是保持惯性运动\r\n4，对上节奏。\r\n\r\n其他就是策略了。	2022-06-19 20:21:35.920459	f
2040	984	Issue	5	有志向的根本在于将自己的三观与梦想统一起来。犹如在心上种下一颗种子。	2022-07-06 07:36:11.412021	f
2041	962	Issue	5	涉及IO的优化，核心思想就是排队理论。\r\n加大并发，增加达到速度。 增大处理速度，就能增加最终吞吐量。\r\n\r\n不断加压，直到增加压力只能增加延时，即说明性能无法进一步提升。\r\n\r\n多环节的性能优化思路跟这篇差不多：https://plantegg.github.io/2018/08/24/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%E4%BB%8E%E8%80%81%E4%B8%AD%E5%8C%BB%E5%88%B0%E7%A7%91%E5%AD%A6%E7%90%86%E8%AE%BA%E6%8C%87%E5%AF%BC/\r\n其思想就是little law，排队理论。 线程数=qps * latency（单位s）。\r\n这是整系统优化的理论。	2022-07-09 15:14:48.294906	f
2003	1053	Issue	5	列存存储优化的思路：\r\n1，减少内存拷贝（次数和总量）\r\n1.1 在什么时候挤掉无效数据\r\n1.2 字段编码\r\n\r\n2，减少数据\r\n2.1 投影，去掉不必要的列\r\n2.2 过滤，去掉不必要的行\r\n2.3 结果集去掉已下推的纯过滤列\r\n2.4 加速过滤，如果某列已经skip block，那么其他条件也不必执行。\r\n2.5 不解码的过滤\r\n\r\n3，减少IO（次数和总量）\r\n\r\n4，缓存命中\r\n\r\n5，并行\r\n\r\n6，预计算\r\n   ac，二级索引，预聚集	2022-04-29 07:59:17.677519	f
2045	945	Issue	5	1，得有世界观，程序观，了解程序的组成结构，行为，矛盾，以及所涉及的人的结构，行为，矛盾，意识。\r\n2，有了矛盾之后，分析清楚主要矛盾，问题症结。\r\n   有时候需要变换问题的描述，看待问题的视角很重要\r\n3，提出方案并进行论证\r\n4，详细设计\r\n5，实施，编码，测试，验证。\r\n6，上线，发布。完成对系统的改变。\r\n\r\n每一步都很重要，搞不好就砸了。	2022-07-17 15:14:48.203826	f
2050	1095	Issue	5		2022-07-21 14:35:26.339737	f
2052	1088	Issue	5	暂不处理	2022-07-21 16:41:28.997872	f
2054	821	Issue	5	情欲是正常的身体需要，是属于思无邪的。\r\n但占有和控制的私心是有过了的。\r\n\r\n同样利益交换也是如此。	2022-07-24 21:21:57.636572	f
2055	1056	Issue	5	解决思路：\r\n1，利用辩证法，认知论，科学等手段去认知事物，解决矛盾。\r\n2，构建美好的心灵世界，这世界有美好也有丑恶，但太阳照常升起，我们可以选择看到美好或邪恶。\r\n   这取决于我们的内心。\r\n3，在他人关系中选择交流，合作，而非抢占控制。	2022-07-24 21:27:26.545543	f
2058	1094	Issue	5		2022-08-01 06:36:55.728555	f
2061	945	Issue	5	实体与行为的关系。\r\n行为依附于实体，实体具备行为，行为又改变实体。\r\n从实体结构入手，讲解行为。有时候行为还会产生新的实体。\r\n两者是同样重要的。\r\n设计文档可以从实体入手。\r\n\r\n设计并非一个随性的过程，而是一个严密的逻辑过程。\r\n\r\n	2022-08-03 14:30:33.200338	f
2064	1001	Issue	5	数据库引擎开发的核心矛盾还不是跟性能作战，而是跟异常作战。\r\n因而其最难能可贵的品质在于如何让系统不出问题或出问题就能很快发现，及时修复。\r\n	2022-08-06 07:30:52.02054	f
2068	1108	Issue	5		2022-08-07 17:36:07.228134	f
2070	1108	Issue	5	基本没看到在delta内查询出来，合并到main，再删除的方案。\r\n删除代价过大。	2022-08-07 17:58:00.009896	f
2071	984	Issue	5	儒道佛都是心灵哲学。讲究智慧。\r\n科学，技术，实践论，矛盾论是改造现实世界的学问。\r\n这中间隔着欲望和情感。只要人的肉身在，欲望不可能完全消除，欲望是驱动现实世界的动力。\r\n欲望重，容易遮蔽心灵。\r\n人生而自由，容易被孤独恐惧所支配，麻木民众，小偷，骗子，土匪，恶霸横行。\r\n焦虑与痛苦弥漫于盛世。物欲的世界少了心灵世界的恐惧，但也多了尘埃。\r\n\r\n尘世的修行做一件事即可，人当然得找到自己喜欢的事情。以技载道。以技立命。\r\n其他的事情又有什么意义呢？ 只会扰乱我们的心灵。\r\n\r\n	2022-08-08 06:43:50.048716	f
2042	1082	Issue	5	系统线程数计算方法：\r\n<pre>\r\n\r\n需要的线程数 = qps * latency(单位秒)。 依据是little’s law，类似的应用是tcp中的bandwidth-delay product。如果这个数目远大于核心数量，应该考虑用异步接口。\r\n举例：\r\n\r\nqps = 2000，latency = 10ms，计算结果 = 2000 * 0.01s = 20。和常见核数在同一个数量级，用同步。\r\nqps = 100, latency = 5s, 计算结果 = 100 * 5s = 500。和常见核数不在同一个数量级，用异步。\r\nqps = 500, latency = 100ms，计算结果 = 500 * 0.1s = 50。和常见核数在同一个数量级，可用同步。如果未来延时继续增长，考虑异步。\r\n\r\nhttps://plantegg.github.io/2018/08/24/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%E4%BB%8E%E8%80%81%E4%B8%AD%E5%8C%BB%E5%88%B0%E7%A7%91%E5%AD%A6%E7%90%86%E8%AE%BA%E6%8C%87%E5%AF%BC/\r\n</pre>	2022-07-09 21:39:39.062824	f
2044	968	Issue	5	软件设计的输入：\r\n分析主要矛盾，次要矛盾，问题来源，需求的根本。\r\n\r\n软件设计方法：\r\n1，有了1之后，要拿出几种方案\r\n   可分别尝试在不同层次来解决问题。   \r\n2，结合1进行结构与行为设计，前提是了解业务(即当前大背景)\r\n   综合考虑性能和可行性，并发，分布式下正确性。\r\n3，可测试性\r\n4，兼容性\r\n5，可监控性\r\n6，描述性\r\n	2022-07-15 13:25:56.18716	f
2046	1086	Issue	5		2022-07-19 06:46:52.071424	f
2048	1092	Issue	5	1，调研clickhouse实现	2022-07-20 07:22:44.826623	f
2049	1095	Issue	5		2022-07-21 14:29:07.845998	f
2051	1095	Issue	5	未经crc校验的网络和磁盘数据是不可靠的，不可用断言。\r\n枚举的default分支应该使用错误处理。不得不说rust这里处理是很恰当的。	2022-07-21 15:02:07.984607	f
2053	945	Issue	5	程序世界居然可以和唯物辩证法联系起来。\r\n\r\n软件设计就是一个认知不断迭代的过程。\r\n实践-认知-实践。\r\n软件的发展就是矛盾的不断变化。\r\n	2022-07-24 21:08:22.402416	f
2056	1095	Issue	5	我们没法对bug做错误处理，assert只是为了在debug下尽早暴露问题。	2022-07-25 13:18:04.81175	f
2057	1097	Issue	5	行列混合时，优化器当前不选索引，导致当join时为全表查询\r\n大并发时，allocator内的原子变量修改冲突频繁，导致性能瓶颈\r\n查询时没有根据投影列信息选择性扫描相关列\r\n列存cursor在scan过程中execCtx的malloc申请过于零碎\r\n并发scan时对列segment首页的热页冲突\r\n并发insert时，插入流程会从xbu0开始寻找空闲空间\r\nswfExecuteCtx上的subMemCtx对lsc表有作用，对tac并无作用\r\ndataset与vdsLinks申请内存过于零散\r\n并发插入时，xbu的写锁冲突很剧烈\r\n\r\ndcSwfGetColumn及dcSwfGetColSeg这类接口调用listGet有明显开销\r\nbitPtrFillFrom函数内部存在对齐等大量操作，在目标位只有1位时，属于冗余操作\r\n修复优化8中的bug，重读版本时重复压栈，冗余动作且概率导致栈溢出\r\n\r\n\r\n随着业务运行，新增数据变多，热页cache失效\r\n插入过程中冲突再打散not null页，列级别打散\r\n	2022-07-26 14:18:35.961952	f
2059	1091	Issue	5	已讨论过一次。\r\n有几个问题：\r\n1，合并或删除并发控制问题。\r\n2，一致性更新问题\r\n   可以直接报错\r\n3，delete bitmap如何合并的问题。\r\n   在内存生成时带着rowid辅助列，在最后一步给新的slice生成bitmap。\r\n4，delete bitmap如何表示\r\n   分层，持久化。\r\n   需作为独立模块，vgd和coral都会用到。	2022-08-01 06:40:25.997163	f
2060	1090	Issue	5	技术材料未完成，问题单也没搞定。	2022-08-01 06:41:07.412334	f
2062	1108	Issue	5		2022-08-03 19:11:03.955027	f
2063	1001	Issue	5	数据库存储引擎的核心挑战是结构细化，动作的不可控(支持任意长度，各种操作的事务)带来的问题：\r\n1，内存存储与磁盘存储\r\n   必然有些数据在内存，有些在磁盘，内存数据没有D，但是其他的同样要考虑。\r\n2，原子性\r\n   解决的问题：即便有各种失败可能，需要保证具有语义一致性要求的多个动作必须要么都成功，要么都失败。\r\n3，隔离性\r\n   解决并发相关下一致性问题\r\n4，持久性\r\n   解决掉电，磁盘错误，部分写等问题\r\n5，可靠性\r\n   解决单机故障问题\r\n6，可增长性\r\n   解决分布式扩容问题\r\n7，安全性\r\n   解决数据泄露问题\r\n8，容灾\r\n   解决多点故障问题\r\n\r\n更细的还有PITR等。	2022-08-06 07:23:07.671395	f
2065	968	Issue	5	软件是为了行为而存在的。\r\n\r\n软件被结构，行为，以及矛盾推动者发展。\r\n行为通过结构来体现，而行为的实现本身又催生出结构，结构与行为本身的矛盾又需要衍生出新的结构。\r\n\r\n其运转需要的是逻辑推理以及实践证实。 \r\n当然不是凭空设想，天才或许可以凭空设想，正好符合预期。 但这不是大道。\r\n\r\n没有严密的逻辑推理可能各种设想天花乱坠，实际本质问题未得以解决。\r\n如同做学问一样。\r\n\r\n任何软件或模块都可以划分为三层：\r\n1，接口层\r\n2，实现层\r\n3，资源层\r\n通常架构是将资源注入到实现层的结构之中。因为资源通常都是全局的。\r\n或者说资源是一颗树。而实现是另一颗树。\r\n\r\n资源犹如空气，水分，土壤。而实现的本质是结构。\r\n内存持久化是软件之地，之母，那CPU就是软件之天，之父。网络就是网络。\r\n结构不应该与天地相绑定，应该是活的。	2022-08-06 07:37:40.56613	f
2077	984	Issue	5	强弱与善恶无关，强弱是指掌握事务客观规律，可以打败弱者。\r\n即强弱与胜负有关。但强弱是不断运动的，追求始终的强也是疲于奔命。\r\n\r\n儿子问：为何好人总是打不过坏人？ \r\n因为好人缺乏驱动力，坏人在欲望情感驱动下有动力战胜其他人。\r\n而好人热爱生活，不喜欢争斗。\r\n这个问题就需要换个问法：好人为什么弱?\r\n按善恶，强弱来划分的话，有四个象限。 有好的强者，有恶的强者，有好的弱者，有恶的弱者。\r\n这4个象限中的人是动态变化的。达到极致必然反弹。\r\n因为还有个中：不善也不恶。不强也不弱。\r\n\r\n怎么讲：不去扶助弱者，而是去解决人遇到的困难。\r\n        不必在乎强弱与成败，而是好好生活，面对现实，面对矛盾，追求生机畅达，生生不息。\r\n不比较。也不搞平衡，横出三界。\r\n\r\n得如此自由，那如何面对孤独和不确定性？\r\n面对现实，实事求是，生机畅达，生生不息。\r\n\r\n	2022-08-09 07:19:21.523196	f
2066	1056	Issue	5	心安得靠心灵世界。\r\n心看到世界万物，生灭变幻，生生不息。\r\n心自由不羁，若受到牵绊则无法安定。\r\n所以心无欲望，无情感，无善恶。不可让这两者占住，否则看不到一个纯然自由的世界。\r\n\r\n意是存在的，意有欲念，有情感，有亲疏。意是人的行为力来源。\r\n\r\n人生活于世界就得到达到意的通达，这就需要认知和实践。\r\n\r\n所以人是什么，心意知行。\r\n\r\n佛教讲四法印，就是说去掉物欲，去掉情感，去掉那个自我，得以见心灵之觉性。\r\n天道中讲 材米油盐，男女之情说的就是意。\r\n儒家的处理方式就是做，而且要做得刚刚好。人间正道是沧桑啊。\r\n道家更彻底，甚至将我去掉，物我两忘。\r\n\r\n	2022-08-07 15:05:08.325696	f
2067	968	Issue	5	设计应该是简单的，如果导致某些动作非常复杂，那么就不是一个很好的设计。\r\n任何时候不能过于复杂，否则就没法演进。\r\n这种复杂并非组件太多带来的，而是组件之间的关系，行为约束太多。	2022-08-07 16:42:40.872582	f
2069	1108	Issue	5	https://www.esensoft.com/industry-news/dx-13580.html\r\n这篇文章详细介绍了HTAP思路。\r\n\r\n目前看到的产品，除了greenplum，其他都是delta main架构，且delta和main不是同为列存。\r\n因为大家觉得列存无法高效的更新。但这是一个误解。列存的更新效率没问题，主要是行式写入代价大。\r\n但是如果是批量写入，列存性能也没问题。\r\n\r\nyashandb TAC已经验证列存更新完全没问题。\r\n\r\n我们也可以不搞delta main，而是在main里面对局部做格式转换，这是一种全新的思路。	2022-08-07 17:39:55.103246	f
2072	966	Issue	5		2022-08-08 06:48:31.442142	f
2074	1110	Issue	5	LSM的本质特点：\r\n写入是追加式的，查询是需要合并的。\r\n\r\n相比Btree，其是相反的。\r\nBtree写入是插空的，分裂的，因而写入随机。 但查询不需要合并的。\r\n\r\n那OLAP为啥都用LSM呢？\r\n1，OLAP数据量大。Btree组织海量数据在一个结构。\r\n2，更新删除。OLAP追加写多，而更新少。 LSM不利于更新删除。Btree可以做原地更新删除。当然也有倾斜风险。\r\n3，LSM实现更简单，没有分裂调整。	2022-08-08 09:49:01.203912	f
2075	1001	Issue	5	不同程度的并发会引起不一样的问题，比如yashandb为支持查询无锁化，需要为查询在内存和持久化上都加上版本检查机制。\r\ndc需要多版本，block也需要oid检查。\r\n\r\n为了支持重启后回滚与dml并发也是要多考虑很多问题。	2022-08-08 12:09:05.220388	f
2076	1108	Issue	5	HTAP的核心矛盾：\r\n1，列存格式与插入的矛盾\r\n2，排序压缩编码的列存格式与更新的矛盾\r\n\r\n实现好HTAP的关键点是读写分离，冷热分离。\r\n为啥要分离，要隔离影响。\r\n\r\n而且冷热分好了，在合并转换等场景阻塞更新也根本不是什么问题。\r\n插入更新与转换并发，只要一个事务锁就搞定了。	2022-08-08 19:06:31.05856	f
2079	1108	Issue	5	HTAP终极方案或许就是greenplum类似。\r\n但是greenplum有几个问题：\r\n1，segment是append only的，不适合并行写入。更新代价也有点大。\r\n2，没有支持重排序，字典编码。\r\n3，vacuum加锁范围太大。\r\n4，貌似没支持segment之间的合并\r\n\r\n要确保所有某种事务结束，最好的方法就是使用事务锁。\r\n而不是自己搞个页面，再用行锁。然后额外搞一套轮询机制。\r\n	2022-08-09 19:48:13.765282	f
2078	968	Issue	5	设计的本质是逻辑，是对矛盾的深入理解，我们必须论证为什么是这样，否则就是凭空设想。\r\n设计一定要透过现象看到本质，实现千变万化。但矛盾的根本是确定不变的，语义也是不变的，语法确千差万别。\r\n\r\n结构行为矛盾不断发展变化推演。\r\n\r\n写不出论文的设计不是好设计 --- 谢锐。	2022-08-09 07:31:00.611594	f
2073	966	Issue	5	自由让人恐惧，让人感觉孤独。因为自由意味者得走自己的路。得去选择。\r\n不仅是被讨厌的勇气，少有人走的路。\r\n\r\n自由的好处是我们可以追求自己的道，可以避免很多愚昧，无聊与麻木的选择，走上自己的山峰。\r\n看到一个我们心灵所想看到的世界。\r\n\r\n痛苦却美丽，真实而孤独\r\n\r\n强大可以得自由	2022-08-08 06:55:02.685788	f
2082	1112	Issue	5		2022-08-10 15:10:07.259413	f
2084	1112	Issue	5	纯列存，根据列的更新查询需要，在数据变冷后，将其中的列分别使用active和stable格式存储。\r\nHTAP的矛盾只剩插入了。\r\n\r\n我们对内存插入做了优化，一是批量处理，二是分散插入冲突，不同插入使用不同的xbu。三是可以使用link优化短的变长。\r\n以及在内存中统一列式，不做行列转换。\r\n\r\n此外最重要的是列存支持索引。从而满足点查点更新场景需要。凭借这些基本能搞定TPCC。\r\n\r\n然后，利用上述idea，保持冷数据的更新能力，同时查询列还可以尽量利用编码，压缩，排序带来的好处。\r\n通过设置不同列的冷热编码格式，整表的排序等等，可以适应各种场景，TP，AP，偏TP或偏AP，任意位置。\r\n	2022-08-12 09:42:33.947371	f
2086	1068	Issue	5	1，说不清楚矛盾以及价值观的需求不是好需求。\r\n2，不能写论文的设计不是好设计\r\n   设计应该讲清楚创新点与竞争力所在，否则为啥去做呢\r\n3，不简单，容易错的代码不是好代码\r\n4，不好用的软件\r\n5，不可成长维护的软件	2022-08-16 08:47:18.96843	f
2089	984	Issue	5	我没能力构建一个真实世界，但我可以构建一个虚拟世界。\r\n以我的世界观。无善恶，无对错，无利弊，无成败。\r\n这他么不就是我们这个世界么？ 世界本如此，佣人自扰之啊。世界就是一堆物质与参数啊。\r\n只是人们对某些特殊物质认知不够，比如过度欲望与情感如同花朵与果实是将要衰亡与腐烂的节奏。\r\n人需要发现这些规律，然后不要搞过了就好，这不就是中庸之道么，按客观规律办事。\r\n人欲也是客观的，也是天理需考虑的部分。\r\n\r\n哪里有善恶呢，这世界并没限制人去改造它，因改造环境而影响其他人于世界而言并非恶啊。\r\n哪里有对错，利弊，成败呢？不过状态差异而已啊。\r\n\r\n事物是发展变化的，总是把自己置于变化的两端必然是不稳定的，怎么能不累呢？\r\n坐在船中间就好了，心安身稳。坐在船头船尾看到的世界都是惊险的。\r\n\r\n欲望与情感像树的果实与花朵，注定是变化与不稳定的，这就是佛道要修去的东西。\r\n但并非绝欲与绝情，而是像树干一样，不去追求那种易变的繁华，淡然朴素的情欲。\r\n\r\n所以修行是什么？不仅是去掉就完事大吉了，修成一块石头？\r\n事物是发展变化的，船的中心也是变化的。\r\n修行就是要去具备认知中的境界，探见事物本质，发而皆中。\r\n所以道并非无为，而是不妄为，船都要翻了还无为吗？ 要认识到矛盾一下子用最少的心力去解决问题，而非带来更大的灾难。\r\n\r\n\r\n\r\n\r\n	2022-08-17 07:43:46.176709	f
2080	950	Issue	5	大神的解答：\r\n总结下，内存order是限定单线程内指令顺序调整的。\r\natomic是锁，是锁就可能会产生等待，跟内存序不是一回事。\r\n\r\n看了一下，觉得没有触及实质的回答，所以补充一下。这个问题的难点在于，很多人以为它们是限制多线程之间的执行顺序（包括我写这篇回答时的最高赞回答看起来也是这么认为的），然而其实不是。事实上，Sequentially-consistent ordering是目前绝大多数编译器的缺省设置。如果按照高赞回答的意思，那么多线程如果使用了atom操作，貌似就几乎变成了单线程（或者回合制）？真的吗？既然是多线程，那么线程之间的执行顺序就一定不是确定性的（你只能在某些点同步它们，但是在任何其它的地方是没有办法保证执行顺序的）。C++11所规定的这6种模式，其实并不是限制（或者规定）两个线程该怎样同步执行，而是在规定一个线程内的指令该怎样执行。是的，我知道这部分的文档（规定）以及给出的例子里面，满屏都是多线程。但是其实讨论的是单线程的问题。更为准确地说，是在讨论单线程内的指令执行顺序对于多线程的影响的问题。首先，什么是原子操作？原子操作就是对一个内存上变量（或者叫左值）的读取-变更-存储（load-add-store）作为一个整体一次完成。让我们考察一下普通的非原子操作：x++这个表达式如果编译成汇编，对应的是3条指令：mov\r\n\r\n作者：知乎用户\r\n链接：https://www.zhihu.com/question/24301047/answer/1193956492\r\n来源：知乎\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。	2022-08-09 20:01:17.459228	f
2081	950	Issue	5	锁的本质就是所有权，锁一定是针对资源的，而不是针对过程。\r\n即锁保证了在某个时间范围内对某个资源的所有权形式。\r\n\r\nMVCC并没有改变资源的使用方式，它只是提供了一种读不加锁的手段。\r\n是否加锁是资源的动作语义决定了的。跟实现方式无关。\r\n\r\n\r\n	2022-08-09 20:06:42.997522	f
2083	1112	Issue	5	<pre>\r\n# 列存事务处理介绍\r\n\r\nhttps://zhuanlan.zhihu.com/p/377583869,该文章介绍了几种方案。\r\n\r\nhttps://www.esensoft.com/industry-news/dx-13580.html\r\n\r\n\r\n主要问题：\r\n\r\n1，经过排序，高度编码压缩的内存，无法很好的完成单条插入，更新操作，同时支持事务性质。\r\n\r\n     常见思路就是支持TP的delta store来解决，delta store有各种形态。\r\n\r\n     in-memory与disk\r\n\r\n     columar 与 row storage\r\n\r\n     inplace-update与append-only\r\n\r\n2，merge与dml并发的矛盾\r\n\r\n      merge过程中最好是append-only的，这样数据不变。在merge完成的最后时刻锁住delta，然后转移delete bitmap即可。\r\n\r\n3，点查点更新\r\n\r\n      这点对于TP非常关键，没有此能力，AP和TP就是割裂的。\r\n\r\n\r\n## GreenPlum AOCO表事务处理\r\n\r\n\r\nAO表使用segment来组织数据，segment内数据按变长组织，通过offset标识一行。支持segment进行Vacuum。\r\n\r\n写入时每个segment都是追加写的，通过控制segment的EOF位置来实现写入事务。\r\n可同时写入多个segment来支持写入并发。最多支持128并发。\r\n\r\n删除通过visibility bitmap来实现，visiBitmap可以映射到segment内的rowid，visiBitmap跟普通记录一样支持MVCC。\r\n更新通过delete + insert实现。\r\n\r\n此外segment还支持通过vacuum来compact。\r\ncompact时先锁定segment(事务锁)，以确保其上的修改操作都结束。\r\n然后读取segment中有效数据生成新的segment，并删除老的segment和visiBitmap。\r\n\r\n\r\n主要问题：对并发有限制，写入发生在离散的多个文件上，对性能有一定影响。\r\n\r\n                 compact segment需要加锁，另外没看到支持排序，字典编码，条件下推等功能。\r\n\r\n                 不支持segment合并\r\n\r\n\r\n参考材料：https://github.com/greenplum-db/gpdb/blob/master/src/backend/access/appendonly/README.md\r\n\r\n\r\n## ClickHouse\r\n\r\n不支持事务，有些场景下存在一致性问题。\r\nhttps://programs.wiki/wiki/clickhouse-real-time-analysis-how-does-clickhouse-ensure-data-consistency.html\r\n\r\n\r\n在 OLAP 数据库中，可变数据（Mutable data）通常是不受欢迎的。ClickHouse 也是如此。\r\n早期的版本中并不支持 UPDATE 和 DELETE 操作。在 1.15 版本后，Clickhouse 提供了 MUTATION 操作（通过 ALTER TABLE 语句）来实现数据的更新、删除，\r\n但这是一种“较重”的操作，它与标准 SQL 语法中的 UPDATE、DELETE 不同，是异步执行的，对于批量数据不频繁的更新或删除比较有用。\r\n除了 MUTATION 操作，Clickhouse 还可以通过 CollapsingMergeTree、VersionedCollapsingMergeTree、ReplacingMergeTree 结合具体业务数据结构来实现数据的更新、\r\n删除，这三种方式都通过 INSERT 语句插入最新的数据，新数据会“抵消”或“替换”掉老数据，\r\n但是“抵消”或“替换”都是发生在数据文件后台 Merge 时，也就是说，在 Merge 之前，新数据和老数据会同时存在。\r\n摘自：https://zhuanlan.zhihu.com/p/441059030\r\n\r\n## StarRock事务\r\n\r\n只支持导入，导入时可指定upsert，根据主键判断是更新还是写入。\r\n同样也不支持完整事务。\r\n\r\n从其支持更新的文章看，应该支持一定程度的OCC(只对writeSet做冲突检查)。\r\n做串行化提交，在提交时检查是否有主键冲突，如果有，则遵循 Last Write Wins 原则。\r\n将老版本的记录标记为删除。\r\n参考文档：https://zhuanlan.zhihu.com/p/513426455:写入事务并发控制\r\n\r\n\r\n## C-Store | Vertica\r\n\r\n存储分为 ROS 和 WOS，分别适应读写场景。\r\n也不支持inplace update，不论ROS、WOS都只能标记删除。\r\n\r\nhttps://web.stanford.edu/class/cs245/readings/c-store.pdf\r\nhttps://vldb.org/pvldb/vol5/p1790_andrewlamb_vldb2012.pdf\r\n这论文中有详细介绍。同样由于事务信息需要挪动，在移动或合并时需要加与修改互斥的排他锁。\r\n\r\nWOS是LSM架构的，追加写入。查询时合并。WOS有行式或列式实现。\r\n\r\nData in the WOS is solely in memory, where column or\r\nrow orientation doesn’t matter. The WOS’s primary pur-\r\npose is to buffer small data inserts, deletes and updates so\r\nthat writes to physical structures contain a sufficient num-\r\nbers of rows to amortize the cost of the writing. The WOS\r\nhas changed over time from row orientation to column ori-\r\nentation and back again. We did not find any significant\r\nperformance differences between these approaches and the\r\nchanges were driven primarily by software engineering con-\r\nsiderations. Data is not encoded or compressed when it is\r\nin the WOS. However, it is segmented according to the pro-\r\njection’s segmentation expression.\r\n\r\n\r\nMerge：\r\n\r\nTuple mover lock: required for certain tuple mover\r\noperations. This lock is compatible with every lock\r\nexcept X and is used by the tuple mover during certain\r\nshort operations on delete vectors.\r\n\r\n\r\n## SAP HANA\r\n\r\nhttps://www.guru99.com/sap-hana-architecture.html\r\n\r\nL1-delta:row store\r\n\r\nL2-delta:column store\r\n\r\nMain store\r\n\r\n\r\n\r\n## TIDB\r\n\r\nTiDB也是delta + main思路，LSM的delta Tree。\r\n\r\nhttps://zhuanlan.zhihu.com/p/164490310\r\n\r\n但是其pageStore并未明确说明是行式还是列式，但是一定是append方式的。因而必须gc无效版本。\r\n\r\n\r\n## ORACE\r\n\r\n专利<<用于OLTP和分析工作量的用于内存数据库的组合行和列式存储>>\r\n\r\n这篇论文跟TAC设计思路很接近。\r\n\r\n\r\n## KUDU\r\n\r\nhttps://www.jianshu.com/p/93c602b637a4?version=2.5.50000.157&platform=win\r\n\r\n\r\n\r\n</pre>	2022-08-11 14:32:53.164985	f
2085	1068	Issue	5		2022-08-16 08:42:49.860824	f
2087	1068	Issue	5		2022-08-16 08:50:01.004866	f
2088	984	Issue	5	我们不喜欢改变环境的人，除非我们主动去改变。\r\n我们也不喜欢让我们改变的人，除非我们主动改变。\r\n所以问题在于尘世中我们不得不去处理这些矛盾。\r\n修行可以加强人的精神力量，思维能力。但实践中的问题仍然需要有处理技巧。\r\n这就是出世与入世的区别。\r\n\r\n实践出真知，真知必然真行。出世有真理乎？\r\n入世与出世是相通的，都是为了增强改变与适应内心与环境的能力。\r\n实现构建内心与真实世界的理想。\r\n\r\n去欲而定，反复练习思维能力就会增强。智慧得以增长。\r\n\r\n\r\n	2022-08-17 07:13:22.101827	f
2093	1118	Issue	5		2022-08-30 15:36:25.009118	f
2095	1119	Issue	5	1，云数仓最牛逼的几家。\r\n2，跟它有哪些技术差距。\r\n3，这个小技术项目要搞定哪几个点。\r\n4，这几个点如何算达成目标，确定验收规格。\r\n   \r\n问题是什么：\r\n1，计算与存储无法独立扩展的问题\r\n   计算与存储绑定，无法适应计算与存储非同步扩展的场景。\r\n   计算与存储绑定，扩缩容不方便。对业务影响大\r\n2，按需计费  \r\n   更适合OLAP\r\n   技术上更容易弹性扩展。\r\n3，SAAS\r\n   简化用户使用\r\n4，数据治理\r\n\r\n云计算：\r\n   统一共享，云的本质是存在寡头，\r\n   如果每家公司都有云，那还是云么。云计算利用统一共享提升了效能，使得可以构建更大的结构体系。\r\n   然而就像其他事物一样，一旦外部环境变化，结构内的个体无法持续发展适应环境，没法满足个体差异化需求，矛盾激化最终走向灭亡。\r\n   比如使用者的差异化需求。\r\n   \r\n或者换个命题：一个组织有一堆资源，如何更加高效的进行管理？以应对外部挑战。\r\n   这里资源包括硬件，网络，数据等。这不仅是成本问题，还是性能问题。\r\n   很自然的想法就是统一管理，弹性扩展，按需使用资源。\r\n   \r\n为什么redshift做不成snowflake？\r\n国内是私有云还是公有云数仓？\r\n私有云数仓有什么特点？\r\n\r\n对比方法：\r\nTB级别\r\n直接使用EBS+s3跟云原生对比公平吗\r\n使用本地模拟延时能接受吗？minio能抗住TB级别的文件么。\r\n某种配置，一定大小的缓存下对比。	2022-08-31 11:35:20.467473	f
2096	1115	Issue	5		2022-08-31 19:40:21.163241	f
2098	1118	Issue	5	1，s3还缺乏一些接口。\r\n比如判断目录是否为空，以及bucket用了多少容量等	2022-09-01 12:26:39.495102	f
2099	1119	Issue	5	1，支持存算分离\r\n1.1 对象存储\r\n1.2 数据湖\r\n\r\n\r\n2，弹性扩展能力，以及扩展对业务的影响\r\n\r\n3，service能力\r\n   简化方便用户使用，用户体验\r\n   \r\n4，SQL, ACID, 数据类型\r\n\r\n\r\n5，数据安全\r\n\r\n6，成本优化\r\n\r\n7，高可用，容灾备份\r\n\r\n8，计算能力，科学计算，AI等	2022-09-02 12:02:38.829009	f
2102	1109	Issue	5	应该让软件的矛盾主体都迅速能参加进来。\r\n即软件使用者应该参与到其中来，并且必须作为矛盾制造者参与进来。	2022-09-04 14:12:06.067878	f
2103	1109	Issue	5	辩证法，对立统一规律在讲什么? 怎么运用。\r\n事物内部是运动的，运动如果一直往一个方向，那么局部就会脱离整体。\r\n即稳定事物内部必然有一个力量来提供反向运动。从而维持稳定性。\r\n\r\n这里运动可以是指那种行为。\r\n在物理学上可以是物理运动。\r\n\r\n我们无法回答存在性问题，但是通过形式逻辑和辩证法研究我们可以了解变化规律问题。\r\n具体软件开发也有这种矛盾。\r\n一个软件实体能怎么变，和不能怎么变就是一种矛盾。\r\n我们定义一种实体，*应该对其变化加以约束*。即定义实体在什么情况下才是它本身。\r\n这种定义越明确，则事物发展得越快。\r\n\r\n\r\n	2022-09-07 09:24:25.757295	f
2104	1109	Issue	5	辩证法，对立统一规律在讲什么? 怎么运用。\r\n事物内部是运动的，运动如果一直往一个方向，那么局部就会脱离整体。\r\n即稳定事物内部必然有一个力量来提供反向运动。从而维持稳定性。\r\n\r\n这里运动可以是指那种行为。\r\n在物理学上可以是物理运动。\r\n\r\n我们无法回答存在性问题，但是通过形式逻辑和辩证法研究我们可以了解变化规律问题。\r\n具体软件开发也有这种矛盾。\r\n一个软件实体能怎么变，和不能怎么变就是一种矛盾。\r\n我们定义一种实体，*应该对其变化加以约束*。即定义实体在什么情况下才是它本身。\r\n这种定义越明确，则事物发展得越快。\r\n\r\n\r\n	2022-09-07 09:25:21.17382	f
2106	1109	Issue	5	公司管理又何尝不是如此，政治又何尝不是如此	2022-09-07 09:27:45.330731	f
2107	1109	Issue	5		2022-09-07 09:36:23.92712	f
2108	1018	Issue	5	1，功能强\r\n2，好用\r\n   最低心智原则\r\n3，快速交付\r\n   简化整洁\r\n   可扩展\r\n   防错\r\n   测试，文档\r\n   兼容，\r\n4，安全的\r\n5，低成本的\r\n   最小资源消耗，最省时间。\r\n6，适应性强  \r\n   可监控可维护的，有在线调节手段。\r\n   极端情况下的逃生手段\r\n\r\n设计原则：\r\n1，最简\r\n2，隔离\r\n   \r\n3，单向依赖\r\n   公共模块不能引用上层。\r\n   公共模块不能使用全局变量。	2022-09-09 05:35:33.955459	f
2118	847	Issue	5	云数仓： 预读取与预计算技术\r\n云数仓下存在冷数据，这些数据具有不变性，很多计算是不需要重复进行的。\r\nCube，AC等都是这些技术的运用。\r\n\r\n另外就是主动读取数据技术，可以分析业务特征，提前进行数据加载。	2022-09-14 08:34:40.150871	f
2105	1109	Issue	5	需求调研 要引入矛盾双方\r\n设计  要引入矛盾双方\r\n开发 要引入矛盾双方\r\n\r\n随着软件规模的扩大，软件内部的约束越来越多，修改的可能性也不断扩大。\r\n如果没有很好的约束那么必然无法快速发展。	2022-09-07 09:27:05.073071	f
2091	1115	Issue	5	<pre>\r\n1，减轻欲念情仇\r\n\t   佛道都很讲这个，过度了就会生发痛苦，而且是人自身生发出的，是内耗。\r\n\t   《四法印》诸漏皆苦，诸行无常。\r\n\t   《道德经》五色令人目盲 ，五音令人耳聋，五味令人口爽，驰骋畋猎令人心发狂，难得之货令人行妨。\r\n\t   \r\n2，感受本我与自然，安心\r\n\t   听从身体和心灵的呼唤，累了就休息，饿了再吃。\r\n\t   第一步做好了这里才容易感受自我，否则就容易遮蔽。\r\n\t   才能体会清平之乐，听天籁之音，看天地之色(非手机)，感无邪之情。\r\n\t\r\n3，处理现实矛盾，根据生存需要发展理念，改造环境。造渡已渡人的船。立命\r\n\t   现代人佛之出世, 道之自然而行。一人一时或许可以。但一般人还是走常规路线。\r\n\t   那就是按 实践，矛盾，发展，辩证的思路处理现实问题，构建现实世界。\r\n\t   理论是活的理论，世界是活的世界，得改变得发展。\r\n           能力不足就补充能力，不怨天尤人。\r\n</pre>	2022-08-26 08:00:27.127508	f
2092	1111	Issue	5	https://zhuanlan.zhihu.com/p/200955929。\r\n\r\n用户为啥用云：\r\n1，性价比\r\n2，好用\r\n\r\n除了上述2种原因外，用户还有一个原因：\r\n即没有替代品。	2022-08-29 08:27:03.903099	f
2094	1118	Issue	5	1，欧博并发相关论文的意见review以修改\r\n2，问题单5583修改增加用例	2022-08-31 09:04:26.334704	f
2097	945	Issue	5	实体  --- 物\r\n行为  --- 事\r\n\r\n矛盾就是事物之间的对立统一关系，物与其他物是对立统一的，因而统一而存在，因对立而变化。\r\n运动是绝对的，事物会不断发展变化。\r\n实践就是讲要认清事物内的矛盾，从而改变事物，获得生存。\r\n\r\n事物结构的发展总是不断复杂化，复杂化带来了竞争优势。\r\n但最终被其内部矛盾或外部矛盾给吞噬。然后衰退与灭亡，最后以新的方式而存在。\r\n\r\n<pre>\r\n   统一共享，云的本质是存在寡头，\r\n   如果每家公司都有云，那还是云么。云计算利用统一共享提升了效能，使得可以构建更大的结构体系。\r\n   然而就像其他事物一样，一旦外部环境变化，结构内的个体无法持续发展适应环境，没法满足个体差异化需求，矛盾激化最终走向灭亡。\r\n   比如使用者的差异化需求。\r\n</pre>	2022-08-31 19:54:33.265046	f
2100	1121	Issue	5	分为2部分可自动执行的，与不可自动执行的。\r\n不可自动执行的：\r\n1，如存在性\r\n2，如选择\r\n3，扩展性\r\n4，易用性\r\n\r\n可执行的：\r\n1，兼容性\r\n2，效率性\r\n3，正确性(部分的)\r\n4, 可维护性\r\n\r\n\r\n并非通过逻辑来证明，但是如果人能执行，那么应该可以一定的规则来执行。	2022-09-04 14:07:17.355963	f
2101	1109	Issue	5	不要用人来执行规则，疲惫且效果不稳定。	2022-09-04 14:08:05.459576	f
2109	1124	Issue	5	无反向依赖，\r\n无直接依赖，\r\n  不要直接依赖数据，而要依赖接口。即是某种实体提供了行为。\r\n  即便该行为只是共享数据。\r\n接口无引用依赖\r\n接口复杂参数使用数据结构进行包装，降低接口依赖。\r\n对称性\r\n关联实体动作的包装：事务及原子操作。局部声明周期可变结构实体。\r\n可撤销动作\r\n可重入动作\r\n可并发动作\r\n可持久化动作\r\n\r\n分解是根据依赖关系来的，如果动作A必须要求同时动作B。\r\n那么就应该包装成一个新动作C。否则使用者就会出现动作遗漏。\r\n如果修改数据M，必然修改数据N，那么就应该把他们放在一起。\r\n即数据同时存在或同时消亡。\r\n这也是数据范式设计的原则。\r\n\r\n实体封装原则：\r\n1，短生命周期依赖长生命周期。\r\n   要注意自由实体的生命周期设计。\r\n   以及实体依赖，被依赖的实体生命周期要覆盖产生依赖的实体。\r\n2，语义依赖，同步修改。\r\n3，里氏替换原则\r\n   如果有一天要加一种新的实现，要实现哪些功能应该是非常明确的。\r\n   或替换一种实现，应该是非常方便的。\r\n4，实体或接口应该只由某个角色来负责。\r\n   不要将不同角色负责的实体混在一起。\r\n   ---可以总结为最小沟通原则。\r\n   \r\n\r\n\r\n软件复杂度与可变性难点就在于共享状态下的行为。\r\n软件难点之一还在于使用最有效的算法来优化行为。	2022-09-12 20:45:15.563944	f
2110	1124	Issue	5		2022-09-13 08:54:03.824825	f
2112	1124	Issue	5	软件依赖相关的一些材料：\r\nhttps://zhuanlan.zhihu.com/p/31391535	2022-09-13 09:19:19.536058	f
2090	984	Issue	5	人的境界：\r\n人活于世，于泛舟江上。安身立命是基础，会游泳能自救，把小舟撑好这是一重境界。\r\n其次是造船的能力，如能造船，便能载落水之人登彼岸。 这重还有一种境界就是教人游泳撑船的人。\r\n再次是航行能力，有人造渡口之船，有人造方舟。\r\n\r\n佛和道都是劝人上岸的，尤其是对于落人的人，岸非常有吸引力。\r\n但岸大小有限别人站那了，得自己造岸也并不容易。而且有亲属他们也不一定能上岸。\r\n所以实际情况也是这条路走的人不多。佛道之人顶多能到2重境界。\r\n其他纯粹在自我方向研究到极致的人都是在这种境界，可救领域的人。\r\n\r\n还有一类人境界更高，譬如列宁，毛等，是造世的一类人。想要探索新的，能容众生的岸，能负众生的船。\r\n所以毛的境界在慧能之上？	2022-08-19 07:29:56.849019	f
2119	1080	Issue	5	首先确定编出的库中有没有，如果有。\r\n确定是否链接错了库。比如之前的install目录中的库	2022-09-15 13:32:13.794296	f
2124	1109	Issue	5		2022-09-21 17:57:13.725334	f
2126	1048	Issue	5	1.大鞭打\r\n2.小鞭打技术\r\n3,网前技术\r\n4，后场进攻套路\r\n5，前场进攻套路\r\n6，中前场攻防转换套路\r\n\r\n最近打球后能感觉到身体哪些地方比较疲惫，通过拉升可以感觉到自己的运动状态。\r\n比如腰腹比较疲惫，大臂不能放松等。\r\n其实放松是需要比较好的身体状态的，这样才能集结爆发力。	2022-09-25 17:37:52.698947	f
2131	1125	Issue	5	可配置性，易用性	2022-09-27 18:31:43.357157	f
2149	968	Issue	5	设计不能从实现角度看，肯定是先有设计，然后论证实现。\r\n否则设计就会偏离。\r\n设计模式(实现模式)都是为了支撑设计的，并非反过来。\r\n\r\n设计要考虑规模，规模决定了很多东西，比如是否分布式，是否分库分表，是否支持并发。要不要搞主备等等。	2022-10-13 09:33:46.578417	f
2150	1056	Issue	5	心不安的原因：\r\n1，工作压力过大，太忙\r\n2，心理情感需要未得到满足\r\n3，未找到目标和意义，无法追寻自我实现与自我超越	2022-10-16 20:03:16.876108	f
2113	939	Issue	5	一致性、复杂性、不可见性和可变性\r\n补充一点：抽象性。\r\n\r\n一致性是任何软件都是存在于特定环境中的，需要适应环境而存在。\r\n复杂性：事务之间本身就有难以摸清的关系，软件如何很好的表达事务关系。\r\n不可见性：\r\n可变性：其实任何事物都是发展变化的，这是辩证法交给我们的，软件当然更是如此。这也是软件的生命力所在。\r\n\r\n抽象性：代码是抽象的，只有其部署实例是具象的。我们写一个桌子的类必然是描述一个抽象的桌子，而不是出现在某个地点某个时间特定的桌子。	2022-09-13 09:25:43.331748	f
2114	1124	Issue	5		2022-09-13 09:26:19.158073	f
2115	945	Issue	5	请理解：\r\n实体与行为：软件包含这两部分，这两者是统一的，没有行为的实体与 没有实体的行为都是不存在的。\r\n            就像光的波力二象一样。\r\n存在与变化：软件将如何发展，变化即矛盾\r\n依赖与约束：这两者关乎复杂度，可变性，正确性	2022-09-13 09:37:38.624539	f
2116	984	Issue	5	有两把武器，一是逻辑，二是辩证	2022-09-13 19:04:40.474706	f
2117	1029	Issue	5	CH最大的问题在于join，没有基于代价的优化器。	2022-09-14 08:29:41.308918	f
2120	618	Issue	5	https://jumpcod.sics.ac.cn:3443/ui/?version=2.5.50000.157&platform=win#/workbench/assets	2022-09-19 08:36:58.544751	f
2139	1125	Issue	5	性能重点考虑的是并发，内存分配，拷贝等	2022-10-08 15:15:57.257728	f
2123	1109	Issue	5	C/C++为什么问题重重，就是没有在一开始就抛弃了矛盾的另一方面。\r\nrust如何解决问题的：\r\n1，对数据类型引入所有权，以及sync send等约束确保安全。\r\n2，通过生命周期实现了约束行为的自动配对。\r\n  比如加速与解锁，打开文件与关闭文件，分配资源与释放资源。\r\n  解决了行为对称性问题\r\n3，语言封装非安全的，然后上层提供安全能力\r\n  比如锁	2022-09-21 17:45:19.65497	f
2136	984	Issue	5	人是可以一路前进的，沿着实践-认知，逻辑，辩证的路。\r\n道阻且长，行则将至。没有回头路，一路向前。回头路就是教条或经验主义。\r\n佛道都解决不了发展问题，实践认知迭代递进的方法论。\r\n\r\n彻底转向实践-认知路径。就像做一个软件系统一样，不开始就永远不会存在，永远都做不成。\r\n事物总是永恒发展的，此生只走实践之路。唯物主义就是实践先于认知的道路。\r\n\r\n小孩当然也不是人的最高级形态，小孩如何处理问题，面对挫折？ \r\n小孩只是有一点，没有内心和外在的枷锁。其接触的环境相对简单。\r\n\r\n唯物辩证，讲的就是实践先于认知，事物存在普遍矛盾，内部矛盾主导事物发展的思路。\r\n历史唯物，讲的历史不以个人意志而转移，有其内在发展规律。历史也是唯物的，也是过往实践走出来的。\r\n\r\n路只能向前走，也许一开始就是对的，但是实践情况是走不通，那怎么办呢？还是得往前躺不是。\r\n一方面锻炼了能力，另外也排除了错误方向。	2022-10-07 19:21:38.745187	f
2125	984	Issue	5	心不安即脱离本性太久，这是病。\r\n治疗方法就是断，断一切。留下的是心灵和知识。\r\n\r\n西方可能是心理学。\r\n任何学说只有不断更新才有生命力。	2022-09-22 07:05:49.723023	f
2127	1048	Issue	5	1，发接发技术	2022-09-25 17:38:41.781909	f
2121	968	Issue	5	每层对象都需要考虑：\r\n1，认知环境明确动作引入在什么样的环境下。\r\n   环境的上下文实体，及其这些实体可能处的状态。\r\n2，该动作引入要求已存在实体提供哪些行为支撑。\r\n3，该环境对新增动作本身引入的实体需要符合哪些要求。\r\n\r\n其实核心就两个点：结构与行为的依赖，约束。\r\n逐步展开，调研。\r\n\r\n编程时代码依赖于设计，而不是实现过程中把实体关系打乱\r\n\r\n	2022-09-19 11:43:58.07183	f
2128	1109	Issue	5		2022-09-25 19:41:45.98029	f
2129	1126	Issue	5		2022-09-26 08:49:45.131878	f
2142	962	Issue	5	鲲鹏性能优化	2022-10-10 13:06:21.844385	f
1952	962	Issue	5	内存中程序的性能核心在于：\r\n1，软件复杂度\r\n2，内存分配\r\n3，内存拷贝\r\n\r\n内存分配可以通过预分配循环使用，应用程序栈，memctx(大块申请，分割使用)等各种手段进行优化。\r\n\r\n并发程序内存分配是个瓶颈，可以考虑使用栈内存，应用内存池等手段进行优化。	2022-03-06 10:44:53.739671	f
2132	1124	Issue	5	当有相关含义的变量没有放在一起，当变量开始也用于其他用途，时间长了，很难搞清楚出现的地方变量究竟是何含义	2022-09-28 06:45:17.742542	f
2133	1125	Issue	5	一个变量应当只有一种含义，一个行为只干一个事情。	2022-09-28 06:46:10.947639	f
2134	1126	Issue	5	事务锁：包含事务状态+内存锁。 事务状态可以是持久化的，也可以是非持久化的。\r\n        当然本质上可以非持久化，进行持久化主要原因是内存放不下所有行锁。\r\nMVCC：MVCC是指读不加锁的解决方案。\r\nMVCC与锁的关系，老版本的链挂在锁上。即锁-事务状态-undo三者有着紧密的联系。\r\n\r\n在yashandb中通过xslot结构将三者结合起来了。\r\n	2022-09-28 07:09:02.291626	f
2140	950	Issue	5	还有一个性质就是独占性。就是反并发性。\r\n\r\n原子性：这里特指多个动作要么完成，要么不完成，在内存中其实现可通过独占性达到。\r\n顺序性\r\n可见性(时间), volatile,内存屏障，可见性跟顺序性有一定关系。\r\n              可见性必然涉及两个点：1，要么推迟可见，比如使用锁。 2，要么使用副本\r\n独占性(时间)，并发引入。锁的本质就是独占性，并发下有问题是因为访问相关资源，因而只要资源的独占性就保证了并发行为的安全。\r\n              独占性还有同步点的效果，即在某个点独占，那么其前面和后面的指定顺序相对该点是确定的。（这是CPU保证的。）\r\n一致性(时间，狭义)，指一份数据的多个副本的一致性，此外还有多个数据的一致性，行为的一致性等不在这个范围。\r\n共识性，分布式引入的。\r\n\r\n根本问题在于：\r\n1，失败，影响原子性\r\n2，并发\r\n3，乱序\r\n4，cache&副本\r\n5，分布\r\n\r\n通常情况下，这些特性之间存在相关关系，这是比较经常弄混的地方。\r\n比如Atomic，其实现涉及独占性，可见性，顺序性。\r\n比如Volatile，涉及可见性，顺序性(编译器级别的顺序性)。\r\nCPU提供了多种独占式命令，比如单核只要关中断，多核有排他指令，以及锁指令等方式。\r\n\r\n所以在讨论上述性质时必须带上行为以及实体。\r\n\r\n\r\n	2022-10-09 06:49:35.709278	f
2143	1125	Issue	5	约束除了动作顺序，关联动作要求之外，还有一种是对实体或行为的要求，比如线程安全，比如可重入等。\r\n\r\n凡是某个性质需要传递性，则相关实体或行为也得具备该性质。	2022-10-11 06:34:56.225586	f
2144	1129	Issue	5		2022-10-12 08:58:40.157604	f
2146	1129	Issue	5		2022-10-12 09:01:17.024426	f
2135	984	Issue	5	心魔又起，它是什么？\r\n1，有很多事情想去处理，但一直没有启动。\r\n2，有有多困难矛盾，但是我还没想好怎么处理。思绪在船边四起，意识扰乱者内心。\r\n   我们的意识在无效率的循环播放还有多少件事要处理。\r\n   或者在循环播放你要失败咯，又要搞砸咯之类的。\r\n3，逃避所带来的失败感。\r\n4，在对比中产生挫败感。\r\n5，不切实际的欲望来对抗失败。\r\n\r\n1，现实中各种各样的困难，需要人的认知和实践不断迭代。\r\n2，而人容易选择逃避问题，并且采用各种欲望来对抗实现矛盾。这样只会越陷越深。\r\n3，同时社会，以及人的潜意识或意识不断的在预警-恐吓心灵。\r\n\r\n人的认知在实践迭代中不断升级，最终得以自由。\r\n\r\n否则我们就像一个被束缚的婴儿，于外恐惧于内用欲望来填塞心灵对抗欲望。\r\n解放：解除束缚，使其自由发展。 解放不是把马围起来喂养。而是把马释放。\r\n      让每个人都有基本的物质保障(其实只要分配公平点这是很容易做到的)，不受暴力恐吓，不受权威愚昧，都能自由的选择热爱的工作。\r\n      这就是解放。\r\n\r\n要区分清楚现实困难，生存发展需要，外部枷锁，以及个体欲望。\r\n解放是要破除后面2个点，否则认为一切都无所谓，不存在什么解放，都是人应该面对的。\r\n外部的妖魔和心里的魔鬼，当然是人需要去克服的，但这并非必然的，欲望是自己喂养的野兽。\r\n在这种斗争的荒野之中，慢慢死去。 你还没明白吗？这世界是有区别的，并非什么都无所谓，都会自然而然。\r\n\r\n解放也不是一次性的，而是反复的。人生而自由却无往不在枷锁之中。但可以做到心无挂碍。\r\n	2022-10-07 06:23:28.842274	f
2137	984	Issue	5	精神需求未满足，人就会空洞。即处在一种精神力较弱的状态。\r\n喜欢低级刺激，休闲娱乐，表面思考，情感满足等形式。\r\n\r\n但好像没有文章讲清楚精神到底是什么？\r\n物质需求低的人，精神需求通常比较高。而我之痛苦的另一个来源或许于此，即不知道如何满足比较高的精神需求。\r\n因而觉得很多东西不是我们想要的。	2022-10-07 20:58:10.987165	f
2138	1127	Issue	5		2022-10-08 12:12:41.315663	f
2141	984	Issue	5	实践的方法：必须以科学严谨的方式推进。\r\n在软件开发领域，以实体行为论，可以完全展开一个软件，研究其中的行为与实体。\r\n但这仍然是理论研究，软件还需要经过测试，运行，使用等环节的检验。	2022-10-09 07:48:56.473264	f
2145	1129	Issue	5		2022-10-12 08:59:50.928082	f
2147	1129	Issue	5		2022-10-12 09:08:07.24232	f
2130	1125	Issue	5	在我们一开始考虑实体与行为时，就应该考虑扩展性，并发性，可靠性，正确性，资源消耗，性能(cache)，兼容性(以及规范遵守性)，可观察性，可跟踪性，安全性，开放性(文档，代码)等。\r\n此外还有依赖，约束，可测试。\r\n再最早的地方引入矛盾，尽早引入测试，尤其是对约束和依赖的测试，做完之后，该实体便是完整的。	2022-09-27 06:41:51.668838	f
2154	942	Issue	5	软件架构就是怎么盖软件大厦的问题，盖茅草屋一般程序员就可以了。	2022-10-16 20:19:23.729678	f
2151	942	Issue	5	架构师需要考虑的一些问题\r\n\r\n<pre>\r\n1，实体有分离的需求，也有联动的需求。\r\n否则有些高级功能也就没法实现。架构应该考虑到这些。\r\n\r\n2，实体的关系组织方式\r\n分层架构，事件架构，微内核架构，微服务架构，云架构等\r\n\r\n3，实体规模\r\n 这决定了分布式，分表分库等\r\n\r\n4，实体各种属性，比如一致性要求，扩展性，安全，性能，约束等等。\r\n\r\n5，考虑使用者时的实体关系。\r\n\r\n6，那些具备传染性的特性。\r\n   如编程风格，如测试框架的选择。\r\n   即我们得有一些手段保证树长大时候一些基本属性不回变。\r\n   叶子都是绿色的，皮肤都是灰色的等。\r\n   \r\n7，掌握一些常用组件。\r\n8，掌握过硬的基础知识。\r\n9，架构师能力需要更全面，因为系统规模大了之后，组件的类型，规模都发生了变化。 \r\n10，软件结构与组织结构，沟通效率。\r\n11，工程基础，打造开发平台\r\n   比如单元测试的组织，文档如何保持代码同步。\r\n   规格限制如何管理。\r\n   配置参数。\r\n   错误处理如何持续更新。\r\n</pre>	2022-10-16 20:07:33.484831	f
2155	950	Issue	5	幂等性：执行一次与执行N次效果一样。\r\n可重入性：可以反复执行，不会出错。\r\n并发安全：可以被多个线程并发调用。	2022-10-19 09:08:31.503734	f
2159	984	Issue	5	人与其他生命的根本区别在于人强大的脑力，可以映射万物，形成复杂的脑部结构。\r\n就像神经网络一样，输入数据，产生网络。\r\n所以人主要在做的事情就是通过生活实践来构造心灵和大脑结构的过程。\r\n我们不可见大脑之外的任何东西，而大脑看到的东西是可以通过我们再组织的。\r\n纯粹于物质，刺激的满足是基础脑部需求。\r\n\r\n保持专注，不分心不恐惧。世界无本意义，我要做的是塑造我们自己，我们自己就是目的。\r\n\r\n且看如何通过实体，行为理论来理解各种问题。\r\n1，软件是什么？\r\n2，设计在干啥？\r\n3，如何描述清楚问题？\r\n4，问题是什么？\r\n5，问题是如何解决的？\r\n\r\n	2022-10-29 15:46:00.19437	f
2164	1110	Issue	5	LSM有个好处是增量化，这样方便于数据加工。\r\nHTAP面临的主要挑战是插入和更新，并非删除。\r\n单条插入和更新会访问大量页面，并且由此带来的并发冲突。\r\n\r\n插入写到新位置没问题，问题就剩下更新了。\r\n更新可以通过我们的HTAP专利解决：如列未做编码压缩，则支持原地更新。否则通过删除+写入方式作为新记录来处理。\r\n原地更新的好处是：\r\n1. 减少空洞，减少合并。\r\n2，更新代价低。\r\n\r\n此外可结合变长页面技术，解决更新问题。变长页面还能很好的与压缩，加密等结合。\r\nhttp://www.vldb.org/pvldb/vol12/p2047-sherkat.pdf?version=2.5.50000.157&platform=win\r\nsap hana，multiple page size\r\n\r\nhttps://www.cnblogs.com/princessd8251/p/3398020.html\r\noracle\r\nhttps://developer.ibm.com/articles/table-spaces-and-buffer-pools/\r\ndb2也支持\r\n\r\n那剩下只有一个问题了：\r\n怎么解决模型变换问题？从TP的范式化到AP的星形模块，雪花模型等。\r\n\r\n	2022-11-02 04:06:04.934049	f
2166	1112	Issue	5	专利稿件意见：\r\n1, 更新频率跟冷热有关系，但这里更强调的是跟业务有关系，业务上该列有一定频率更新，因而存为原地可更新的格式。可参考实施例。\r\n2，权利1中可交代更新频率与存储类型的关系。\r\n3，未点名相比删除再插入的实现方式原地更新的好处？没此背景其他人可能难理解。\r\n4，权利1中数据包应说明其是含部分列的情况，通常更新涉及表的部分列，如果这些列都是符合原地更新条件，则进行原地更新。\r\n5，权利4描述有误，全部可原地更新，选择原地更新。	2022-11-05 05:14:02.716196	f
2169	1140	Issue	5		2022-11-05 12:51:52.913997	f
2167	1112	Issue	5	1, 更新频率跟冷热有关系，但这里更强调的是跟业务有关系，业务上该列有一定频率更新，数据变冷后\r\n   该列保留其原地可更新的格式。可参考实施例。\r\n2，对冷热数据的处理是本专利一个很独特的点，与delta+main架构不一样，我们是将热数据中低频更新列变冷(转换存储格式).\r\n   而delta+main架构是将热数据放在delta，这决定了其只能使用删除再插入的方式处理冷数据更新。\r\n3，权利1中可交代数据冷热，列的更新频率与存储类型的关系。\r\n4，未点名相比删除再插入的实现方式原地更新的好处？没此背景其他人可能难理解。\r\n5，权利1中数据包应说明其是含部分列的情况，通常更新涉及表的部分列，如果这些列都是符合原地更新条件，则进行原地更新。\r\n6，权利4描述有误，全部可原地更新，选择原地更新。	2022-11-05 05:47:33.24887	f
2168	1139	Issue	5		2022-11-05 12:18:51.794423	f
2170	934	Issue	5	在思想上麻痹，每个人期待统治者施加恩惠。权利赋予人民，谁赋予？\r\n在经济上剥夺个人经济基础。\r\n再有出头者，直接暴力武器上。我的一切都是国家给的，这句话何其凄凉。\r\n人都没法立起来。\r\n所以这片土地上产出：奴才，傻子(有部分是装的)，骗子，躺平者。\r\n为啥成功者给人一种奸诈的感觉，就是奴才和骗子。\r\n然后统治者铲除他们。\r\n\r\n不独立无其他。	2022-11-07 06:50:14.549456	f
2175	968	Issue	5	设计之难：\r\n1，搞清楚做什么很难\r\n2，复杂的事情做好做对很难，正确答案并非显而易见，需要反复认知，推敲调研。\r\n3，保持连贯性很难，如何做到看一个地方，就知道其他地方。\r\n   里氏替换原则就很难。\r\n4，设计经验传承也很难。	2022-11-08 18:21:52.250151	f
2172	1140	Issue	5	TAC通过逻辑页面获取物理页面有一个cache，但是在增量插入情况下，该cache刷新有一定频率(需要积攒足够的新增页面)。\r\n因而在导入数据后直接测更新可能大量页面cache未命中，可以通过重启让cache重新加载再测试update，验证该cache对性能的影响。\r\n这个点我跟汪鹏对了下，一方面我们可以优化cache刷新机制，另外针对持续有插入的情况，获取物理页面的冲突可能还是会很高，这\r\n在之前TPCC性能测试的时候就发现了该问题，需要考虑其他方案来优化。\r\n\r\n即存储结构的设计要注意：\r\n1，不可多行合并，否则无法解决多行事务一致性问题。\r\n   VCS，多行合并方案最终被遗弃。\r\n2，并发能力，要考虑清楚热页冲突问题。\r\n3，一致性框架尽量统一，不要单独搞。\r\n  比如元数据管理自己使用xslot回滚，不如使用系统表。	2022-11-08 14:25:08.315545	f
2176	1125	Issue	5	正确性：约束，一致性，行为正确性\r\n性能：并发并行，缓存系统，资源开销，资源占用稳定性\r\n可靠性：故障处理，备份容灾\r\n兼容性：规范遵从\r\n扩展性：功能扩展，模块扩展\r\n测试性：可测试性，测试完全\r\n可维护性：可定位跟踪，可观察分析\r\n安全性：\r\n开放性：	2022-11-08 18:36:21.676079	f
2178	968	Issue	5	凡是某类实体都应该遵守其基于约束，以及遵守该类实体的设计原则，行为特性。\r\n这就是里式替换原则。\r\n\r\n设计必须是树或森林，或者单向图。即依赖不能反。	2022-11-08 18:41:21.682604	f
2158	705	Issue	5	人既不是完全没准备，也不是全量准备，而是身体一部分在准备，而另一部分在放松。\r\n通过状态变化产生了移动。\r\n业余选手的病根在于：\r\n1，没有踏地准备或不够放松，导致步伐太慢。\r\n2，步伐慢，经常到不了位，因而无法蹬地借力。\r\n3，来不及做展肩架拍动作，没有前期的慢带动过程。\r\n4，喜欢仓促进攻，身体重心容易失衡。\r\n	2022-10-29 15:34:31.830226	f
2160	984	Issue	5	有什么比天地万物，宇宙星辰更值得赏析呢？\r\n不要被外物所累，除非外物本质就在丰富我们自己，我们自己就是目的。	2022-10-30 20:26:52.158589	f
2161	1109	Issue	5		2022-10-31 07:08:59.415944	f
2171	1136	Issue	5	<pre>\r\n什么是云\r\n\r\n云是对于计算,存储,网络等基础设施的封装。\r\n\r\n\r\n云主机与本地对比：\r\n\r\n应用程序优化\r\n\t\r\n\r\n客户\r\n\t\r\n\r\n客户\r\n\r\n扩缩\r\n\t\r\n\r\n客户\r\n\t\r\n\r\n客户\r\n\r\n高可用性\r\n\t\r\n\r\n客户\r\n\t\r\n\r\n客户\r\n\r\n数据库备份\r\n\t\r\n\r\n客户\r\n\t\r\n\r\n客户\r\n\r\n数据库软件修补\r\n\t\r\n\r\n客户\r\n\t\r\n\r\n客户\r\n\r\n数据库软件安装\r\n\t\r\n\r\n客户\r\n\t\r\n\r\n客户\r\n\r\n操作系统 (OS) 修补\r\n\t\r\n\r\n客户\r\n\t\r\n\r\n客户\r\n\r\n操作系统安装\r\n\t\r\n\r\n客户\r\n\t\r\n\r\n客户\r\n\r\n服务器维护\r\n\t\r\n\r\n客户\r\n\t\r\n\r\nAWS\r\n\r\n硬件生命周期\r\n\t\r\n\r\n客户\r\n\t\r\n\r\nAWS\r\n\r\n电源、网络和冷却\r\n\t\r\n\r\n客户\r\n\t\r\n\r\nAWS\r\n什么是云数据库\r\n\r\n百度百科：云数据库是指被优化或部署到一个虚拟计算环境中的数据库，可以实现按需付费、按需扩展、高可用性以及存储整合等优势。\r\n\r\n在下表中，您可以查找 Amazon EC2 和 Amazon RDS 的管理模型比较。\r\n\r\n应用程序优化\r\n\t\r\n\r\n客户\r\n\t\r\n\r\n客户\r\n\r\n扩缩\r\n\t\r\n\r\n客户\r\n\t\r\n\r\nAWS\r\n\r\n高可用性\r\n\t\r\n\r\n客户\r\n\t\r\n\r\nAWS\r\n\r\n数据库备份\r\n\t\r\n\r\n客户\r\n\t\r\n\r\nAWS\r\n\r\n数据库软件修补\r\n\t\r\n\r\n客户\r\n\t\r\n\r\nAWS\r\n\r\n数据库软件安装\r\n\t\r\n\r\n客户\r\n\t\r\n\r\nAWS\r\n\r\n操作系统修补\r\n\t\r\n\r\n客户\r\n\t\r\n\r\nAWS\r\n\r\n操作系统安装\r\n\t\r\n\r\n客户\r\n\t\r\n\r\nAWS\r\n\r\n服务器维护\r\n\t\r\n\r\nAWS\r\n\t\r\n\r\nAWS\r\n\r\n硬件生命周期\r\n\t\r\n\r\nAWS\r\n\t\r\n\r\nAWS\r\n\r\n电源、网络和冷却\r\n\t\r\n\r\nAWS\r\n\t\r\n\r\nAWS\r\n什么是云数仓\r\n\r\n\r\n百度百科：未收录\r\n\r\n\r\n从各种资料综合看，云数仓相对于云数据库之外，其还需具备如下能力：\r\n\r\n1，数仓技术\r\n\r\n向量化计算，列式存储，压缩编码等\r\n\r\n2，存储计算分离，数据本地缓存\r\n\r\n3，数据共享\r\n\r\n4，多模数据\r\n\r\n5，**\r\n\r\n其中1是必备的，否则就是云数据库。\r\n\r\n\r\n在Amazon Redshift推出的前几年，我们的很多客户就已经把除了数据仓库之外的所有工作负载迁移到了云端。\r\n\r\n数据仓库常常是客户在企业本地运行的最后一个应用，\r\n\r\n而且他们仍面临如成本高昂、带有惩罚性质的许可费、难以扩展，并且无法分析所有数据等重重挑战。\r\n\r\n客户的诉求之一便是希望在云中大规模地运行具备足够性价比的数据仓库来分析所有数据，同时兼顾性能。\r\n\r\nhttp://www.199it.com/archives/1514846.html\r\n数据湖\r\n\r\n智库百科：数据湖 是一个以原始格式存储数据的存储库或系统。 它按原样存储数据，而无需事先对数据进行结构化处理。\r\n\r\nELT与ETL的区别，一个数据后处理。\r\n\r\nhttps://developer.aliyun.com/article/871923#slide-9\r\n\r\n\r\n应用场景\r\n\r\nhttps://help.aliyun.com/document_detail/93838.html?spm=5176.20718342.J_8590859590.1.57f363f1D0ddQu\r\n\r\nhttps://aws.amazon.com/cn/redshift/powered-by-redshift/\r\n\r\n\r\n市场情况\r\n\r\nThe Forrester Wave™: Cloud Data Warehouse：PDF\r\n\r\nhttps://developer.aliyun.com/article/783543?utm_content=g_1000269587\r\n\r\n目前还没看到有单独的市场份额统计。\r\n</pre>	2022-11-08 13:52:05.726252	f
2173	991	Issue	5	rust可部分解决重入问题。\r\n比如用c写代码，在未作检查的情况下，可能重复分配或释放资源。\r\n但是rust对变量重新生成，则老的对象生命周期结束，可避免该问题。	2022-11-08 15:32:05.22253	f
2165	1136	Issue	5		2022-11-02 15:14:46.398129	f
2174	1141	Issue	5	错误的成本更高，软件的设计一贯性以及连续性要求极高。\r\n打地基和建设的水平要求更高。	2022-11-08 16:54:54.085432	f
2185	1120	Issue	5	勇于斗争者才有和平独立，逃避斗争只会迎来奴役和内卷。\r\n有很多人喊着独立自由，而又不敢斗争。\r\n\r\n读书人最大的问题就是以和平之名软弱，身处自我矛盾之中，在内耗，纠结，奴役之路上不得解脱。	2022-11-16 06:37:13.017287	f
2179	1132	Issue	5		2022-11-08 18:57:07.386338	f
2186	1105	Issue	5	vtune分析clickhouse报alternative stack size too small \r\nhttps://www.intel.com/content/www/us/en/develop/documentation/vtune-help/top/troubleshooting/error-message-stack-size-is-too-small.html\r\n\r\n根因分析：clickhouse也使用了signal altstack，且内部硬编码使用了16KB大小。\r\n处理办法：换成命令执行，带上-run-pass-thru=--no-altstack\r\n\r\n"C:\\Program Files (x86)\\Intel\\oneAPI\\vtune\\latest\\bin64\\vtune" -run-pass-thru=--no-altstack -target-system ssh:clickhouse@192.168.3.103 -target-install-dir=/tmp/vtune_profiler_2022.3.0.624050 -collect hotspots -knob enable-characterization-insights=false --target-pid 27183	2022-11-16 06:42:34.8272	f
2192	1106	Issue	5	sudo tcpdump -i lo -s 1500 port 9601 -w yasdb2.cap	2022-11-25 08:30:54.833165	f
2181	1143	Issue	5	这是第二步，第一步我们通过s3和本地缓存解决了存储扩展问题。	2022-11-11 04:35:21.836542	f
2182	1143	Issue	5		2022-11-11 04:38:50.340716	f
2183	1140	Issue	5	heap其实也有页面映射，这个映射就是segment/extent结构。\r\n除此之外，还有空间管理问题	2022-11-11 08:31:25.151552	f
2184	1136	Issue	5	1,存储计算分离\r\n2，存储扩展\r\n3，计算弹性扩展\r\n4，湖仓，外部数据纳管\r\n   外部数据支持删除更新吗？	2022-11-12 15:33:52.24634	f
2194	18	Issue	5	PR锁\r\nhttps://my.oschina.net/LastRitter/blog/1541364?version=2.5.50000.157&platform=win	2022-12-05 17:11:17.89894	f
2195	1153	Issue	5	只能说框架就是一坨屎，到处发散修改。	2022-12-07 13:29:20.373704	f
2197	950	Issue	5	lock到底做了啥让变量可见？\r\nlock的变量是volatile的，访问时携带内存屏障指令。这样就可以保证cacheline失效消息得到处理。\r\n因而lock期间的变量的cacheline在本cpu得以刷新，因而这些修改对其他cpu可见。\r\n\r\n\r\n所以在锁的实现上，一般lock都会加入读屏障，保证后续代码可以读到别的cpu核心上的未回写的缓存数据，而unlock都会加入写屏障，将所有的未回写的缓存进行回写。	2022-12-09 15:08:19.189533	f
2187	1146	Issue	5		2022-11-18 06:57:41.146184	f
2188	1147	Issue	5		2022-11-18 08:42:55.878373	f
2043	962	Issue	5	优化分三类：\r\n1，内存优化\r\n  使用vtune等工具搞起\r\n  小内存分配对并发影响很大。\r\n2，io交互优化\r\n  \r\n  分析是否压满：运用排队理论，往上压，保证每步的达到速率。分析瓶颈优化处理速率。\r\n                吞吐量 = 达到速率 * 处理速率。\r\n                如达到100，处理速率是1，那么就是100. 这两个是相互影响的，处理跟不上，那么达到速率最终会下降。达到速率跟不上则必然吞吐量上不去。\r\n  观察svctm：如果此值较高，说明磁盘io离散性大，布局需要优化。\r\n3，并行优化\r\n  并行有问题：请求速率就是不够\r\n  \r\n4，cache优化	2022-07-14 07:22:09.204526	f
2189	1146	Issue	5	1，提升自己搞事件的能力\r\n2，保持专注，提升心境：平静而专注于解决问题\r\n3，寻找自己的市场	2022-11-21 06:42:29.388709	f
2190	991	Issue	5	凡是涉及一致性的地方都需要设计对应的校验手段，比如静态检查，运行时检查，测试等。	2022-11-21 19:13:29.526606	f
2191	1124	Issue	5	尽量避免反向依赖，否则下层实体无法移动位置。\r\n比如存储的block，不应该依赖于spcId，这样如果上层变更spcId，则下层无法跟着变化。\r\n	2022-11-21 19:17:00.488459	f
2162	984	Issue	5	1，世界观\r\n世界是什么样的，不了解这个，也就没法理解周遭发生的一切。。\r\n世界观是人对于外部输入信息的基本处理，即观世界，人能看到怎么样的世界取决于其世界观。\r\n实体在时空下的行为。并且是不断变化的，辩证逻辑。\r\n2，人生观\r\n这个得从人的角度出发，人与世界是什么关系？我们该怎么做。\r\n人有一个自我构造的世界，而究极一生都在做构造自己的世界。人所能见者也是通过大脑模拟的。\r\n所以说心外无物，人是看不见其大脑接受信息之外的东西的。\r\n通过观察，学习，实践等手段。\r\n看得清，看得深，看得远，然后做就好了。\r\n\r\n为了成为真正的人，独立自由的人，有自己体系(三观)的人。\r\n人生没有真正的失败者，只有达到和未达到。不往前走和拼命追赶的人生本质是一样的。\r\n都看不到沿途的风景。我偶尔专注的做事情，也偶尔停下脚步欣赏沿途的风景。\r\n就像打球一样，太快或者太慢都是不合适的，合适的是按照一定的节奏来运转。\r\n\r\n当我心神专注时，我的思维运行于物体之内，物与我合成一体。我忘记了自己的存在。\r\n\r\n也是禅宗：应无所住，而生其心。\r\n心学：将我们的心神运行于事物之上，然后用“良知”去体会事物本身的矛盾，善恶。\r\n然后尝试去解决矛盾，为善去恶。\r\n但这有个前提，即我们的心念可以运行事物，即意识可以分辨事物，了解事物。\r\n同时我们拥有无善无恶的良知，这或许是庄子众生无别，也可能是等级森林。总之得有一个明确的尺度。\r\n\r\n王阳明或许也是思考非常多，然后形成了自己的体系。但是无法具象化或符号化其思维过程？\r\n\r\n2.1，不是毫无准备，也不是僵硬的紧张准备。\r\n2.2，节奏至关重要，过度紧张不利于发挥。要学会掌握节奏。\r\n2.3  不能受太多别人干扰，按客观规律办事。\r\n2.4，立地成佛，明天的我与今天的将不一样。\r\n   过去不可追，未来总可期。\r\n2.5，善良，谦虚都是好品质，前提是理解他们的真实内涵和使用场景。\r\n2.6  除了生死还有什么大事，养生不好么，见天地见众生，快快乐乐的做点事。\r\n\r\n3，价值观\r\n人该做什么? 改变自己这是当然的，人本身就是目的。\r\n但是人需要通过外部世界的交互和实践中改变，即通过认识和改变世界来改变自己和身边的人。\r\n人的意义只能在于人本身，王阳明说我心光明，就是这个意思，我心光明就是最重要的事，构造我们的内心，认知。\r\n整个社会是一个整体的话，也可以看成一个森林。人得到什么，取决于其在森林中所处的位置，而处于什么位置取决于我们想做成什么。\r\n建高楼大厦的人自然在顶上，做一个具体插座的人自然在底下，当前你可以发明一个新插座。\r\n社会还有一种可能是扁平架构，这要求很高的治理能力。致力于上层结构的人利用权力拿走太多是社会的根本矛盾。\r\n我不管什么他妈的成功学，什么名利道德，什么恐惧焦虑，抓住一个点就好了，就是不断的迭代去做就好了，做就能改变。\r\n\r\n\r\n4.方法论 \r\n   1，实践作为检验。避免教条主义和经验主义。\r\n   2，复杂问题的处理都是需要方法逻辑的。\r\n   2.1 先思考而不是先搜索，搜索与尝试可以解决单点问题，但复杂问题不好使。\r\n   3，说不清楚，做无结果，完了没总结，这是大忌。\r\n      在痛苦中痛苦，而没能在痛苦中成长。   \r\n\t  犹如在黑夜中行走，失败了我们要放一个警示牌，说清楚情况。\r\n\t  成功了我们也要去搞明白为啥是可行的，以便后人知道环境有变，可能此路不行了。\r\n   4，有5类问题\r\n      1，误解，理解差异，表达，程度问题。\r\n      2，资源调度问题，多则损之，少则补之。\r\n      3，实体行为优化问题\r\n      4，没有打通关节的问题，需要新的实体，以及相关新的行为步骤来解决的问题。\r\n         或外部环境变化，局部实体需调整结构来适应的问题\r\n      5，正确性问题\r\n\t 	2022-10-31 10:25:38.508047	f
2199	1156	Issue	5		2022-12-12 20:36:59.11609	f
2193	1074	Issue	5	这是软件开发的困难之二，之一是了解当前所有涉及实体行为的关系，软件复杂性难题，涉及如何做调研。\r\n需求和目标为啥难？\r\n1，信息传递丢失。\r\n   信息传递过程中目的和意义被丢掉，代替以如何做或其他形式，甚至谬传为谣言。\r\n2，看问题的维度多样性\r\n   我们知道了想达到什么目的，但是通常我们趋利避害，因为我们自己所在实体位置关系，看问题的视角难免偏颇。\r\n   因而我们会考虑以某种偏见来描述问题，进而产生错误方案。\r\n3，需求与实际问题的差距，没有言说的部分\r\n   我们描述需求通常只描述一面，比如某模块要支持啥啥，但是这仅是功能描述。\r\n   需求还必然有其他层面，比如对行为性能的要求，对兼容性要求，对安全的要求等等。\r\n\r\n举个最近的例子：在软件的内存管理中，提到一个需求即某模块去掉对jemallc依赖。\r\n这看起来好像没啥可做，就是将jemalloc换成malloc，但背后其实隐藏了要解决短期小内存与长期大内存分配引起的内存上涨后OOM的问题。\r\n	2022-12-02 06:51:07.511555	f
2196	1154	Issue	5		2022-12-07 14:47:35.232372	f
2122	1042	Issue	5	我的观点：\r\n1，volatile不能解决顺序问题\r\n2，volatile能解决可见性问题。\r\n   举个例子两个线程加载一个对象，一个线程发现另外一个线程正在加载，于是等待。\r\n   那么这个等待就可以通过volatile变量来检查对方是否完成。\r\n\r\nvolatile不能解决多线程下的顺序问题，但是可以解决是否发生的问题。\r\n不能解决happns before，但是可解决happened的问题。	2022-09-20 17:46:28.886115	f
2198	1120	Issue	5	斗争为了成为真正的人，独立自由的人，有自己体系(三观)的人。\r\n人生没有真正的失败者，只有达到和未达到。不往前走和拼命追赶的人生本质是一样的。\r\n都看不到沿途的风景。我偶尔专注的做事情，也偶尔停下脚步欣赏沿途的风景。\r\n就像打球一样，太快或者太慢都是不合适的，合适的是按照一定的节奏来运转。\r\n\r\n当我心神专注时，我的思维运行于物体之内，物与我合成一体。我忘记了自己的存在。\r\n\r\n也是禅宗：应无所住，而生其心。\r\n心学：将我们的心神运行于事物之上，然后用“良知”去体会事物本身的矛盾，善恶。\r\n      然后尝试去解决矛盾，为善去恶。\r\n      但这有个前提，即我们的心念可以运行事物，即意识可以分辨事物，了解事物。\r\n      同时我们拥有无善无恶的良知，这或许是庄子众生无别，也可能是等级森林。总之得有一个明确的尺度。\r\n\r\n王阳明或许也是思考非常多，然后形成了自己的体系。但是无法具象化或符号化其思维过程？	2022-12-12 20:31:52.27227	f
2203	968	Issue	5	软件的需求调研，设计都需要落地，怎么落地？\r\n地就是人，实体，行为组成的软件，即要落到对应的实体行为上去。\r\n\r\n往深入点讲：\r\n1，如果需求是在某个实体上优化某个行为。\r\n   那么就得考虑其上下文中其他实体该如何适配。其下游实体是否也得提供实现？并以此传递下去？\r\n   那些潜在的要求如何表达，比如兼容性，比如实体在主备环境中，需提供复制能力？\r\n2，如果需要是增加某类实体\r\n   那么这个实体其要实现哪些行为？遵守哪些约束？\r\n   增加了该实体后，其父亲，周边实体行为是否会增加新的约束或限制？\r\n3，哪些实体的变更会影响了整体设计？\r\n   显然中间结构层影响更大，以及被广泛依赖的实体。其约束传递到整个系统。\r\n   例如数据库中的buffer，以及系统中的万物类（类上一大堆方法，被系统的各个模块所依赖）\r\n4，新增行为的参数在其他层次中的实体中产生，需要携带参数？\r\n   参数实体，以及shared ptr解决实体生命周期不够的问题。\r\n	2022-12-13 12:13:06.232118	f
2201	968	Issue	5	\r\n见《SSDR 12，软件结构》\r\n<pre>\r\n架构核心就是中间层的结构。\r\n软件中有很多通用的部分，其实数据结构，空间管理，内存管理，资源抽象等等就那么些东西。\r\n数据结构也就那些。这些公共或外部资源的抽象其实都可作为公共部分。\r\n比如编码，压缩，字典等等。包括系统提供的能力。\r\n</pre>\r\n\r\n软件除了实体行为外，还应该加一个人。\r\n人与软件实体，软件行为都有关系。小到软件开发涉及的组织结构，开发，测试人员，文档，用户等等。\r\n用户可能还划分为使用者，购买者，以及生态。\r\n\r\n这也可以解释为啥基础软件开源非常重要，因为开源可以让基础软件最大的群体---开发者参与其中。	2022-12-12 21:23:29.084515	f
2206	1108	Issue	5	行列混合的两种思路：\r\n1，由列到行\r\n  将变长部分使用行管理，变长列可以聚集存，也可以每列单独存。\r\n2，由行到列\r\n  将行中的部分列抽出来，作为一个子relation，采用定长列式存储。\r\n\r\n其实核心区别在于：1，列是否聚集。 2，变长和定长的管理。\r\n\r\n终极方案还是将事务与数据独立，列根据需要按定长，变长，聚集或分开存。	2022-12-14 14:10:56.095404	f
2208	968	Issue	5	架构的权衡：当我们引入新功能后，现有的功能部分得到增益，有的被损害。要根据行为的重要性来综合考虑。\r\n实体分开利于实现迁移和变动，合并利于实现全局行为。\r\nLSM和Btree其实就是这两者的明显体现。\r\nLSM好实现局部优化，差异化竞争力。Btree适合全局，可以全局有序。\r\n\r\n架构只能选择当下最重要最有利的方案，但是要稍微考虑下其相反方面。\r\n尽量不要形成巨大的短板。以致于劣势过于明显而被抛弃。\r\n比如Rust的编译时间完全从架构上舍弃有点可惜。\r\n\r\n或者从衡量的角度，要加权乘法的方式来评估选择优劣。	2022-12-15 12:48:01.626059	f
2209	1159	Issue	5		2022-12-27 09:11:29.176548	f
2210	1109	Issue	5	架构腐化标准：\r\n1，软件中的模块无法重用。即不能通过组合的方式来快速实现功能。\r\n2，软件中无法新增实现，因为已经说不清楚要加些什么，改哪些地方才能得到一个新的实现。	2022-12-27 09:15:30.014603	f
2177	968	Issue	5	如果设计是一个实体树，那么任何层次的实体都需要考虑以下属性：\r\n环境：上下文，约束，在实体树中的层次，以及与其他实体的关系。\r\n正确性：约束，一致性，行为正确性\r\n性能：并发并行，缓存系统，资源开销，资源占用稳定性\r\n可靠性：故障处理，备份容灾\r\n兼容性：规范遵从，软件升级\r\n扩展性：功能扩展，模块扩展\r\n测试性：可测试性，测试完全\r\n可维护性：可定位跟踪，可观察分析\r\n安全性：\r\n开放性：文档，手册，注释。\r\n并行性：多人操作时如何并行？哪些地方会有瓶颈？\r\n\r\n	2022-11-08 18:37:59.391592	f
2213	1160	Issue	5		2022-12-27 14:41:24.045378	f
2245	660	Issue	5	张代谦 一面通过\r\n1，近四年从事云存储开发，对系统掌握较为深入，了解其中的痛点以及技术线路。\r\n   尤其是云上大规模集群管理，运维监控方面有一定经验。\r\n2，沟通良好，思路清晰。\r\n3，主要用C++开发，基础问题回答一般。\r\n4，了解数据库内核基本概念，原理实现未深入。\r\n5，已于去年底从腾讯离职。\r\n\r\n可考虑在云原生或分布式方向上发挥其经验作用。	2023-02-08 18:13:26.059571	f
2200	981	Issue	5	架构核心就是中间层的结构。\r\n软件中有很多通用的部分，其实数据结构，空间管理，内存管理，资源抽象等等就那么些东西。\r\n数据结构也就那些。这些公共或外部资源的抽象其实都可作为公共部分。\r\n比如编码，压缩，字典等等。包括系统提供的能力。	2022-12-12 21:19:53.878772	f
2202	968	Issue	5	通过调研分析，调研分析是在搞什么？当然也是搞清楚这些关系。\r\n人，实体，行为。\r\n\r\n然后结合环境需要来完成设计。\r\n如果没有一种语言来描述设计，那么设计就成了空中楼阁，就更枉谈方法论了。\r\n这样只能做很简单的模块设计或实现。	2022-12-12 21:24:33.412707	f
2204	1149	Issue	5	1，T + 0，流计算，流批一体。\r\n2，AI与数仓的结合\r\n3，数据打通与共享问题\r\n   数据库的互联网时代\r\n4，数据治理，数据的权限问题。\r\n   比如web3.0	2022-12-13 14:32:07.009822	f
2205	968	Issue	5		2022-12-13 16:48:41.421367	f
2207	221	Issue	5	按照人实体行为软件模型。\r\n面试能力可以从三方面：\r\n1，考察基础模块掌握度。\r\n  这个可深可浅，比如将列存存储，事务，Btree与LSM，压缩编码，Cache等。\r\n  也可以浅点，考察布隆过滤器，hashmap等。\r\n  也可以深点，到并发控制的细节，内存管理方法，磁盘技术（比如如何判断磁盘已经压满？）\r\n\r\n2，在往上，参考架构能力\r\n  比如讲自己的设计，讲不同体系的利弊等。\r\n  主要看其如何进行设计。比如可以问：如何运用一些设计原则，如何防止架构腐烂？\r\n\r\n3，看方向的能力\r\n  对前沿技术的了解情况。	2022-12-14 14:35:46.237911	f
2211	1160	Issue	5	1，事务状态怎么记\r\n2，记录与事务状态怎么关联\r\n3，如何回滚\r\n   要注意有些操作天生不可回滚，比如空间扩展，这种扩展是立即对其他事务可见的。\r\n   还有比如对内存的修改，同样在没有锁的保护下，是立即可访问的。\r\n4，如何提供原子操作\r\n5，如何提供自治事务\r\n6，控制文件的实现\r\n7，segment空间管理\r\n8，页级空间管理\r\n9，锁与延迟清理\r\n   记录状态刷新。\r\n10，故障恢复，持久化与checkpoint\r\n11，复制，备份，归档\r\n\r\nmvcc	2022-12-27 13:52:58.701712	f
2212	1097	Issue	5	并行设计	2022-12-27 14:08:28.130686	f
2215	1153	Issue	5		2022-12-28 08:17:14.605959	f
2216	790	Issue	5	比较复杂的地方需注意：\r\n1，并发控制\r\n2，有一致性要求的地方\r\n\r\n其他需注意的：\r\n1，没有暴露的约束\r\n2，软件复杂度引起的错误，误解\r\n   	2022-12-29 15:06:21.957757	f
2220	1159	Issue	5	1，TableDict不应该传入底层结构。\r\n   造成的问题是结构对上层依赖，如果结构用于其他场景会收到影响。\r\n   比如swf用于索引存储。或者用于元数据存储等等。\r\n2，cursor不应该传入底层。这样不同结构的访问会使用大量cursor。如果不同结构复用cursor会造成意外的共享问题。\r\n   cursor这种结构注定放大了范围。\r\n3，结构的dict应该作为结构的部分，属于结构的模块。 	2022-12-30 15:15:22.520725	f
2236	1167	Issue	5	参考资料：\r\nhttps://juejin.cn/post/6873052756203012103\r\nhttps://zhuanlan.zhihu.com/p/428216764	2023-02-01 09:07:19.765112	f
2219	1161	Issue	5	代码已经一坨了，怎么让它清晰起来啊。\r\n\r\n模块的接口使用顺序，参数构建方法，返回值获取方式以及含义等都应该以文档材料说明。\r\n如果有其他潜在约束，也需要加以说明。\r\n模块的设计目的也需加以说明。尤其是其他模块也能做到类似功能时。	2022-12-30 14:45:30.069622	f
2223	1162	Issue	5	s3只提供了cpp接口，可以在上面封装一层，提供c的库。\r\n封装时注意：\r\nhttps://docs.aws.amazon.com/zh_cn/general/latest/gr/signature-version-4.html\r\nhttps://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html\r\n凭证是从ak/sk等生成的，ak/sk可以通过不同的方法提供。\r\n比如环境变量，文件，EC2等等，直接在程序中给出也是一种方式。\r\n可以自己重写credentialProvider，clickhouse就是这么搞的。\r\n然后通过凭证给后续的请求做signature。	2023-01-27 17:29:46.512601	f
2224	984	Issue	5	1，世界是怎样的？\r\n   客观唯心主义，康德：人只能认知现象界，无法了解物自体的本质。\r\n   辩证唯物主义，马克思：客观物质是存在的，物质是运动变化者的。\r\n                         人的意识是客观世界的反应，同时也许遵守客观世界规律。\r\n   我并不完全认为意识仅仅是客观世界的反应，至少在尚未弄清意识起源之前。\r\n   或许真有高维世界呢？AI未来也许就是一个例子。\r\n   \r\n2，可知与不可知。\r\n   即便是唯物主义也无法说明人的意识是否能认知所有事物。\r\n   即彻底的可知无法证明，完全不可知当然也是荒谬的。\r\n   我们依赖生存，就靠着对于现象的共同认知。\r\n3，人生的意义\r\n   就同可知不可知一样，我们无法回答为什么存在。\r\n   但是我们可以选择，比如目的，行为，构建自己周边所有系统等。\r\n   没有人能放下尘世的一切，人总是身处于各种系统中。\r\n   可以砍掉工作，但一般砍不掉家庭，最起码的生存总是要的。\r\n   既然在就得考虑如何在系统中维持生存。\r\n   \r\n4，辩证唯物下的世界   \r\n   世界由人，物以及运动组成。\r\n   从软件(纯意识)看，由人，实体，行为组成。\r\n   只是实体类型千差万别，人又非常复杂，难以完全了解。\r\n5，人当如何生活？\r\n   人的成长过程充满了困难，绝大部分人都是带着各种缺陷。\r\n   有些是环境给予的，天灾，社会家庭环境。有些是我们自己赋予的。\r\n5.1 财富\r\n   人天生在生存恐惧之中，物质匮乏会带来各种负面的影响。\r\n   另外在社会关系中，进一步转换成其他问题，如精神情感无法满足，社会认同差等。\r\n   在解决生存问题时财富是原材料，但是财富也可能出现在虚拟的故事中，成为人们难以满足欲望的体现。\r\n5.2 精神情感\r\n   精神情感贫瘠的人会出现焦虑，逃避，内心恐惧缺乏力量。\r\n   即会减弱人的生命力，去行动构建的能力。\r\n   或者在构建周边系统时，构建出不合适的系统。比如严重依赖家庭或某个团体。\r\n   或通过游戏或物质刺激来转移注意力。\r\n   此外精神情感弱的人还容易示弱，因为本身就弱。\r\n   \r\n5.3 社会关系\r\n   他人的不认可，批评会引起自信心缺乏，成就感缺失，进而引起行动力下降。\r\n   同时关系差更容易进入竞争关系，容易招致他人打压。\r\n   而爱和鼓励则会增强人的自信。\r\n\r\n5.4 强弱关乎生存\r\n   为什么选择下一代，肯定是因为我们更强，或我们选择变强。\r\n   因为我坚信人的力量。\r\n   不被反噬的强大才是真的强。\r\n   \r\n5.5 做正确的事，无为的事\r\n   生存发展而做的事，与贪图功名利禄做的事同样有别。\r\n   为爱与快乐而做的事，与恐惧或欲望而做的当然有区别。\r\n   \r\n5.6 正确的做事\r\n   归纳演绎，科学与实践\r\n   不论哲学还是科学，都得以实践，事实为标准。   \r\n   \r\n我曾经看不到物和事的价值，只是一味的缩减开支，毫无目标的漫游。\r\n大脑沉迷于假大空的故事概念(必然能力不足，行动力弱，缺乏决断，因而精致利己)，无法自拔，思而不学。\r\n半吊子知识分子，高不成，低不就。\r\n书本中各种高大上的述事，而现实世界中很多是小而具体的事。\r\n很少人在读书阶段就能与现实联系起来。缺乏对现实世界的认知，无法发挥书本中知识的力量。\r\n\r\n而如今方知将一切落入到人和事的实践中。去构建系统，构建与人的关系。\r\n编程，生活中的小事，乃至整个社会都有其共性，都可以用类似的方式来表达，然后尝试去解决。\r\n书在事上磨。	2023-01-27 19:32:39.340975	f
2230	1163	Issue	5		2023-01-29 18:14:52.917083	f
2232	1163	Issue	5		2023-01-29 18:31:26.016409	f
2234	1165	Issue	5		2023-01-30 07:25:43.254111	f
2235	1164	Issue	5	这个意识形态很重要，\r\n1,软件是提供行为服务的，软件不仅是计算机代码。\r\n1.1，软件最终是面向人和物(抽象的)的。这决定了软件的开发者不应该面向计算机来实现软件。\r\n     比如我们常用的windows跟现代手机系统在这点上就差距巨大，使用者甚至需要在网上搜索资料才能用。甚至有的问题还得求助于开发人员。\r\n     我们经常被网络配置，硬件管理，扩容等等乱七八糟的事情困扰，一个缺乏明确接口，缺乏完备性的软件是令人头疼的。\r\n1.2，图形界面是面向真实的人的，因而应该先提供服务接口，面向抽象的人，即行为接口。\r\n1.3，软件的计费以及成本应该是明确量化的，包括使用的资源。\r\n\r\n所以现代软件走上serverless的道路，越来越少的人需要去关注计算机，那些硬件，软件配置，操作系统配置，网络配置等细节问题。\r\n细节无关服务，细节应该被隐藏。我们甚至并不关心服务是不是用计算机实现的。所以serverless是回归软件本质的。\r\n\r\n2，软件的发展，变化根本是来自外部人，物，环境，行为的变化。\r\n比如云计算到来，意味着软件的运维发生了变化。AI或许会影响开发者行为。\r\n用户越来越依赖数据决策，上层开发者的述求等等。\r\n所以如果想干一番事业，得去了解这些时势变化。\r\n\r\n	2023-01-31 09:12:40.126249	f
2238	1081	Issue	5	本质上一切对外的表现都尽量应该保持兼容性，具体有：\r\n1，对外RPC，API\r\n2，持久化文件\r\n3，二进制库\r\n4，文档\r\n5，配置文件，对外错误码，报错信息。\r\n6，对外工具\r\n\r\n另外系统由不同服务或进程组成，其间的通信兼容性也要考虑。\r\n\r\n比如数据库的存储，系统表，视图这些也是对外可见的。\r\n因而其名称考虑要长远些，不能因为功能调整导致表实质含义变化，表名或字段就发生变化。\r\n存储结构更是如此，尤其涉及大量数据的格式。\r\n比如一个设计教训，在列格式上将null和数据放在一个segment，结果字段变成nullable之后无法处理。（因为数据页顺序存放）\r\n\r\n持久化结构4字节对齐，预留部分要初始化为0。	2023-02-01 18:10:06.634957	f
2240	1168	Issue	5	还有一种比兼容性更难处理：将一个子结构移动到其他父节点下\r\n比如分布式下基于物理文件的扩缩容。\r\n这里要求底层结构不能对上层产生任何依赖。比如页面不能记录上层spaceId。\r\n另外内存中缓存数据也需要考虑搬迁的影响\r\n	2023-02-01 18:15:57.580669	f
2242	1166	Issue	5		2023-02-03 15:35:09.738182	f
2244	1165	Issue	5	实体：\r\n引用与拷贝的区别，引用产生实体依赖，被引用者必须存在更久。\r\n调用产生逻辑依赖，可见的格式也是逻辑依赖。这些看起来很基本，却是模块化编程的根本。	2023-02-03 15:38:59.595685	f
2246	1160	Issue	5	Thread\r\nMemory\r\nConfig\r\nLog\r\nError\r\nKernel：\r\n1. database\r\n1.1 ctrl\r\n1.2 main tab\r\n1.3 sys tab\r\n2，object\r\n2.1 dict\r\n2.2 struct\r\n2.2.0 ssm\r\n2.2.1 heap\r\n2.2.1.-3 segment\r\n2.2.1.-2 heap ssm\r\n2.2.1.-1 metacache\r\n2.2.1.0 buffer\r\n2.2.1.1 block/page\r\n2.2.1.1.0 block redo\r\n2.2.1.1.1 block undo\r\n2.2.2 btree\r\n3，task\r\n3.1 smon\r\n3.2 rb\r\n\r\n5,persist\r\n5.1 ckpt\r\n5.2 dw\r\n5.3 bw\r\n\r\n6，redo\r\n6.0 atomic\r\n6.1 logic\r\n6.2 arch\r\n6.3 recovery\r\n6.4 buf\r\n\r\n4，handler\r\n4.1 cursor\r\n4.2 xact\r\n4.2.1 undo segment/list\r\n4.2.2 transaction\r\n4.2.2.-1 xrm\r\n4.2.2.0 xat\r\n4.2.2.0.0 xblock/cache\r\n4.2.2.1 xa协议，gtid\r\n4.2.2.2 dirtylist\r\n4.2.3 lock\r\n4.2.4 redo pack	2023-02-09 12:34:39.938353	f
2214	968	Issue	5	结构设计的注意点：\r\n1，参数放大\r\nvrs也存在放大参数的情况。vrs不应该依赖swfDict。\r\n切不可搞cursor这种既是输入又是输出的参数，混淆了模块关系，搞不清楚怎么去调用接口。\r\n也不知道怎么拿接口的输出结果。\r\n\r\n2，下层结构感知上层\r\n这种需利用回调来实现。比如结构不能感知表。\r\n结构可能被表使用，也可能被索引使用。即其上层是未知的。\r\n3，结构的元数据最好与结构本身一起存放。\r\n这样的好处是结构的元数据不必被上层感知，尽量保证其自身的完备性。\r\n这样结构本身可以更好的被复用。否则上层不同场景元数据处理均不一样，也很麻烦。	2022-12-28 07:37:10.503848	f
2217	1161	Issue	5	Swf是否应该引入ColumnDict？然后每列按照ColumnDict作为参数。\r\nswfDict作为整体，扩大了参数范围。   \r\n\r\n结构的Dict应该作为结构的模块，而不是作为dict cache模块。dict Cache不能算作一个模块。\r\n且Dict不应该是一坨，不同子模块有自己的元数据。Dict作为每个模块的self，最重要的结构体而存在。\r\n访问器应该拿到对应需要的最小Dict，最小表Dict信息来实现一个模块。\r\n\r\n否则一个模块就有多个对外的出口。\r\n\r\n甚至我们连一个模块使用说明都写不清楚，ut也写不清楚。\r\n同时引用模块的多个文件，而没用一个单一出口。	2022-12-30 14:43:13.520866	f
2218	1161	Issue	5		2022-12-30 14:43:30.129304	f
2221	1140	Issue	5	1，数据类型没用很好的封装起来，导致到处都是散落的类型转换处理。\r\n  虽然实现了一套函数在各种类型转换，但是没用封装好类型本身。\r\n2，相同类型，行和列有不兼容的格式，同样没用在其他层次封装这种差异，散落了一地。	2023-01-10 07:07:25.828752	f
2247	984	Issue	5	人内心与业力的关系：\r\n先得有自我，然后又不执着于我。这样人可以在各种环境中适应并成为强者。\r\n把自己调整成需要的样子，同时又可以在各种场景切换。\r\n君子不器，做事就得认真不苟，考虑全面。等等。在其他场合规则就会发生一些变化。\r\n环境要求我们的职责并不一样。\r\n即尊重客观，但是又有自己的主见主张。\r\n	2023-02-11 20:20:00.574957	f
2248	1172	Issue	5	如果将一批操作全部记录一条redo内，这条redo要么有效，要么无效（crc校验）。\r\n那么系统就实现了原子性。如果在回复客户端之前，一定能保证redo写好，就对客户端保证了原子性，这就是ceph的原子性原理。\r\n但数据库更复杂，要保证多个长期操作的原子性，那么就必须得通过undo了，否则必须将redo记录完整，且一定成功的情况下才可以执行修改操作。\r\n这对于长事务不现实。\r\n\r\nredo是事务，undo，以及savepoint等模块的基础。在redo之上做事务状态管理。	2023-02-11 22:48:07.866342	f
2249	1173	Issue	5		2023-02-14 12:45:21.027317	f
2250	1173	Issue	5	在频繁分配，高并发的场景下，使用jemalloc或本地缓存比malloc性能高出了4倍。	2023-02-14 12:46:24.244606	f
2251	1159	Issue	5	Lob设计：\r\n单独使用lob segment主要是因为heap segment删除时写undo开销太大。\r\nlob segment的空间通过Lob index segment实现了循环使用的效果。\r\n但是使用文件也不太合适，如果Lob不是很大，那么会产生非常多的小文件。\r\n\r\n页级MVCC：\r\n实际列存做成了按batch来做MVCC，页级MVCC代价太大。\r\n先拷贝到读取缓存，然后在缓存上revert。\r\n\r\n结构的元数据：\r\n使用系统表存这没啥问题。当然也可以使用元数据页面存。\r\n主要问题在于其不必跟表或索引等对象相关联。\r\n这样不利于子结构独立性，当多层子结构嵌套，子结构太多时，涉及子结构元数据的加载。\r\n主要还是解决元数据版本的问题，查询需要用老版本的元数据。\r\n如果底层自行管理元数据，则很合适且独立，使用系统表则总是把子结构与表，列等对象关联上。\r\n\r\n现在实际做成了部分对象使用元数据块，部分使用系统表。\r\n这些都支持MVCC，这没问题。\r\n\r\n其实存储架构设计难点就在于子结构复用。这里是变化最多的。\r\n底层事务虽然复杂，但是机制只有一套。	2023-02-15 14:00:09.545501	f
2252	1159	Issue	5	内核架构的理解：\r\ndevice\r\nctrl redo\r\ntablespace \r\nundo，事务控制块，锁\r\n数据块,buffer\r\n结构(结构的空闲空间管理，结构的元数据及缓存，结构锁，结构访问器) 事务管理，持久化\r\n对象层(对象元数据缓存，对象锁，cursor） 后台数据转移线程等\r\n内核 内核句柄\r\n\r\n其中结构和对象层是变化频繁的。device层也有一些新变化。\r\n	2023-02-16 07:02:38.466224	f
2253	1020	Issue	5	clion激活，注意server模式有时候连不上，可以尝试activate code方式。\r\n\r\n关于选择License server方式和 Activation code的问题：\r\n网络好的情况建议选择License server；\r\n网络不好或者离线状态请选择Activation code。\r\nPS：纠结个毛啊，直接一路默认就很爽！！！	2023-03-01 11:51:50.957849	f
2254	950	Issue	5	一个场景分析：\r\nif (loaded) {\r\n  return;\r\n} else {\r\nspinLock\r\nif (loaded) {\r\nreturn\r\n}\r\nst.x = 1;\r\nst.loaded = true;\r\nspinUnlock\r\n}\r\n\r\nCOD_ASSERT(st.x == 1);\r\n\r\n该程序在并发下是否会挂掉？\r\n答案是会。	2023-03-01 13:42:14.558942	f
2255	1164	Issue	5	软件与人类其他产品一样作为人造物来应对现实世界以及人类社会的挑战。\r\n部分人造物依赖于其他人造物，软件依赖于其他软件，以及硬件实物。\r\n由此而构建出整个人类世界。\r\n\r\n因而软件的变化来自两个方面：\r\n1，上游的变化，外部世界或上游人造物发生变化。\r\n2，下游变化，比如硬件实体或其他底层人造物变化。\r\n\r\n\r\n\r\n	2023-03-02 07:46:03.415838	f
2273	991	Issue	5	结构决定了性能，决定了可变性，也决定了约束。\r\n约束以及其范围的错误认知是复杂度之外导致设计失败的另外一个主要原因。\r\n复杂度一方面由在大范围内不断分化的场景所致，还有一些是为了走短路径而违反结构化原则。\r\n就像编码失败很可能是一直未进行良好的测试一样。\r\n\r\n我们忽视了对立面，因而出现异常与失控。\r\n\r\n程序语言可表达编码，但很少对测试进行限制。\r\n同样程序通常表达了实体以及其行为，但很少去表达约束。\r\n然而约束很多时候是可行以及正确的前提。\r\n\r\nRust语言提供了一种方式：Bound\r\nTrait Bound，可以表达实体的行为约束。\r\nLifetime Bound，表达存在时间的约束。	2023-04-03 07:52:04.796149	f
1872	968	Issue	5	软件设计是将一个事物展开的过程，这与认知事物是相反的过程。\r\n软件出口总是很小，而内涵却很大。\r\n而软件设计的难点也在于如何合适的认知抽象事物。事物涉及的范围越大，就越难以合适的描述。\r\n有人能看到一个房子，有人能看到街道，有人能看到城市，有人能看到国家。\r\n有人能看到一天，有人能看一年，这种顶层认知才是设计的核心，也是设计难的根本所在。\r\n\r\n软件扩展性的理解：\r\n软件扩展是在高度结构化的程序上的继续发展，并非是随意的。\r\n高度结构化的本质在于理清了事物组成部分之间的关系，行为，可见性，约束等等。使得事物有特定的行为或特性。\r\n\r\n软件设计是需要考虑很多维度的，就像打仗不能只考虑对战环节。\r\n这世界本身就是可以从非常多维度去认知的。\r\n\r\n软件设计的常用维度：\r\n1，空间\r\n   对应于物理结构设计，包括软件组件，运行资源，磁盘，内存，CPU，网络等\r\n2，时间\r\n   对应于运行结构设计，线程，进程等，自驱动，如何驱动系统。\r\n3，逻辑\r\n   模块设计，包括实体，实体关系。 行为，行为复杂度等\r\n4，接口与文档\r\n   软件组件发布，接口与文档独立性等。\r\n   开发人员视角。\r\n5，验证\r\n   可测试性，可验证性。\r\n6，配置维护日志等\r\n   运维人员视角，看到组件安装包，哪些模块作为一个组件发布，以及资源占用等。\r\n\r\n这是有了各种不同的维度，不同的要求因而才衍生出各种设计工具，以及不同的设计图。 \r\n详见4+1视图。（用户，物理，逻辑，部署，运行）\r\n但是软件设计的核心是第3点。\r\n开发平台需要做的就是不断的封装，让开发人员聚焦在第三点上。	2021-10-24 07:22:17.673058	f
2222	1160	Issue	5	如果事务必须修改内存，那么有如下处理办法：\r\n1，在事务内修改，但是事务结束时需要根据提交或回滚，做相应的补偿操作。\r\n   不用记录undo，但是撤销操作需要。\r\n2，在事务成功后修改。\r\n   如果该修改本身失败，那需要后续动作进行补偿。\r\n\r\n提交阶段也需要用到原子操作，修改事务控制块的操作，与记录提交的redo需要一起写。	2023-01-11 15:00:46.960362	f
2225	984	Issue	5	2023年更：\r\n1，人生目标不应该是个体意识，而是自己以及周边的系统\r\n   理论体系有了，就不断在此基础上完善，然后在人和事上练。\r\n   不做事，周边系统与关系全部衰竭，则必然变弱。\r\n   不构建系统，则永远成不了。\r\n\r\n2，身边的所有事都可以看成系统，并用形式化方法来分析处理。	2023-01-27 19:47:58.654601	f
2228	1031	Issue	5		2023-01-29 18:03:42.040449	f
2226	106	Issue	5	房子提供了方便性却不认可其价值。\r\n深圳房价高的原因在于其：\r\n1，价值，即提供的学位，生活便利性，气候以及环境优势，工作可获得性，创业机会。\r\n2，投资价值。基于价值。\r\n所以如果不在深圳工作，当然要卖房。\r\n或者有能力在其他地方获取类似的生活质量，教育，便利性也可考虑换。\r\n只要价值没有出现更好的替代物就暂时不换。\r\n\r\n问题的一方面在房价，而另一方面在于我将在哪里做什么。\r\n现在的工作有2个问题：\r\n1，持续性堪忧。\r\n2，无法走向更高的地方。\r\n   独立创业，这或许是一个伪命题，也许现在工作才是创业的好地方。\r\n   至少是调研以及前期准备的好地方。	2023-01-27 20:43:59.56479	f
2227	991	Issue	5	软件bug的根源在于：隐含的约束未被满足。\r\n\r\nrust牛逼在哪？ 通过类型系统，零成本抽象等表达了隐含约束。使得系统的行为符合预期。\r\n\r\n主要有如下几点：\r\n1，动作对称性，资源泄漏基本都是此类问题引起。\r\n2，不安全的函数，不安全的并发访问。其实实例的定义就决定了其是否是线程安全的。\r\n3，数组越界，数值越界。 严格的类型系统。\r\n\r\nC语言怎么写可以达到上述效果？\r\n1，通过命名更显示的表达，比如对称性，open/close， create/destroy\r\n2，通过运行时检查，比如进出次数必须相等，堆栈必须还原。\r\n3，通过对关联动作的封装，简化外部使用。\r\n4，通过用例来表达约束。这一招rust里面也可以用。\r\n5，通过代码分析工具。\r\n	2023-01-29 18:02:20.217696	f
2229	1163	Issue	5		2023-01-29 18:11:48.964921	f
2231	1163	Issue	5		2023-01-29 18:17:30.061531	f
2233	984	Issue	5	1，实相存在，业力也存在。生老病死，欲望功业都是在的。\r\n   在心灵和理念上修无法解决上述问题。\r\n2，佛学致力于解决执着于相的问题，这样可以达成内心的极致平和。\r\n   没有我执，精神消耗就少了，身心放松就更容易处理实相问题。这是间接作用。\r\n3，人的主观感受多来自虚相，即我执对实相加工产生的虚相。\r\n   虚相的产生就是因为有我执，佛教发现的就是这个道理，\r\n   是故众生皆具如来智慧德相，皆因妄想执着不能证得。\r\n\r\n所以活着还是得求道证道，办实事，这样才能增加业力解决实相问题。\r\n但是这过程难免出虚相，这时需要静归。   	2023-01-30 07:20:22.194329	f
2237	1167	Issue	5		2023-02-01 09:17:45.862695	f
2239	1168	Issue	5	本质上一切对外的表现都尽量应该保持兼容性，具体有：\r\n1，对外RPC，API\r\n2，持久化文件\r\n3，二进制库\r\n4，文档\r\n5，配置文件，对外错误码，报错信息。\r\n6，对外工具\r\n\r\n另外系统由不同服务或进程组成，其间的通信兼容性也要考虑。\r\n\r\n比如数据库的存储，系统表，视图这些也是对外可见的。\r\n因而其名称考虑要长远些，不能因为功能调整导致表实质含义变化，表名或字段就发生变化。\r\n存储结构更是如此，尤其涉及大量数据的格式。\r\n比如一个设计教训，在列格式上将null和数据放在一个segment，结果字段变成nullable之后无法处理。（因为数据页顺序存放）\r\n\r\n持久化结构4字节对齐，预留部分要初始化为0。	2023-02-01 18:10:55.289982	f
2241	1169	Issue	5	这样个人的贡献可以很好的跟踪起来。\r\n输出的技术分析等也可以在gitlab上，可以另外用一个gitlab工程。	2023-02-03 08:29:37.724078	f
2148	950	Issue	5	实际只有三个问题：\r\n1，独占性(某个时间区)\r\n  在CPU上有两种实现方式：一是cacheline独占状态，二是总线锁。\r\n2，可见性\r\n  副本相关的问题，如果只有单副本，那么就不存在这个问题。\r\n3，内存序\r\n  内存序是由于编译优化，以及指令乱序执行，cache store非立即可见引起的。\r\n  即其解决的是不同操作数的。\r\n  顺序问题，即先后问题，等待问题。\r\n\r\nvolatile：\r\n1，编译器不能优化到不访问内存，避免使用寄存器优化，这样mesi协议才能起作用。\r\n   即最终其他cpu可以看到该修改，但是没有内存屏障volatile不能解决内存序问题\r\n2，单线程内多个volatile变量之间指令不可乱序  \r\n\r\n内存屏障：\r\nhttps://zhuanlan.zhihu.com/p/125737864\r\nhttps://blog.csdn.net/Soul_wh/article/details/125318641\r\n\r\n内存屏障解决的是cpu cache优化(store buffer与invalid queue)没有及时处理引入的内存序问题。\r\n注意内存屏障并非是通过要求另一个cpu怎么做达到效果的，而只能限定本CPU怎么做。\r\n也因此在c++,rust中原子操作都提供了内存序的选择。（另外原子操作本身可能就是通过cache锁实现的，因而也顺便提供关于cache屏障的能力）\r\n内存屏障有限制CPU重排的作用。即解决了顺序一致性和cache一致性问题。\r\n\r\n原子变量：\r\nhttps://blog.wangzhl.com/posts/gcc-built-in-functions-for-atomic-memory-access/\r\n原子变量GCC实现是带屏障的。原子变量的实现也用到了volatile。\r\ntypedef volatile CodUint32  CodAtomicUint32;\r\n\r\n锁：\r\n锁在访问前有读屏障，释放时有写屏障。\r\n同样锁也是作用在一个CPU上。但因为有共享的内存状态存在，因而达到独占的目的。因此也得使用volatile。\r\ntypedef volatile CodUint32 SpinLock;\r\n锁在顺序，cache一致性，独占(临界等待)三者上都做了保证。\r\n\r\n狭义的原子变量：\r\n1，独占性\r\n因为操作在内存不存在局部失败的问题。\r\n\r\n广义原子性：\r\n1，独占性\r\n2，不可部分失败\r\n  \r\n为啥原子操作的变量需要是volatile的？\r\n由volatile第一点作用推出，原子操作的数据必须是volatile的。\r\n\r\n锁：\r\n1，独占性\r\n2，独占时间\r\n3，关于切换执行的规则\r\n  正是由于第二点，所以才有第三点，锁时间越长，处理方式就越不一样。\r\n4，锁的模式\r\n  区分了读写不能的使用方式\r\n\r\n\r\n从上面看就知道独占性和可见性有点关系，如果只有一份数据，那只要独占就确保了可见性，但是效率低。\r\n多份数据，那么就存在可见性问题，可见性就有时间了，即何时可见最新的副本。	2022-10-13 08:52:53.072121	f
2256	942	Issue	5		2023-03-07 10:25:59.587787	f
2263	1119	Issue	5	YashanDB的存算分离并不彻底，计算组内节点不能缩为0，因为数据本质上还是为计算组划分了。	2023-03-14 18:33:10.564978	f
2264	1161	Issue	5	软件加法做起来很爽，但是会做减法的才是高手。	2023-03-16 13:29:04.189825	f
2267	984	Issue	5	现实世界有其结构与规律，人在内心也模拟构建了自己的世界。\r\n这两者是对一而统一的，相互在发展。\r\n而人的根本性矛盾即在于其结构与现实世界的矛盾。\r\n佛道都倾向于收敛内心世界，降低与现实的摩擦。减少痛苦得身心自由。\r\n儒的思路是用认知改造客观世界。但其问题在于对于世界的认知不足。\r\n毛等走辩证统一道路，世界客观变化，人需要利用客观规律并且保持变化。\r\n西哲也是这条路，自然科学，社会科学知识，然后运用于现实。\r\n\r\n文人的毛病在于陷于文字范式中，一种内卷式的文字结构，脱离于真实世界。\r\n而统治也倾向于疲，穷，愚化底层人民。只要具备这种可能性。\r\n恐惧欲望与愚昧。文人尚可以玩玩文字范式以自娱。其他人沉浸于世俗的牢笼之中。\r\n帝国模式必然如此。但人可以无限可能性。\r\n	2023-03-25 06:46:43.194356	f
2271	1166	Issue	5	软件就是一个树结构。\r\n需求是树在土地上面的部分，软件实现和需求具备一定同构性，软件就是地下的部分。\r\n软件由纷繁复杂的需求场景所塑造。	2023-04-02 05:25:47.42961	f
2275	1189	Issue	5		2023-04-05 22:20:11.948714	f
2276	1191	Issue	5		2023-04-05 22:40:08.658257	f
2274	942	Issue	5	架构设计：\r\n1，不容易出错\r\n2，容易扩展\r\n3，容易调测，跟踪\r\n4，性能好\r\n5，兼容性好\r\n6，资源消耗低，能耗低\r\n\r\n结构的利弊与约束，利弊要考虑上述方面。	2023-04-04 11:47:59.152875	f
2278	962	Issue	5	加并发cpu上不去，2个原因：\r\n1，锁\r\n2，等io，或者io处理时间长。	2023-04-07 16:55:58.12157	f
2279	1053	Issue	5	1，bitshuffle编码\r\n2，压缩与io一个粒度这没啥大问题，但是要支持连续读，保证io可以更大粒度。\r\n   这样在小io时解压代价不会同步提升。	2023-04-10 06:49:27.631679	f
2280	1193	Issue	5		2023-04-11 18:55:32.175966	f
2282	1166	Issue	5	接口与函数的第一个参数非常重要，体现了其模块位置。即self	2023-04-14 14:40:24.820774	f
2285	1157	Issue	5	比如系统内部涉及兼容性，对外接口，配置等变更时需维护一个readme文档	2023-04-23 12:07:47.317598	f
2287	962	Issue	5	pipeline本质就是流水线，流水线为啥能提升性能，与并行的关系是啥？\r\n向量化换种说法就是批量处理。\r\n\r\n流水线(并行(预处理(批量化(免拷贝(结构化)))))\r\n预处理包括预计算，缓存，预读等.\r\n结构化指结构针对最有行为设计，从而可以用最小的io，网络，计算次数来完成。\r\n常用技术有数据组织，编码压缩，过滤等。	2023-04-24 07:15:01.598131	f
2288	1195	Issue	5	亮点： \r\n1，实时分析\r\n    冷热分离，热数据实时同步\r\n2，极致性能\r\n    热冷数据统一列式存储\r\n     冷数据极致压缩编码\r\n     索引，条件下推，向量计算优化\r\n     bulkload导入\r\n3，SQL与事务\r\n    完善的SQL支持\r\n     事务一致性及隔离保障\r\n     支持唯一性约束等\r\n4，低成本\r\n    存算分离，冷数据对象存储，本地缓存加速\r\n	2023-04-25 09:05:06.353053	f
2243	984	Issue	5	从某种程度来说，不仅软件是这种结构，整个社会都可以投射出类似结构。\r\n而从事的行业以及理解成在树的不同部位去用功。\r\n这样看整个人生与软件是同构的，生活与软件也是同构的。\r\n\r\n从功业来说，做更顶层的事业力更大，但是做错了代价也更大。\r\n做底层的事功业小，但是错了代价也小。主要还是要适合自己的喜好和能力。\r\n另外事物都有其完整性，有了开头就得有结尾，世人通常只取美好部分，而忽视其他部分。\r\n人应该慎重的选择物质和信息摄入。\r\n人需要功业来维持身体与外界的能量交换。\r\n\r\n做事的时候聚集精神，在当下上用功做好。不要心神涣散。\r\n养神的时候就静心养神，锻炼自己的精神力。\r\n人有物质和意识，意识的运转需要心神。锻炼身体和锻炼心神同样重要。\r\n保持物质，精神的平衡，人就会处于舒适愉悦的状态。\r\n一般都会比较缺的人，容易搞过。比如经常饿肚子的人容易吃多。\r\n经常震荡难以维持平衡。\r\n\r\n总结：\r\n1，明确结构，以及自己位置，功业效率最优化\r\n2，知事物的正反\r\n3，保持平衡\r\n\r\n人痛苦的根源是自己在社会体系结构中的位置不符合预期。\r\n往上求不得，往下求不得，维持着有担心结构解体。\r\n实际上哪有这么多问题呢，做就好了，该上上，该下下。	2023-02-03 15:38:05.546196	f
2257	942	Issue	5	维基：软件架构是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。软件架构會包括軟體組件、組件之間的關係，組件特性以及組件間關係的特性[1]\r\n\r\n1，实体森林体系,\r\n2，结构之间的参数实体，协议。\r\n3，大量实体都必需具备的属性，即软件文化，需要广泛遵守与认可。不仅是code实体，还有虚拟人实体。\r\n  	2023-03-07 10:33:01.932245	f
2258	1179	Issue	5	TP重事务，行级事务，点查。\r\nAP重查询，批量化处理	2023-03-07 13:43:53.074485	f
2260	1166	Issue	5	软件结构还需要考虑：\r\n1,每个层次的接口\r\n2,接口中作为流动实体的结构，尤其是大量数据传输结构。外部通信结构\r\n3,再往下就是资源管理，包括内存资源，CPU，存储等。\r\n4,再往下就是跨平台支持\r\n\r\n从整体而言仍然是树，但是树中不仅有抽象结构，还有物理结构。\r\n	2023-03-11 11:48:02.920198	f
2261	1144	Issue	5	最近感悟：\r\n1,一定是大臂抬起，小臂放松，才好鞭打。\r\n2,反手击球一定是最好跨出右腿瞬间，这样才是左腿发力，大臂带动。\r\n3,击球瞬间一定是回动步，而不是去步。击球完成则开始了回动。	2023-03-12 16:13:06.864598	f
2262	1174	Issue	5		2023-03-12 16:13:40.242129	f
2259	984	Issue	5	软件与组织同构，组织不团结则软件也零散，无法形成一体化的竞争力。\r\n所以软件长成什么样，取决于我们如何对待身边的人。\r\n我们的客户，是强制还是抱养，是迎合还是引导？\r\n\r\n组织内也是如此，利益斗争与合作共赢。\r\n利益斗争可适当激发战斗力，合作共赢可激发整体效益。\r\n个人也是如此，一个人躺平，或追随世俗，不坚定走自己的路就没法找到自己。\r\n但如果不顾客观事实，与他人合作学习，那也难以改进自己。\r\n\r\n架构或许能决定竞争力，但文化才决定了生命力。\r\n组织中的个体需要自己独立顽强的生存，同时也需要来自组织的帮忙与关心。\r\n\r\n因为需要压榨，所以信息不对称，所以走压迫之路。\r\n要传递生存危机，同时也要共享收益。\r\n透明，开放，信任，真诚的环境才好搞出事情，并非说没有惩罚，而是要透明且开放，得有审判过程，而不是一言堂。\r\n\r\n一方面鼓励团队互相抢食，另外还说团结合作。除非所有人承认不平衡性。这点是反人性的。\r\n另外一个矛盾就是团队领袖的个人危机，即他希望下属有斗争制衡。以维持树形权利结构。\r\n即组织权力不可私有，应该共有，必需在组织内进行公开选举。\r\n以及明确权力对应的职责和利益。\r\n\r\n\r\n	2023-03-09 06:33:12.069161	f
2265	1183	Issue	5	https://docs.oracle.com/javase/8/docs/api/java/sql/package-summary.html\r\n\r\nhttps://docs.oracle.com/javase/tutorial/jdbc/basics/index.html	2023-03-22 17:56:41.091164	f
2268	984	Issue	5	这世界最有趣的就是我们拥有一个无限潜力的大脑，而世界恰好也是纷繁复杂的，因而有了无限的可能性。\r\n否则就是一潭死水。	2023-03-25 06:55:35.999659	f
2266	950	Issue	5	http://www.wowotech.net/memory_management/456.html\r\nX86没有invalid queue，同时Store buffer是fifo的，因而只有store load问题。\r\n\r\n解释下什么是StoreStore，StoreLoad，LoadLoad，LoadStore。\r\n前提：在一个CPU执行的Load与Store命令顺序确定的情况下，其他CPU受cache影响后看到的效果。     \r\n\r\nStoreStore问题是说：在CPU上Store a，Store b顺序执行，在其他CPU读取时是否假设b更新了，a一定更新了。\r\nStoreLoad问题是说：在CPU上Store a，load B顺序执行，在其他CPU是否可假设b读了，则a一定写了。\r\n              在x86下保证不了，因为a可能写到store buffer。其他CPU看不到。\r\n// store-load的乱序\r\nvoid* demo_2_thread_A(void* arg)\r\n{\r\n    waitAllThreadReady(&threadReady1, &threadReady2);\r\n\r\n    a = 1;\r\n    MFENCE; // 这里不加，几秒会core，这里虽然a执行先于b，但是a的最新值在其他线程不可见。\r\n    if (b == 0) {\r\n        assert(flag == 0);\r\n        flag = 1;\r\n    }\r\n}\r\n\r\n// store-load的乱序\r\nvoid* demo_2_thread_B(void* arg)\r\n{\r\n    waitAllThreadReady(&threadReady2, &threadReady1);\r\n\r\n    b = 1;\r\n    if (a == 0) {\r\n        assert(flag == 0);  // A和B，最多只有一个线程能走到这里\r\n        flag = 1;\r\n    }\r\n}\r\n\r\n\r\nLoadLoad问题是说：在CPU上load a，load B顺序执行，在其他CPU看是否load b执行了，则load a必然执行。\r\n              例如CPU1执行了s a, mfence, s b。是否CPU2读到B的的新版本，则一定也能读到a的新版本。\r\n              CPU1: a++； mfence; b++, \r\n              CPU2: assert(b >= a);    \r\nLoadStore问题是说，造CPU上执行了load a，store b，其他CPU看到store b执行了，那么a是否一定会加载？\r\n             x86下没有invalid queue，我理解这个问题没关系，顶多是b效果被延迟看到。\r\n\r\n注意一点，内存屏障，锁都是限制单线程的行为的。\r\n	2023-03-23 17:46:10.74695	f
2269	1185	Issue	5	数据库的数据类型非常丰富。\r\n除了数值类型，字符串，二进制，还有number，各种时间，各种lob，json, gis，以及行业数据结构。\r\n\r\n结构映射万物，结构产生行为。\r\n万物皆结构。万物皆类型。\r\n\r\n数据类型的丰富，也即现实世界的丰富化。	2023-03-27 18:53:58.082149	f
1931	1008	Issue	5	接口是架构的关键部分，应该有核心程序员来编写。\r\n\r\n接口最小信息原则。\r\n1.尽可能少接口，接口尽可能少参数。用户只需感知其需要的参数。\r\n2.最常用路径简化，按照事物由简单到分化的原则来设计接口。	2022-02-17 06:58:37.929769	f
2270	1158	Issue	5		2023-04-02 05:22:20.490995	f
2272	991	Issue	5		2023-04-03 07:51:50.658969	f
2277	1189	Issue	5	怎么做补充1：\r\n发现结构性问题，解决有"价值"的问题。\r\n上面来的问题值钱，下面来的问题费心费力不赚钱。\r\n通过解决上面的问题才能缓解下面的压力，为缓解争取环境和时间。\r\n技术中层必需往上走，并将知识传递给下层，组织才能获得成长。\r\n而这个前提是中层的利益需要得以保障，否则路径就行不通。\r\n\r\n通过结构性的思考来整体的解决问题，赢得良性发展。\r\n\r\n中国社会就是中间缺乏症，顶层依赖太重难以变化，底层压力太大也难以变化。\r\n但如果顶层放松管控，让中层活跃起来，让知识流动到下层，就有希望。\r\n目前看非常难，顶层严格控制。顶层而言安全需求是第一位的，发展其次。	2023-04-06 06:57:58.459379	f
2281	1193	Issue	5	StarRock 云化方案：\r\n1，将BE作为热数据存储。长期看其思路是将其作为一个特殊的VM。\r\n   无法\r\n2，独立出CN Group来处理计算，有点类似VM，但其思路主要是vm内扩展。\r\n   snowflake更倾向于扩展新的vm。\r\nhttps://zhuanlan.zhihu.com/p/544132074\r\n计算节点无状态化，方便实现极致的弹性扩缩容。\r\n\r\nGauss DWS：https://bbs.huaweicloud.com/live/DTT_live/202303291630.html\r\n\r\n元数据独立之后本地事务的实时性会受到一定影响。\r\n元数据以及事务信息不在DN上，如何做到实时事务？\r\n\r\n架构1：计算组内分DN和PN，PN所有计算共享。\r\n       这种不同查询资源完全不隔离。\r\n\t   \r\n架构2：纵向分计算组，横向分VM。有热数据VM 和其他VM。\r\n       计算组基于分布，在计算组内扩PN。VM由各计算组内PN组成。\r\n       问题：1，VM最小规模就是每个计算组一个PN。\r\n\t\t\t 2，按计算组来划分查询请求，则可能压力负担不均衡。\r\n\t            其他计算组的PN没活干。\r\n\t\t\t 3，此外如果计算组内的PN挂了，那整个VM的查询就玩不下去了。\r\n\t\t\t\t\r\n架构3：VM独立概念，可以将热数据的计算组包装成VM。\r\n       另外还有独立的纯查询VM。纯查询VM可独立扩展。\r\n       问题：1，元数据怎么获取？\r\n\t   一种思路是将热数据Vm，同时也作为元数据存储。\r\n\t   思路2是将冷数据的元数据下层到对象存储。其他VM从对象存储获取。\r\n\t   \r\n架构4：snowfalke架构，不含热数据VM，DN统一无状态。状态由独立元数据集群管理。\r\n       DN也没主备之分。\r\n\t   可以支持超大规模集群。\r\n\t   \r\n\t   \r\n\t   	2023-04-12 11:56:55.248266	f
2283	1194	Issue	5	能否让软件构建效率极大提升，重回个人时代。	2023-04-19 13:10:35.602956	f
2284	1194	Issue	5	软件构建之难：\r\n1，比如有代码缺无测试，可自动化测试性并非在最初就引入项目中。\r\n2，比如约束，约束完整性就项目过程中几乎无法准守，这也是软件经常出问题的原因。\r\n3，分离的文档和测试管理，所有项目相关的都应该在git项目中管理。\r\n4，结构设计合理性与完善性。\r\n   业务架构翻译到软件架构的合理性。这里还涉及结构创新。\r\n\r\n我不需要你保证，我需要一个系统能自动化的保证。	2023-04-19 13:24:52.428143	f
2286	1144	Issue	5	为啥要架拍，因为没架，就没有引拍，就出不来大臂带动小臂，鞭打的效果。\r\n同样为啥要侧身？因为不侧身就没有转体带动。\r\n反手也也是，反手也需要侧身位，不然只能折叠腰腹来发力。	2023-04-24 06:34:40.426833	f
\.


--
-- Name: journals_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.journals_id_seq', 2288, true);


--
-- Data for Name: member_roles; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.member_roles (id, member_id, role_id, inherited_from) FROM stdin;
1	1	3	\N
2	2	3	\N
3	3	3	\N
4	4	3	\N
5	5	3	\N
6	6	3	\N
7	7	3	\N
8	8	3	\N
9	9	3	\N
10	10	3	\N
11	11	3	\N
12	12	3	\N
13	13	3	\N
16	16	3	\N
17	17	3	\N
18	18	3	\N
19	19	3	\N
20	20	3	\N
21	21	3	\N
22	22	3	\N
24	24	3	\N
25	25	3	\N
26	26	3	\N
27	27	3	\N
28	28	3	\N
29	29	3	\N
30	30	3	\N
31	31	3	\N
32	32	3	\N
33	33	3	\N
34	34	3	\N
\.


--
-- Name: member_roles_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.member_roles_id_seq', 34, true);


--
-- Data for Name: members; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.members (id, user_id, project_id, created_on, mail_notification) FROM stdin;
1	5	1	2017-09-09 13:44:14.789108	f
2	5	2	2017-09-29 15:10:43.170467	f
3	5	3	2018-09-21 12:40:30.177546	f
4	5	4	2018-09-21 12:43:25.159787	f
5	5	5	2018-10-06 06:52:05.913283	f
6	5	6	2018-10-06 06:55:05.142788	f
7	5	7	2018-10-06 06:58:50.469603	f
8	5	8	2018-10-06 19:30:02.336985	f
9	5	9	2018-10-11 07:38:55.381493	f
10	5	10	2018-10-23 08:46:47.550045	f
11	6	11	2018-11-02 21:17:56.13826	f
12	5	11	2018-11-02 21:44:20.988067	f
13	6	12	2018-11-04 09:26:25.382233	f
16	5	15	2018-12-01 16:16:30.686479	f
17	5	16	2019-02-15 07:00:28.179207	f
18	5	17	2019-02-20 08:44:13.828998	f
19	5	18	2019-03-06 22:42:24.328044	f
20	6	19	2019-03-18 07:36:59.035039	f
21	6	20	2019-03-18 08:22:17.451149	f
22	6	21	2019-03-18 15:34:34.970119	f
24	5	23	2019-05-13 06:55:47.29369	f
25	5	24	2019-09-23 07:20:38.678478	f
26	5	25	2020-05-14 06:51:50.829848	f
27	5	26	2020-05-17 07:44:31.253933	f
28	5	27	2020-12-07 06:19:36.700285	f
29	5	28	2020-12-13 07:53:20.550395	f
30	5	29	2020-12-24 19:03:36.901619	f
31	5	30	2021-01-18 05:59:38.582174	f
32	5	31	2022-04-08 05:58:20.014419	f
33	5	32	2022-05-16 05:59:27.141127	f
34	5	33	2022-07-20 07:08:33.096073	f
\.


--
-- Name: members_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.members_id_seq', 34, true);


--
-- Data for Name: messages; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.messages (id, board_id, parent_id, subject, content, author_id, replies_count, last_reply_id, created_on, updated_on, locked, sticky) FROM stdin;
\.


--
-- Name: messages_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.messages_id_seq', 1, false);


--
-- Data for Name: news; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.news (id, project_id, title, summary, description, author_id, created_on, comments_count) FROM stdin;
1	1	成立共进会	研讨以下几个方面的问题：1，产品路线  2，业界资讯  3，人才发掘  4，体系改进   	不讨论：产品进度，特性开发，bug修复，性能测试等具体任务。\r\n\r\n非官方组织，第一批由公司少数骨干自由加入\r\n\r\n进入标准：发表一个上述主题的演讲，被其他成员认可。	5	2017-11-02 06:58:54.218828	1
2	1	mos组发展建议	讨论人才需求，产品线路，内部流程体系，软件大体分割，组织结构划分等。	软件是有生命的，在不同方向都需要发展，每个方向都有做不完的事情，但是术业有专攻。\r\n\r\n事情有需要做的，有不需要做的，有可以小做的，有需要大做的。\r\n\r\n人可以兼任，但是角色不能缺失。\r\n\r\n行业调研，社区跟踪，创新规划这方面需要一个有经验，有前瞻性的人。  *这是组织的眼睛*\r\n\r\n产品落实，方案设计，软件实现，功能测试，自测(这块完全没做起来)。\r\n集成测试。\r\n文档，安全整改\r\n运维\r\n\r\n这些都是需要的角色。\r\n\r\n我们的招人的目标是找到对我们缺乏角色 正好有兴趣，有志于在这些领域发力的人。\r\n我们需要招的是有追求的人，而不是仅仅完成工作的人。严格工作验收标准。\r\n\r\n让组织进入正向循环，我们不加班，但是要求良好的身体状态，高效的工作。\r\n\r\n我们不仅是一个工作团体，还是一个相互促进的团体，一个让人变得更好的团队。\r\n\r\n我们的使命：用创新存储技术定义美好未来 \r\n	5	2017-11-02 07:24:17.818835	0
\.


--
-- Name: news_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.news_id_seq', 2, true);


--
-- Data for Name: open_id_authentication_associations; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.open_id_authentication_associations (id, issued, lifetime, handle, assoc_type, server_url, secret) FROM stdin;
\.


--
-- Name: open_id_authentication_associations_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.open_id_authentication_associations_id_seq', 1, false);


--
-- Data for Name: open_id_authentication_nonces; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.open_id_authentication_nonces (id, "timestamp", server_url, salt) FROM stdin;
\.


--
-- Name: open_id_authentication_nonces_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.open_id_authentication_nonces_id_seq', 1, false);


--
-- Data for Name: projects; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.projects (id, name, description, homepage, is_public, parent_id, created_on, updated_on, identifier, status, lft, rgt, inherit_members, default_version_id, default_assigned_to_id) FROM stdin;
25	BEAS2.0	记录开发任务，以及自发现任务		f	\N	2020-05-14 06:51:50.656823	2020-05-30 18:20:41.907398	beas2-0	1	1	2	f	\N	\N
27	软件开发技巧			t	\N	2020-12-07 06:19:36.541384	2020-12-07 06:19:36.541384	design_dev	1	59	60	f	\N	\N
10	行业与市场调研	了解市场行情，技术趋势等		f	\N	2018-10-23 08:46:47.501908	2019-02-03 17:16:47.631665	business	1	51	52	f	\N	\N
4	英语学习	为了远离贫乏无趣的垃圾新闻，资讯		t	\N	2018-09-21 12:43:25.125945	2018-11-04 09:06:43.287005	english	1	49	50	f	\N	\N
7	计算机学习	学习计算机相关知识，包括数学知识等		f	\N	2018-10-06 06:58:50.439351	2018-11-02 21:12:10.930594	algorithm	1	53	54	f	\N	\N
26	编程语言			t	\N	2020-05-17 07:44:31.134989	2020-05-17 07:44:31.134989	language	1	41	42	f	\N	\N
28	物理学			t	\N	2020-12-13 07:53:20.495402	2020-12-13 07:53:20.495402	physical	1	39	40	f	\N	\N
18	脑洞想法	描述关于创业的各方面		f	\N	2019-03-06 22:42:24.284928	2021-01-04 20:55:36.464316	trade	1	47	48	f	\N	\N
23	软件工程&语言问题	任何领域有脉络，也有细节，此工程记录相关的细节		t	\N	2019-05-13 06:55:47.100097	2021-06-25 07:44:55.719911	software_engineering	1	57	58	f	\N	\N
32	数学及问题解决			t	\N	2022-05-16 05:59:27.122688	2022-05-16 05:59:27.122688	math_question	1	37	38	f	\N	\N
11	个人形象	整理个人形象相关知识		t	\N	2018-11-02 21:17:56.088144	2018-11-03 06:13:12.042154	my_show	1	21	22	f	\N	\N
2	s3client	使用go开发一个简单的s3 client,命令行方式，可以在windows和linux上运行。		f	\N	2017-09-29 15:10:43.099959	2018-11-04 08:57:35.201875	s3client	1	17	18	f	\N	\N
9	三人行必有我师	注意自己思维上可能存在的漏洞，同时明白自己存在的局限性。 这样经常自省，同时善于与人合作，借用别人的长处。		f	\N	2018-10-11 07:38:55.35387	2019-02-03 17:15:37.076377	improve	1	19	20	f	\N	\N
8	人，心理，性格	了解关于人的一切		f	\N	2018-10-06 19:30:02.311049	2019-02-03 17:15:52.348994	disposition_psychological	1	23	24	f	\N	\N
29	dailylog			t	\N	2020-12-24 19:03:36.866642	2020-12-24 19:03:36.866642	dailylog	1	15	16	f	\N	\N
1	ceph jewel	mos，对象存储，基于http的restful api，提供对象处理等增值功能	http://ceph.com/	f	\N	2017-09-08 11:35:55.561573	2018-12-08 22:13:03.174772	ceph-jewel	1	13	14	f	\N	\N
5	政经法文史哲	记录自己阅读过的经济，政治，法律知识		f	\N	2018-10-06 06:52:05.872179	2019-02-03 17:16:25.760802	zjf	1	35	36	f	\N	\N
21	房屋装修知识篇	2019年完成第一套房屋装修\r\n\r\n\r\n\r\n		t	\N	2019-03-18 15:34:34.925627	2019-03-18 15:34:59.894009	family-1	1	33	34	f	\N	\N
19	家庭会议及活动安排	讨论关于家庭的大小事件及对假期的各种安排		t	\N	2019-03-18 07:36:58.967809	2019-03-18 07:36:58.967809	family	1	29	30	f	\N	\N
33	YashanDB开发			t	\N	2022-07-20 07:08:33.034012	2022-07-20 07:08:33.034012	yashandb	1	11	12	f	\N	\N
15	羽毛球	记录羽毛球技术理解，通过羽毛球琢磨明白高手之路，不仅在羽毛球，也在其他任何自己想做的事情上。\r\n身体运用之妙，与大脑有相似之处。		f	\N	2018-12-01 16:16:30.629822	2022-10-23 12:23:15.672807	badminton	1	43	44	f	\N	\N
17	SICS	数据库，数据分析加速		t	\N	2019-02-20 08:44:13.769895	2019-04-22 12:51:06.139828	sics	1	9	10	f	\N	\N
16	Cuckoo	时间记录		f	\N	2019-02-15 07:00:28.049879	2020-05-30 18:20:35.63685	cuckoo	1	5	6	f	\N	\N
12	谢震成长专辑	1、观察记录谢震成长过程中的日常\r\n2、学习解决育儿过程中遇到的困难\r\n3、记录思考自身在育儿过程中的成长		t	\N	2018-11-04 09:26:25.336824	2018-11-04 09:26:25.336824	child_rearing	1	55	56	f	\N	\N
20	职业转型探索	通过向专业人士进行职业生涯进行咨询及规划\r\n通过行动去探索了解职业能力\r\n通过思考去完成职业方向的重订\r\n\r\n链接身边的人和事，逐步梳理出自己想要的方向		t	\N	2019-03-18 08:22:17.376321	2019-03-18 08:22:17.376321	work	1	45	46	f	\N	\N
30	体能daily	早上A套餐：\r\n1, 7点起床，拉升5分钟。\r\n2，每天早上在家跑3公里，大约花费20分钟\r\n3，完事后3分钟静蹲，2分钟脚踝练习\r\n\r\n中午B套餐：\r\n1，饭后静走10分钟\r\n2，拉升10分钟\r\n\r\n晚上B套餐(10点前回家)：\r\n1，热身5分钟\r\n2，练习平板撑10分钟\r\n3，卷腹10分钟\r\n4，挥拍练习10分钟(可选)\r\n5，拉升5分钟		f	\N	2021-01-18 05:59:38.521598	2021-01-18 05:59:38.521598	bodydaily	1	27	28	f	\N	\N
6	思考方法与原则	记录各种思考方法，以及各种观点，作为原则。\r\n\r\n以不断丰富自我这台机器。		f	\N	2018-10-06 06:55:05.113616	2019-02-03 17:16:09.051381	think_idea	1	31	32	f	\N	\N
31	从头写一个存储引擎			f	\N	2022-04-08 05:58:19.87636	2022-04-08 05:58:19.87636	mystore	1	25	26	f	\N	\N
3	Linux	我不确定我能做到什么程度，也不确定爱到什么程度。\r\n它就像深山中的美女一样，但是我还没走进美丽的山谷，也无从窥探其美貌。		f	\N	2018-09-21 12:40:30.122716	2018-11-02 21:11:04.466525	linux	1	7	8	f	\N	\N
24	Coral	AC storage engine 		t	\N	2019-09-23 07:20:38.632257	2019-09-23 07:21:23.554092	coral	1	3	4	f	\N	\N
\.


--
-- Name: projects_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.projects_id_seq', 33, true);


--
-- Data for Name: projects_trackers; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.projects_trackers (project_id, tracker_id) FROM stdin;
1	3
1	4
1	5
1	6
1	7
2	3
2	4
2	6
2	7
1	8
1	9
3	6
3	7
3	8
4	6
4	7
4	8
6	6
6	7
6	8
7	6
7	7
7	8
8	6
8	8
5	6
5	8
9	6
9	8
10	3
10	6
10	8
11	6
11	8
12	8
12	6
15	6
15	8
16	7
17	6
17	7
17	8
18	6
18	8
19	6
19	8
20	6
20	8
21	6
21	8
23	6
23	8
24	3
24	6
24	8
25	3
25	7
26	6
26	8
27	3
27	6
28	3
28	6
28	8
29	3
29	6
30	10
31	6
32	6
33	3
33	4
33	7
\.


--
-- Data for Name: queries; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.queries (id, project_id, name, filters, user_id, column_names, sort_criteria, group_by, type, visibility, options) FROM stdin;
\.


--
-- Name: queries_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.queries_id_seq', 1, false);


--
-- Data for Name: queries_roles; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.queries_roles (query_id, role_id) FROM stdin;
\.


--
-- Data for Name: repositories; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.repositories (id, project_id, url, login, password, root_url, type, path_encoding, log_encoding, extra_info, identifier, is_default, created_on) FROM stdin;
\.


--
-- Name: repositories_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.repositories_id_seq', 1, false);


--
-- Data for Name: roles; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.roles (id, name, "position", assignable, builtin, permissions, issues_visibility, users_visibility, time_entries_visibility, all_roles_managed, settings) FROM stdin;
2	Anonymous	0	t	2	---\n- :view_messages\n- :view_issues\n- :view_news\n	default	all	all	t	\N
3	队友	1	f	0	---\n- :add_project\n- :edit_project\n- :close_project\n- :select_project_modules\n- :manage_members\n- :manage_versions\n- :add_subprojects\n- :manage_public_queries\n- :save_queries\n- :view_messages\n- :add_messages\n- :edit_messages\n- :edit_own_messages\n- :delete_own_messages\n- :manage_boards\n- :view_calendar\n- :view_documents\n- :add_documents\n- :edit_documents\n- :view_files\n- :manage_files\n- :view_gantt\n- :view_issues\n- :add_issues\n- :edit_issues\n- :copy_issues\n- :manage_issue_relations\n- :manage_subtasks\n- :set_issues_private\n- :set_own_issues_private\n- :add_issue_notes\n- :edit_issue_notes\n- :edit_own_issue_notes\n- :view_private_notes\n- :set_notes_private\n- :view_issue_watchers\n- :add_issue_watchers\n- :delete_issue_watchers\n- :import_issues\n- :manage_categories\n- :view_news\n- :manage_news\n- :comment_news\n- :view_changesets\n- :browse_repository\n- :commit_access\n- :manage_related_issues\n- :manage_repository\n- :view_time_entries\n- :log_time\n- :edit_time_entries\n- :edit_own_time_entries\n- :manage_project_activities\n- :view_wiki_pages\n- :view_wiki_edits\n- :export_wiki_pages\n- :edit_wiki_pages\n- :rename_wiki_pages\n- :delete_wiki_pages\n- :delete_wiki_pages_attachments\n- :protect_wiki_pages\n- :manage_wiki\n	default	members_of_visible_projects	own	t	--- !ruby/hash:ActiveSupport::HashWithIndifferentAccess\npermissions_all_trackers: !ruby/hash:ActiveSupport::HashWithIndifferentAccess\n  view_issues: '1'\n  add_issues: '1'\n  edit_issues: '1'\n  add_issue_notes: '1'\n  delete_issues: '1'\npermissions_tracker_ids: !ruby/hash:ActiveSupport::HashWithIndifferentAccess\n  view_issues: []\n  add_issues: []\n  edit_issues: []\n  add_issue_notes: []\n  delete_issues: []\n
1	Non member	0	t	1	---\n- :add_project\n- :save_queries\n- :view_messages\n- :add_messages\n- :edit_own_messages\n- :delete_own_messages\n- :view_documents\n- :add_documents\n- :edit_documents\n- :view_issues\n- :add_issues\n- :edit_issues\n- :copy_issues\n- :manage_subtasks\n- :add_issue_notes\n- :edit_issue_notes\n- :view_news\n	default	all	all	t	--- !ruby/hash:ActiveSupport::HashWithIndifferentAccess\npermissions_all_trackers: !ruby/hash:ActiveSupport::HashWithIndifferentAccess\n  view_issues: '1'\n  add_issues: '1'\n  edit_issues: '1'\n  add_issue_notes: '1'\n  delete_issues: '1'\npermissions_tracker_ids: !ruby/hash:ActiveSupport::HashWithIndifferentAccess\n  view_issues: []\n  add_issues: []\n  edit_issues: []\n  add_issue_notes: []\n  delete_issues: []\n
\.


--
-- Name: roles_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.roles_id_seq', 3, true);


--
-- Data for Name: roles_managed_roles; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.roles_managed_roles (role_id, managed_role_id) FROM stdin;
\.


--
-- Data for Name: schema_migrations; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.schema_migrations (version) FROM stdin;
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
20090214190337
20090312172426
20090312194159
20090318181151
20090323224724
20090401221305
20090401231134
20090403001910
20090406161854
20090425161243
20090503121501
20090503121505
20090503121510
20090614091200
20090704172350
20090704172355
20090704172358
20091010093521
20091017212227
20091017212457
20091017212644
20091017212938
20091017213027
20091017213113
20091017213151
20091017213228
20091017213257
20091017213332
20091017213444
20091017213536
20091017213642
20091017213716
20091017213757
20091017213835
20091017213910
20091017214015
20091017214107
20091017214136
20091017214236
20091017214308
20091017214336
20091017214406
20091017214440
20091017214519
20091017214611
20091017214644
20091017214720
20091017214750
20091025163651
20091108092559
20091114105931
20091123212029
20091205124427
20091220183509
20091220183727
20091220184736
20091225164732
20091227112908
20100129193402
20100129193813
20100221100219
20100313132032
20100313171051
20100705164950
20100819172912
20101104182107
20101107130441
20101114115114
20101114115359
20110220160626
20110223180944
20110223180953
20110224000000
20110226120112
20110226120132
20110227125750
20110228000000
20110228000100
20110401192910
20110408103312
20110412065600
20110511000000
20110902000000
20111201201315
20120115143024
20120115143100
20120115143126
20120127174243
20120205111326
20120223110929
20120301153455
20120422150750
20120705074331
20120707064544
20120714122000
20120714122100
20120714122200
20120731164049
20120930112914
20121026002032
20121026003537
20121209123234
20121209123358
20121213084931
20130110122628
20130201184705
20130202090625
20130207175206
20130207181455
20130215073721
20130215111127
20130215111141
20130217094251
20130602092539
20130710182539
20130713104233
20130713111657
20130729070143
20130911193200
20131004113137
20131005100610
20131124175346
20131210180802
20131214094309
20131215104612
20131218183023
20140228130325
20140903143914
20140920094058
20141029181752
20141029181824
20141109112308
20141122124142
20150113194759
20150113211532
20150113213922
20150113213955
20150208105930
20150510083747
20150525103953
20150526183158
20150528084820
20150528092912
20150528093249
20150725112753
20150730122707
20150730122735
20150921204850
20150921210243
20151020182334
20151020182731
20151021184614
20151021185456
20151021190616
20151024082034
20151025072118
20151031095005
20160404080304
20160416072926
20160529063352
20161001122012
20161002133421
20161010081301
20161010081528
20161010081600
20161126094932
20161220091118
20170207050700
20170302015225
20170309214320
20170320051650
20170418090031
20170419144536
\.


--
-- Data for Name: settings; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.settings (id, name, value, updated_on) FROM stdin;
1	default_projects_public	1	2017-09-09 14:01:14.750486
2	default_projects_modules	---\n- issue_tracking\n- time_tracking\n- news\n- documents\n- files\n- wiki\n- repository\n- boards\n- calendar\n- gantt\n	2017-09-09 14:01:14.772669
3	default_projects_tracker_ids	--- []\n	2017-09-09 14:01:14.77768
4	sequential_project_identifiers	0	2017-09-09 14:01:14.78175
5	new_project_user_role_id	3	2017-09-09 14:01:14.785668
6	cross_project_issue_relations	0	2017-09-09 14:23:28.046273
7	link_copied_issue	ask	2017-09-09 14:23:28.050932
8	cross_project_subtasks	tree	2017-09-09 14:23:28.054774
9	issue_group_assignment	0	2017-09-09 14:23:28.058648
10	default_issue_start_date_to_creation_date	1	2017-09-09 14:23:28.062662
11	display_subprojects_issues	1	2017-09-09 14:23:28.066722
12	issue_done_ratio	issue_field	2017-09-09 14:23:28.070438
13	non_working_week_days	--- []\n	2017-09-09 14:23:28.07467
14	issues_export_limit	500	2017-09-09 14:23:28.078853
15	gantt_items_limit	500	2017-09-09 14:23:28.082751
16	parent_issue_dates	derived	2017-09-09 14:23:28.086425
17	parent_issue_priority	derived	2017-09-09 14:23:28.090175
18	parent_issue_done_ratio	derived	2017-09-09 14:23:28.094472
20	issue_list_default_totals	--- []\n	2017-09-09 14:23:28.103609
21	timelog_required_fields	---\n- issue_id\n	2017-09-09 14:27:53.58517
22	enabled_scm	---\n- Subversion\n- Darcs\n- Mercurial\n- Cvs\n- Bazaar\n- Git\n	2017-09-09 14:38:15.079008
23	autofetch_changesets	1	2017-09-09 14:38:15.08596
24	sys_api_enabled	0	2017-09-09 14:38:15.090022
25	repository_log_display_limit	100	2017-09-09 14:38:15.095267
26	commit_logs_formatting	1	2017-09-09 14:38:15.100042
27	commit_ref_keywords	refs,references,IssueID	2017-09-09 14:38:15.104353
28	commit_cross_project_ref	0	2017-09-09 14:38:15.108667
29	commit_logtime_enabled	0	2017-09-09 14:38:15.113626
30	commit_update_keywords	--- []\n	2017-09-09 14:38:15.118447
32	default_language	en	2017-09-09 14:38:43.457353
33	force_default_language_for_anonymous	0	2017-09-09 14:38:43.462013
34	force_default_language_for_loggedin	0	2017-09-09 14:38:43.466133
35	start_of_week		2017-09-09 14:38:43.470558
36	date_format		2017-09-09 14:38:43.475092
37	time_format		2017-09-09 14:38:43.479545
38	timespan_format	decimal	2017-09-09 14:38:43.48442
39	user_format	firstname_lastname	2017-09-09 14:38:43.488857
40	gravatar_enabled	0	2017-09-09 14:38:43.492812
41	gravatar_default		2017-09-09 14:38:43.49745
42	thumbnails_enabled	0	2017-09-09 14:38:43.502039
43	thumbnails_size	100	2017-09-09 14:38:43.506616
44	new_item_menu_tab	2	2017-09-09 14:38:43.511362
31	ui_theme		2017-09-09 14:38:48.30716
47	per_page_options	25,50,100	2017-11-02 07:40:15.966085
48	search_results_per_page	10	2017-11-02 07:40:15.969991
49	activity_days_default	30	2017-11-02 07:40:15.97399
50	host_name	localhost:3000	2017-11-02 07:40:15.977742
51	protocol	http	2017-11-02 07:40:15.981396
52	text_formatting	textile	2017-11-02 07:40:15.985768
53	cache_formatted_text	0	2017-11-02 07:40:15.98951
54	wiki_compression		2017-11-02 07:40:15.993247
55	feeds_limit	15	2017-11-02 07:40:15.996942
19	issue_list_default_columns	---\n- tracker\n- status\n- priority\n- subject\n- updated_on\n- done_ratio\n- due_date\n	2019-05-07 09:21:23.502442
46	welcome_text	道阻且长，行则将至	2022-10-07 20:15:51.908925
45	app_title	欢迎来到我的世界	2022-11-13 14:24:09.834488
\.


--
-- Name: settings_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.settings_id_seq', 55, true);


--
-- Data for Name: time_entries; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.time_entries (id, project_id, user_id, issue_id, hours, comments, activity_id, spent_on, tyear, tmonth, tweek, created_on, updated_on) FROM stdin;
\.


--
-- Name: time_entries_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.time_entries_id_seq', 1, false);


--
-- Data for Name: tokens; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.tokens (id, user_id, action, value, created_on, updated_on) FROM stdin;
181	1	session	4551f60108e035630fbee6e4d1eb92e327fa1a99	2018-10-18 07:15:40.646275	2018-10-22 17:14:33.554011
3	1	feeds	2a6c211249a45edb1a540eaa28129530c060c9f9	2017-09-08 10:13:38.715419	2017-09-08 10:13:38.715419
268	6	session	f7c6be651c8a75a5ae51d576c59ee12404f0f838	2019-04-01 12:41:51.928684	2019-04-01 12:55:11.69253
138	1	session	d673a10d751a8e71fab299e613c139464abe3223	2018-03-06 15:12:45.853225	2018-03-06 17:50:35.530439
295	6	session	b8f78e5138b3c50e82fff98423175561d4e3e995	2019-05-21 16:12:59.443692	2019-05-22 04:32:35.411699
5	1	session	5eaf00ec5c4624da58278a536516900f6a626e10	2017-09-08 15:48:40.038748	2017-09-08 15:58:54.035176
642	5	session	9017953a2c0e4188f01a3abfda06e6f9d51526b6	2023-03-01 07:02:19.882891	2023-03-02 08:00:48.838207
7	5	feeds	ed6985de793bd3605e12f5193a367c20cecc8110	2017-09-09 13:36:32.91414	2017-09-09 13:36:32.91414
269	6	session	28105be5315721d6a08928ee60f09dff73c49606	2019-04-01 13:13:49.997551	2019-04-01 13:14:59.096911
649	5	session	5757121b0d2b7f0670589d6c195a3383f93e3c0c	2023-04-06 09:05:39.162079	2023-04-11 18:55:32.235794
174	1	session	293965a3f710b36ddd930e645973175fcba02a27	2018-10-08 16:55:27.594317	2018-10-09 07:14:45.881231
265	6	session	3eb199c2c96dfd7609c4a8ece11c6e25e139b1fa	2019-03-29 07:10:30.732845	2019-03-29 07:35:41.200962
648	5	session	c1894ba4c4a8c2c6d7e01a1786cd89484296494d	2023-04-02 05:19:34.205881	2023-04-05 22:45:24.624041
646	5	session	64d4db75ca0f4cb0ce008a5d11366b4fe2c06219	2023-03-23 17:07:42.2964	2023-03-27 18:54:28.13172
264	6	session	c88b673f49a93cfb5028d15097b94db4b3b205be	2019-03-26 12:44:56.267184	2019-03-26 12:46:52.408066
652	1	session	389e416dcd086a96201508798a6f31e906fe2fcf	2023-04-24 10:20:42.858971	2023-04-24 10:21:35.536304
645	5	session	a040de43e981b5b25379094f06ba3b567b614064	2023-03-12 16:07:38.96689	2023-03-12 16:14:39.025787
16	1	session	5a6651b22876d62abd6f23036f55839c61a9354c	2017-09-09 14:31:12.442175	2017-09-09 14:34:57.143466
653	5	session	18754f06b7aebe88ec7d1cdf58d7955a59cac257	2023-04-24 17:42:32.040651	2023-04-27 08:10:03.022032
19	1	session	63b0b9167a4c725731126c9bc7e70d0e5a7fb646	2017-09-09 14:37:05.619804	2017-09-09 22:38:36.901998
186	6	feeds	6774209beb571ab9fdac814a925cc4563b4a5a99	2018-11-02 21:03:47.65632	2018-11-02 21:03:47.65632
91	1	session	7c68ac4b530ef2f629743d601ddd1fb038d7e445	2017-11-24 17:56:20.856395	2017-11-24 19:49:00.97245
292	6	session	5721297b86698a00ddd9ba5174bb9048bbeef64c	2019-05-15 12:44:31.368376	2019-05-15 12:54:25.417913
296	6	session	dc14f49f6c071af4e6367f45571097a8c1558425	2019-05-22 12:48:18.336613	2019-05-22 13:01:01.732979
651	5	session	446996c63a6a53b3e85be0b0f8e235451f02d4cd	2023-04-14 17:12:35.403792	2023-04-30 22:18:07.779594
647	5	session	5b8a4b3b8cc6169674ab14f73c2c876318e88b0a	2023-03-30 13:57:10.44618	2023-04-06 07:14:59.443691
493	5	recovery	ae710fec417aa4780d19e6b283fbb57a02032821	2021-01-18 06:06:13.374226	2021-01-18 06:06:13.374226
619	1	session	ec14af563e7aa255752f8fb36f4d65bf6693d76e	2022-11-13 14:21:03.281524	2022-11-13 14:24:13.56431
318	6	session	730e5069514c57799f240525f420f6e77d068966	2019-09-08 22:19:47.50409	2019-09-08 22:25:41.605576
291	6	session	4b07e1bd24f7ee5ad7ecc333ce8f2e47ea298449	2019-05-14 12:12:32.69694	2019-05-14 12:56:40.361423
257	1	session	470e3baeb3687037387bdfff1b50108eecf694e9	2019-03-18 16:50:01.569499	2019-03-19 12:01:29.48565
357	6	session	e04db8ce26865a0fb1e536dced4b95204e1c6514	2020-03-29 18:37:45.885865	2020-03-29 18:39:32.093754
643	5	session	a1165d9e38343ea4dab070461755aed9fb7e0df1	2023-03-06 18:13:14.635694	2023-03-22 17:56:41.17736
644	5	session	4fcf06b1ac506a747f3701e3700bcbd1bd2a6ba0	2023-03-11 05:10:26.248357	2023-03-11 11:48:39.571598
\.


--
-- Name: tokens_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.tokens_id_seq', 653, true);


--
-- Data for Name: trackers; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.trackers (id, name, is_in_chlog, "position", is_in_roadmap, fields_bits, default_status_id) FROM stdin;
3	Bug	f	1	t	0	17
5	Backport	f	3	t	266	17
4	Feature	f	2	t	256	17
7	Task	f	5	t	0	17
8	Question	f	6	t	253	17
9	运维	f	7	t	249	1
6	Document	f	4	t	0	17
10	训练	f	8	t	319	4
\.


--
-- Name: trackers_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.trackers_id_seq', 10, true);


--
-- Data for Name: user_preferences; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.user_preferences (id, user_id, others, hide_mail, time_zone) FROM stdin;
2	5	---\n:no_self_notified: true\n:my_page_layout:\n  left:\n  - issuesassignedtome\n  right:\n  - issuesreportedbyme\n  top: []\n:my_page_settings: {}\n:gantt_zoom: 2\n:gantt_months: 6\n	t	
1	1	---\n:no_self_notified: '1'\n:my_page_layout:\n  left:\n  - issuesassignedtome\n  right:\n  - issuesreportedbyme\n  top: []\n:my_page_settings: {}\n:comments_sorting: asc\n:warn_on_leaving_unsaved: '1'\n:textarea_font: ''\n:gantt_zoom: 2\n:gantt_months: 6\n	t	
3	6	---\n:no_self_notified: '1'\n:comments_sorting: asc\n:warn_on_leaving_unsaved: '1'\n:textarea_font: ''\n:my_page_layout:\n  left:\n  - issuesassignedtome\n  right:\n  - issuesreportedbyme\n:my_page_settings: {}\n:gantt_zoom: 2\n:gantt_months: 6\n	t	
4	4	---\n:no_self_notified: true\n:activity_scope:\n- issues\n- changesets\n- news\n- documents\n- files\n:my_page_layout:\n  left:\n  - issuesassignedtome\n  right:\n  - issuesreportedbyme\n:my_page_settings: {}\n	t	
\.


--
-- Name: user_preferences_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.user_preferences_id_seq', 4, true);


--
-- Data for Name: users; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.users (id, login, hashed_password, firstname, lastname, admin, status, last_login_on, language, auth_source_id, created_on, updated_on, type, identity_url, mail_notification, salt, must_change_passwd, passwd_changed_on) FROM stdin;
2				Anonymous users	f	1	\N		\N	2017-09-08 09:19:08.610272	2017-09-08 09:19:08.610272	GroupAnonymous	\N		\N	f	\N
3				Non member users	f	1	\N		\N	2017-09-08 09:19:08.634653	2017-09-08 09:19:08.634653	GroupNonMember	\N		\N	f	\N
4				Anonymous	f	0	\N		\N	2017-09-08 09:32:08.187458	2017-09-08 09:32:08.187458	AnonymousUser	\N	only_my_events	\N	f	\N
1	admin	9c808d0f454373257c6244edd28f163ccc57ddf1	锐	谢	t	1	2023-04-24 10:20:42.855173	zh	\N	2017-09-08 09:19:05.860956	2017-09-08 10:11:30.688077	User	\N	all	b5aebbc8ff7d41094ded4194fe0fc9a8	f	2017-09-08 10:10:45
5	xierui	2a2d26482c6819a88fb27329084a94869f3ab580	rui	xie	f	1	2023-04-24 17:42:32.036611	zh	\N	2017-09-08 13:40:38.638884	2017-09-08 13:56:54.537329	User	\N	only_my_events	71101b163c545d1a50957a35b34dd9a7	f	2017-09-08 13:40:38
6	hudongyin	9352cccf310bcb298049d66bd43264f50dc70e21	冬寅	胡	f	1	2020-03-29 18:37:45.880795	zh	\N	2018-11-02 21:03:05.617788	2018-11-02 21:03:05.617788	User	\N	only_my_events	2c9c2daf5128fb4ef19492e31b09364b	f	2018-11-02 21:03:05
\.


--
-- Name: users_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.users_id_seq', 6, true);


--
-- Data for Name: versions; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.versions (id, project_id, name, description, effective_date, created_on, updated_on, wiki_page_title, status, sharing) FROM stdin;
1	1	mos3.1.1	对象存储初始版本	\N	2017-09-09 14:07:40.007388	2017-09-09 14:07:40.007388		open	tree
2	1	mos5.1.0	支持es的版本	\N	2017-09-12 07:35:54.380506	2017-09-12 07:35:54.380506		open	tree
3	1	mos3.1.2	前海人寿	\N	2017-10-24 14:49:38.628034	2017-10-24 14:49:38.628034		open	none
4	1	mos	master	\N	2017-10-26 07:06:54.189411	2017-10-26 07:06:54.189411		open	none
5	1	mos3.1.3		\N	2017-11-14 09:39:42.450242	2017-11-14 09:39:42.450242		open	none
\.


--
-- Name: versions_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.versions_id_seq', 5, true);


--
-- Data for Name: watchers; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.watchers (id, watchable_type, watchable_id, user_id) FROM stdin;
1	Issue	3	5
2	Issue	12	5
3	News	1	5
4	News	2	5
6	Issue	116	5
\.


--
-- Name: watchers_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.watchers_id_seq', 14, true);


--
-- Data for Name: wiki_content_versions; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.wiki_content_versions (id, wiki_content_id, page_id, author_id, data, compression, comments, updated_on, version) FROM stdin;
1	1	1	5	\\x68312e2063657068207267772049414d0d0a0d0a68322e20776861742069732049414d0d0a687474703a2f2f646f63732e6177732e616d617a6f6e2e636f6d2f49414d2f6c61746573742f5573657247756964652f696e74726f64756374696f6e2e68746d6c0d0a0d0a415753204964656e7469747920616e6420416363657373204d616e6167656d656e7420e698afe4b880e4b8aae78bace7ab8be79a847765622073657276696365efbc8ce4b88de4bb85e7bb997333e4bdbfe794a8efbc8ce698afe4b880e4b8aae5ae8ce59684e79a84e69d83e99990e7aea1e79086e7b3bbe7bb9fe380820d0a0d0a68332e2049414d2f62756b63657420706f6c696379202f2041434c20636f6d706172650d0a68747470733a2f2f6177732e616d617a6f6e2e636f6d2f636e2f626c6f67732f73656375726974792f69616d2d706f6c69636965732d616e642d6275636b65742d706f6c69636965732d616e642d61636c732d6f682d6d792d636f6e74726f6c6c696e672d6163636573732d746f2d73332d7265736f75726365732f0d0a0d0a41434ce68ea7e588b6e79a84e58aa8e4bd9ce4b99fe6af94e8be83e5b091efbc8ce8808ce4b894e4b88de694afe68c81e58cb9e9858de696b9e5bc8f			2017-10-13 13:02:52.351724	1
2	1	1	5	\\x68312e2063657068207267772049414d0d0a0d0a68322e20776861742069732049414d0d0a687474703a2f2f646f63732e6177732e616d617a6f6e2e636f6d2f49414d2f6c61746573742f5573657247756964652f696e74726f64756374696f6e2e68746d6c0d0a0d0a415753204964656e7469747920616e6420416363657373204d616e6167656d656e7420e698afe4b880e4b8aae78bace7ab8be79a847765622073657276696365efbc8ce4b88de4bb85e7bb997333e4bdbfe794a8efbc8ce698afe4b880e4b8aae5ae8ce59684e79a84e69d83e99990e7aea1e79086e7b3bbe7bb9fe380820d0a0d0a68322e2049414d2f62756b63657420706f6c696379202f2041434c20636f6d706172650d0a68747470733a2f2f6177732e616d617a6f6e2e636f6d2f636e2f626c6f67732f73656375726974792f69616d2d706f6c69636965732d616e642d6275636b65742d706f6c69636965732d616e642d61636c732d6f682d6d792d636f6e74726f6c6c696e672d6163636573732d746f2d73332d7265736f75726365732f0d0a0d0a41434ce68ea7e588b6e79a84e58aa8e4bd9ce4b99fe6af94e8be83e5b091efbc8ce8808ce4b894e4b88de694afe68c81e58cb9e9858de696b9e5bc8f			2017-10-13 13:03:07.11753	2
3	2	2	5	\\xe698af786673e79a84627567efbc8ce98187e588b035313265e79a84e79b98e5b0b1e4bc9ae587bae997aee9a298efbc8ce7bd91e4b88ae4b99fe6b2a1e8afb4e6b885e6a59aefbc8ce4b88de8bf87e58fafe4bba5e8af95e4b880e4b88be68da2e4b880e4b88b6d6b6673e79a84e58f82e695b0e4bc9ae4b88de4bc9ae587bae78eb00d0a0d0ae6a682e5bfb5e4bb8be7bb8defbc9a0d0a68747470733a2f2f656e2e77696b6970656469612e6f72672f77696b692f416476616e6365645f466f726d6174			2017-11-01 07:23:11.577609	1
4	3	3	5	\\x686173682020e59388e5b88cefbc8ce68896e88085e58fabe695a3e58897efbc8ce6b3a8e6848fe8bf99e58faae698afe4b880e4b8aae7ae97e6b395efbc8ce59388e5b88ce7ae97e6b395e5b086e4bbbbe6848fe995bfe5baa6e79a84e4ba8ce8bf9be588b6e580bce698a0e5b084e4b8bae8be83e79fade79a84e59bbae5ae9ae995bfe5baa6e79a84e4ba8ce8bf9be588b6e580bcefbc8ce8bf99e4b8aae5b08fe79a84e4ba8ce8bf9be588b6e580bce7a7b0e4b8bae59388e5b88ce580bce380820d0a687474703a2f2f77696b692e6d62616c69622e636f6d2f77696b692f2545352539332538382545352542382538432545372541452539372545362542332539350d0a0d0ae4b99fe5b0b1e698afe8afb4e68a8ae5afb9e8b1a1e79a846b6579e8aea1e7ae97e5be97e588b068617368e580bce79a84e8bf87e7a88befbc8ce6898de698af68617368e380820d0a0d0a68617368e7a2b0e6929eefbc9a0d0a687474703a2f2f7777772e6a69616e7368752e636f6d2f702f6266316437656565323864300d0a0d0a68617368e7ae97e6b395e79a84e789b9e782b9efbc9ae58d95e59091e680a7efbc8ce99abee58fafe98086efbc8ce68a97e7a2b0e6929ee380820d0a0d0a0d0ae8808c68617368e6a1b6e58899e698afe58fa6e5a496e79a84e6a682e5bfb5e38082e5b19ee4ba8e68617368e8a1a8e79a84e88c83e795b40d0a0d0a6861736820e8a1a8e4b8bbe8a681e4bc98e58abfefbc9ae99a8fe69cbae8afbbe58699e9809fe5baa6e5bfabefbc8ce59ba0e8808ce59ca8e6b5b7e9878fe695b0e68daee4b88ae8bf90e794a8e5b9bfe6b39be380820d0a0d0a68617368e8a1a8e58aa3e58abfefbc9ae9a1bae5ba8fe8afbbe58699e685a2efbc9f20e4b8bae4bb80e4b9886275636b657420696e646578e8a681e794a868617368e696b9e5bc8fe7bb84e7bb87e591a2efbc9f			2017-11-10 12:36:03.388463	1
5	3	3	5	\\x686173682020e59388e5b88cefbc8ce68896e88085e58fabe695a3e58897efbc8ce6b3a8e6848fe8bf99e58faae698afe4b880e4b8aae7ae97e6b395efbc8ce59388e5b88ce7ae97e6b395e5b086e4bbbbe6848fe995bfe5baa6e79a84e4ba8ce8bf9be588b6e580bce698a0e5b084e4b8bae8be83e79fade79a84e59bbae5ae9ae995bfe5baa6e79a84e4ba8ce8bf9be588b6e580bcefbc8ce8bf99e4b8aae5b08fe79a84e4ba8ce8bf9be588b6e580bce7a7b0e4b8bae59388e5b88ce580bce380820d0a687474703a2f2f77696b692e6d62616c69622e636f6d2f77696b692f2545352539332538382545352542382538432545372541452539372545362542332539350d0a0d0ae4b99fe5b0b1e698afe8afb4e68a8ae5afb9e8b1a1e79a846b6579e8aea1e7ae97e5be97e588b068617368e580bce79a84e8bf87e7a88befbc8ce6898de698af68617368e380820d0a0d0a68617368e7a2b0e6929eefbc9a0d0a687474703a2f2f7777772e6a69616e7368752e636f6d2f702f6266316437656565323864300d0a0d0a68617368e7ae97e6b395e79a84e789b9e782b9efbc9ae58d95e59091e680a7efbc8ce99abee58fafe98086efbc8ce68a97e7a2b0e6929ee380820d0a0d0a0d0ae8808c68617368e6a1b6e58899e698afe58fa6e5a496e79a84e6a682e5bfb5e38082e5b19ee4ba8e68617368e8a1a8e79a84e88c83e795b40d0a0d0a6861736820e8a1a8e4b8bbe8a681e4bc98e58abfefbc9a0d0a31efbc8ce695a3e58897e69588e69e9c0d0a2020e5a682e69e9ce68c89e785a7e5898de7bc80e69da5e694bee588b0e4b88de5908ce6a1b6efbc8ce4b880e4b8aae69e81e7abafe4be8be5ad90e698afe68980e69c89e69687e4bbb6e983bde698afe8bf99e7a78de5898de7bc800d0a32efbc8ce99a8fe69cbae8afbbe58699e9809fe5baa6e5bfabefbc8ce59ba0e8808ce59ca8e6b5b7e9878fe695b0e68daee4b88ae8bf90e794a8e5b9bfe6b39be380820d0a0d0a68617368e8a1a8e58aa3e58abfefbc9ae9a1bae5ba8fe8afbbe58699e685a2efbc9f20e4b8bae4bb80e4b9886275636b657420696e646578e8a681e794a868617368e696b9e5bc8fe7bb84e7bb87e591a2efbc9f0d0a5247575261646f733a3a6765745f6275636b65745f696e6465785f6f626a6563740d0a0d0a0d0a436f6e73697374656e742068617368696e6720e79a84e59fbae69cace6809de683b3e5b0b1e698afe5b086e5afb9e8b1a1e5928c20636163686520e983bde698a0e5b084e588b0e5908ce4b880e4b8aa206861736820e695b0e580bce7a9bae997b4e4b8adefbc8ce5b9b6e4b894e4bdbfe794a8e79bb8e5908ce79a84206861736820e7ae97e6b395e380820d0ae4b880e887b4e680a7e59388e5b88ce7ae97e6b395e4b8bbe8a681e4bdbfe794a8e59ca8e58886e5b883e5bc8fe695b0e68daee5ad98e582a8e7b3bbe7bb9fe4b8adefbc8ce68c89e785a7e4b880e5ae9ae79a84e7ad96e795a5e5b086e695b0e68daee5b0bde58fafe883bde59d87e58c80e58886e5b883e588b0e68980e69c89e79a84e5ad98e582a8e88a82e782b9e4b88ae58ebbefbc8ce4bdbfe5be97e7b3bbe7bb9fe585b7e69c89e889afe5a5bde79a84e8b49fe8bdbde59d87e8a1a1e680a7e883bde5928ce689a9e5b195e680a7e380820d0a0d0ae4b880e887b4e680a768617368e79a84e694b9e8bf9befbc9a0d0ae5bc95e585a5e8999ae68b9fe88a82e782b9efbc8ce981bfe5858de68980e69c89e695b0e68daee58f82e4b88ee8bf81e7a7bbe380820d0a			2017-11-10 12:59:13.063024	2
6	4	4	5	\\xe6a8a1e68b9fe8afb7e6b182e8849ae69cacefbc9a0d0a0d0a3c7072653e3c636f646520636c6173733d2274657874223e0d0a23212f62696e2f73680d0a49643d226f425a44394f70564f68713262484568616b5635220d0a4b65793d2248576e6a7866486b4f6a5577754b387a496248375078486e7a626170656b58306e4453457a563151220d0a2349643d22383734374b4341483850484a543343325431454a220d0a234b65793d22594375704a593561363146544f39396531714f493748736672397632563030724735503854756772220d0a0d0a72756e5f636d6428297b0d0a20202020617574683d222f61646d696e2f6c6f672f220d0a2020202075726c3d24310d0a202020206461746556616c75653d2260545a3d474d542064617465202b2725612c2025642025622025592025483a254d3a255320474d542760220d0a2020202023636f6e74656e74547970653d226170706c69636174696f6e2f782d7777772d666f726d2d75726c656e636f646564220d0a20202020737472696e67546f5369676e3d224745545c6e5c6e5c6e247b6461746556616c75657d5c6e247b617574687d220d0a202020206563686f2022247b737472696e67546f5369676e7d220d0a202020207369676e61747572653d606563686f202d656e20247b737472696e67546f5369676e7d207c206f70656e73736c2073686131202d686d616320247b4b65797d202d62696e617279207c20626173653634600d0a202020206563686f202272756e20636d6420247b75726c7d207369676e617475726520efbc9a247b7369676e61747572657d220d0a202020206375726c202d69202d5820474554202d482022446174653a20247b6461746556616c75657d22202d482022417574686f72697a6174696f6e3a2041575320247b49647d3a247b7369676e61747572657d222022247b75726c7d220d0a202020206563686f2022656e6420636d64220d0a7d0d0a0d0a236563686f2024310d0a72756e5f636d642024310d0a3c2f636f64653e3c2f7072653e0d0a0d0a2e2f733361646d696e2e73682022687474703a2f2f31302e31302e312e3135373a383039302f61646d696e2f6c6f672f3f747970653d646174612669643d31303826696e666f26726777782d7a6f6e6567726f75703d64353361656130622d306237362d346330372d393034312d656238316532653365353039220d0a0d0ae8b083e8af95e591bde4bba4			2018-04-14 15:29:28.707809	1
\.


--
-- Name: wiki_content_versions_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.wiki_content_versions_id_seq', 6, true);


--
-- Data for Name: wiki_contents; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.wiki_contents (id, page_id, author_id, text, comments, updated_on, version) FROM stdin;
1	1	5	h1. ceph rgw IAM\r\n\r\nh2. what is IAM\r\nhttp://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html\r\n\r\nAWS Identity and Access Management 是一个独立的web service，不仅给s3使用，是一个完善的权限管理系统。\r\n\r\nh2. IAM/bukcet policy / ACL compare\r\nhttps://aws.amazon.com/cn/blogs/security/iam-policies-and-bucket-policies-and-acls-oh-my-controlling-access-to-s3-resources/\r\n\r\nACL控制的动作也比较少，而且不支持匹配方式		2017-10-13 13:03:07.11753	2
2	2	5	是xfs的bug，遇到512e的盘就会出问题，网上也没说清楚，不过可以试一下换一下mkfs的参数会不会出现\r\n\r\n概念介绍：\r\nhttps://en.wikipedia.org/wiki/Advanced_Format		2017-11-01 07:23:11.577609	1
3	3	5	hash  哈希，或者叫散列，注意这只是一个算法，哈希算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。\r\nhttp://wiki.mbalib.com/wiki/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95\r\n\r\n也就是说把对象的key计算得到hash值的过程，才是hash。\r\n\r\nhash碰撞：\r\nhttp://www.jianshu.com/p/bf1d7eee28d0\r\n\r\nhash算法的特点：单向性，难可逆，抗碰撞。\r\n\r\n\r\n而hash桶则是另外的概念。属于hash表的范畴\r\n\r\nhash 表主要优势：\r\n1，散列效果\r\n  如果按照前缀来放到不同桶，一个极端例子是所有文件都是这种前缀\r\n2，随机读写速度快，因而在海量数据上运用广泛。\r\n\r\nhash表劣势：顺序读写慢？ 为什么bucket index要用hash方式组织呢？\r\nRGWRados::get_bucket_index_object\r\n\r\n\r\nConsistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并且使用相同的 hash 算法。\r\n一致性哈希算法主要使用在分布式数据存储系统中，按照一定的策略将数据尽可能均匀分布到所有的存储节点上去，使得系统具有良好的负载均衡性能和扩展性。\r\n\r\n一致性hash的改进：\r\n引入虚拟节点，避免所有数据参与迁移。\r\n		2017-11-10 12:59:13.063024	2
4	4	5	模拟请求脚本：\r\n\r\n<pre><code class="text">\r\n#!/bin/sh\r\nId="oBZD9OpVOhq2bHEhakV5"\r\nKey="HWnjxfHkOjUwuK8zIbH7PxHnzbapekX0nDSEzV1Q"\r\n#Id="8747KCAH8PHJT3C2T1EJ"\r\n#Key="YCupJY5a61FTO99e1qOI7Hsfr9v2V00rG5P8Tugr"\r\n\r\nrun_cmd(){\r\n    auth="/admin/log/"\r\n    url=$1\r\n    dateValue="`TZ=GMT date +'%a, %d %b %Y %H:%M:%S GMT'`"\r\n    #contentType="application/x-www-form-urlencoded"\r\n    stringToSign="GET\\n\\n\\n${dateValue}\\n${auth}"\r\n    echo "${stringToSign}"\r\n    signature=`echo -en ${stringToSign} | openssl sha1 -hmac ${Key} -binary | base64`\r\n    echo "run cmd ${url} signature ：${signature}"\r\n    curl -i -X GET -H "Date: ${dateValue}" -H "Authorization: AWS ${Id}:${signature}" "${url}"\r\n    echo "end cmd"\r\n}\r\n\r\n#echo $1\r\nrun_cmd $1\r\n</code></pre>\r\n\r\n./s3admin.sh "http://10.10.1.157:8090/admin/log/?type=data&id=108&info&rgwx-zonegroup=d53aea0b-0b76-4c07-9041-eb81e2e3e509"\r\n\r\n调试命令		2018-04-14 15:29:28.707809	1
\.


--
-- Name: wiki_contents_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.wiki_contents_id_seq', 4, true);


--
-- Data for Name: wiki_pages; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.wiki_pages (id, wiki_id, title, created_on, protected, parent_id) FROM stdin;
1	1	Wiki	2017-10-13 13:02:52.328596	f	\N
2	1	512e盘	2017-11-01 07:23:11.574926	f	\N
3	1	Hash	2017-11-10 12:36:03.385698	f	1
4	1	Rgw_multisite_curl请求	2018-04-14 15:29:28.703562	f	\N
\.


--
-- Name: wiki_pages_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.wiki_pages_id_seq', 4, true);


--
-- Data for Name: wiki_redirects; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.wiki_redirects (id, wiki_id, title, redirects_to, created_on, redirects_to_wiki_id) FROM stdin;
\.


--
-- Name: wiki_redirects_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.wiki_redirects_id_seq', 1, false);


--
-- Data for Name: wikis; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.wikis (id, project_id, start_page, status) FROM stdin;
1	1	Wiki	1
2	2	Wiki	1
3	5	Wiki	1
5	19	Wiki	1
6	20	Wiki	1
8	24	Wiki	1
9	33	Wiki	1
\.


--
-- Name: wikis_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.wikis_id_seq', 9, true);


--
-- Data for Name: workflows; Type: TABLE DATA; Schema: public; Owner: redmine
--

COPY public.workflows (id, tracker_id, old_status_id, new_status_id, role_id, assignee, author, type, field_name, rule) FROM stdin;
1	3	0	3	1	f	f	WorkflowTransition	\N	\N
2	3	0	3	2	f	f	WorkflowTransition	\N	\N
3	3	0	3	3	f	f	WorkflowTransition	\N	\N
4	3	0	4	1	f	f	WorkflowTransition	\N	\N
5	3	0	4	2	f	f	WorkflowTransition	\N	\N
6	3	0	4	3	f	f	WorkflowTransition	\N	\N
10	3	0	13	1	f	f	WorkflowTransition	\N	\N
11	3	0	13	2	f	f	WorkflowTransition	\N	\N
12	3	0	13	3	f	f	WorkflowTransition	\N	\N
13	3	0	14	1	f	f	WorkflowTransition	\N	\N
14	3	0	14	2	f	f	WorkflowTransition	\N	\N
15	3	0	14	3	f	f	WorkflowTransition	\N	\N
16	3	0	17	1	f	f	WorkflowTransition	\N	\N
17	3	0	17	2	f	f	WorkflowTransition	\N	\N
18	3	0	17	3	f	f	WorkflowTransition	\N	\N
19	3	0	18	1	f	f	WorkflowTransition	\N	\N
20	3	0	18	2	f	f	WorkflowTransition	\N	\N
21	3	0	18	3	f	f	WorkflowTransition	\N	\N
22	3	1	3	1	f	f	WorkflowTransition	\N	\N
23	3	1	3	2	f	f	WorkflowTransition	\N	\N
24	3	1	3	3	f	f	WorkflowTransition	\N	\N
25	3	1	4	1	f	f	WorkflowTransition	\N	\N
26	3	1	4	2	f	f	WorkflowTransition	\N	\N
27	3	1	4	3	f	f	WorkflowTransition	\N	\N
31	3	1	13	1	f	f	WorkflowTransition	\N	\N
32	3	1	13	2	f	f	WorkflowTransition	\N	\N
33	3	1	13	3	f	f	WorkflowTransition	\N	\N
34	3	1	14	1	f	f	WorkflowTransition	\N	\N
35	3	1	14	2	f	f	WorkflowTransition	\N	\N
36	3	1	14	3	f	f	WorkflowTransition	\N	\N
37	3	1	16	1	f	f	WorkflowTransition	\N	\N
38	3	1	16	2	f	f	WorkflowTransition	\N	\N
39	3	1	16	3	f	f	WorkflowTransition	\N	\N
40	3	1	17	1	f	f	WorkflowTransition	\N	\N
41	3	1	17	2	f	f	WorkflowTransition	\N	\N
42	3	1	17	3	f	f	WorkflowTransition	\N	\N
43	3	1	18	1	f	f	WorkflowTransition	\N	\N
44	3	1	18	2	f	f	WorkflowTransition	\N	\N
45	3	1	18	3	f	f	WorkflowTransition	\N	\N
46	3	3	4	1	f	f	WorkflowTransition	\N	\N
47	3	3	4	2	f	f	WorkflowTransition	\N	\N
48	3	3	4	3	f	f	WorkflowTransition	\N	\N
52	3	3	13	1	f	f	WorkflowTransition	\N	\N
53	3	3	13	2	f	f	WorkflowTransition	\N	\N
54	3	3	13	3	f	f	WorkflowTransition	\N	\N
55	3	3	14	1	f	f	WorkflowTransition	\N	\N
56	3	3	14	2	f	f	WorkflowTransition	\N	\N
57	3	3	14	3	f	f	WorkflowTransition	\N	\N
58	3	3	16	1	f	f	WorkflowTransition	\N	\N
59	3	3	16	2	f	f	WorkflowTransition	\N	\N
60	3	3	16	3	f	f	WorkflowTransition	\N	\N
61	3	17	3	1	f	f	WorkflowTransition	\N	\N
62	3	17	3	2	f	f	WorkflowTransition	\N	\N
63	3	17	3	3	f	f	WorkflowTransition	\N	\N
64	3	17	4	1	f	f	WorkflowTransition	\N	\N
65	3	17	4	2	f	f	WorkflowTransition	\N	\N
66	3	17	4	3	f	f	WorkflowTransition	\N	\N
67	3	17	13	1	f	f	WorkflowTransition	\N	\N
68	3	17	13	2	f	f	WorkflowTransition	\N	\N
69	3	17	13	3	f	f	WorkflowTransition	\N	\N
70	3	17	14	1	f	f	WorkflowTransition	\N	\N
71	3	17	14	2	f	f	WorkflowTransition	\N	\N
72	3	17	14	3	f	f	WorkflowTransition	\N	\N
73	3	17	16	1	f	f	WorkflowTransition	\N	\N
74	3	17	16	2	f	f	WorkflowTransition	\N	\N
75	3	17	16	3	f	f	WorkflowTransition	\N	\N
76	3	17	17	1	f	f	WorkflowTransition	\N	\N
77	3	17	17	2	f	f	WorkflowTransition	\N	\N
78	3	17	17	3	f	f	WorkflowTransition	\N	\N
79	3	17	18	1	f	f	WorkflowTransition	\N	\N
80	3	17	18	2	f	f	WorkflowTransition	\N	\N
81	3	17	18	3	f	f	WorkflowTransition	\N	\N
82	3	18	4	1	f	f	WorkflowTransition	\N	\N
83	3	18	4	2	f	f	WorkflowTransition	\N	\N
84	3	18	4	3	f	f	WorkflowTransition	\N	\N
88	3	18	6	1	f	f	WorkflowTransition	\N	\N
89	3	18	6	2	f	f	WorkflowTransition	\N	\N
90	3	18	6	3	f	f	WorkflowTransition	\N	\N
91	3	18	7	1	f	f	WorkflowTransition	\N	\N
92	3	18	7	2	f	f	WorkflowTransition	\N	\N
93	3	18	7	3	f	f	WorkflowTransition	\N	\N
94	3	18	8	1	f	f	WorkflowTransition	\N	\N
95	3	18	8	2	f	f	WorkflowTransition	\N	\N
96	3	18	8	3	f	f	WorkflowTransition	\N	\N
97	3	3	15	1	f	f	WorkflowTransition	\N	\N
98	3	3	15	2	f	f	WorkflowTransition	\N	\N
99	3	3	15	3	f	f	WorkflowTransition	\N	\N
100	3	4	6	1	f	f	WorkflowTransition	\N	\N
101	3	4	6	2	f	f	WorkflowTransition	\N	\N
102	3	4	6	3	f	f	WorkflowTransition	\N	\N
103	3	4	7	1	f	f	WorkflowTransition	\N	\N
104	3	4	7	2	f	f	WorkflowTransition	\N	\N
105	3	4	7	3	f	f	WorkflowTransition	\N	\N
106	3	4	8	1	f	f	WorkflowTransition	\N	\N
107	3	4	8	2	f	f	WorkflowTransition	\N	\N
108	3	4	8	3	f	f	WorkflowTransition	\N	\N
109	3	4	11	1	f	f	WorkflowTransition	\N	\N
110	3	4	11	2	f	f	WorkflowTransition	\N	\N
111	3	4	11	3	f	f	WorkflowTransition	\N	\N
112	3	4	15	1	f	f	WorkflowTransition	\N	\N
113	3	4	15	2	f	f	WorkflowTransition	\N	\N
114	3	4	15	3	f	f	WorkflowTransition	\N	\N
115	3	6	9	1	f	f	WorkflowTransition	\N	\N
116	3	6	9	2	f	f	WorkflowTransition	\N	\N
117	3	6	9	3	f	f	WorkflowTransition	\N	\N
118	3	6	10	1	f	f	WorkflowTransition	\N	\N
119	3	6	10	2	f	f	WorkflowTransition	\N	\N
120	3	6	10	3	f	f	WorkflowTransition	\N	\N
121	3	6	11	1	f	f	WorkflowTransition	\N	\N
122	3	6	11	2	f	f	WorkflowTransition	\N	\N
123	3	6	11	3	f	f	WorkflowTransition	\N	\N
124	3	7	8	1	f	f	WorkflowTransition	\N	\N
125	3	7	8	2	f	f	WorkflowTransition	\N	\N
126	3	7	8	3	f	f	WorkflowTransition	\N	\N
127	3	8	9	1	f	f	WorkflowTransition	\N	\N
128	3	8	9	2	f	f	WorkflowTransition	\N	\N
129	3	8	9	3	f	f	WorkflowTransition	\N	\N
130	3	8	10	1	f	f	WorkflowTransition	\N	\N
131	3	8	10	2	f	f	WorkflowTransition	\N	\N
132	3	8	10	3	f	f	WorkflowTransition	\N	\N
133	3	8	11	1	f	f	WorkflowTransition	\N	\N
134	3	8	11	2	f	f	WorkflowTransition	\N	\N
135	3	8	11	3	f	f	WorkflowTransition	\N	\N
136	3	9	10	1	f	f	WorkflowTransition	\N	\N
137	3	9	10	2	f	f	WorkflowTransition	\N	\N
138	3	9	10	3	f	f	WorkflowTransition	\N	\N
139	3	9	12	1	f	f	WorkflowTransition	\N	\N
140	3	9	12	2	f	f	WorkflowTransition	\N	\N
141	3	9	12	3	f	f	WorkflowTransition	\N	\N
142	3	10	9	1	f	f	WorkflowTransition	\N	\N
143	3	10	9	2	f	f	WorkflowTransition	\N	\N
144	3	10	9	3	f	f	WorkflowTransition	\N	\N
145	3	10	12	1	f	f	WorkflowTransition	\N	\N
146	3	10	12	2	f	f	WorkflowTransition	\N	\N
147	3	10	12	3	f	f	WorkflowTransition	\N	\N
148	3	11	9	1	f	f	WorkflowTransition	\N	\N
149	3	11	9	2	f	f	WorkflowTransition	\N	\N
150	3	11	9	3	f	f	WorkflowTransition	\N	\N
151	3	11	10	1	f	f	WorkflowTransition	\N	\N
152	3	11	10	2	f	f	WorkflowTransition	\N	\N
153	3	11	10	3	f	f	WorkflowTransition	\N	\N
154	3	12	1	1	f	f	WorkflowTransition	\N	\N
155	3	12	1	2	f	f	WorkflowTransition	\N	\N
156	3	12	1	3	f	f	WorkflowTransition	\N	\N
157	3	13	1	1	f	f	WorkflowTransition	\N	\N
158	3	13	1	2	f	f	WorkflowTransition	\N	\N
159	3	13	1	3	f	f	WorkflowTransition	\N	\N
160	3	14	1	1	f	f	WorkflowTransition	\N	\N
161	3	14	1	2	f	f	WorkflowTransition	\N	\N
162	3	14	1	3	f	f	WorkflowTransition	\N	\N
163	3	15	1	1	f	f	WorkflowTransition	\N	\N
164	3	15	1	2	f	f	WorkflowTransition	\N	\N
165	3	15	1	3	f	f	WorkflowTransition	\N	\N
166	3	16	1	1	f	f	WorkflowTransition	\N	\N
167	3	16	1	2	f	f	WorkflowTransition	\N	\N
168	3	16	1	3	f	f	WorkflowTransition	\N	\N
169	4	0	1	1	f	f	WorkflowTransition	\N	\N
170	4	0	1	2	f	f	WorkflowTransition	\N	\N
171	4	0	1	3	f	f	WorkflowTransition	\N	\N
172	4	0	17	1	f	f	WorkflowTransition	\N	\N
173	4	0	17	2	f	f	WorkflowTransition	\N	\N
174	4	0	17	3	f	f	WorkflowTransition	\N	\N
175	4	1	1	1	f	f	WorkflowTransition	\N	\N
176	4	1	1	2	f	f	WorkflowTransition	\N	\N
177	4	1	1	3	f	f	WorkflowTransition	\N	\N
178	4	17	12	1	f	f	WorkflowTransition	\N	\N
179	4	17	12	2	f	f	WorkflowTransition	\N	\N
180	4	17	12	3	f	f	WorkflowTransition	\N	\N
181	4	17	13	1	f	f	WorkflowTransition	\N	\N
182	4	17	13	2	f	f	WorkflowTransition	\N	\N
183	4	17	13	3	f	f	WorkflowTransition	\N	\N
184	4	17	16	1	f	f	WorkflowTransition	\N	\N
185	4	17	16	2	f	f	WorkflowTransition	\N	\N
187	4	1	18	3	f	f	WorkflowTransition	\N	\N
188	4	4	12	3	f	f	WorkflowTransition	\N	\N
189	4	6	4	3	f	f	WorkflowTransition	\N	\N
190	4	6	12	3	f	f	WorkflowTransition	\N	\N
191	4	17	4	3	f	f	WorkflowTransition	\N	\N
192	4	17	6	3	f	f	WorkflowTransition	\N	\N
193	4	17	18	3	f	f	WorkflowTransition	\N	\N
194	4	18	4	3	f	f	WorkflowTransition	\N	\N
195	4	18	6	3	f	f	WorkflowTransition	\N	\N
196	5	0	1	3	f	f	WorkflowTransition	\N	\N
197	5	0	17	3	f	f	WorkflowTransition	\N	\N
198	5	1	11	3	f	f	WorkflowTransition	\N	\N
199	5	1	13	3	f	f	WorkflowTransition	\N	\N
200	5	1	17	3	f	f	WorkflowTransition	\N	\N
201	5	11	12	3	f	f	WorkflowTransition	\N	\N
202	5	17	11	3	f	f	WorkflowTransition	\N	\N
203	5	17	13	3	f	f	WorkflowTransition	\N	\N
204	6	0	1	1	f	f	WorkflowTransition	\N	\N
205	6	0	1	2	f	f	WorkflowTransition	\N	\N
206	6	0	1	3	f	f	WorkflowTransition	\N	\N
207	6	1	17	1	f	f	WorkflowTransition	\N	\N
208	6	1	17	2	f	f	WorkflowTransition	\N	\N
209	6	1	17	3	f	f	WorkflowTransition	\N	\N
210	6	4	12	1	f	f	WorkflowTransition	\N	\N
211	6	4	12	2	f	f	WorkflowTransition	\N	\N
212	6	4	12	3	f	f	WorkflowTransition	\N	\N
213	6	17	4	1	f	f	WorkflowTransition	\N	\N
214	6	17	4	2	f	f	WorkflowTransition	\N	\N
215	6	17	4	3	f	f	WorkflowTransition	\N	\N
216	6	0	17	1	f	f	WorkflowTransition	\N	\N
217	6	0	17	2	f	f	WorkflowTransition	\N	\N
218	6	0	17	3	f	f	WorkflowTransition	\N	\N
233	7	0	19	3	f	f	WorkflowTransition	\N	\N
234	7	19	20	3	f	f	WorkflowTransition	\N	\N
235	7	19	24	3	f	f	WorkflowTransition	\N	\N
236	7	20	21	3	f	f	WorkflowTransition	\N	\N
237	7	21	22	3	f	f	WorkflowTransition	\N	\N
238	7	22	23	3	f	f	WorkflowTransition	\N	\N
239	7	23	24	3	f	f	WorkflowTransition	\N	\N
223	8	0	17	3	f	f	WorkflowTransition	\N	\N
224	8	17	4	3	f	f	WorkflowTransition	\N	\N
225	8	4	12	3	f	f	WorkflowTransition	\N	\N
226	8	1	17	3	f	f	WorkflowTransition	\N	\N
227	8	0	1	3	f	f	WorkflowTransition	\N	\N
228	9	0	17	3	f	f	WorkflowTransition	\N	\N
229	9	17	4	3	f	f	WorkflowTransition	\N	\N
230	9	4	12	3	f	f	WorkflowTransition	\N	\N
231	9	1	17	3	f	f	WorkflowTransition	\N	\N
232	9	0	1	3	f	f	WorkflowTransition	\N	\N
240	10	0	4	2	f	f	WorkflowTransition	\N	\N
241	10	0	4	3	f	f	WorkflowTransition	\N	\N
242	10	0	4	1	f	f	WorkflowTransition	\N	\N
243	10	1	4	2	f	f	WorkflowTransition	\N	\N
244	10	1	4	3	f	f	WorkflowTransition	\N	\N
245	10	1	4	1	f	f	WorkflowTransition	\N	\N
246	10	4	12	2	f	f	WorkflowTransition	\N	\N
247	10	4	12	3	f	f	WorkflowTransition	\N	\N
248	10	4	12	1	f	f	WorkflowTransition	\N	\N
249	10	4	13	2	f	f	WorkflowTransition	\N	\N
250	10	4	13	3	f	f	WorkflowTransition	\N	\N
251	10	4	13	1	f	f	WorkflowTransition	\N	\N
\.


--
-- Name: workflows_id_seq; Type: SEQUENCE SET; Schema: public; Owner: redmine
--

SELECT pg_catalog.setval('public.workflows_id_seq', 251, true);


--
-- Name: attachments attachments_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.attachments
    ADD CONSTRAINT attachments_pkey PRIMARY KEY (id);


--
-- Name: auth_sources auth_sources_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.auth_sources
    ADD CONSTRAINT auth_sources_pkey PRIMARY KEY (id);


--
-- Name: boards boards_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.boards
    ADD CONSTRAINT boards_pkey PRIMARY KEY (id);


--
-- Name: changes changes_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.changes
    ADD CONSTRAINT changes_pkey PRIMARY KEY (id);


--
-- Name: changesets changesets_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.changesets
    ADD CONSTRAINT changesets_pkey PRIMARY KEY (id);


--
-- Name: comments comments_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.comments
    ADD CONSTRAINT comments_pkey PRIMARY KEY (id);


--
-- Name: custom_field_enumerations custom_field_enumerations_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.custom_field_enumerations
    ADD CONSTRAINT custom_field_enumerations_pkey PRIMARY KEY (id);


--
-- Name: custom_fields custom_fields_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.custom_fields
    ADD CONSTRAINT custom_fields_pkey PRIMARY KEY (id);


--
-- Name: custom_values custom_values_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.custom_values
    ADD CONSTRAINT custom_values_pkey PRIMARY KEY (id);


--
-- Name: documents documents_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.documents
    ADD CONSTRAINT documents_pkey PRIMARY KEY (id);


--
-- Name: email_addresses email_addresses_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.email_addresses
    ADD CONSTRAINT email_addresses_pkey PRIMARY KEY (id);


--
-- Name: enabled_modules enabled_modules_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.enabled_modules
    ADD CONSTRAINT enabled_modules_pkey PRIMARY KEY (id);


--
-- Name: enumerations enumerations_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.enumerations
    ADD CONSTRAINT enumerations_pkey PRIMARY KEY (id);


--
-- Name: import_items import_items_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.import_items
    ADD CONSTRAINT import_items_pkey PRIMARY KEY (id);


--
-- Name: imports imports_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.imports
    ADD CONSTRAINT imports_pkey PRIMARY KEY (id);


--
-- Name: issue_categories issue_categories_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.issue_categories
    ADD CONSTRAINT issue_categories_pkey PRIMARY KEY (id);


--
-- Name: issue_relations issue_relations_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.issue_relations
    ADD CONSTRAINT issue_relations_pkey PRIMARY KEY (id);


--
-- Name: issue_statuses issue_statuses_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.issue_statuses
    ADD CONSTRAINT issue_statuses_pkey PRIMARY KEY (id);


--
-- Name: issues issues_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.issues
    ADD CONSTRAINT issues_pkey PRIMARY KEY (id);


--
-- Name: journal_details journal_details_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.journal_details
    ADD CONSTRAINT journal_details_pkey PRIMARY KEY (id);


--
-- Name: journals journals_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.journals
    ADD CONSTRAINT journals_pkey PRIMARY KEY (id);


--
-- Name: member_roles member_roles_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.member_roles
    ADD CONSTRAINT member_roles_pkey PRIMARY KEY (id);


--
-- Name: members members_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.members
    ADD CONSTRAINT members_pkey PRIMARY KEY (id);


--
-- Name: messages messages_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.messages
    ADD CONSTRAINT messages_pkey PRIMARY KEY (id);


--
-- Name: news news_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.news
    ADD CONSTRAINT news_pkey PRIMARY KEY (id);


--
-- Name: open_id_authentication_associations open_id_authentication_associations_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.open_id_authentication_associations
    ADD CONSTRAINT open_id_authentication_associations_pkey PRIMARY KEY (id);


--
-- Name: open_id_authentication_nonces open_id_authentication_nonces_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.open_id_authentication_nonces
    ADD CONSTRAINT open_id_authentication_nonces_pkey PRIMARY KEY (id);


--
-- Name: projects projects_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_pkey PRIMARY KEY (id);


--
-- Name: queries queries_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.queries
    ADD CONSTRAINT queries_pkey PRIMARY KEY (id);


--
-- Name: repositories repositories_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.repositories
    ADD CONSTRAINT repositories_pkey PRIMARY KEY (id);


--
-- Name: roles roles_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.roles
    ADD CONSTRAINT roles_pkey PRIMARY KEY (id);


--
-- Name: settings settings_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.settings
    ADD CONSTRAINT settings_pkey PRIMARY KEY (id);


--
-- Name: time_entries time_entries_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.time_entries
    ADD CONSTRAINT time_entries_pkey PRIMARY KEY (id);


--
-- Name: tokens tokens_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.tokens
    ADD CONSTRAINT tokens_pkey PRIMARY KEY (id);


--
-- Name: trackers trackers_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.trackers
    ADD CONSTRAINT trackers_pkey PRIMARY KEY (id);


--
-- Name: user_preferences user_preferences_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.user_preferences
    ADD CONSTRAINT user_preferences_pkey PRIMARY KEY (id);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: versions versions_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.versions
    ADD CONSTRAINT versions_pkey PRIMARY KEY (id);


--
-- Name: watchers watchers_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.watchers
    ADD CONSTRAINT watchers_pkey PRIMARY KEY (id);


--
-- Name: wiki_content_versions wiki_content_versions_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.wiki_content_versions
    ADD CONSTRAINT wiki_content_versions_pkey PRIMARY KEY (id);


--
-- Name: wiki_contents wiki_contents_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.wiki_contents
    ADD CONSTRAINT wiki_contents_pkey PRIMARY KEY (id);


--
-- Name: wiki_pages wiki_pages_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.wiki_pages
    ADD CONSTRAINT wiki_pages_pkey PRIMARY KEY (id);


--
-- Name: wiki_redirects wiki_redirects_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.wiki_redirects
    ADD CONSTRAINT wiki_redirects_pkey PRIMARY KEY (id);


--
-- Name: wikis wikis_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.wikis
    ADD CONSTRAINT wikis_pkey PRIMARY KEY (id);


--
-- Name: workflows workflows_pkey; Type: CONSTRAINT; Schema: public; Owner: redmine
--

ALTER TABLE ONLY public.workflows
    ADD CONSTRAINT workflows_pkey PRIMARY KEY (id);


--
-- Name: boards_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX boards_project_id ON public.boards USING btree (project_id);


--
-- Name: changeset_parents_changeset_ids; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX changeset_parents_changeset_ids ON public.changeset_parents USING btree (changeset_id);


--
-- Name: changeset_parents_parent_ids; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX changeset_parents_parent_ids ON public.changeset_parents USING btree (parent_id);


--
-- Name: changesets_changeset_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX changesets_changeset_id ON public.changes USING btree (changeset_id);


--
-- Name: changesets_issues_ids; Type: INDEX; Schema: public; Owner: redmine
--

CREATE UNIQUE INDEX changesets_issues_ids ON public.changesets_issues USING btree (changeset_id, issue_id);


--
-- Name: changesets_repos_rev; Type: INDEX; Schema: public; Owner: redmine
--

CREATE UNIQUE INDEX changesets_repos_rev ON public.changesets USING btree (repository_id, revision);


--
-- Name: changesets_repos_scmid; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX changesets_repos_scmid ON public.changesets USING btree (repository_id, scmid);


--
-- Name: custom_fields_roles_ids; Type: INDEX; Schema: public; Owner: redmine
--

CREATE UNIQUE INDEX custom_fields_roles_ids ON public.custom_fields_roles USING btree (custom_field_id, role_id);


--
-- Name: custom_values_customized; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX custom_values_customized ON public.custom_values USING btree (customized_type, customized_id);


--
-- Name: documents_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX documents_project_id ON public.documents USING btree (project_id);


--
-- Name: enabled_modules_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX enabled_modules_project_id ON public.enabled_modules USING btree (project_id);


--
-- Name: groups_users_ids; Type: INDEX; Schema: public; Owner: redmine
--

CREATE UNIQUE INDEX groups_users_ids ON public.groups_users USING btree (group_id, user_id);


--
-- Name: index_attachments_on_author_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_attachments_on_author_id ON public.attachments USING btree (author_id);


--
-- Name: index_attachments_on_container_id_and_container_type; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_attachments_on_container_id_and_container_type ON public.attachments USING btree (container_id, container_type);


--
-- Name: index_attachments_on_created_on; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_attachments_on_created_on ON public.attachments USING btree (created_on);


--
-- Name: index_attachments_on_disk_filename; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_attachments_on_disk_filename ON public.attachments USING btree (disk_filename);


--
-- Name: index_auth_sources_on_id_and_type; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_auth_sources_on_id_and_type ON public.auth_sources USING btree (id, type);


--
-- Name: index_boards_on_last_message_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_boards_on_last_message_id ON public.boards USING btree (last_message_id);


--
-- Name: index_changesets_issues_on_issue_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_changesets_issues_on_issue_id ON public.changesets_issues USING btree (issue_id);


--
-- Name: index_changesets_on_committed_on; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_changesets_on_committed_on ON public.changesets USING btree (committed_on);


--
-- Name: index_changesets_on_repository_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_changesets_on_repository_id ON public.changesets USING btree (repository_id);


--
-- Name: index_changesets_on_user_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_changesets_on_user_id ON public.changesets USING btree (user_id);


--
-- Name: index_comments_on_author_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_comments_on_author_id ON public.comments USING btree (author_id);


--
-- Name: index_comments_on_commented_id_and_commented_type; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_comments_on_commented_id_and_commented_type ON public.comments USING btree (commented_id, commented_type);


--
-- Name: index_custom_fields_on_id_and_type; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_custom_fields_on_id_and_type ON public.custom_fields USING btree (id, type);


--
-- Name: index_custom_fields_projects_on_custom_field_id_and_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE UNIQUE INDEX index_custom_fields_projects_on_custom_field_id_and_project_id ON public.custom_fields_projects USING btree (custom_field_id, project_id);


--
-- Name: index_custom_fields_trackers_on_custom_field_id_and_tracker_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE UNIQUE INDEX index_custom_fields_trackers_on_custom_field_id_and_tracker_id ON public.custom_fields_trackers USING btree (custom_field_id, tracker_id);


--
-- Name: index_custom_values_on_custom_field_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_custom_values_on_custom_field_id ON public.custom_values USING btree (custom_field_id);


--
-- Name: index_documents_on_category_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_documents_on_category_id ON public.documents USING btree (category_id);


--
-- Name: index_documents_on_created_on; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_documents_on_created_on ON public.documents USING btree (created_on);


--
-- Name: index_email_addresses_on_user_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_email_addresses_on_user_id ON public.email_addresses USING btree (user_id);


--
-- Name: index_enumerations_on_id_and_type; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_enumerations_on_id_and_type ON public.enumerations USING btree (id, type);


--
-- Name: index_enumerations_on_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_enumerations_on_project_id ON public.enumerations USING btree (project_id);


--
-- Name: index_issue_categories_on_assigned_to_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issue_categories_on_assigned_to_id ON public.issue_categories USING btree (assigned_to_id);


--
-- Name: index_issue_relations_on_issue_from_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issue_relations_on_issue_from_id ON public.issue_relations USING btree (issue_from_id);


--
-- Name: index_issue_relations_on_issue_from_id_and_issue_to_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE UNIQUE INDEX index_issue_relations_on_issue_from_id_and_issue_to_id ON public.issue_relations USING btree (issue_from_id, issue_to_id);


--
-- Name: index_issue_relations_on_issue_to_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issue_relations_on_issue_to_id ON public.issue_relations USING btree (issue_to_id);


--
-- Name: index_issue_statuses_on_is_closed; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issue_statuses_on_is_closed ON public.issue_statuses USING btree (is_closed);


--
-- Name: index_issue_statuses_on_position; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issue_statuses_on_position ON public.issue_statuses USING btree ("position");


--
-- Name: index_issues_on_assigned_to_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issues_on_assigned_to_id ON public.issues USING btree (assigned_to_id);


--
-- Name: index_issues_on_author_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issues_on_author_id ON public.issues USING btree (author_id);


--
-- Name: index_issues_on_category_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issues_on_category_id ON public.issues USING btree (category_id);


--
-- Name: index_issues_on_created_on; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issues_on_created_on ON public.issues USING btree (created_on);


--
-- Name: index_issues_on_fixed_version_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issues_on_fixed_version_id ON public.issues USING btree (fixed_version_id);


--
-- Name: index_issues_on_parent_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issues_on_parent_id ON public.issues USING btree (parent_id);


--
-- Name: index_issues_on_priority_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issues_on_priority_id ON public.issues USING btree (priority_id);


--
-- Name: index_issues_on_root_id_and_lft_and_rgt; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issues_on_root_id_and_lft_and_rgt ON public.issues USING btree (root_id, lft, rgt);


--
-- Name: index_issues_on_status_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issues_on_status_id ON public.issues USING btree (status_id);


--
-- Name: index_issues_on_tracker_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_issues_on_tracker_id ON public.issues USING btree (tracker_id);


--
-- Name: index_journals_on_created_on; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_journals_on_created_on ON public.journals USING btree (created_on);


--
-- Name: index_journals_on_journalized_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_journals_on_journalized_id ON public.journals USING btree (journalized_id);


--
-- Name: index_journals_on_user_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_journals_on_user_id ON public.journals USING btree (user_id);


--
-- Name: index_member_roles_on_inherited_from; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_member_roles_on_inherited_from ON public.member_roles USING btree (inherited_from);


--
-- Name: index_member_roles_on_member_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_member_roles_on_member_id ON public.member_roles USING btree (member_id);


--
-- Name: index_member_roles_on_role_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_member_roles_on_role_id ON public.member_roles USING btree (role_id);


--
-- Name: index_members_on_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_members_on_project_id ON public.members USING btree (project_id);


--
-- Name: index_members_on_user_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_members_on_user_id ON public.members USING btree (user_id);


--
-- Name: index_members_on_user_id_and_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE UNIQUE INDEX index_members_on_user_id_and_project_id ON public.members USING btree (user_id, project_id);


--
-- Name: index_messages_on_author_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_messages_on_author_id ON public.messages USING btree (author_id);


--
-- Name: index_messages_on_created_on; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_messages_on_created_on ON public.messages USING btree (created_on);


--
-- Name: index_messages_on_last_reply_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_messages_on_last_reply_id ON public.messages USING btree (last_reply_id);


--
-- Name: index_news_on_author_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_news_on_author_id ON public.news USING btree (author_id);


--
-- Name: index_news_on_created_on; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_news_on_created_on ON public.news USING btree (created_on);


--
-- Name: index_projects_on_lft; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_projects_on_lft ON public.projects USING btree (lft);


--
-- Name: index_projects_on_rgt; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_projects_on_rgt ON public.projects USING btree (rgt);


--
-- Name: index_queries_on_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_queries_on_project_id ON public.queries USING btree (project_id);


--
-- Name: index_queries_on_user_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_queries_on_user_id ON public.queries USING btree (user_id);


--
-- Name: index_repositories_on_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_repositories_on_project_id ON public.repositories USING btree (project_id);


--
-- Name: index_roles_managed_roles_on_role_id_and_managed_role_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE UNIQUE INDEX index_roles_managed_roles_on_role_id_and_managed_role_id ON public.roles_managed_roles USING btree (role_id, managed_role_id);


--
-- Name: index_settings_on_name; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_settings_on_name ON public.settings USING btree (name);


--
-- Name: index_time_entries_on_activity_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_time_entries_on_activity_id ON public.time_entries USING btree (activity_id);


--
-- Name: index_time_entries_on_created_on; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_time_entries_on_created_on ON public.time_entries USING btree (created_on);


--
-- Name: index_time_entries_on_user_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_time_entries_on_user_id ON public.time_entries USING btree (user_id);


--
-- Name: index_tokens_on_user_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_tokens_on_user_id ON public.tokens USING btree (user_id);


--
-- Name: index_user_preferences_on_user_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_user_preferences_on_user_id ON public.user_preferences USING btree (user_id);


--
-- Name: index_users_on_auth_source_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_users_on_auth_source_id ON public.users USING btree (auth_source_id);


--
-- Name: index_users_on_id_and_type; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_users_on_id_and_type ON public.users USING btree (id, type);


--
-- Name: index_users_on_type; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_users_on_type ON public.users USING btree (type);


--
-- Name: index_versions_on_sharing; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_versions_on_sharing ON public.versions USING btree (sharing);


--
-- Name: index_watchers_on_user_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_watchers_on_user_id ON public.watchers USING btree (user_id);


--
-- Name: index_watchers_on_watchable_id_and_watchable_type; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_watchers_on_watchable_id_and_watchable_type ON public.watchers USING btree (watchable_id, watchable_type);


--
-- Name: index_wiki_content_versions_on_updated_on; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_wiki_content_versions_on_updated_on ON public.wiki_content_versions USING btree (updated_on);


--
-- Name: index_wiki_contents_on_author_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_wiki_contents_on_author_id ON public.wiki_contents USING btree (author_id);


--
-- Name: index_wiki_pages_on_parent_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_wiki_pages_on_parent_id ON public.wiki_pages USING btree (parent_id);


--
-- Name: index_wiki_pages_on_wiki_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_wiki_pages_on_wiki_id ON public.wiki_pages USING btree (wiki_id);


--
-- Name: index_wiki_redirects_on_wiki_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_wiki_redirects_on_wiki_id ON public.wiki_redirects USING btree (wiki_id);


--
-- Name: index_workflows_on_new_status_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_workflows_on_new_status_id ON public.workflows USING btree (new_status_id);


--
-- Name: index_workflows_on_old_status_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_workflows_on_old_status_id ON public.workflows USING btree (old_status_id);


--
-- Name: index_workflows_on_role_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_workflows_on_role_id ON public.workflows USING btree (role_id);


--
-- Name: index_workflows_on_tracker_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX index_workflows_on_tracker_id ON public.workflows USING btree (tracker_id);


--
-- Name: issue_categories_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX issue_categories_project_id ON public.issue_categories USING btree (project_id);


--
-- Name: issues_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX issues_project_id ON public.issues USING btree (project_id);


--
-- Name: journal_details_journal_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX journal_details_journal_id ON public.journal_details USING btree (journal_id);


--
-- Name: journals_journalized_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX journals_journalized_id ON public.journals USING btree (journalized_id, journalized_type);


--
-- Name: messages_board_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX messages_board_id ON public.messages USING btree (board_id);


--
-- Name: messages_parent_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX messages_parent_id ON public.messages USING btree (parent_id);


--
-- Name: news_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX news_project_id ON public.news USING btree (project_id);


--
-- Name: projects_trackers_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX projects_trackers_project_id ON public.projects_trackers USING btree (project_id);


--
-- Name: projects_trackers_unique; Type: INDEX; Schema: public; Owner: redmine
--

CREATE UNIQUE INDEX projects_trackers_unique ON public.projects_trackers USING btree (project_id, tracker_id);


--
-- Name: queries_roles_ids; Type: INDEX; Schema: public; Owner: redmine
--

CREATE UNIQUE INDEX queries_roles_ids ON public.queries_roles USING btree (query_id, role_id);


--
-- Name: time_entries_issue_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX time_entries_issue_id ON public.time_entries USING btree (issue_id);


--
-- Name: time_entries_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX time_entries_project_id ON public.time_entries USING btree (project_id);


--
-- Name: tokens_value; Type: INDEX; Schema: public; Owner: redmine
--

CREATE UNIQUE INDEX tokens_value ON public.tokens USING btree (value);


--
-- Name: unique_schema_migrations; Type: INDEX; Schema: public; Owner: redmine
--

CREATE UNIQUE INDEX unique_schema_migrations ON public.schema_migrations USING btree (version);


--
-- Name: versions_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX versions_project_id ON public.versions USING btree (project_id);


--
-- Name: watchers_user_id_type; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX watchers_user_id_type ON public.watchers USING btree (user_id, watchable_type);


--
-- Name: wiki_content_versions_wcid; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX wiki_content_versions_wcid ON public.wiki_content_versions USING btree (wiki_content_id);


--
-- Name: wiki_contents_page_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX wiki_contents_page_id ON public.wiki_contents USING btree (page_id);


--
-- Name: wiki_pages_wiki_id_title; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX wiki_pages_wiki_id_title ON public.wiki_pages USING btree (wiki_id, title);


--
-- Name: wiki_redirects_wiki_id_title; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX wiki_redirects_wiki_id_title ON public.wiki_redirects USING btree (wiki_id, title);


--
-- Name: wikis_project_id; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX wikis_project_id ON public.wikis USING btree (project_id);


--
-- Name: wkfs_role_tracker_old_status; Type: INDEX; Schema: public; Owner: redmine
--

CREATE INDEX wkfs_role_tracker_old_status ON public.workflows USING btree (role_id, tracker_id, old_status_id);


--
-- PostgreSQL database dump complete
--

